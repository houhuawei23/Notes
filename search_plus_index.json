{"./":{"url":"./","title":"Introduction","keywords":"","body":"My Notes for nearly Everything, by hhw åšè§‚è€Œçº¦å–ï¼Œåšç§¯è€Œè–„å‘ã€‚1 Learn: Record learning resources, environment configuration, common questions and precautions when learning something or a certain skill Linux: Linux related notes, including Linux distribution, display, user management, input method, etc. PythonLibs - Programming: Programming related notes, about design patterns and so on. ReadingNotes: Personal reading notes, including books and articles. Network: Network related notes, including network protocols, network architecture, etc. Papers: Papers I read and want to remember. ConfigExamples: Configuration examples for different tools and editors. Git: Git related notes, including basic usage, branch management, etc. Misc: Miscellaneous notes, uncategorized notes. â­ If you think this repository is helpful to you, please give me a star! ğŸ˜š "},"ConfigExamples/ConfigExamples.html":{"url":"ConfigExamples/ConfigExamples.html","title":"ConfigExamples","keywords":"","body":"Configuration Examples Configuration Examples .clang-format .gitignore .clang-format --- Language: Cpp AccessModifierOffset: -2 AlignAfterOpenBracket: Align AlignArrayOfStructures: None AlignConsecutiveMacros: None AlignConsecutiveAssignments: None AlignConsecutiveBitFields: None AlignConsecutiveDeclarations: None AlignEscapedNewlines: Left AlignOperands: Align AlignTrailingComments: true ... .gitignore **/.** **/__pycache__ **/data **/__pycache__ **/*.model *.zip *.pyc *.pyo "},"Git/Github.html":{"url":"Git/Github.html","title":"Github","keywords":"","body":"Github Github Stars: Github Starred Repositories Manager Displaying Contributors Image on README files with no Pain! contributors-img: contrib.rocks contributors-img all-contributors Best-README-Template Github Actions: GitHub Actions for GitHub Pges Github Profile: wakatime: Dashboards for developers, dashboard github-readme-stats waka-readme-stats This GitHub action helps to add cool dev metrics to your github profile Readme waka-readme Wakatime Weekly Metrics on your Profile Readme. Github Resources: orignianl link: https://github.com/pathto/Sitemap.svg raw link: https://github.com/pathto/Sitemap.svg?raw=true auto redirect to: https://raw.githubusercontent.com/pathto/Sitemap.svg raw.githubusercontent.com: github ç”¨æ¥å­˜å‚¨ç”¨æˆ·ä¸Šä¼ æ–‡ä»¶çš„æœåŠ¡åœ°å€ã€‚æ”¾åœ¨äºšé©¬é€Š s3 ä¸Šã€‚æ˜¯ github çš„ç´ ææœåŠ¡å™¨ (assets server), é¿å…è·Ÿä¸»æœåŠ¡æŠ¢å è´Ÿè½½ raw.githubusercontent.com/username/repo-name/branch-name/path Replace username with the username of the user that created the repo. Replace repo-name with the name of the repo. Replace branch-name with the name of the branch. Replace path with the path to the file. "},"Git/git.html":{"url":"Git/git.html","title":"git","keywords":"","body":"Git Commands Q & A git-scm Commands git branch git remote git push git merge git config git rebase git reset git branch # List all branches (local and remote; the current branch is highlighted by *): git branch --all # Create new branch based on the current commit: git branch branch_name # Create new branch based on a specific commit: git branch branch_name commit_hash # Rename a branch (must not have it checked out to do this): git branch -m|--move old_branch_name new_branch_name # Delete a local branch (must not have it checked out to do this): git branch -d|--delete branch_name # Delete a remote branch: git push remote_name --delete remote_branch_name git remote # chekout remotes git remote -v # Show information about a remote: git remote show remote_name # Add a remote: git remote add remote_name remote_url # Change the URL of a remote (use --add to keep the existing URL): git remote set-url remote_name new_url # Remove a remote: git remote remove remote_name # Rename a remote: git remote rename old_name new_name # add additional url to the remote branch named `origin` # after that, the `origin` branch will has multi url # if run `git push origin main`, git will push to both of them git remote set-url --add origin get push Push commits to a remote repository. # Send local changes in the current branch to its default remote counterpart: git push # Send changes from a specific local branch to its remote counterpart: git push remote_name local_branch # Send changes from a specific local branch to its remote counterpart, # and set the remote one as the default push/pull target of the local one: git push -u remote_name local_branch # --set-upstream git merge Merge branches # Merge a branch into your current branch: git merge branch_name # Edit the merge message: git merge --edit branch_name # Merge a branch and create a merge commit: git merge --no-ff branch_name # Abort a merge in case of conflicts: git merge --abort # Merge using a specific strategy: git merge --strategy strategy --strategy-option strategy_option branch_name # !! merge to only create a commit on top of current commit git merge --squash branch_name --ff, --no-ff, --ff-only Specifies how a merge is handled when the merged-in history is already a descendant of the current history. --ff is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the refs/tags/ hierarchy, in which case --no-ff is assumed. With --ff, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit). When not possible (when the merged-in history is not a descendant of the current history), create a merge commit. With --no-ff, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward. With --ff-only, resolve the merge as a fast-forward when possible. When not possible, refuse to merge and exit with a non-zero status. --squash, --no-squash Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the HEAD, or record $GIT_DIR/MERGE_HEAD (to cause the next git commit command to create a merge commit). This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus). git config # You have divergent branches and need to specify how to reconcile them. # You can do so by running one of the following commands sometime before # your next pull: git config pull.rebase false # merge git config pull.rebase true # rebase git config pull.ff only # fast-forward only git rebase Reapply commits from one branch on top of another branch. Commonly used to \"move\" an entire branch to another base, creating copies of the commits in the new location. # Rebase the current branch on top of another specified branch: git rebase new_base_branch # Start an interactive rebase, which allows the commits to be reordered, omitted, combined or modified: git rebase -i|--interactive target_base_branch_or_commit_hash git reset Undo commits or unstage changes, by resetting the current Git HEAD to the specified state. If a path is passed, it works as \"unstage\"; if a commit hash or branch is passed, it works as \"uncommit\". # Unstage everything: git reset # Unstage specific file(s): git reset path/to/file1 path/to/file2 ... # Interactively unstage portions of a file: git reset --patch path/to/file # Undo the last commit, keeping its changes (and any further uncommitted changes) in the filesystem: git reset HEAD~ # Undo the last two commits, adding their changes to the index, i.e. staged for commit: git reset --soft HEAD~2 # Discard any uncommitted changes, staged or not (for only unstaged changes, use git checkout): git reset --hard # !! Reset the repository to a given commit, discarding committed, staged and uncommitted changes since then: git reset --hard commit Q & A How to set default upstream branch for git push or git pull? 1 checkout which branch your local branch is tracking: git branch -vv 2 set upstream branch for local branch git branch --set-upstream-to=origin/remote-branch-name local-branch-name 3 unset the upstream branch git branch --unset-upstream local-branch-name squash multiple commits into one to create a cleaner pull request upstream rep/branch 'abc/main', my rep/branch 'forked-abc/main' and 'forked-abc/dev' how to do: we can develop on 'forked-abc/dev' with multiple commits then checkout 'forked-abc/main' and merge 'forked-abc/dev' to it then rebase 'forked-abc/main' on top of 'abc/main' squash all the commits on 'forked-abc/main' into one commit finally i can create a pull request to 'abc/main' with only one conbined commit how: # Add the original repository as a remote git remote add upstream https://github.com/abc/main.git # Fetch latest changes git fetch upstream # Rebase your branch onto the latest upstream branch git checkout your-branch # main # git merge dev git rebase upstream/main # Squash commits git rebase -i upstream/main # Mark commits as `pick` or `squash`, then save # Force-push the squashed commit git push --force-with-lease origin your-branch # Create a pull request # Go to your forked repository and create a pull request to the original repository How to avoid enter password every time when pushing to a remote repository (https)? A: Use Git's credential helper to cache your credentials. Security Note!!! \\ Storing credentials in plain text (using the store helper) can be insecure, as anyone with access to your file system can read them. Use the cache helper or libsecret for better security. 1. Use the Credential Cache Helper The credential cache helper keeps your credentials in memory for a short period (default is 15 minutes). # enable credential cache helper git config --global credential.helper cache # change cache timeout (in seconds) git config --global credential.helper 'cache --timeout=3600' 2. Use the Credential Store Helper The credential store helper saves your credentials in a plain text file on disk, which is more persistent but less secure than the cache method. # enable the credential store helper git config --global credential.helper store When you use git pull or git push for the first time after configuring this, Git will prompt you for your username and password, and then store them in a file at ~/.git-credentials. 3. Use the libsecret Credential Helper The libsecret credential helper integrates with GNOME Keyring to securely store your credentials. # First, install the required package: sudo apt-get install libsecret-1-0 libsecret-1-dev # Then, you need to compile the `libsecret` credential helper. # This is a one-time setup: cd /usr/share/doc/git/contrib/credential/libsecret sudo make # Finally, configure Git to use the `libsecret` helper: git config --global credential.helper /usr/share/doc/git/contrib/credential/libsecret/git-credential-libsecret 4. Store Credentials for a Single Repository If you want to store credentials for just one repository and not globally, navigate to your repository and run: git config credential.helper store "},"Guides/Self-Cultivation-of-Programmers.html":{"url":"Guides/Self-Cultivation-of-Programmers.html","title":"Self-Cultivation-of-Programmers","keywords":"","body":"Self Cultivation of Programmers reference: ç¨‹åºå‘˜çš„è‡ªæˆ‘ä¿®å…» å†™ç»™å¹´è½»ç¨‹åºå‘˜çš„å»ºè®® æ¯”â€œä¸€èˆ¬äººâ€æ›´åŠªåŠ› é€‚æ—¶å»ºç«‹ä¸ªäººæƒå¨ ä¿æŒå¥½å¥‡å¿ƒ æŠ›å¼€ä»£ç ä¸äººæ²Ÿé€šï¼Œç»“è¯†æ›´ä¼˜ç§€çš„äºº or é€šè¿‡ä»£ç /å‚ä¸é¡¹ç›®ç»“è¯†å…¶ä»–å¼€å‘è€… ä¸ºä¼˜ç§€çš„äººå·¥ä½œæˆ–åŠªåŠ› åè°ƒç”Ÿæ´»ä¸å·¥ä½œï¼Œenjoy your life ç›¸ä¿¡è‡ªå·±çš„å¤©èµ‹å’Œåˆ›é€ åŠ› å°½å¯èƒ½æŒç»­åœ°ã€é•¿ä¹…åœ°åšä¸€ä»¶æœ‰æ„ä¹‰çš„äº‹ï¼ŒæŠŠå®ƒåšå¥½åšç²¾ ä¿æŒä¸¥è°¨ã€ç»´æŒå£°èª‰ å‹¤äºæ€è€ƒï¼Œä¸è½»æ˜“è¯´ç®€å•/ä¸å¯èƒ½ æ‰¾åˆ°è‡ªå·±æ‰€çƒ­çˆ±çš„ï¼Œå¯¹äººå¯¹äº‹ä¿æŒçœŸè¯šå’Œçƒ­æƒ… é”»ç‚¼è¡¨è¾¾èƒ½åŠ›ï¼Œæ•¢è¯´å¤šè¯´ï¼Œåˆ›é€ æœºä¼šã€æŠŠæ¡æœºä¼šå¤šè®²å¤šåˆ†äº« æ·±å…¥åœ°æ€è€ƒï¼Œä¸è¦æµ…å°è¾„æ­¢ã€çš®æ¯›è‚¤æµ… å–„äºæ€»ç»“å½’çº³ï¼Œä»çº·ç¹çš„è¡¨é¢ç°è±¡ä¸­æ€»ç»“æŠ½è±¡å‘ç°é—®é¢˜çš„æœ¬è´¨ã€å‘ç°å…³é”®çš„é—®é¢˜ çºµæ¨ªæ­é˜–ã€åˆçºµè¿æ¨ª å°†ä¸åŒé¢†åŸŸä¸åŒè§’åº¦çš„ä¸œè¥¿ç›¸è´¯é€šã€å‘ç°ç›¸ä¼¼ä¹‹å¤„ã€å…±é€šè´¨å¤„ï¼Œå¹¶ä»è¿ç§»æ¯”è¾ƒä¸­è·å¾—å¯å‘ å¯¹æ–°é²œæŠ€æœ¯ä¿æŒæ•é”ï¼Œå­¦ä¹ æ–°æŠ€æœ¯ã€æ–°è§‚å¿µå¹¶å°†å…¶åº”ç”¨åˆ°è‡ªå·±çš„å·¥ä½œä¸­ å¹³è¡¡å–èˆï¼Œåœ¨æœ‰é™çš„æ—¶é—´æœ‰é™çš„èµ„æºæœ‰é™çš„èƒ½åŠ›å†…è§£å†³é—®é¢˜ å¿«é€Ÿè¿­ä»£æ›´æ–° ä»å¤±è´¥ä¸­å­¦ä¹ ï¼Œç§¯ç´¯ç»éªŒï¼Œæ€»ç»“æ–¹æ³• å¯¹è‡ªå·±ã€å¯¹é¡¹ç›®ã€å¯¹ä»£ç ã€å¯¹äº‹æƒ…æœ‰ç€é«˜çš„è‡ªæˆ‘è¦æ±‚ ä¸è¦å›¾çœäº‹è€Œåšä¸€äº›æ„šè ¢çš„äº‹æƒ… å¦‚ä½•æ‰¾åˆ°é è°±çš„ç¨‹åºå‘˜ ç®€å†ï¼šé‡ç‚¹é¡¹ç›®ç»éªŒï¼›ä¸ç¼–ç¨‹æœ‰å…³çš„ç¤¾ä¼šåŒ–æ´»åŠ¨ è‡ªæˆ‘ä»‹ç»ï¼Œä»‹ç»è‡ªå·±æœ€æ“…é•¿çš„ã€æœ€æœ‰æ¿€æƒ…çš„ è¯­è¨€è¡¨è¾¾èƒ½åŠ›ã€é€»è¾‘æ€ç»´èƒ½åŠ›ã€ä¸“ä¸šèƒ½åŠ› æ˜¯å¦æœ‰æ¸…æ™°çš„è‡ªæˆ‘è®¤çŸ¥å’Œè‡ªæˆ‘è‚¯å®š æ˜¯å¦æœ‰è‡ªå·±æ‰€çƒ­çˆ±çš„ï¼Œæ˜¯å¦è‘†æœ‰æ¿€æƒ…ä¸çƒ­å¿± åŸºç¡€æ‰“ç‰¢äº†å—ï¼Ÿ è®¡ç®—æœºåŸç†ï¼Ÿè®¡ç®—æœºç½‘ç»œåŸºæœ¬åŸç†... å¯¹è‡ªå·±ä¸“ç²¾çš„æŠ€æœ¯æ˜¯å¦è¶³å¤Ÿæ·±å…¥ï¼Ÿ "},"Learn/Learn.html":{"url":"Learn/Learn.html","title":"Learn","keywords":"","body":"Learn Notes ç‰©ç‰©è€Œä¸ç‰©äºç‰©ã€‚1 "},"Learn/LearnDrones/Note.html":{"url":"Learn/LearnDrones/Note.html","title":"LearnDrones","keywords":"","body":"Learn Drones Labs æœºå™¨äººç ”ç©¶å›¢é˜Ÿ multi_uav_simulator UPenn GRASP kumarrobotics å®¾å¤•æ³•å°¼äºšå¤§å­¦å·¥ç¨‹ç³» General Robotics, Automation, Sensing and Perception (GRASP) Laboratory Vijay Kumar ç»´æ°Â·åº“é©¬å°” è‡´åŠ›äºåˆ›å»ºè‡ªä¸»åœ°é¢å’Œç©ºä¸­æœºå™¨äººã€è®¾è®¡é›†ä½“è¡Œä¸ºçš„ä»¿ç”Ÿç®—æ³•ä»¥åŠæœºå™¨äººç¾¤ HKUST Aerial Robotics é¦™æ¸¯ç§‘æŠ€å¤§å­¦ ç©ºä¸­æœºå™¨äººç ”ç©¶ç»„ github æ²ˆåŠ­åŠ¼ çŠ¶æ€ä¼°è®¡ã€ä¼ æ„Ÿå™¨èåˆã€å®šä½å’Œåœ°å›¾ç»˜åˆ¶ä»¥åŠå¤æ‚ç¯å¢ƒä¸­çš„è‡ªä¸»å¯¼èˆª VINS-MONO, Fiesta, FAST-planner SUSTech SmarT Autonomous Robotics Group github å—æ–¹ç§‘æŠ€å¤§å­¦ï¼ˆSUSTechï¼‰ å‘¨åšå®‡ åŠ©ç†æ•™æˆï¼ˆå‰¯ç ”ç©¶å‘˜ï¼‰ ZJU FAST Lab æµ™æ±Ÿå¤§å­¦ æ— äººç³»ç»Ÿä¸è‡ªä¸»è®¡ç®—å®éªŒå®¤ é«˜é£ è®¸è¶… æ— äººæœºè¿åŠ¨è§„åˆ’ github Fast-Drone-250 ego-planner-swarm ego-planner IWIN Center for Intelligent Wireless Networks and Cooperative Control (IWIN Center) ä¸Šæµ·äº¤é€šå¤§å­¦è‡ªåŠ¨åŒ–ç³» æ™ºèƒ½æ— çº¿ç½‘ç»œä¸ååŒæ§åˆ¶ä¸­å¿ƒ ä½•å»ºå¹³ ETH-Z ASL è‹é»ä¸–è”é‚¦ç†å·¥å¤§å­¦è‡ªä¸»ç³»ç»Ÿå®éªŒå®¤ Roland Siegwart Rotors_simulatorï¼ŒNext best view planner è¿åŠ¨è§„åˆ’ã€å»ºå›¾ã€å¾®å‹æ— äººæœºã€å…¨å‘é£è¡Œå™¨ã€å¤ªé˜³èƒ½æ— äººæœºã€æ— äººæœºç¼–é˜Ÿé£è¡Œ ETH RPG è‹é»ä¸–è”é‚¦ç†å·¥å¤§å­¦è‡ªä¸»ç³»ç»Ÿå®éªŒå®¤ è§†è§‰æ— äººæœºè‡ªä¸»å¯¼èˆªï¼ˆæ—  GPSã€æ¿€å…‰é›·è¾¾ï¼‰ã€å¤šæœºååŒã€è¿åŠ¨è§„åˆ’ã€æ§åˆ¶ç­–ç•¥ã€æ•æ·é£è¡Œã€ä¾§é‡äºç¯å¢ƒæ„ŸçŸ¥ç­‰ UZH-RPG è‹é»ä¸–å¤§å­¦æœºå™¨äººä¸æ„ŸçŸ¥ç ”ç©¶ç»„ Scaramuzza ä¸»æŒçš„å®éªŒå®¤ï¼Œ å®éªŒå®¤å·¥ä½œåŒ…æ‹¬ SVOï¼Œäº‹ä»¶ç›¸æœºï¼ŒåŸºäºå­¦ä¹ çš„ä¸€ç³»åˆ—æ— äººæœºè‡ªä¸»é£è¡Œä¸ç«é€Ÿç­‰å·¥ä½œï¼ŒFlightmare æ— äººæœºä»¿å¹³å°ã€‚ MIT-ACL éº»çœç†å·¥å¤§å­¦ç©ºé—´æ§åˆ¶å®éªŒå®¤ Jonathan How æ•™æˆä¸»æŒçš„å®éªŒå®¤ï¼Œå®éªŒå®¤åœ¨å¤šæœºè·¯å¾„è§„åˆ’ï¼Œå¤šæ™ºèƒ½ä½“å¼ºåŒ–å­¦ä¹ ï¼Œä¸»åŠ¨æ„ŸçŸ¥è¿åŠ¨è§„åˆ’ç­‰é¢†åŸŸæœ‰å¾ˆå¥½çš„å·¥ä½œ å¤šä¼¦å¤šå¤§å­¦é£è¡Œç³»ç»Ÿä¸æ§åˆ¶å®éªŒå®¤ï¼ˆUofT FSCï¼‰ Hugh liu æ•™æˆä¸»æŒçš„å®éªŒå®¤ã€‚ å®éªŒå®¤è¿™å‡ å¹´å·¥ä½œé›†ä¸­åœ¨æ— äººæœºç»³ç³»è´Ÿè½½æ§åˆ¶ï¼Œå¤šæœºåä½œç»³ç³»è´Ÿè½½æ§åˆ¶ï¼Œå¤šæœºè¿åŠ¨è§„åˆ’ç­‰é¢†åŸŸã€‚æœ‰ä¸€æ‰¹ç›¸å½“å¥½çš„å·¥ä½œã€‚å¯¹æ§åˆ¶æ„Ÿå…´è¶£çš„æœ‹å‹å¯ä»¥å…³æ³¨æ­¤å®éªŒå®¤ã€‚ å¡è€åŸºæ¢…éš†å¤§å­¦æœºå™¨äººå­¦é™¢ï¼ˆAir Labï¼‰ ç ”ç©¶æ–¹å‘ä¸ºå¤šæ—‹ç¿¼é£è¡Œå™¨è‡ªä¸»å¯¼èˆªç³»ç»Ÿã€ç§»åŠ¨å¹³å°æ— äººæœºè‡ªä¸»é™è½ç­‰ã€‚ rislab Resilient Intelligent Systems Lab (RISLab) Carnegie Mellon Universityâ€™s Robotics Institute Papers RACER: rapid collaborative exploration with a decentralized multi-UAV system ieeexplore 2023 IEEE Transactions on Robotics King-Sun Fu Memorial Best Paper Award å‘¨åšå®‡ è¯¥æ–‡ç« ä»‹ç»äº†ä¸€ä¸ªå»ä¸­å¿ƒåŒ–çš„å¤šæ— äººæœºï¼ˆUnmanned Aerial Vehicles, UAVsï¼‰ç³»ç»Ÿï¼Œæ—¨åœ¨é€šè¿‡åä½œå¿«é€Ÿæ¢ç´¢æœªçŸ¥ç¯å¢ƒã€‚è¯¥ç³»ç»Ÿé¦–å…ˆé€šè¿‡åœ¨çº¿çš„æœªæ¢ç´¢åŒºåŸŸåˆ†è§£å’ŒåŸºäºæˆå¯¹äº¤äº’çš„æ–¹å¼è°ƒåº¦å¤šæ— äººæœºï¼Œå³ä¾¿åœ¨å¼‚æ­¥å’Œä¸ç¨³å®šçš„é€šä¿¡æ¡ä»¶ä¸‹ä¹Ÿèƒ½åˆç†åˆ†é…æ¢ç´¢ä»»åŠ¡ã€‚æ­¤å¤–ï¼Œé€šè¿‡ä¸€ç§è€ƒè™‘å®¹é‡çš„è½¦è¾†è·¯å¾„é—®é¢˜ï¼Œä¼˜åŒ–äº†æ— äººæœºç¾¤è¦†ç›–æœªçŸ¥ç©ºé—´çš„è·¯å¾„ï¼Œåˆç†å¹³è¡¡å„æ— äººæœºçš„å·¥ä½œè½½è·ã€‚åœ¨è¯¥ç³»ç»Ÿä¸­ï¼Œæ¯ä¸ªæ— äººæœºæ ¹æ®åˆ†é…çš„ä»»åŠ¡ï¼Œé€šè¿‡å±‚çº§è§„åˆ’å™¨å¿«é€Ÿå“åº”ç¯å¢ƒå˜åŒ–ï¼Œä»è€Œå®‰å…¨é«˜æ•ˆåœ°æ¢ç´¢æœªçŸ¥ç©ºé—´ã€‚æ— äººæœºé—´é€šè¿‡èåˆè§†è§‰ã€æƒ¯æ€§æµ‹é‡å•å…ƒã€è¶…å®½å¸¦ç­‰å¤šç§ä¼ æ„Ÿå™¨ä¿¡æ¯å®ç°ç›¸äº’å®šä½ã€‚è¯¥ç³»ç»Ÿåœ¨ä»¿çœŸå’ŒçœŸå®ä¸–ç•Œçš„ä¸¥å³»ç¯å¢ƒä¸­è¿›è¡Œäº†å¤§é‡æµ‹è¯•ï¼Œå¯ä»¥é€‚åº”å®¤å†…ã€é‡å¤–ç­‰å¤šç§å¤æ‚åœºæ™¯ï¼ˆå¦‚ä¸‹å›¾ 1ï¼‰ï¼Œæ˜¾ç¤ºå‡ºäº†é«˜æ•ˆç‡ã€å¯æ‰©å±•æ€§å’Œåœ¨é€šä¿¡å—é™æƒ…å†µä¸‹çš„ç¨³å¥æ€§ã€‚è¯¥å·¥ä½œé¦–æ¬¡å®ç°äº†åœ¨çœŸå®ä¸–ç•Œå¤æ‚åœºæ™¯ä¸­å¤šæ— äººæœºå®Œå…¨å»ä¸­å¿ƒåŒ–çš„åä½œæ¢ç´¢ï¼Œå¯¹äºå„ç§æœºå™¨äººåº”ç”¨ï¼Œå¦‚å·¡æ£€ã€æœæ•‘ç­‰ï¼Œå…·æœ‰é‡è¦çš„å®é™…æ„ä¹‰ã€‚ Journal æœŸåˆŠ zhihu: æœºå™¨äººé¢†åŸŸä¸»è¦æœŸåˆŠåŠå›½é™…ä¼šè®®æ±‡æ€» 2021 æœºå™¨äººé¢†åŸŸä¸»è¦å›½é™…ä¼šè®®ä¸æœŸåˆŠåˆ—è¡¨ Science Robotics 26.1 Q1 1Q science IEEE Transactions on Robotics (TRO) IF 9.4, JCR Q1, CAS Q1 Computer Science Applications, Control and Systems Engineering, Electrical and Electronic Engineering ieee International Journal of Robotics Research (IJRR) 7.5 Q1 Q2 sagepub Drones IF 4.4, JCR Q1 (Remote Sensing), CAS Q2 mdpi UAV, UAS, RPAS Aerospace Science and Technology IF 5 JCR Q1, CAS Q1 sciencedirect Soft Robotics Q1 Robotics and Computer-Integrated Manufacturing 9.1 Q1 1 åŒº æ³¨é‡è®¡ç®—æœºç§‘å­¦å’Œæœºæ¢°åˆ¶é€ ç³»ç»Ÿçš„ç»“åˆ Vehicular Communications (Engineering: Automotive Engineering) IF 5.8, JCR Q1, CAS Q2 sciencedirect Robotics and Computer-Integrated Manufacturing The emphasis of the journal Robotics and Computer-Integrated Manufacturing is on disseminating the application of research to the development of new or improved industrially-relevant robotics, manufacturing technologies, and innovative manufacturing strategies. Preference is given to papers describing original research that includes both theory and experimental validation. Comprehensive review papers on topical issues related to robotics and manufacturing will also be considered. Papers on conventional machining processes, modelling and simulation, supply chain management, and resource optimisation, will generally be considered out of scope, as there are other more appropriate journals in these areas. Overly theoretical or mathematical papers will be directed to other more appropriate journals as well. Original papers are welcomed in the areas of industrial robotics, human-robot collaborative manufacturing, cloud-based manufacturing, cyber-physical production systems, big data analytics in manufacturing, smart mechatronics, machine learning, adaptive and sustainable manufacturing, and other fields involving unique manufacturing technologies. ã€Šæœºå™¨äººä¸è®¡ç®—æœºé›†æˆåˆ¶é€ ã€‹æ‚å¿—çš„é‡ç‚¹æ˜¯ä¼ æ’­ç ”ç©¶åœ¨æ–°å‹æˆ–æ”¹è¿›çš„å·¥ä¸šç›¸å…³æœºå™¨äººã€åˆ¶é€ æŠ€æœ¯å’Œåˆ›æ–°åˆ¶é€ ç­–ç•¥çš„å¼€å‘ä¸­çš„åº”ç”¨ã€‚ä¼˜å…ˆè€ƒè™‘æè¿°åŸåˆ›ç ”ç©¶çš„è®ºæ–‡ï¼ŒåŒ…æ‹¬ç†è®ºå’Œå®éªŒéªŒè¯ã€‚è¿˜å°†è€ƒè™‘ä¸æœºå™¨äººå’Œåˆ¶é€ ç›¸å…³çš„çƒ­é—¨é—®é¢˜çš„ç»¼åˆè¯„è®ºè®ºæ–‡ã€‚å…³äºä¼ ç»ŸåŠ å·¥å·¥è‰ºã€å»ºæ¨¡å’Œä»¿çœŸã€ä¾›åº”é“¾ç®¡ç†å’Œèµ„æºä¼˜åŒ–çš„è®ºæ–‡é€šå¸¸è¢«è®¤ä¸ºè¶…å‡ºèŒƒå›´ï¼Œå› ä¸ºè¿™äº›é¢†åŸŸè¿˜æœ‰å…¶ä»–æ›´åˆé€‚çš„æœŸåˆŠã€‚è¿‡äºç†è®ºæˆ–æ•°å­¦çš„è®ºæ–‡ä¹Ÿå°†è¢«å®šå‘åˆ°å…¶ä»–æ›´åˆé€‚çš„æœŸåˆŠã€‚å·¥ä¸šæœºå™¨äººã€äººæœºååŒåˆ¶é€ ã€äº‘åˆ¶é€ ã€ç½‘ç»œç‰©ç†ç”Ÿäº§ç³»ç»Ÿã€åˆ¶é€ å¤§æ•°æ®åˆ†æã€æ™ºèƒ½æœºç”µä¸€ä½“åŒ–ã€æœºå™¨å­¦ä¹ ã€è‡ªé€‚åº”å’Œå¯æŒç»­åˆ¶é€ ä»¥åŠå…¶ä»–æ¶‰åŠç‹¬ç‰¹é¢†åŸŸçš„åŸåˆ›è®ºæ–‡å—åˆ°æ¬¢è¿åˆ¶é€ æŠ€æœ¯ã€‚ Vehicular Communications (Engineering: Automotive Engineering) types of communications involving vehicles, including vehicleâ€“toâ€“vehicle and vehicleâ€“toâ€“infrastructure. The scope includes (but not limited to) the following topics related to vehicular communications: è¯¥æœŸåˆŠçš„ç›®æ ‡æ˜¯å‘è¡¨è½¦è¾†é€šä¿¡é¢†åŸŸçš„é«˜è´¨é‡åŒè¡Œè¯„å®¡è®ºæ–‡ã€‚èŒƒå›´æ¶µç›–æ¶‰åŠè½¦è¾†çš„æ‰€æœ‰ç±»å‹çš„é€šä¿¡ï¼ŒåŒ…æ‹¬è½¦è¾†å¯¹è½¦è¾†å’Œè½¦è¾†å¯¹åŸºç¡€è®¾æ–½ã€‚èŒƒå›´åŒ…æ‹¬ï¼ˆä½†ä¸é™äºï¼‰ä»¥ä¸‹ä¸è½¦è¾†é€šä¿¡ç›¸å…³çš„ä¸»é¢˜ï¼š Vehicle to vehicle and vehicle to infrastructure communications è½¦è¾†åˆ°è½¦è¾†å’Œè½¦è¾†åˆ°åŸºç¡€è®¾æ–½é€šä¿¡ Channel modelling, modulating and coding ä¿¡é“å»ºæ¨¡ã€è°ƒåˆ¶å’Œç¼–ç  Congestion Control and scalability issues æ‹¥å¡æ§åˆ¶å’Œå¯æ‰©å±•æ€§é—®é¢˜ Protocol design, testing and verification åè®®è®¾è®¡ã€æµ‹è¯•å’ŒéªŒè¯ Routing in vehicular networks è½¦è½½ç½‘ç»œä¸­çš„è·¯ç”± Security issues and countermeasures å®‰å…¨é—®é¢˜åŠå¯¹ç­– Deployment and field testing éƒ¨ç½²å’Œç°åœºæµ‹è¯• Reducing energy consumption and enhancing safety of vehicles é™ä½èƒ½æºæ¶ˆè€—å¹¶æé«˜è½¦è¾†å®‰å…¨æ€§ Wireless inâ€“car networks æ— çº¿è½¦è½½ç½‘ç»œ Data collection and dissemination methods æ•°æ®æ”¶é›†å’Œä¼ æ’­æ–¹æ³• Mobility and handover issues ç§»åŠ¨æ€§å’Œç§»äº¤é—®é¢˜ Safety and driver assistance applications å®‰å…¨å’Œé©¾é©¶å‘˜è¾…åŠ©åº”ç”¨ UAV æ— äººæœº Underwater communications æ°´ä¸‹é€šè®¯ Autonomous cooperative driving è‡ªåŠ¨ååŒé©¾é©¶ Social networks ç¤¾äº¤ç½‘ç»œ Internet of vehicles è½¦è”ç½‘ Standardization of protocols åè®®æ ‡å‡†åŒ– Drones scimagojr Drones (ISSN 2504-446X) is an international, peer-reviewed, open access journal published monthly online. The journal focuses on design and applications of drones, including unmanned aerial vehicle (UAV), Unmanned Aircraft Systems (UAS), and Remotely Piloted Aircraft Systems (RPAS), etc. Likewise, contributions based on unmanned water/underwater drones and unmanned ground vehicles are also welcomed. ã€Šæ— äººæœºã€‹ï¼ˆISSN 2504-446Xï¼‰æ˜¯ä¸€ä»½å›½é™…åŒè¡Œè¯„å®¡ã€å¼€æ”¾è·å–æœŸåˆŠï¼Œæ¯æœˆåœ¨çº¿å‡ºç‰ˆã€‚è¯¥æ‚å¿—é‡ç‚¹å…³æ³¨æ— äººæœºçš„è®¾è®¡å’Œåº”ç”¨ï¼ŒåŒ…æ‹¬æ— äººæœºï¼ˆUAVï¼‰ã€æ— äººæœºç³»ç»Ÿï¼ˆUASï¼‰å’Œé¥æ§é©¾é©¶é£æœºç³»ç»Ÿï¼ˆRPASï¼‰ç­‰ã€‚åŒæ ·ï¼ŒåŸºäºæ— äººæ°´ä¸Š/æ°´ä¸‹æ— äººæœºå’Œæ— äººåœ°é¢è½¦è¾†çš„è´¡çŒ®ä¹Ÿå—åˆ°æ¬¢è¿ã€‚ IEEE Transactions on Robotics The IEEE Transactions on Robotics (T-RO) publishes fundamental papers on all aspects of Robotics, featuring interdisciplinary approaches from computer science, control systems, electrical engineering, mathematics, mechanical engineering, and other fields. Robots and intelligent machines and systems are critical in areas such as industrial applications; service and personal assistants; surgical operations; space, underwater, and remote exploration; entertainment; safety, search, and rescue; military applications; agriculture applications; and intelligent vehicles. Special emphasis in the T-RO is placed on intelligent machines and systems for unstructured environments, where a significant portion of the environment is unknown and cannot be directly sensed or controlled. IEEE æœºå™¨äººå­¦æ±‡åˆŠ (T-RO) å‘è¡¨æœºå™¨äººå­¦å„ä¸ªæ–¹é¢çš„åŸºç¡€è®ºæ–‡ï¼Œæ¶µç›–è®¡ç®—æœºç§‘å­¦ã€æ§åˆ¶ç³»ç»Ÿã€ç”µæ°”å·¥ç¨‹ã€æ•°å­¦ã€æœºæ¢°å·¥ç¨‹å’Œå…¶ä»–é¢†åŸŸçš„è·¨å­¦ç§‘æ–¹æ³•ã€‚æœºå™¨äººã€æ™ºèƒ½æœºå™¨å’Œç³»ç»Ÿåœ¨å·¥ä¸šåº”ç”¨ç­‰é¢†åŸŸè‡³å…³é‡è¦ï¼›æœåŠ¡å’Œç§äººåŠ©ç†ï¼›å¤–ç§‘æ‰‹æœ¯ï¼›å¤ªç©ºã€æ°´ä¸‹å’Œè¿œç¨‹æ¢ç´¢ï¼›å¨±ä¹;å®‰å…¨ã€æœç´¢å’Œæ•‘æ´ï¼›å†›äº‹åº”ç”¨ï¼›å†œä¸šåº”ç”¨ï¼›å’Œæ™ºèƒ½æ±½è½¦ã€‚ T-RO ç‰¹åˆ«å¼ºè°ƒéç»“æ„åŒ–ç¯å¢ƒä¸­çš„æ™ºèƒ½æœºå™¨å’Œç³»ç»Ÿï¼Œå…¶ä¸­ç¯å¢ƒçš„å¾ˆå¤§ä¸€éƒ¨åˆ†æ˜¯æœªçŸ¥çš„ï¼Œæ— æ³•ç›´æ¥æ„ŸçŸ¥æˆ–æ§åˆ¶ã€‚ Conference ä¼šè®® IEEE International Conference on Robotics and Automation (ICRA) IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) Robotic: Science and Systems (RSS) Conference on Robot Learning (CoRL) CAA ä¸­å›½è‡ªåŠ¨åŒ–å­¦ä¼šæ¨èå­¦æœ¯ä¼šè®®ã€ç§‘æŠ€æœŸåˆŠç›®å½• 2022-12-06 ä¸­å›½è‡ªåŠ¨åŒ–å­¦ä¼šæ¨èå­¦æœ¯ä¼šè®®ã€ç§‘æŠ€æœŸåˆŠç›®å½•å‘å¸ƒ ã€Šä¼šè®®ç›®å½•ã€‹åˆ†ä¸º A ç±»ã€B ç±»ã€C ç±»ä¸‰æ¡£ã€‚A ç±»ä»£è¡¨å›½é™…ä¸Šæå°‘æ•°çš„é¡¶çº§ä¼šè®®ï¼›B ç±»ä»£è¡¨å›½é™…ä¸Šè‘—åå’Œéå¸¸é‡è¦çš„ä¼šè®®ï¼›C ç±»ä»£è¡¨å›½é™…å­¦æœ¯ç•Œæ‰€è®¤å¯çš„é‡è¦ä¼šè®®ã€‚ã€Šä¼šè®®ç›®å½•ã€‹åŒ…å«è‡ªåŠ¨åŒ–å­¦ç§‘é¢†åŸŸ 12 ä¸ªç»†åˆ†é¢†åŸŸçš„ 230 ä¸ªå­¦æœ¯ä¼šè®®ï¼Œ12 ä¸ªç»†åˆ†é¢†åŸŸä¸ºï¼š ï¼ˆ1ï¼‰æ§åˆ¶ç†è®ºä¸æ§åˆ¶å·¥ç¨‹ï¼› ï¼ˆ2ï¼‰æ¨¡å¼è¯†åˆ«ä¸æ™ºèƒ½ç³»ç»Ÿï¼› ï¼ˆ3ï¼‰æ£€æµ‹æŠ€æœ¯ä¸è‡ªåŠ¨åŒ–è£…ç½®ï¼› ï¼ˆ4ï¼‰å¯¼èˆªã€åˆ¶å¯¼ä¸æ§åˆ¶ï¼› ï¼ˆ5ï¼‰ç³»ç»Ÿå·¥ç¨‹ï¼› ï¼ˆ6ï¼‰ç”Ÿç‰©ä¿¡æ¯å­¦ï¼› ï¼ˆ7ï¼‰ä¼ä¸šä¿¡æ¯åŒ–ï¼› ï¼ˆ8ï¼‰æ™ºèƒ½æ„ŸçŸ¥ä¸è‡ªä¸»æ§åˆ¶ï¼› ï¼ˆ9ï¼‰æœºå™¨äººä¸æ— äººç³»ç»Ÿï¼› ï¼ˆ10ï¼‰ä»¿çœŸç§‘å­¦ä¸å·¥ç¨‹ï¼› ï¼ˆ11ï¼‰ç»¼åˆäº¤å‰ï¼› ï¼ˆ12ï¼‰å‰æ²¿é«˜ç«¯ã€‚ ã€ŠæœŸåˆŠç›®å½•ã€‹å»¶ç»­ 2018 å¹´ç‰ˆï¼Œåˆ†ä¸º A ç±»ã€B ç±»ä¸¤æ¡£ï¼Œå…± 315 ä¸ªåˆŠç‰©ï¼ŒA ç±»ä»£è¡¨å›½å†…å¤–é¡¶çº§å­¦æœ¯åˆŠç‰©ï¼ŒB ç±»ä»£è¡¨å›½å†…å¤–è‘—åå­¦æœ¯åˆŠç‰©ã€‚å…¶ä¸­ï¼ŒA ç±»ä¸­å‰ 20%çš„é¡¶å°–æœŸåˆŠåˆ’åˆ†ä¸º A+ç±»ï¼Œä»¥æœŸå›½å†…å­¦æœ¯æœŸåˆŠå¯¹æ ‡çªç ´ã€‚ Tools RealSense Driver github source installation The shared object will be installed in /usr/local/lib, header files in /usr/local/include. sudo apt install libpcl-dev Mavros: Micro Air Vehicle Robot Operating System MAVLink extendable communication node for ROS with proxy for Ground Control Station. This package provides communication driver for various autopilots with MAVLink communication protocol. Additional it provides UDP MAVLink bridge for ground control stations (e.g. QGroundControl). mavros ç”¨äºæ— äººæœºé€šä¿¡ï¼Œå¯ä»¥å°†é£æ§ä¸ä¸»æ§çš„ä¿¡æ¯è¿›è¡Œäº¤æ¢ ceres-solver: googlesource An open source lib for modeling and solving large, complicated optimization problems. It can be used to solve Non-linear Least Squares problems with bounds constraints and general unconstrained optimization problems. å®ƒå¯ç”¨äºæ±‚è§£å…·æœ‰è¾¹ç•Œçº¦æŸçš„éçº¿æ€§æœ€å°äºŒä¹˜æ³•é—®é¢˜å’Œä¸€èˆ¬çš„æ— çº¦æŸä¼˜åŒ–é—®é¢˜ã€‚ glog C++ implementation of the Google logging module. pip uninstall em pip install empy # install ros noetic dependencies # [ddynamic_reconfigure](https://github.com/pal-robotics/ddynamic_reconfigure) catkin_make_isolated --install -DPYTHON_EXECUTABLE=/usr/bin/python3 --force-cmake # must be: dont be higher than 0.10.0 Package: liblog4cxx-dev Version: 0.10.0-15ubuntu2 Concepts SDF Signed Distance Field ç¬¦å·è·ç¦»åœº æè¿°æˆ–å­˜å‚¨ç‚¹ä¸åœºæ™¯ç‰©ä½“è¡¨é¢ä½ç½®å…³ç³»çš„æ–¹å¼ å½“ç‚¹åœ¨ç‰©ä½“çš„å†…éƒ¨æ—¶è·ç¦»ä¸ºè´Ÿæ•°ï¼Œåœ¨ç‰©ä½“è¡¨é¢æ—¶è·ç¦»ä¸º 0ï¼Œåœ¨ç‰©ä½“å¤–éƒ¨æ—¶è·ç¦»ä¸ºæ­£æ•° ä½œç”¨: ç”¨äºå¿«é€ŸæŸ¥è¯¢ä»»æ„ä¸€ç‚¹åˆ°åœºæ™¯ä¸­ç‰©ä½“è¡¨é¢çš„æœ€çŸ­è·ç¦» å¦‚ä½•å»ºç«‹å’Œä½¿ç”¨ï¼Ÿ Intro to Signed Distance Fields Gradient-based trajectory planning åŸºäºæ¢¯åº¦çš„è½¨è¿¹è§„åˆ’ blog: Gradient-based trajectory planning CHOMP: Gradient Optimization Techniques for Efficient Motion Planning GPT4o: Gradient-Based Trajectory Planning: Overview åŸºäºæ¢¯åº¦çš„è½¨è¿¹è§„åˆ’ï¼šæ¦‚è¿° Gradient-based trajectory planning is a method used to determine a path or trajectory for an object (like a robot or vehicle) by iteratively improving an initial trajectory based on gradient information. The goal is to optimize a trajectory with respect to certain objectives, such as minimizing energy, avoiding obstacles, or reaching a target point efficiently. åŸºäºæ¢¯åº¦çš„è½¨è¿¹è§„åˆ’æ˜¯ä¸€ç§é€šè¿‡åŸºäºæ¢¯åº¦ä¿¡æ¯è¿­ä»£æ”¹è¿›åˆå§‹è½¨è¿¹æ¥ç¡®å®šç‰©ä½“ï¼ˆå¦‚æœºå™¨äººæˆ–è½¦è¾†ï¼‰çš„è·¯å¾„æˆ–è½¨è¿¹çš„æ–¹æ³•ã€‚ç›®æ ‡æ˜¯é’ˆå¯¹æŸäº›ç›®æ ‡ä¼˜åŒ–è½¨è¿¹ï¼Œä¾‹å¦‚æœ€å°åŒ–èƒ½é‡ã€é¿å¼€éšœç¢ç‰©æˆ–æœ‰æ•ˆåœ°åˆ°è¾¾ç›®æ ‡ç‚¹ã€‚ Key Thoughts of the Method è¯¥æ–¹æ³•çš„æ ¸å¿ƒæ€æƒ³ Optimization via Gradients: é€šè¿‡æ¢¯åº¦è¿›è¡Œä¼˜åŒ–ï¼š The trajectory is treated as a variable in an optimization problem. è½¨è¿¹è¢«è§†ä¸ºä¼˜åŒ–é—®é¢˜ä¸­çš„å˜é‡ã€‚ Gradients of a cost function (e.g., distance to obstacles, time taken, energy expenditure) with respect to the trajectory are computed and used to iteratively improve the trajectory. è®¡ç®—æˆæœ¬å‡½æ•°ç›¸å¯¹äºè½¨è¿¹çš„æ¢¯åº¦ï¼ˆä¾‹å¦‚ï¼Œåˆ°éšœç¢ç‰©çš„è·ç¦»ã€æ‰€èŠ±è´¹çš„æ—¶é—´ã€èƒ½é‡æ¶ˆè€—ï¼‰å¹¶ç”¨äºè¿­ä»£åœ°æ”¹è¿›è½¨è¿¹ã€‚ Cost Function Design: ä»£ä»·å‡½æ•°è®¾è®¡ï¼š A carefully designed cost function combines all relevant objectives, such as collision avoidance, smoothness, and time efficiency. ç²¾å¿ƒè®¾è®¡çš„æˆæœ¬å‡½æ•°ç»“åˆäº†æ‰€æœ‰ç›¸å…³ç›®æ ‡ï¼Œä¾‹å¦‚é¿å…ç¢°æ’ã€å¹³æ»‘åº¦å’Œæ—¶é—´æ•ˆç‡ã€‚ Commonly, the cost function includes terms for proximity to obstacles, adherence to desired dynamics, and overall trajectory smoothness. é€šå¸¸ï¼Œæˆæœ¬å‡½æ•°åŒ…æ‹¬ä¸éšœç¢ç‰©çš„æ¥è¿‘ç¨‹åº¦ã€å¯¹æ‰€éœ€åŠ¨æ€çš„éµå®ˆä»¥åŠæ€»ä½“è½¨è¿¹å¹³æ»‘åº¦ç­‰é¡¹ã€‚ Iterative Adjustment: è¿­ä»£è°ƒæ•´ï¼š Starting with an initial trajectory, gradient descent or a similar optimization algorithm adjusts the trajectory step-by-step. ä»åˆå§‹è½¨è¿¹å¼€å§‹ï¼Œæ¢¯åº¦ä¸‹é™æˆ–ç±»ä¼¼çš„ä¼˜åŒ–ç®—æ³•é€æ­¥è°ƒæ•´è½¨è¿¹ã€‚ Constraints (e.g., dynamics, kinematics) are often included to ensure feasible and safe paths. é€šå¸¸åŒ…æ‹¬çº¦æŸï¼ˆä¾‹å¦‚åŠ¨åŠ›å­¦ã€è¿åŠ¨å­¦ï¼‰ä»¥ç¡®ä¿å¯è¡Œä¸”å®‰å…¨çš„è·¯å¾„ã€‚ Scalability and Flexibility: å¯æ‰©å±•æ€§å’Œçµæ´»æ€§ï¼š The method can handle high-dimensional trajectory spaces, making it suitable for robotic arms, drones, and autonomous vehicles. è¯¥æ–¹æ³•å¯ä»¥å¤„ç†é«˜ç»´è½¨è¿¹ç©ºé—´ï¼Œä½¿å…¶é€‚ç”¨äºæœºæ¢°è‡‚ã€æ— äººæœºå’Œè‡ªåŠ¨é©¾é©¶è½¦è¾†ã€‚ Advantages ä¼˜ç‚¹ Adaptability: Gradient-based methods can adapt trajectories to dynamic environments by continuously updating the solution as conditions change. é€‚åº”æ€§ï¼šåŸºäºæ¢¯åº¦çš„æ–¹æ³•å¯ä»¥é€šè¿‡éšç€æ¡ä»¶å˜åŒ–ä¸æ–­æ›´æ–°è§£å†³æ–¹æ¡ˆæ¥ä½¿è½¨è¿¹é€‚åº”åŠ¨æ€ç¯å¢ƒã€‚ Optimality: These methods aim to find a locally (and sometimes globally) optimal solution based on the cost function. æœ€ä¼˜æ€§ï¼šè¿™äº›æ–¹æ³•æ—¨åœ¨åŸºäºæˆæœ¬å‡½æ•°æ‰¾åˆ°å±€éƒ¨ï¼ˆæœ‰æ—¶æ˜¯å…¨å±€ï¼‰æœ€ä¼˜è§£ã€‚ Mathematical Rigorousness: Strong theoretical foundation allows for analysis and guarantees under certain conditions. æ•°å­¦ä¸¥è°¨æ€§ï¼šå¼ºå¤§çš„ç†è®ºåŸºç¡€å¯ä»¥åœ¨ä¸€å®šæ¡ä»¶ä¸‹è¿›è¡Œåˆ†æå’Œä¿è¯ã€‚ Wide Applicability: Useful for a range of domains like robotics, autonomous driving, and animation. å¹¿æ³›çš„é€‚ç”¨æ€§ï¼šå¯ç”¨äºæœºå™¨äººã€è‡ªåŠ¨é©¾é©¶å’ŒåŠ¨ç”»ç­‰ä¸€ç³»åˆ—é¢†åŸŸã€‚ Smoothness: Incorporating smoothness constraints often results in trajectories that are smooth and practical for real-world use. å¹³æ»‘åº¦ï¼šç»“åˆå¹³æ»‘åº¦çº¦æŸé€šå¸¸ä¼šäº§ç”Ÿå¹³æ»‘ä¸”é€‚åˆå®é™…ä½¿ç”¨çš„è½¨è¿¹ã€‚ Disadvantages ç¼ºç‚¹ Local Minima: The method may converge to a suboptimal solution due to the presence of local minima in the cost function. å±€éƒ¨æœ€å°å€¼ï¼šç”±äºæˆæœ¬å‡½æ•°ä¸­å­˜åœ¨å±€éƒ¨æœ€å°å€¼ï¼Œè¯¥æ–¹æ³•å¯èƒ½ä¼šæ”¶æ•›åˆ°æ¬¡ä¼˜è§£ã€‚ Computational Cost: Computing gradients and solving high-dimensional optimization problems can be computationally expensive. è®¡ç®—æˆæœ¬ï¼šè®¡ç®—æ¢¯åº¦å’Œè§£å†³é«˜ç»´ä¼˜åŒ–é—®é¢˜çš„è®¡ç®—æˆæœ¬å¯èƒ½å¾ˆé«˜ã€‚ Dependence on Initial Guess: Performance and results heavily depend on the quality of the initial trajectory. å¯¹åˆå§‹çŒœæµ‹çš„ä¾èµ–ï¼šæ€§èƒ½å’Œç»“æœåœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå–å†³äºåˆå§‹è½¨è¿¹çš„è´¨é‡ã€‚ Complex Cost Function Design: Designing an appropriate and effective cost function can be challenging and problem-specific. å¤æ‚çš„æˆæœ¬å‡½æ•°è®¾è®¡ï¼šè®¾è®¡é€‚å½“ä¸”æœ‰æ•ˆçš„æˆæœ¬å‡½æ•°å¯èƒ½å…·æœ‰æŒ‘æˆ˜æ€§å¹¶ä¸”é’ˆå¯¹å…·ä½“é—®é¢˜ã€‚ Dynamic Environments: Handling highly dynamic and uncertain environments can be difficult without extensive computational resources. åŠ¨æ€ç¯å¢ƒï¼šå¦‚æœæ²¡æœ‰å¤§é‡çš„è®¡ç®—èµ„æºï¼Œå¤„ç†é«˜åº¦åŠ¨æ€å’Œä¸ç¡®å®šçš„ç¯å¢ƒå¯èƒ½ä¼šå¾ˆå›°éš¾ã€‚ Origin and Key Papers èµ·æºå’Œå…³é”®è®ºæ–‡ The principles of gradient-based optimization trace back to classical optimization theory. In trajectory planning, this concept has been extensively developed in robotics and control literature. A key early reference is \"CHOMP: Covariant Hamiltonian Optimization for Motion Planning\" by Marc Toussaint and Sachin Chitta, which formalized gradient-based optimization in the context of trajectory planning. Other significant contributions include works on STOMP (Stochastic Trajectory Optimization for Motion Planning) and TrajOpt (Trajectory Optimization). åŸºäºæ¢¯åº¦çš„ä¼˜åŒ–åŸç†å¯ä»¥è¿½æº¯åˆ°ç»å…¸ä¼˜åŒ–ç†è®ºã€‚ åœ¨è½¨è¿¹è§„åˆ’ä¸­ï¼Œè¿™ä¸ªæ¦‚å¿µå·²åœ¨æœºå™¨äººæŠ€æœ¯å’Œæ§åˆ¶æ–‡çŒ®ä¸­å¾—åˆ°å¹¿æ³›å‘å±•ã€‚ ä¸€ä¸ªé‡è¦çš„æ—©æœŸå‚è€ƒæ–‡çŒ®æ˜¯ Marc Toussaint å’Œ Sachin Chitta æ’°å†™çš„â€œCHOMPï¼šè¿åŠ¨è§„åˆ’çš„åå˜å“ˆå¯†é¡¿ä¼˜åŒ–â€ ï¼Œå®ƒåœ¨è½¨è¿¹è§„åˆ’çš„èƒŒæ™¯ä¸‹å½¢å¼åŒ–äº†åŸºäºæ¢¯åº¦çš„ä¼˜åŒ–ã€‚ å…¶ä»–é‡è¦è´¡çŒ®åŒ…æ‹¬STOMPï¼ˆè¿åŠ¨è§„åˆ’éšæœºè½¨è¿¹ä¼˜åŒ–ï¼‰å’ŒTrajOptï¼ˆè½¨è¿¹ä¼˜åŒ–ï¼‰æ–¹é¢çš„å·¥ä½œã€‚ Applications åº”ç”¨é¢†åŸŸ Autonomous Vehicles: Planning collision-free and efficient routes in complex environments. Robotics: Motion planning for robotic arms, humanoid robots, and drones. Computer Graphics: Smooth trajectory generation for animations. Space Exploration: Path optimization for spacecraft and planetary rovers. Medical Robotics: Trajectory planning for surgical robots to ensure precision. åŒ»ç–—æœºå™¨äººï¼šæ‰‹æœ¯æœºå™¨äººçš„è½¨è¿¹è§„åˆ’ä»¥ç¡®ä¿ç²¾åº¦ã€‚ è‡ªåŠ¨é©¾é©¶è½¦è¾†ï¼šåœ¨å¤æ‚ç¯å¢ƒä¸­è§„åˆ’æ— ç¢°æ’ä¸”é«˜æ•ˆçš„è·¯çº¿ã€‚ æœºå™¨äººæŠ€æœ¯ï¼šæœºæ¢°è‡‚ã€äººå½¢æœºå™¨äººå’Œæ— äººæœºçš„è¿åŠ¨è§„åˆ’ã€‚ è®¡ç®—æœºå›¾å½¢å­¦ï¼šåŠ¨ç”»çš„å¹³æ»‘è½¨è¿¹ç”Ÿæˆã€‚ å¤ªç©ºæ¢ç´¢ï¼šèˆªå¤©å™¨å’Œè¡Œæ˜Ÿæ¼«æ¸¸å™¨çš„è·¯å¾„ä¼˜åŒ–ã€‚ Related Techniques ç›¸å…³æŠ€æœ¯ Gradient-based trajectory planning is part of a broader class of optimization-based motion planning techniques, including: åŸºäºæ¢¯åº¦çš„è½¨è¿¹è§„åˆ’æ˜¯æ›´å¹¿æ³›çš„åŸºäºä¼˜åŒ–çš„è¿åŠ¨è§„åˆ’æŠ€æœ¯çš„ä¸€éƒ¨åˆ†ï¼ŒåŒ…æ‹¬ï¼š Sampling-based Planning (e.g., RRT, PRM): Focus on randomly sampling the configuration space. åŸºäºé‡‡æ ·çš„è§„åˆ’ï¼ˆä¾‹å¦‚ï¼ŒRRTã€PRMï¼‰ ï¼šé‡ç‚¹æ˜¯å¯¹é…ç½®ç©ºé—´è¿›è¡Œéšæœºé‡‡æ ·ã€‚ Optimization-based Planning (e.g., CHOMP, STOMP): Emphasize iterative refinement using optimization. åŸºäºä¼˜åŒ–çš„è§„åˆ’ï¼ˆä¾‹å¦‚ CHOMPã€STOMPï¼‰ ï¼šå¼ºè°ƒä½¿ç”¨ä¼˜åŒ–è¿›è¡Œè¿­ä»£ç»†åŒ–ã€‚ Machine Learning Approaches: Use learned models to assist or replace traditional optimization techniques. æœºå™¨å­¦ä¹ æ–¹æ³•ï¼šä½¿ç”¨å­¦ä¹ æ¨¡å‹æ¥è¾…åŠ©æˆ–å–ä»£ä¼ ç»Ÿçš„ä¼˜åŒ–æŠ€æœ¯ã€‚ "},"Learn/LearnDrones/FastDrone-250.html":{"url":"Learn/LearnDrones/FastDrone-250.html","title":"FastDrone-250","keywords":"","body":"Fast-Drone 250 eigen error: no match for â€˜operator=â€™ Important: lower eigen from 3.4.0 to 3.3.7 lower liblog4cxx from 1.0.0 to 0.10.0 dependent ros package (noetic): control_toolbox - melodic-devel ddynamic_reconfigure - kinetic-devel geographic_info - master geometry2 - noetic-devel mavlink-gbp-release - release/noetic/mavlink mavros - master pcl_msgs - noetic-devel perception_pcl - melodic-devel realtime_tools - melodic-devel unique_identifier - master in your catkin workspace: catkin_make_isolated --install \\ -DCMAKE_BUILD_TYPE=Release \\ -DPYTHON_EXECUTABLE=/usr/bin/python3 "},"Learn/LearnDrones/Planner/FastPlanner-2019.html":{"url":"Learn/LearnDrones/Planner/FastPlanner-2019.html","title":"FastPlanner-2019","keywords":"","body":"Fast Planner 2019 B. Zhou, F. Gao, L. Wang, C. Liu, and S. Shen, Robust and efficient quadrotor trajectory generation for fast autonomous flight, IEEE Robotics and Automation Letters, vol. 4, no. 4, pp. 3529â€“3536, 2019 "},"Learn/LearnDrones/Planner/EGO-Swarm-2021.html":{"url":"Learn/LearnDrones/Planner/EGO-Swarm-2021.html","title":"EGO-Swarm-2021","keywords":"","body":"EGO-Swarm-21 æœ¬æ–‡æå‡ºäº†ä¸€ç§å»ä¸­å¿ƒåŒ–çš„ã€å¼‚æ­¥çš„ç³»ç»Ÿçš„è§£å†³æ–¹æ¡ˆï¼Œç”¨äºä»…åˆ©ç”¨æœºè½½èµ„æºåœ¨éšœç¢ç‰©ä¸°å¯Œçš„æœªçŸ¥åœºæ™¯ä¸­å®ç°å¤šæœºå™¨äººè‡ªä¸»å¯¼èˆªã€‚è§„åˆ’ç³»ç»Ÿæ˜¯åœ¨åŸºäºæ¢¯åº¦çš„å±€éƒ¨è§„åˆ’æ¡†æ¶ä¸‹åˆ¶å®šçš„ï¼Œé€šè¿‡å°†ç¢°æ’é£é™©è¡¨è¿°ä¸ºéçº¿æ€§ä¼˜åŒ–é—®é¢˜çš„æƒ©ç½šæ¥é¿å…ç¢°æ’ã€‚ä¸ºäº†æé«˜é²æ£’æ€§å¹¶æ‘†è„±å±€éƒ¨æœ€å°å€¼ï¼Œæˆ‘ä»¬é‡‡ç”¨äº†ä¸€ç§è½»é‡çº§æ‹“æ‰‘è½¨è¿¹ç”Ÿæˆæ–¹æ³•ã€‚ç„¶åï¼Œæ™ºèƒ½ä½“ï¼ˆAgentï¼‰åˆ©ç”¨ä¸å¯é çš„è½¨è¿¹å…±äº«ç½‘ç»œï¼Œåœ¨å‡ æ¯«ç§’å†…ç”Ÿæˆå®‰å…¨ã€å¹³æ»‘å’ŒåŠ¨æ€å¯è¡Œçš„è½¨è¿¹ã€‚é€šè¿‡ä½¿ç”¨æ·±åº¦å›¾åƒä¸­çš„æ™ºèƒ½ä½“æ£€æµ‹æ¥çº æ­£æ™ºèƒ½ä½“ä¹‹é—´çš„ç›¸å¯¹å®šä½æ¼‚ç§»ã€‚æˆ‘ä»¬çš„æ–¹æ³•åœ¨æ¨¡æ‹Ÿå’Œå®é™…å®éªŒä¸­éƒ½å¾—åˆ°äº†éªŒè¯ã€‚æºä»£ç å·²å‘å¸ƒï¼Œä¾›ç¤¾åŒºå‚è€ƒã€‚ nontriviality of obstacle parameterization éšœç¢ç‰©å‚æ•°åŒ–çš„å¤æ‚æ€§ limited sensing range æœ‰é™çš„æ„ŸçŸ¥èŒƒå›´ unreliable and bandwidth limited communication ä¸å¯é å’Œå¸¦å®½æœ‰é™çš„é€šä¿¡ positioning drift caused by inconsistent localization ä¸ä¸€è‡´å®šä½å¼•èµ·çš„ä½ç½®æ¼‚ç§» æ‹“æ‰‘è§„åˆ’å’Œäº’åŠ¨é¿éšœ 1 Introduction å››æ—‹ç¿¼æœºçš„çµæ´»æ€§ä½¿å¾—è¯¥æœºå™¨èƒ½å¤Ÿåœ¨æœªçŸ¥ç¯å¢ƒä¸­è¿›è¡Œå•ä¸€æœºå™¨è‡ªä¸»å¯¼èˆªï¼Œå¹¶åœ¨å¼€æ”¾æˆ–å·²çŸ¥é¢†åŸŸä¸­è¿›è¡Œå¤šæœºç²¾ç¡®ç¼–é˜Ÿæ§åˆ¶ã€‚ç„¶è€Œï¼Œå¾ˆå°‘æœ‰å·¥ä½œåŒæ—¶ç»“åˆè¿™ä¸¤è€…æ¥å±•ç¤ºèƒ½å¤Ÿåœ¨å…±äº«ç›¸åŒæœªçŸ¥ç©ºé—´çš„å››æ—‹ç¿¼æœºç¾¤ä½“ä¸­å¯¼èˆªçš„çœŸå®ç³»ç»Ÿï¼Œå°¤å…¶æ˜¯ä»…é€šè¿‡æœºè½½å¤„ç†ã€‚éƒ¨ç½²å¤šä¸ªå››æ—‹ç¿¼æœºåœ¨æœªçŸ¥ç¯å¢ƒä¸­å­˜åœ¨çš„å›°éš¾åŒ…æ‹¬ä½†ä¸é™äºéšœç¢ç‰©å‚æ•°åŒ–çš„å¤æ‚æ€§ã€æœ‰é™çš„æ„ŸçŸ¥èŒƒå›´ã€ä¸å¯é å’Œå¸¦å®½æœ‰é™çš„é€šä¿¡ä»¥åŠç”±ä¸ä¸€è‡´å®šä½å¼•èµ·çš„ä½ç½®æ¼‚ç§»ã€‚ä¸€äº›ç›¸å…³å·¥ä½œï¼Œä¾‹å¦‚ï¼Œæ¨è¿›äº†çœŸå®çš„å››æ—‹ç¿¼æœºç¾¤ä½“èƒ½å¤Ÿé¿éšœçš„èƒ½åŠ›ã€‚ç„¶è€Œï¼Œä¸Šè¿°å›°éš¾åœ¨å¤§å¤šæ•°ä¹‹å‰çš„å·¥ä½œä¸­ç»å¸¸è¢«å¿½ç•¥ï¼Œåœ¨è¿åŠ¨æ•æ‰ç³»ç»Ÿæˆ–çº¯ç²¹æ¨¡æ‹Ÿä¸­ï¼Œé™åˆ¶äº†å®ƒä»¬ç®—æ³•åœ¨å®è·µä¸­çš„åº”ç”¨ã€‚ æœ¬æ–‡æå‡ºäº†ä¸€ç§ç³»ç»Ÿæ€§çš„è§£å†³æ–¹æ¡ˆï¼Œèƒ½å¤Ÿåœ¨å­˜åœ¨ä¸Šè¿°å›°éš¾çš„æ‹¥æŒ¤ç¯å¢ƒä¸­å¯¹å››æ—‹ç¿¼æœºç¾¤ä½“è¿›è¡Œé«˜æ€§èƒ½è¡Œè¿›ã€‚æ­¤å¤–ï¼Œå®ƒä¸éœ€è¦å¤–éƒ¨å®šä½å’Œè®¡ç®—æˆ–é¢„å…ˆæ„å»ºçš„åœ°å›¾ã€‚æ‰€æå‡ºçš„ç³»ç»Ÿåä¸º$\\textbf{EGO-Swarm}$ï¼Œæ˜¯æˆ‘ä»¬å…ˆå‰å·¥ä½œ ESDF-free Gradient-based lOcal planner (EGO-Planner) çš„æ‰©å±•ï¼Œä¸ºæœªçŸ¥ç¯å¢ƒä¸­å•ä¸€å››æ—‹ç¿¼æœºçš„æœºè½½å±€éƒ¨è§„åˆ’å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚è¯¥æ‰©å±•åŒ…æ‹¬ä¸¤ä¸ªéƒ¨åˆ†ï¼Œæ‹“æ‰‘è§„åˆ’å’Œäº’åŠ¨é¿éšœã€‚ å¦‚å›¾ 3 æ‰€ç¤ºï¼Œéå‡¸é…ç½®ç©ºé—´å¯èƒ½ä¼šå¯¼è‡´ä¸å¸Œæœ›çš„è¡Œä¸ºï¼Œä¾‹å¦‚åŠ¨åŠ›å­¦ä¸å¯è¡Œæ€§æˆ–æ‹¥æŒ¤å¯¼èˆªã€‚å› æ­¤ï¼Œåƒæ‹“æ‰‘è§„åˆ’è¿™æ ·çš„ç­–ç•¥å¯ä»¥æœ‰åŠ©äºæ‘†è„±å±€éƒ¨æœ€å°å€¼ã€‚åŸºäº EGO-Planner ä¸­çš„ç¢°æ’æˆæœ¬å…¬å¼ï¼Œå‰ç«¯æ‹“æ‰‘è·¯å¾„æœç´¢æ˜¯éšå«å®Œæˆçš„ï¼Œå› æ­¤å‡ ä¹ä¸éœ€è¦è®¡ç®—ã€‚ é€šè¿‡å°†ç¾¤ä½“ç¢°æ’çš„åŠ æƒæƒ©ç½šæ·»åŠ åˆ°ç›®æ ‡å‡½æ•°ä¸­ï¼Œå®ç°äº†åˆ†æ•£çš„äº’åŠ¨é¿éšœã€‚è¿™ä¸ªæƒ©ç½šæ˜¯é€šè¿‡å°†æœªæ¥ä¸€æ®µæ—¶é—´å†…çš„æ™ºèƒ½ä½“åˆ†å¸ƒä¸æ­£åœ¨ä¼˜åŒ–çš„è½¨è¿¹è¿›è¡Œæ¯”è¾ƒæ¥è¯„ä¼°çš„ã€‚ä¸ºäº†æœ€å°åŒ–æ•°æ®ä¼ è¾“å¹¶å…è®¸ä¸å¯é çš„é€šä¿¡ï¼Œä½¿ç”¨å¹¿æ’­ç½‘ç»œå…±äº«è½¨è¿¹ã€‚è€Œæ ¡æ­£ç›¸å¯¹å®šä½æ¼‚ç§»ï¼ˆå¯ä»¥å¢åŠ åˆ°åŠç±³ï¼‰ï¼Œåˆ™æ˜¯é€šè¿‡æ¯”è¾ƒç›®å‡»æ™ºèƒ½ä½“çš„è§‚æµ‹å’Œè½¨è¿¹è¯„ä¼°çš„é¢„æµ‹æ¥è¿›è¡Œã€‚ æ‹“æ‰‘è§„åˆ’ï¼štopological planning äº’åŠ¨é¿éšœï¼šreciprocal collision avoidance 2 Related Works A. Single Quadrotor Local Planning å•å››æ—‹ç¿¼é£è¡Œå™¨å±€éƒ¨è§„åˆ’ åŸºäºæ¢¯åº¦çš„è¿åŠ¨è§„åˆ’æ˜¯å››æ—‹ç¿¼æœºå™¨äººå±€éƒ¨è§„åˆ’çš„ä¸»æµæ–¹æ³•ã€‚åŸºäºå¼€åˆ›æ€§çš„ç ”ç©¶ [4, 5]ï¼Œè¿™äº›ç ”ç©¶å°†å±€éƒ¨è§„åˆ’é—®é¢˜å½¢å¼åŒ–ä¸ºæ— çº¦æŸçš„éçº¿æ€§ä¼˜åŒ–é—®é¢˜ï¼Œæå‡ºäº†ä¸€ç³»åˆ—çš„å·¥ä½œ [6]â€“[10]ã€‚è¿™äº›å·¥ä½œè€ƒè™‘äº†è½¨è¿¹çš„å¹³æ»‘æ€§ã€å¯è¡Œæ€§å’Œå®‰å…¨æ€§ï¼Œé‡‡ç”¨äº†å¤šç§å‚æ•°åŒ–æ–¹æ³•ï¼ŒåŒ…æ‹¬å¤šé¡¹å¼å’Œ B æ ·æ¡æ›²çº¿ã€‚æœ€è¿‘æˆ‘ä»¬æå‡ºäº†ä¸€ç§åä¸º EGO-Planner çš„å•å››æ—‹ç¿¼å¯¼èˆªç³»ç»Ÿ [3]ï¼Œé€šè¿‡é‡‡ç”¨æ›´ç´§å‡‘çš„ç¯å¢ƒè¡¨ç¤ºæ–¹æ³•ï¼Œè¿›ä¸€æ­¥å‡å°‘äº†è®¡ç®—æ—¶é—´ã€‚æœ¬æ–‡çš„ç ”ç©¶å³åŸºäºæ­¤å·¥ä½œã€‚ åŸºäºæ¢¯åº¦çš„è¿åŠ¨è§„åˆ’ EGO-Planner-20 B. Topological Planning æ‹“æ‰‘è§„åˆ’ æ‹“æ‰‘è§„åˆ’ç”¨äºé¿å…å±€éƒ¨æœ€å°å€¼ã€‚ åŸºäºå¤åˆ†æä¸­çš„äºŒç»´æ›²é¢åŒèƒšç­‰ä»·å…³ç³» [11]ï¼ŒRosmann ç­‰ [12]æå‡ºäº†ä¸€ç§åœ¨ä¸åŒæ‹“æ‰‘ç»“æ„ä¸‹ä½¿ç”¨ Voronoi å’ŒåŸºäºé‡‡æ ·çš„å‰ç«¯ä»¥åŠ TEBï¼ˆTimed-Elastic-Bandsï¼‰å±€éƒ¨è§„åˆ’å™¨ [13]ä½œ ä¸ºåç«¯çš„è½¨è¿¹è§„åˆ’æ–¹æ³•ã€‚ ç„¶è€Œï¼Œä¸‰ç»´ä¸­çš„åŒèƒšç­‰ä»·å…³ç³»è¦ç®€å•å¾—å¤šã€‚ä¸ºäº†æ•æ‰åˆ°åŒºåˆ«æ˜æ˜¾çš„æœ‰ç”¨è·¯å¾„ï¼ŒJaillet ç­‰ [14]æ„å»ºäº†è§†è§‰å˜å½¢è·¯ç½‘ï¼Œå®ƒåŒ…å«äº†æ¯”åŒä¼¦ç­‰ä»·ç±»çš„å…¸å‹è·¯å¾„æ›´ä¸°å¯Œä¸”æ›´ç›¸å…³çš„ä¿¡æ¯ã€‚åŸºäº [14]ï¼ŒZhou ç­‰ [15]é€šè¿‡æå‡ºä¸€ç§æœ‰æ•ˆçš„æ‹“æ‰‘ç­‰ä»·æ€§æ£€æµ‹å®ç°äº†å®æ—¶æ‹“æ‰‘è§„åˆ’ã€‚æˆ‘ä»¬è¿›ä¸€æ­¥æ‰©å±•äº† EGO-Planner ä»¥åŠ é€Ÿæ‹“æ‰‘è§„åˆ’çš„å‰ç«¯éƒ¨åˆ†ã€‚ C. Decentralized Drone Swarm å»ä¸­å¿ƒåŒ–æ— äººæœºé›†ç¾¤ å»ä¸­å¿ƒåŒ–æ–¹æ³•å·²ç»åœ¨æ–‡çŒ®ä¸­æå‡ºï¼Œä¾‹å¦‚ [16]â€“[20]ã€‚é€Ÿåº¦éšœç¢è¢«ç”¨æ¥ä¿è¯ç‚¹æœºå™¨äºº [16]ã€ å…¨å‘æ€§ä»£ç†[17]å’Œéå…¨å‘æ€§ä»£ç† [18]çš„æ— ç¢°æ’èˆªè¿¹ã€‚ Liu ç­‰äºº [21]æå‡ºäº†ä¸€ç§å»ä¸­å¿ƒåŒ–å¼‚æ­¥è§„åˆ’ç­–ç•¥ï¼Œç”¨äºé¿å…é™æ€/åŠ¨æ€éšœç¢ç‰©å’Œè½¦è¾†é—´ç¢°æ’ã€‚è™½ç„¶è¿™äº›ç®—æ³•é€šè¿‡ä»¿çœŸè¿›è¡Œäº†éªŒè¯ï¼Œä½†æœªé›†æˆæ„ŸçŸ¥ã€å»ºå›¾å’Œè§„åˆ’èƒ½åŠ›ã€‚å®éªŒç»“æœåœ¨æ–‡çŒ®ä¸­å·²ç»å±•ç¤º [19, 20]ã€‚ [19]å®ç°äº†å¤šè½¦è¾†ç‚¹å¯¹ç‚¹è½¬ç§»è€Œæ— éœ€å¤–éƒ¨éšœç¢ç‰©ï¼Œè€Œ [20]åˆ™ä¾èµ–äºä¸“é—¨çš„è§„åˆ’ä¼˜å…ˆçº§ã€‚ç„¶è€Œï¼Œè¿™äº›ç®—æ³•å‡æœªåœ¨å®åœ°ç¯å¢ƒä¸­å®ç°å…¨è‡ªä¸»åŒ–ã€‚ 3 IMPLICIT TOPOLOGICAL TRAJECTORY GENERATION OF GRADIENT-BASED LOCAL PLANNING åŸºäºæ¢¯åº¦çš„å±€éƒ¨è§„åˆ’éšå¼æ‹“æ‰‘è½¨è¿¹ç”Ÿæˆ æœ¬èŠ‚é¦–å…ˆä»‹ç»äº†æˆ‘ä»¬ä¹‹å‰å…³äº EGO-Planner çš„å·¥ä½œ\\cite{zhou2020ego}ï¼Œè¿™æ˜¯æˆ‘ä»¬æå‡ºçš„ç¾¤ä½“ç³»ç»Ÿçš„åŸºç¡€ã€‚ ç„¶åè§£é‡Šäº†æ‰€æå‡ºçš„æ‹“æ‰‘è§„åˆ’ç­–ç•¥ã€‚ A. An ESDF-Free Gradient-based local planner ä½œä¸ºåŸºäºæ¢¯åº¦çš„å±€éƒ¨è§„åˆ’å™¨ï¼ŒEGO-Planner å°†è½¨è¿¹ç”Ÿæˆé—®é¢˜å½¢å¼åŒ–ä¸ºä¸€ä¸ªéçº¿æ€§ä¼˜åŒ–é—®é¢˜ï¼Œå®ƒåœ¨å¹³æ»‘åº¦ $J_s$ã€ç¢°æ’ $J_c$ã€åŠ¨æ€å¯è¡Œæ€§ $J_d$ å’Œç»ˆç«¯è¿›åº¦ $J_t$ ä¹‹é—´è¿›è¡Œæƒè¡¡ã€‚ ä¼˜åŒ–é—®é¢˜çš„å†³ç­–å˜é‡æ¥è‡ªäºæ§åˆ¶ç‚¹ $\\mathbf{Q}$ï¼Œè¿™äº›æ§åˆ¶ç‚¹ç”¨äºå‚æ•°åŒ–è½¨è¿¹çš„å‡åŒ€ B-æ ·æ¡ $\\mathbf{\\Phi}$ã€‚é—®é¢˜å®šä¹‰å¦‚ä¸‹ï¼š minâ¡QJEGO=âˆ‘Î»rJr, \\min _{\\mathbf{Q}} J_{\\mathrm{EGO}}=\\sum \\lambda_{r} J_{r}, Qminâ€‹JEGOâ€‹=âˆ‘Î»râ€‹Jrâ€‹, å…¶ä¸­ $r={s,c,d,t}$ï¼Œä¸‹æ ‡ä¸º$\\lambda$è¡¨ç¤ºç›¸åº”çš„æƒé‡ã€‚ $J$ çš„é¡¹å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼šæœ€å°è¯¯å·®å’Œè½¯éšœç¢çº¦æŸã€‚ æœ€å°è¯¯å·®é¡¹ $J_s$ å’Œ$J_t$ï¼Œé€šè¿‡æœ€å°åŒ–å†³ç­–å˜é‡çº¿æ€§å˜æ¢$L(\\mathbf{Q})$ä¸æœŸæœ›å€¼ $\\mathcal{D}$ä¹‹é—´çš„æ€»è¯¯å·®ï¼Œè¢«è¡¨ç¤ºä¸º Jr=âˆ‘QâˆˆÎ¦âˆ¥L(Q)âˆ’Dâˆ¥nn J_{r}=\\sum_{\\mathbf{Q} \\in \\boldsymbol{\\Phi}}\\|L(\\mathbf{Q})-\\mathcal{D}\\|_{n}^{n} Jrâ€‹=QâˆˆÎ¦âˆ‘â€‹âˆ¥L(Q)âˆ’Dâˆ¥nnâ€‹ è½¯è¾¹ç•Œçº¦æŸé¡¹ $J_c$ å’Œ $J_d$ æ˜¯æƒ©ç½šå†³ç­–å˜é‡è¶…è¿‡ç‰¹å®šé˜ˆå€¼ $\\mathcal{T}$ çš„å¸¸è§è¡¨è¾¾å¼ã€‚ Jr=âˆ‘QâˆˆÎ¦{âˆ¥L(Q)âˆ’(Tâˆ’Ïµ)Sâˆ¥nnL(Q)>(Tâˆ’Ïµ)0L(Q)â‰¤(Tâˆ’Ïµ) J_{r}=\\sum_{\\mathbf{Q} \\in \\boldsymbol{\\Phi}}\\left\\{\\begin{array}{cl}\\left\\|\\frac{L(\\mathbf{Q})-(\\mathcal{T}-\\epsilon)}{S}\\right\\|_{n}^{n} & L(\\mathbf{Q})>(\\mathcal{T}-\\epsilon) \\\\ 0 & L(\\mathbf{Q}) \\leq(\\mathcal{T}-\\epsilon)\\end{array}\\right. Jrâ€‹=QâˆˆÎ¦âˆ‘â€‹{âˆ¥âˆ¥âˆ¥âˆ¥â€‹SL(Q)âˆ’(Tâˆ’Ïµ)â€‹âˆ¥âˆ¥âˆ¥âˆ¥â€‹nnâ€‹0â€‹L(Q)>(Tâˆ’Ïµ)L(Q)â‰¤(Tâˆ’Ïµ)â€‹ å…¶ä¸­ï¼Œå‚æ•°$S$ï¼Œ$n$å’Œ $\\epsilon$å½±å“ç€å•è¾¹çº¦æŸè¿‘ä¼¼çš„å‡†ç¡®åº¦ï¼Œå¦‚\\cite{rosmann2012trajectory}æ‰€è¿°ã€‚ å˜æ¢$L(\\cdot)$å’Œå‚æ•°æ ¹æ®æƒ©ç½šç±»å‹é€‰æ‹©ã€‚ ç”±äºç¯‡å¹…æœ‰é™ï¼Œåœ¨æ­¤å¤„çœç•¥äº†$L(\\cdot)$çš„å…·ä½“å½¢å¼ï¼Œå¯åœ¨\\cite{zhou2020ego}ä¸­æ‰¾åˆ°ã€‚ åœ¨ EGO-Planner ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§æ–°é¢–çš„éšœç¢ç‰©è·ç¦»ä¼°è®¡æ–¹æ³•ï¼Œè¯¥æ–¹æ³•æ ¹æ®æ¯ä¸ª $\\mathbf{Q}$ç‹¬ç«‹æ‹¥æœ‰çš„ç¯å¢ƒä¿¡æ¯è¿›è¡Œå‚æ•°åŒ–ã€‚ ç”±è‹¥å¹² ${\\mathbf{p},\\mathbf{v}}$å¯¹å‚æ•°åŒ–çš„ä¿¡æ¯é«˜åº¦æŠ½è±¡è‡ªå‘¨å›´éšœç¢ç‰©ï¼Œå…¶ä¸­ $\\mathbf{p}$è¡¨ç¤ºéšœç¢ç‰©è¡¨é¢ä¸Šçš„é”šç‚¹ï¼Œ $\\mathbf{v}$è¡¨ç¤ºä»å†…éƒ¨æŒ‡å‘å¤–éƒ¨çš„å®‰å…¨æ–¹å‘ï¼Œå¦‚å›¾ \\ref{pic:ap_v_pair} æ‰€ç¤ºã€‚ ç„¶åï¼Œç¬¬ $i$ ä¸ªæ§åˆ¶ç‚¹ $\\mathbf{Q}_i$åˆ°ç¬¬$j$ä¸ªéšœç¢ç‰©çš„éšœç¢ç‰©è·ç¦»$d{ij}$è¢«å®šä¹‰ä¸º TODO ${\\mathbf{p},\\mathbf{v}}$ å¯¹çš„ç”Ÿæˆå’Œè½¨è¿¹ä¼˜åŒ–è¿‡ç¨‹å¦‚å›¾ \\ref{pic:a*p_v_pair} å’Œ \\ref{pic:final_traj}æ‰€ç¤ºã€‚ é¦–å…ˆï¼Œç»™å‡ºä¸€ä¸ªç®€å•çš„åˆå§‹è½¨è¿¹ $\\mathbf{\\Phi}$ ï¼Œä¸è€ƒè™‘ç¢°æ’ã€‚ ç„¶åï¼Œæœç´¢è¿æ¥ç¢°æ’æ®µä¸¤ç«¯çš„å®‰å…¨è·¯å¾„ $\\mathbf{\\Gamma}$ã€‚ ç„¶åï¼Œä»$\\mathbf{\\Phi}$åˆ° $\\mathbf{\\Gamma}$ ç”Ÿæˆå‘é‡ $\\mathbf{v}$ ï¼Œå¹¶åœ¨éšœç¢ç‰©è¡¨é¢å®šä¹‰ $\\mathbf{p}$ ã€‚ é€šè¿‡ç”Ÿæˆçš„ ${\\mathbf{p},\\mathbf{v}}$ å¯¹ï¼Œè§„åˆ’å™¨æœ€å¤§åŒ– $d*{ij}$ å¹¶è¿”å›ä¼˜åŒ–çš„è½¨è¿¹ã€‚ ç”±äºæ–‡ç« é•¿åº¦æœ‰é™ï¼Œæˆ‘ä»¬åªæä¾›äº† EGO-Planner åŸºæœ¬æ€æƒ³çš„ç®€åŒ–æè¿°ã€‚ è¯¦ç»†è§£é‡Šå¯å‚è§\\cite{zhou2020ego}ã€‚ B. Implicit Topological Trajectory Generation åˆ†æ\\cite{jaillet2008path, zhou2020robust}å‘ç°ï¼Œå¹¿æ³›ä½¿ç”¨çš„åŒä¼¦æ¦‚å¿µæ— æ³•å¾ˆå¥½åœ°æ•æ‰ä¸‰ç»´æƒ…å†µä¸‹çš„å€™é€‰è½¨è¿¹ï¼Œå¦‚å›¾\\ref{pic:topo_relation}æ‰€ç¤ºã€‚å› æ­¤ï¼ŒJaillet ç­‰äºº\\cite{jaillet2008path}æå‡ºäº†åœ¨ä¸‰ç»´ç©ºé—´ä¸­æ›´æœ‰ç”¨çš„å…³ç³»ï¼Œç§°ä¸ºå¯è§æ€§å˜å½¢ï¼ˆVD-visibility deformationï¼‰ï¼Œè€Œ Zhou ç­‰äºº\\cite{zhou2020robust}è¿›ä¸€æ­¥æå–äº† VD çš„ä¸€ä¸ªå­é›†ï¼Œç§°ä¸ºå‡åŒ€å¯è§æ€§å˜å½¢ï¼ˆUVD-uniform visibility deformationï¼‰ï¼Œè¿™ä½¿å¾—å®æ—¶æ“ä½œæˆä¸ºå¯èƒ½ã€‚ç„¶è€Œï¼Œæœ¬æ–‡ä»ç„¶æ²¿ç”¨ä¹‹å‰çš„ç ”ç©¶ä¸­ä½¿ç”¨çš„æœ¯è¯­â€œæ‹“æ‰‘è§„åˆ’â€ï¼Œä»¥é¿å…æ­§ä¹‰ã€‚æ»¡è¶³ UVD çš„è½¨è¿¹è¢«è®¤ä¸ºæ˜¯åŒèƒšçš„ã€‚\\cite{zhou2020robust}ä¸­å®šä¹‰çš„ UVD ä¸ºï¼š å®šä¹‰ 1ï¼š ä¸¤æ¡è½¨è¿¹ $\\tau_1(s)$ã€ $\\tau_2(s)$ï¼Œå…¶å‚æ•°ä¸º $s\\in \\left[0,1\\right]$ï¼Œä¸”æ»¡è¶³ $\\tau_1(0) = \\tau_2(0)$ã€ $\\tau_1(1) = \\tau_2(1)$ çš„æ¡ä»¶ï¼Œå¦‚æœå¯¹äºæ‰€æœ‰çš„ $s$ï¼Œçº¿æ®µ $\\tau_1(s) \\tau_2(s)$ æ²¡æœ‰ç¢°æ’ï¼Œåˆ™å±äºç›¸åŒçš„ UVD ç±»åˆ«ã€‚ ä¼ ç»Ÿçš„æ‹“æ‰‘è§„åˆ’æ–¹æ³• \\cite{jaillet2008path, rosmann2012trajectory, rosmann2017integrated, zhou2020robust} ä¸»è¦ç”±æ‹“æ‰‘ä¸åŒçš„è·¯å¾„æœç´¢å’Œåç«¯ä¼˜åŒ–ç»„æˆï¼Œä¸»è¦å…³æ³¨åœ¨æ‹“æ‰‘ä¸Šä¸åŒçš„åŒä¼¦ä¸­å¯»æ‰¾å¤šä¸ªåˆå§‹è·¯å¾„ã€‚ ä¸è¿™äº›æ–¹æ³•ä¸åŒï¼Œæ‰€æå‡ºçš„æ–¹æ³•é€šè¿‡å°† $\\mathbf{v}$ åè½¬ä¸º $\\mathbf{v}{new} := -\\mathbf{v}$ï¼Œåœ¨ä¸åŒæ–¹å‘ä¸Šæ„å»ºè·ç¦»åœºã€‚ ç„¶åï¼Œä¸€ä¸ªæœç´¢è¿‡ç¨‹åœ¨éšœç¢ç‰©è¡¨é¢ä¸Šæ²¿ç€ $\\mathbf{v}{new}$ ç¡®å®šä¸€ä¸ªæ–°çš„é”šç‚¹ $\\mathbf{p}{new}$ï¼Œå¦‚å›¾\\ref{pic:multi*p_v} æ‰€ç¤ºã€‚ å®ƒä»¬æ„æˆäº†æ–°çš„ä¸€å¯¹ ${\\mathbf{p}*{new}, \\mathbf{v}{new}}$ï¼Œå¯¼è‡´äº†ä¸€ä¸ªä¸åŒçš„å±€éƒ¨æå°å€¼ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ²¡æœ‰é‡‡ç”¨æ˜ç¡®çš„è·¯å¾„æœç´¢ï¼Œä½†æ˜¯ä»»ä½•ç»è¿‡ $\\mathbf{p}$ å’Œ $\\mathbf{p}_{new}$ çš„è·¯å¾„å¯¹åº”ç€ Def.\\ref{def:UVD} åœ¨è¿™ä¸¤ä¸ªç‚¹ä¸Šçš„è¿åã€‚ éšåï¼Œä¸åŒçš„è½¨è¿¹åœ¨ä¸åŒçš„çº¿ç¨‹ä¸­å¹¶è¡Œè¿›è¡Œä¼˜åŒ–ï¼Œå¦‚å›¾ 4.d æ‰€ç¤ºã€‚ æ‰§è¡Œæˆæœ¬æœ€ä½çš„è½¨è¿¹ã€‚ 4 æ— äººæœºé›†ç¾¤å¯¼èˆª A. Reciprocal Collision Avoidance äº’ç›¸é¿å…ç¢°æ’ è®¾$t$æ—¶åˆ»ç¬¬$k$ä¸ªä»£ç†åœ¨$K$ä¸ªä»£ç†ä¸­çš„ä½ç½®çŠ¶æ€ä¸º$x_k(t) \\in \\mathcal{X} \\subset \\mathbb{R}^3$ã€‚ $\\mathcal{X}_k^{free}(t) \\subset \\mathcal{X}$ æ˜¯è€ƒè™‘å…¶ä»–ä»£ç†å­˜åœ¨æ—¶ä»£ç†$k$çŠ¶æ€ç©ºé—´ä¸­çš„è‡ªç”±åŒºåŸŸã€‚ å› æ­¤ï¼Œ$\\mathcal{X}_k^{free}(t) := \\mathcal{X} \\backslash { i \\in \\mathbb{Z} \\backslash k, i \\leq K | x_i(t)}$ï¼Œå¹¶ä¸”å¯¹äº$\\mathbf{\\Phi}_k$çš„å®šä¹‰åŸŸä¸­çš„ä»»ä½•$t$ï¼Œ$\\mathbf{\\Phi}_k(t) \\in \\mathcal{X}_k^{free}(t)$ï¼Œå¦‚å›¾ 6 æ‰€ç¤ºã€‚ ä¸\\cite{liu2017search}ä¸åŒï¼Œè¿™é‡Œå¿½ç•¥äº†å·²åœ¨ Sec.III-A ä¸­å¤„ç†çš„éšœç¢ç‰©å’ŒåŠ¨æ€çº¦æŸã€‚ ä¸éšœç¢ç‰©ç¢°æ’å’ŒåŠ¨æ€ä¸å¯è¡Œæ€§çš„æƒ©ç½šç±»ä¼¼ï¼Œæˆ‘ä»¬ä¸ºä»£ç†$k$çš„ç¾¤ä½“é¿ç¢°åˆ¶å®šäº†æƒ©ç½šå‡½æ•°$J_{w,k}$ï¼Œä½œä¸ºè½¯çº¦æŸã€‚ dk,i(t)=âˆ¥E1/2[Î¦k(t)âˆ’Î¦i(t)]âˆ¥âˆ’(C+Ïµ) \\begin{array}{l}d_{k, i}(t)=\\left\\|\\mathbf{E}^{1 / 2}\\left[\\boldsymbol{\\Phi}_{k}(t)-\\boldsymbol{\\Phi}_{i}(t)\\right]\\right\\|-(\\mathcal{C}+\\epsilon) \\\\\\end{array} dk,iâ€‹(t)=âˆ¥âˆ¥âˆ¥â€‹E1/2[Î¦kâ€‹(t)âˆ’Î¦iâ€‹(t)]âˆ¥âˆ¥âˆ¥â€‹âˆ’(C+Ïµ)â€‹ å…¶ä¸­ï¼Œ$i \\in \\mathbb{Z} \\backslash k, i \\leq K$ ï¼Œ$ts$ å’Œ $t_e$ æ˜¯è½¨è¿¹ $\\mathbf{\\Phi}_k(t)$ æ—¶é—´è·¨åº¦å†…çš„å…¨å±€èµ·å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´ã€‚ $\\mathcal{C}$ æ˜¯ç”¨æˆ·å®šä¹‰çš„ä»£ç†é—´éš™ã€‚ $\\mathbf{E}:=\\rm{diag}(1,1,1/c), c>1$ å°†æ¬§å¼è·ç¦»è½¬æ¢ä¸ºå…·æœ‰è¾ƒçŸ­ä¸»è½´çš„æ¤­åœ†è·ç¦»ï¼Œä»¥å‡è½»ä¸‹å†²é£é™©ã€‚ å°†åŠ æƒé¡¹ $J{w,k}$ æ·»åŠ åˆ°æ–¹ç¨‹(1)ä¸­ï¼Œå¾—åˆ°æ¯ä¸ªä»£ç†çš„æ€»ä¼˜åŒ–é—®é¢˜ã€‚ minâ¡QJ=JEGO+Î»wJw. \\min _{\\mathbf{Q}} J=J_{\\mathrm{EGO}}+\\lambda_{w} J_{w}. Qminâ€‹J=JEGOâ€‹+Î»wâ€‹Jwâ€‹. ä»»ä½•åŒ…å«ä»å†³ç­–å˜é‡åˆ°è½¨è¿¹ä¸Šç‚¹çš„æ˜ å°„çš„è½¨è¿¹å‚æ•°åŒ–æ–¹æ³•éƒ½å¯ä»¥åº”ç”¨äºå…¬å¼ï¼ˆ\\ref{equ:swarm_collision}ï¼‰ã€‚ æœ¬æ–‡ä½¿ç”¨$p_b$é˜¶å‡åŒ€ B æ ·æ¡å¯¹è½¨è¿¹è¿›è¡Œå‚æ•°åŒ–ï¼Œè¿™ä½¿å¾—ä½ç½®è¯„ä¼°å…·æœ‰çŸ©é˜µè¡¨ç¤º\\cite{zhou2019robust}ã€‚ Î¦(t)=s(t)âŠ¤Mpb+1qms(t)=[1s(t)s2(t)â‹¯spb(t)]âŠ¤qm=[Qmâˆ’pbQmâˆ’pb+1Qmâˆ’pb+2â‹¯Qm]âŠ¤ \\begin{array}{l}\\boldsymbol{\\Phi}(t)=\\mathbf{s}(t)^{\\top} \\mathbf{M}_{p_{b}+1} \\mathbf{q}_{m} \\\\ \\mathbf{s}(t)=\\left[\\begin{array}{lllll}1 & s(t) & s^{2}(t) & \\cdots & s^{p_{b}}(t)\\end{array}\\right]^{\\top} \\\\ \\mathbf{q}_{m}=\\left[\\begin{array}{lllll}\\mathbf{Q}_{m-p_{b}} & \\mathbf{Q}_{m-p_{b}+1} & \\mathbf{Q}_{m-p_{b}+2} & \\cdots & \\mathbf{Q}_{m}\\end{array}\\right]^{\\top} \\\\\\end{array} Î¦(t)=s(t)âŠ¤Mpbâ€‹+1â€‹qmâ€‹s(t)=[1â€‹s(t)â€‹s2(t)â€‹â‹¯â€‹spbâ€‹(t)â€‹]âŠ¤qmâ€‹=[Qmâˆ’pbâ€‹â€‹â€‹Qmâˆ’pbâ€‹+1â€‹â€‹Qmâˆ’pbâ€‹+2â€‹â€‹â‹¯â€‹Qmâ€‹â€‹]âŠ¤â€‹ å…¶ä¸­$\\mathbf{M}{p_b+1}$æ˜¯ç”±$p_b$ç¡®å®šçš„å¸¸æ•°çŸ©é˜µï¼Œå½“$t$å±äºèŠ‚ç‚¹è·¨åº¦$(t_m, t{m+1}]$æ—¶ï¼Œ$s(t)=(t-t_m)/\\triangle t$ã€‚ B. Localization Drift Compensation å®šä½åç§»è¡¥å¿ ä½œä¸ºä¸ªä½“åœ¨æœªçŸ¥ç¯å¢ƒä¸­çš„å®šä½ï¼ˆæ²¡æœ‰å¯é çš„é«˜é¢‘ç¯è·¯é—­åˆï¼‰ï¼Œåœ¨é£è¡Œè¿‡ç¨‹ä¸­æ¼‚ç§»ä¸æ–­ç§¯ç´¯ã€‚ Xu ç­‰äºº \\cite{xu2020decentralized} æå‡ºäº†ä¸€ç§åŸºäºé¢å¤– UWB è·ç¦»æµ‹é‡çš„èˆªç©ºç¾¤ä½“çŠ¶æ€ä¼°è®¡æ–¹æ³•ï¼Œå¹¶å®ç°äº†å‡†ç¡®çš„ååŒå®šä½ã€‚ ç„¶è€Œï¼Œæˆ‘ä»¬æ›´å…³æ³¨ç©¿è¶Šå……æ»¡éšœç¢çš„ç¯å¢ƒï¼Œå¹¶ä¸”å¿…é¡»ä¸ºå…¶ä»–åº”ç”¨ç¨‹åºä¿ç•™è®¡ç®—å’Œé€šä¿¡èµ„æºã€‚ Therefore, inspired by \\cite{xu2020decentralized}, a simplified and lightweight relative drift estimation method is proposed by comparing the predicted position evaluated from received agents' trajectories and the measured positions from depth images of witnessed agents. å› æ­¤ï¼Œåœ¨ \\cite{xu2020decentralized} çš„å¯å‘ä¸‹ï¼Œé€šè¿‡æ¯”è¾ƒä»æ¥æ”¶åˆ°çš„ä»£ç†è½¨è¿¹è¯„ä¼°çš„é¢„æµ‹ä½ç½®ä¸ç›®å‡»ä»£ç†æ·±åº¦å›¾åƒä¸­æµ‹é‡ä½ç½®ï¼Œæå‡ºäº†ä¸€ç§ç®€åŒ–å’Œè½»é‡çº§çš„ç›¸å¯¹æ¼‚ç§»ä¼°è®¡æ–¹æ³•ã€‚ å½“è½¨è¿¹è·Ÿè¸ªè¯¯å·®å¯ä»¥å¿½ç•¥ä¸è®¡ï¼Œå¹¶ä¸”å¯èƒ½å‘ç”Ÿç¢°æ’çš„ä»»ä½•ä¸¤ä¸ªä»£ç†ä¸­è‡³å°‘æœ‰ä¸€å°èƒ½çœ‹åˆ°å¦ä¸€å°æ—¶ï¼Œè¯¥ç­–ç•¥ç”Ÿæ•ˆã€‚ å› æ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨ \\cite{MelKum1105} ä¸­çš„æ§åˆ¶å™¨è¿›è¡Œç²¾ç¡®è·Ÿè¸ªï¼Œå¹¶ä½¿ç”¨å¹¿è§’ç›¸æœºæ¥é™ä½å¤±å»ä»£ç†çš„å¯èƒ½æ€§ã€‚ æ¶ˆé™¤æ¼‚ç§»çš„è¿‡ç¨‹å¦‚ä¸‹ã€‚ åœ¨è¯„ä¼°ä»£ç†$i$çš„å½“å‰ä½ç½®$\\mathbf{\\Phi}i(t{now})$åï¼Œç¡®å®šä¸€ä¸ªä»¥$\\mathbf{\\Phi}i(t{now})$ä¸ºä¸­å¿ƒï¼ŒåŠå¾„ä¸º$\\mathcal{R}$çš„çƒå½¢ä¿¡ä»»åŒºåŸŸ$\\mathcal{S} \\subset \\mathbb{R}^3$ï¼Œå…¶ä¸­$\\mathcal{R}$æ˜¯ä¸€ä¸ªç»éªŒå‚æ•°ï¼Œè¡¨ç¤ºä»å®éªŒä¸­ä¼°è®¡çš„å…¸å‹æ¼‚ç§»çš„ä¸Šç•Œã€‚ ç„¶åï¼Œå°†$\\mathcal{S}$æ˜ å°„åˆ°å½“å‰æ•è·çš„æ·±åº¦å›¾åƒï¼Œå³æ»¡è¶³çš„åŒºåŸŸ$\\mathcal{S'} \\subset \\mathbb{R}^2$ã€‚ z[sâ€²âŠ¤1]âŠ¤=KTwc[sâŠ¤1]âŠ¤, z\\left[\\begin{array}{ll}\\mathbf{s}^{\\prime}{ }^{\\top} & 1\\end{array}\\right]^{\\top}=\\mathbf{K} \\mathbf{T}_{\\mathrm{w}}^{\\mathrm{c}}\\left[\\begin{array}{ll}\\mathbf{s}^{\\top} & 1\\end{array}\\right]^{\\top}, z[sâ€²âŠ¤â€‹1â€‹]âŠ¤=KTwcâ€‹[sâŠ¤â€‹1â€‹]âŠ¤, å…¶ä¸­$\\mathbf{s'} \\in \\mathcal{S'}$ï¼Œ$\\mathbf{s} \\in \\mathcal{S}$ï¼Œ$\\mathbf{K}$å’Œ$\\mathbf{T}^{\\rm{c}}_{\\rm{w}}$æ˜¯ç›¸æœºçš„å†…å‚å’Œå¤–å‚çŸ©é˜µï¼Œ$z$æ˜¯${s}$æ²¿ä¸»å…‰è½´åç¦»å…‰å­¦ä¸­å¿ƒçš„åå·®ã€‚ $\\mathcal{S'}$æ˜¯ä¸€ä¸ªéœ€è¦è¿›è¡Œå¤æ‚è®¡ç®—æ‰èƒ½å¾—åˆ°çš„æ¤­åœ†é”¥æ›²çº¿ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬é‡‡ç”¨äº†ä¸€ä¸ªè¿‘ä¼¼çš„è½´å¯¹é½æ¤­åœ†$\\mathcal{\\bar{S}'}$æ¥ä»£æ›¿ç²¾ç¡®çš„$\\mathcal{S'}$ã€‚ ç²¾ç¡®å®šä¹‰ä¿¡èµ–åŒºåŸŸå¹¶ä¸æ˜¯å¿…è¦çš„ï¼Œå› ä¸ºå®ƒåªæ˜¯ä¸€ä¸ªç»éªŒåŒºåŸŸã€‚ ç„¶åæˆ‘ä»¬å°†$\\mathcal{\\bar{S}'}$ä¸­çš„æ¯ä¸ªç‚¹æŠ•å½±åˆ°ä¸–ç•Œåæ ‡ç³»ï¼Œå¹¶æ”¶é›†å±äº$\\mathcal{S}$çš„ç‚¹ï¼Œè¿™æ ·å¾—åˆ°ä¸€ä¸ªç‚¹ç°‡$\\mathcal{P} \\subset \\mathcal{S}$ã€‚ ç„¶åï¼Œä»£ç†è§‚æµ‹çš„ä½ç½®$\\mathbf{P}$è¢«è§†ä¸º$\\mathcal{P}$çš„ä¸­å¿ƒï¼ˆç¬¬ä¸€åŸå§‹çŸ©-first raw momentï¼‰ã€‚ P=Î¼1â€²(P). \\mathbf{P}=\\mu_{1}^{\\prime}(\\mathcal{P}). P=Î¼1â€²â€‹(P). å¦‚æœ$\\mathcal{P}$ä»…åŒ…å«å¯¹åº”ä»£ç†çš„è§‚æµ‹è€Œæ²¡æœ‰ä»»ä½•æ— å…³çš„ç‰©ä½“ï¼Œåˆ™ç­‰å¼ï¼ˆ\\ref{equ:moment}ï¼‰æˆç«‹ï¼Œä½†è¿™ä¸èƒ½ä¿è¯ã€‚ ç„¶è€Œï¼Œç”±äºæ¯ä¸ªä»£ç†éƒ½å¯¹é‚»è¿‘ç‰©ä½“æœ‰é—´éš”çš„è½¨è¿¹è§„åˆ’ï¼Œç­‰å¼ï¼ˆ\\ref{equ:moment}ï¼‰åœ¨å¤§å¤šæ•°æ—¶é—´å†…æˆç«‹ã€‚ ä¸ºäº†æ”¹è¿›ä»£ç†æ£€æµ‹çš„é²æ£’æ€§ï¼Œè¿˜æ·»åŠ äº†å…¶ä»–æ¡ä»¶ï¼Œå¦‚åƒç´ æ•°ç›®ã€$\\mathcal{P}$çš„äºŒé˜¶ä¸­å¿ƒçŸ©ï¼Œå½“å‰æµ‹é‡ä¸å…ˆå‰æµ‹é‡ä¹‹é—´çš„å·®å¼‚ç­‰ã€‚ æ›´ä¸¥æ ¼çš„æ ‡å‡†ä¼šå¢åŠ è¯¯è¯†ç‡ï¼Œä½†ç”±äºå®šä½æ¼‚ç§»å˜åŒ–ç¼“æ…¢ï¼Œè¿™æ˜¯æ— å®³çš„ã€‚ æœ€åï¼Œ$\\mathbf{\\Phi}i(t{now})$å’Œ$\\mathbf{P}$ä¹‹é—´çš„è¯¯å·®è¢«é€å…¥ä¸€ä¸ªæ»¤æ³¢å™¨ï¼Œç„¶åè·å¾—ä¼°è®¡çš„æ¼‚ç§»ã€‚ C. Agent Removal from Depth Images ä»æ·±åº¦å›¾ä¸­åˆ é™¤ä»£ç† æˆ‘ä»¬ä½¿ç”¨å æ®æ …æ ¼åœ°å›¾æ¥å­˜å‚¨é™æ€éšœç¢ç‰©ï¼Œå¹¶ä½¿ç”¨æ·±åº¦å›¾åƒè¿›è¡Œåœ°å›¾èåˆã€‚ ç§»åŠ¨ä»£ç†åœ¨ç¬¬\\ref{sec:Reciprocal_Collision_Avoidance}èŠ‚ä¸­å¾—åˆ°å¤„ç†ã€‚ å› æ­¤ï¼Œåœ¨åœ°å›¾æ„å»ºä¸­æ— éœ€è®°å½•ç§»åŠ¨ä»£ç†å¹¶å°†å…¶è§†ä¸ºéšœç¢ç‰©ï¼Œç”šè‡³ä¼šäº§ç”Ÿä¸å¿…è¦çš„å¹²æ‰°ã€‚ ä¸ºäº†æ¶ˆé™¤ç§»åŠ¨ç‰©ä½“çš„å½±å“ï¼Œæˆ‘ä»¬åœ¨ç¬¬\\ref{sec:compensate_localization_drafting}èŠ‚ä¸­é€šè¿‡é®ç½©å’Œç§»é™¤æ£€æµ‹åˆ°çš„ä»£ç†çš„åƒç´ ä»æ·±åº¦å›¾åƒä¸­å‰”é™¤ï¼Œå¦‚å›¾ 7 æ‰€ç¤ºã€‚ é™¤æ­¤ä¹‹å¤–ï¼Œé®æŒ¡äº†å¤§éƒ¨åˆ†è§†é‡çš„ç§»åŠ¨ç‰©ä½“ä¹Ÿä¼šå¯¹è§†è§‰æƒ¯æ€§é‡Œç¨‹è®¡ï¼ˆVIOï¼‰äº§ç”Ÿå¹²æ‰°ã€‚ å› æ­¤ï¼Œç°åº¦å›¾åƒä¸Šçš„ä»£ç†ä¹Ÿä¼šé€šè¿‡ç›¸åº”æ·±åº¦å›¾åƒçš„ç›¸åŒé®ç½©è¿›è¡Œç§»é™¤ã€‚ è¿™é‡Œä½¿ç”¨çš„ä»£ç†æ£€æµ‹æ ‡å‡†è¾ƒä¸ºå®½æ¾ï¼Œå› ä¸ºè¯¯åˆ¤çš„æ­£æ ·æœ¬æ¯”è¯¯åˆ¤çš„è´Ÿæ ·æœ¬æ›´ä¸ºæœ‰å®³ã€‚ 5 System Architecture ç³»ç»Ÿæ¶æ„å¦‚å›¾ 8 æ‰€ç¤ºï¼Œå…¶ä¸­åŒ…å«äº†å•ä¸ªä»£ç†å’Œå¤š Agent é€šä¿¡ç³»ç»Ÿçš„è¯¦ç»†æ¶æ„ã€‚ A. Navigation System of A Single Agent å•ä¸€æ™ºèƒ½ä½“ç³»ç»Ÿï¼ŒåŒ…æ‹¬ç¡¬ä»¶å’Œè½¯ä»¶è®¾ç½®ï¼ŒåŸºäºæˆ‘ä»¬å…ˆå‰çš„å·¥ä½œEGO-Planner \\cite{zhou2020ego}ï¼Œå¢åŠ äº†ä¸€ä¸ªæ¨¡å—æ¥è¡¥å¿ VIO æ¼‚ç§»å¹¶åœ¨å›¾åƒä¸­å»é™¤è¢«è§‚å¯Ÿåˆ°çš„æ™ºèƒ½ä½“ã€‚ å¯¹äºæœªçŸ¥ç¯å¢ƒä¸­çš„è½¨è¿¹ç”Ÿæˆï¼Œä½¿ç”¨æœ¬åœ°è§„åˆ’å™¨ã€‚ å½“å½“å‰è½¨è¿¹ä¸æ–°å‘ç°çš„éšœç¢ç‰©å‘ç”Ÿç¢°æ’æˆ–æ™ºèƒ½ä½“æ¥è¿‘å½“å‰è½¨è¿¹çš„ç»“æŸæ—¶ï¼Œæ¿€æ´»è§„åˆ’ã€‚ B. Communication Framework ç³»ç»Ÿç”±ä¸¤ä¸ªç½‘ç»œè¿æ¥ï¼Œå³å…±äº«è½¨è¿¹çš„å¹¿æ’­ç½‘ç»œå’ŒåŒæ­¥æ—¶é—´æˆ³ä»¥åŠç®¡ç†é¡ºåºå¯åŠ¨çš„é“¾ç½‘ç»œã€‚ Broadcast Network å¹¿æ’­ç½‘ç»œï¼š ä¸€æ—¦ä¸€ä¸ª agent ç”Ÿæˆäº†ä¸€ä¸ªæ–°çš„æ— ç¢°æ’è½¨è¿¹ï¼Œå®ƒä¼šç«‹å³å¹¿æ’­ç»™æ‰€æœ‰çš„ agentã€‚ å…¶ä»– agent æ¥æ”¶å¹¶å­˜å‚¨è¿™ä¸ªè½¨è¿¹ï¼Œä»¥ä¾¿åœ¨å¿…è¦æ—¶ä¸ºè‡ªå·±ç”Ÿæˆå®‰å…¨è½¨è¿¹ã€‚ è¿™ç§é—­ç¯ç­–ç•¥åœ¨ç½‘ç»œè¿æ¥ç¨³å®šä¸”å»¶è¿Ÿå¯å¿½ç•¥çš„ç†æƒ³æƒ…å†µä¸‹èƒ½æ­£å¸¸å·¥ä½œã€‚ ç„¶è€Œï¼Œåœ¨å®è·µä¸­ä¸èƒ½ä¿è¯è¿™ä¸€ç‚¹ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸¤ç§æ–¹æ³•æ¥å‡å°‘ç¢°æ’çš„å¯èƒ½æ€§ã€‚ é¦–å…ˆï¼Œåœ¨ç½‘ç»œå®¹é‡ä¸‹ä»¥ç»™å®šé¢‘ç‡å¹¿æ’­ä¸€ä¸ªè½¨è¿¹ã€‚ è¿™ä¸ä¼šå¼•èµ·è®¡ç®—è´Ÿæ‹…ï¼Œå› ä¸ºå…¸å‹çš„è½¨è¿¹åŒ…å« 3D èˆªç‚¹å’Œå…¶ä»–å‚æ•°ï¼Œå¤§å°å°äº 0.5KBã€‚ ç›¸æ¯”ä¹‹ä¸‹ï¼Œç°ä»£æ— çº¿ç½‘ç»œå¦‚è“ç‰™\\footnote{https://www.bluetooth.com/}å¯ä»¥å®ç°è¶…è¿‡ 1Mbps çš„é€Ÿåº¦ã€‚ å…¶æ¬¡ï¼Œæ¯ä¸ª agent åœ¨ä»å¹¿æ’­ç½‘ç»œæ¥æ”¶åˆ°è½¨è¿¹åç«‹å³æ£€æŸ¥ç¢°æ’ï¼Œå¦‚æœå‘ç°æ½œåœ¨ç¢°æ’ï¼Œå°±ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„æ— ç¢°æ’è½¨è¿¹ã€‚ è¿™ä¸€ç­–ç•¥å¯ä»¥è§£å†³å¤šä¸ª agent åœ¨å¾ˆçŸ­çš„æ—¶é—´å†…ç”Ÿæˆè½¨è¿¹ï¼Œè€Œæ²¡æœ‰æ¥æ”¶åˆ°å…¶ä»– agent çš„è½¨è¿¹çš„é—®é¢˜ï¼Œè¿™æ˜¯ç”±äºå»¶è¿Ÿæˆ–æ•°æ®åŒ…ä¸¢å¤±é€ æˆçš„ã€‚ æ­¤å¤–ï¼Œè€ƒè™‘åˆ° agent æ•°é‡çš„å¢åŠ ä¼šå¯¼è‡´è®¡ç®—å¤æ‚åº¦çš„å¢åŠ ã€‚ åœ¨è§„åˆ’ä¹‹å‰ï¼Œæ¯ä¸ª agent å°†å…¶å½“å‰ä½ç½®ä¸æ¥æ”¶åˆ°çš„å‘¨å›´ agent çš„è½¨è¿¹è¿›è¡Œæ¯”è¾ƒï¼Œä»»ä½•è¶…å‡ºè§„åˆ’èŒƒå›´çš„è½¨è¿¹å°†è¢«å¿½ç•¥ã€‚ 2ï¼‰Chain Network é“¾å¼ç½‘ç»œï¼š ä¸€ä¸ªåŸºäºè¿æ¥çš„ç¨³å®šé“¾ç½‘ç»œè¢«ç”¨äºæ—¶é—´æˆ³åŒæ­¥å’Œç³»ç»Ÿå¯åŠ¨ç®¡ç†ã€‚ åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶ï¼Œä»£ç†ç”Ÿæˆé¢„å®šä¹‰é¡ºåºçš„è½¨è¿¹ã€‚ æ¯ä¸ªä»£ç†é€šè¿‡é“¾ç½‘ç»œåœ¨æ”¶åˆ°ä¼˜å…ˆçº§æ›´é«˜çš„ä»£ç†çš„è½¨è¿¹åç”Ÿæˆåˆå§‹è½¨è¿¹ã€‚ è¿™ç§ç­–ç•¥é¿å…äº†åœ¨ç³»ç»Ÿå¯åŠ¨è¿‡ç¨‹ä¸­ç”±äºåŒæ—¶ç”Ÿæˆè½¨è¿¹è€Œå¼•èµ·çš„æ··ä¹±ï¼Œå› ä¸ºä»£ç†åœ¨é‚£æ—¶æ²¡æœ‰å…¶ä»–è½¨è¿¹çš„ä¿¡æ¯ã€‚ 6 åŸºå‡†æµ‹è¯• åœ¨æ¨¡æ‹Ÿä¸­ï¼Œä½¿ç”¨ i7-9700KF CPU è¿›è¡ŒåŸºå‡†æ¯”è¾ƒã€‚å¯¹äºå‚æ•°è®¾ç½®ï¼Œè§„åˆ’è§†è·è®¾ç½®ä¸º 7.5mã€‚$\\lambda_s=1.0,~\\lambda_c=\\lambda_w=\\lambda_t=0.5,~\\lambda_d=0.1$ã€‚åœ°å›¾åˆ†è¾¨ç‡ä¸º 0.1mã€‚é‡æ–°è§„åˆ’æ¯ç§’è§¦å‘ä¸€æ¬¡æˆ–è€…é¢„æµ‹åˆ°ç¢°æ’æ—¶è§¦å‘ã€‚è¿™ä¸ªè®¾ç½®åœ¨æ¨¡æ‹Ÿå’ŒçœŸå®ä¸–ç•Œå®éªŒä¸­éƒ½è¢«é‡‡ç”¨ã€‚ A. Topological Planning\r æˆ‘ä»¬å°†æ‰€å»ºè®®çš„ EGO-Swarm ä¸ Fast-Planner\\cite{zhou2020robust}åœ¨å€™é€‰è½¨è¿¹æ•°å’Œå‰ç«¯æ‹“æ‰‘è·¯å¾„æœç´¢çš„è®¡ç®—æ—¶é—´æ–¹é¢çš„æ‹“æ‰‘è§„åˆ’æ€§èƒ½è¿›è¡Œæ¯”è¾ƒã€‚ å¦‚å›¾ 9 æ‰€ç¤ºï¼ŒEGO-Swarm å‘ç°çš„å€™é€‰è½¨è¿¹è¾ƒå°‘ï¼Œè¿™æ„å‘³ç€æ‰¾åˆ°å…¨å±€æœ€ä¼˜è§£çš„æ¦‚ç‡è¾ƒä½ï¼Œä½†æ¯”\\cite{zhou2020robust}å¿« 100 å€ã€‚ ç”±äº Fast-Planner é€šè¿‡ PRM\\cite{kavraki1996probabilistic}å›¾æœç´¢ã€è·¯å¾„ç¼©çŸ­å’Œè·¯å¾„ä¿®å‰ªæ¥æ‰¾åˆ°æ‹“æ‰‘ä¸Šä¸åŒçš„è·¯å¾„ï¼Œè¿™äº›æ–¹æ³•è€—æ—¶è¾ƒé•¿ä½†è‡ªç”±åº¦è¾ƒé«˜ï¼Œä¸æ‰€æå‡ºçš„éšå¼æ‹“æ‰‘è·¯å¾„æœç´¢æ–¹æ³•ç›¸æ¯”ã€‚ B. Swarm Planning In Empty Space ç©ºåœ° æˆ‘ä»¬å°†æå‡ºçš„æ–¹æ³•ä¸ DMPC\\cite{luis2019trajectory}ï¼ŒORCA\\cite{van2011reciprocalnbody}å’Œ RBP\\cite{park2020efficient}è¿›è¡Œæ¯”è¾ƒï¼Œæ¯”è¾ƒçš„æŒ‡æ ‡åŒ…æ‹¬é£è¡Œè·ç¦»($d{\\rm{fly}}$)ï¼Œé£è¡Œæ—¶é—´($t{\\rm{fly}}$)ï¼Œæ¯ä¸ªæœºå™¨äººçš„ç¢°æ’æ¬¡æ•°å’Œè®¡ç®—æ—¶é—´($t_{\\rm{cal}}$)ã€‚ æ¯ä¸ªæ¯”è¾ƒçš„æ–¹æ³•éƒ½ä½¿ç”¨é»˜è®¤å‚æ•°ï¼Œé™¤äº†æœ€å¤§é€Ÿåº¦å’ŒåŠ é€Ÿåº¦ã€‚ å¦‚å›¾\\ref{pic:multicomp}æ‰€ç¤ºï¼Œå…«ä¸ªæœºå™¨äººåœ¨ä¸€ä¸ªåœ†åœˆä¸Šè¿›è¡Œäº¤æ¢è½¬æ¢ã€‚ Tab.\\ref{tab:plan_cmp}ä¸­çš„ç»“æœæ˜¯æ‰€æœ‰æœºå™¨äººçš„å¹³å‡å€¼ã€‚ $t{\\rm{cal}}$ç”¨' *'è¡¨ç¤ºï¼Œå› ä¸ºæˆ‘ä»¬è®°å½•çš„ç¦»çº¿æ–¹æ³• DMPC å’Œ RBP çš„è®¡ç®—æ—¶é—´æ˜¯è®¡åˆ’æ‰€æœ‰æœºå™¨äººæ•´ä¸ªè½¨è¿¹çš„æ€»æ—¶é—´ï¼Œè€Œå¯¹äº ORCA å’Œ EGO-Swarm æ¥è¯´ï¼Œå®ƒæ˜¯æ¯ä¸ªæœºå™¨äººçš„æœ¬åœ°é‡æ–°è§„åˆ’æ—¶é—´ã€‚ Tab.\\ref{tab:plan_cmp}å’Œå›¾ 10 è¡¨æ˜ï¼ŒRBP å€¾å‘äºç”Ÿæˆå®‰å…¨ä½†ä¿å®ˆçš„è½¨è¿¹ï¼Œå› ä¸ºæ„å»ºå‡¸ç›¸å¯¹å®‰å…¨é£è¡Œèµ°å»Š \\cite{park2020efficient}æ˜¾è‘—å‹ç¼©äº†è§£ç©ºé—´ã€‚ DMPC è®¾è®¡ç”¨äºåˆ†å¸ƒå¼éƒ¨ç½²ã€‚ ç„¶è€Œï¼Œåœ¨çœŸå®ä¸–ç•Œçš„åº”ç”¨ä¸­æ— æ³•ä¿è¯å‡†ç¡®å’Œé«˜é¢‘çš„å§¿æ€é€šä¿¡ã€‚ é«˜æ•ˆçš„è§„åˆ™ä½¿ ORCA æ›´æ–°é€Ÿåº¦å¿«ã€‚ ç„¶è€Œï¼Œä½¿ç”¨é€Ÿåº¦ä½œä¸ºæ§åˆ¶å‘½ä»¤ä½¿å…¶ä¸é€‚ç”¨äºå››æ—‹ç¿¼ç­‰ä¸‰é˜¶ç³»ç»Ÿã€‚ ç¢°æ’é£é™©ä¹Ÿé™åˆ¶äº†å®ƒçš„åº”ç”¨ã€‚ ç›¸æ¯”ä¹‹ä¸‹ï¼Œæˆ‘ä»¬æå‡ºçš„æ–¹æ³•ç”Ÿæˆäº†æœ€çŸ­çš„æ— ç¢°æ’ã€éä¿å®ˆæ€§çš„è½¨è¿¹ï¼Œå¹¶å…·æœ‰å¿«é€Ÿè®¡ç®—çš„ç‰¹ç‚¹ã€‚ å› æ­¤ï¼Œå®ƒå¯ä»¥å®ç°å››æ—‹ç¿¼çš„å®æ—¶åº”ç”¨ã€‚ In Obstacle-rich Environments åœ¨éšœç¢ç‰©å¯†é›†çš„ç¯å¢ƒ æˆ‘ä»¬æ¨¡æ‹Ÿäº†åæ¶æ— äººæœºä»¥æ¯ç§’ 2 ç±³çš„é€Ÿåº¦é™åˆ¶ä»åœ°å›¾çš„ä¸€è¾¹é£åˆ°å¦ä¸€è¾¹ï¼Œå››æ—‹ç¿¼åŠå¾„ä¸º 0.2 ç±³ã€‚ å›¾ 2 æ˜¯ 0.42 ä¸ªéšœç¢ç‰©/$m^2$çš„æ¨¡æ‹Ÿå¿«ç…§ã€‚ æ¯ä¸ªä»£ç†å•ç‹¬æ„ŸçŸ¥ç¯å¢ƒï¼Œå¹¶ä¸”æ„å»ºçš„å±€éƒ¨åœ°å›¾ä»¥ä¸åŒçš„é¢œè‰²æ˜¾ç¤ºã€‚ ç»“æœæ€»ç»“åœ¨è¡¨ 2 ä¸­ï¼Œå…¶ä¸­$d{\\rm{fly}}$æ˜¯å¹³å‡é£è¡Œè·ç¦»ï¼Œ$d{\\rm{safe}}$æ˜¯é£è¡Œæµ‹è¯•æœŸé—´ä¸éšœç¢ç‰©çš„æœ€è¿‘è·ç¦»ã€‚ è®¾è®¡äº†ä¸€ç§é€†å‘ç‚¹å¯¹ç‚¹è½¬æ¢ï¼Œä½¿å¾—åœ¨åœ°å›¾ä¸­å¿ƒå‘¨å›´ä¸å¯é¿å…åœ°è¿›è¡Œç›¸äº’é¿ç¢°ã€‚ åœ¨è¿™ç§æƒ…æ™¯ä¸‹ï¼Œå±äºç¾¤ä½“çš„æ¯ä¸ªä»£ç†éƒ½æˆåŠŸåœ°è§„åˆ’äº†å¹³ç¨³ä¸”å®‰å…¨çš„è½¨è¿¹ã€‚ Scalability Analysis å¯æ‰©å±•æ€§åˆ†æ æˆ‘ä»¬åœ¨ä¸€ä¸ªæƒ…æ™¯ä¸­è¯„ä¼°è®¡ç®—æ€§èƒ½ï¼Œå…¶ä¸­æ’åˆ—æˆä¸€æ¡ç›´çº¿çš„ä»£ç†é£å‘éšæœºç›®æ ‡ç‚¹ï¼Œè·ç¦» 50 ç±³ã€‚æ­£å¦‚å›¾ 11 æ‰€ç¤ºï¼Œåœ¨ç¬¬ 5.B.1 èŠ‚çš„æŒ‰éœ€ç¢°æ’æ£€æŸ¥ç­–ç•¥çš„å½±å“ä¸‹ï¼Œéšç€ä»£ç†æ•°é‡çš„å¢åŠ ï¼Œæ—¶é—´å¤æ‚åº¦é€æ¸è¶‹äºå¹³ç¨³ã€‚ 7 Real-World exp 1ï¼‰Indoor åœ¨å®¤å†…å®éªŒä¸­ï¼Œé€Ÿåº¦é™åˆ¶ä¸º 1.5 ç±³/ç§’ï¼Œå¦‚å›¾ 12 æ‰€ç¤ºã€‚ æœ€ä¸Šæ–¹çš„å›¾æ˜¾ç¤ºäº†ä¸‰æ¶å››æ—‹ç¿¼æ— äººæœºè¿›è¡Œå¾ªç¯äº¤æ¢ï¼Œå¹¶è¿›è¡Œäº’ç›¸é¿ç¢°ã€‚ åœ¨ä¸­é—´çš„å›¾ä¸­ï¼Œå››æ—‹ç¿¼æ— äººæœºæˆåŠŸä¾æ¬¡é€šè¿‡ä¸€ä¸ªç‹­çª„çš„é—¨ã€‚ åœ¨åº•éƒ¨çš„å›¾ä¸­ï¼Œç¯å¢ƒæ›´åŠ æ‹¥æŒ¤ã€‚ ä¸‰æ¶å››æ—‹ç¿¼æ— äººæœºæˆåŠŸç©¿è¶Šäº†è¿™ä¸ªç¯å¢ƒã€‚ åœ¨ä¸€ä¸ªæ ‘æœ¨é—´è·å¤§çº¦ä¸º 2 ç±³çš„æ£®æ—ä¸­ï¼Œå¦‚å›¾ 1 æ‰€ç¤ºï¼Œä¸‰ä¸ªå››æ—‹ç¿¼æ— äººæœºä¸€èµ·ä»æ£®æ—ä¸­èµ·é£ï¼Œå¹¶æˆåŠŸåˆ°è¾¾æ£®æ—å¤–çš„ç›®æ ‡ä½ç½®ã€‚ é€Ÿåº¦é™åˆ¶è®¾å®šä¸º 1.5 ç±³/ç§’ã€‚ ä¸ºè¿›ä¸€æ­¥å¼ºè°ƒç›¸äº’é¿è®©ï¼Œæˆ‘ä»¬å°†ç›®æ ‡ä½ç½®ç›¸å¯¹äºèµ·å§‹ä½ç½®çš„é¡ºåºé¢ å€’ï¼Œä½¿å¾—ç›¸äº’é¿è®©æˆä¸ºä¸å¯é¿å…çš„ï¼Œå°±åƒæˆ‘ä»¬åœ¨ç¬¬\\ref{sec:In_Obstacle-rich_Environments}èŠ‚ä¸­æ‰€åšçš„é‚£æ ·ã€‚ æœ‰å…³å®éªŒçš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è€ƒæˆ‘ä»¬åœ¨ github ä¸Šçš„ä»£ç ï¼Œå¹¶è§‚çœ‹æˆ‘ä»¬é™„ä¸Šçš„è§†é¢‘\\footnote{https://github.com/ZJU-FAST-Lab/ego-planner-swarm}ã€‚ 8 æ€»ç»“ æœ¬æ–‡æå‡ºäº†ä¸€ç§åœ¨æœªçŸ¥æ‚ä¹±ç¯å¢ƒä¸­åˆ©ç”¨ä»…é™äºæœºè½½èµ„æºçš„å¤šæœºå™¨äººå¯¼èˆªçš„ç³»ç»Ÿæ€§è§£å†³æ–¹æ¡ˆã€‚ åŸºå‡†æ¯”è¾ƒè¡¨æ˜å…¶è®¡ç®—æ—¶é—´çŸ­ä¸”è½¨è¿¹è´¨é‡é«˜ã€‚ å®é™…ä¸–ç•Œå®éªŒéªŒè¯äº†å…¶é²æ£’æ€§å’Œæ•ˆç‡ "},"Learn/LearnDrones/Planner/EGO-Planner-2020.html":{"url":"Learn/LearnDrones/Planner/EGO-Planner-2020.html","title":"EGO-Planner-2020","keywords":"","body":"EGO-Planner-2020 EGO-Planner: An ESDF-free Gradient-based Local Planner for Quadrotors IEEE Robotics and Automation Letters (Volume: 6, Issue: 2, April 2021) github code arxiv Abstract Gradient-based planners are widely used for quadrotor local planning, in which a Euclidean Signed Distance Field (ESDF) is crucial for evaluating gradient magnitude and direction. Nevertheless, computing such a field has much redundancy since the trajectory optimization procedure only covers a very limited subspace of the ESDF updating range. In this paper, an ESDF-free gradient-based planning framework is proposed, which significantly reduces computation time. The main improvement is that the collision term in penalty function is formulated by comparing the colliding trajectory with a collision free guiding path . The resulting obstacle information will be stored only if the trajectory hits new obstacles, making the planner only extract necessary obstacle information. Then, we lengthen the time allocation if dynamical feasibility is violated. An anisotropic curve fitting algorithm is introduced to adjust higher order derivatives of the trajectory while maintaining the original shape. Benchmark comparisons and real-world experiments verify its robustness and high-performance. The source code is released as ros packages. åŸºäºæ¢¯åº¦çš„è§„åˆ’å™¨å¹¿æ³›ç”¨äºå››æ—‹ç¿¼æœ¬åœ°è§„åˆ’ï¼Œå…¶ä¸­ æ¬§å‡ é‡Œå¾—æœ‰ç¬¦å·è·ç¦»åœºï¼ˆESDFï¼‰å¯¹äºè¯„ä¼°æ¢¯åº¦å¤§å°å’Œæ–¹å‘è‡³å…³é‡è¦ã€‚ ç„¶è€Œï¼Œè®¡ç®—è¿™æ ·çš„åœºä¼šå­˜åœ¨å¾ˆå¤šå†—ä½™ï¼Œå› ä¸ºè½¨è¿¹ä¼˜åŒ–è¿‡ç¨‹ä»…è¦†ç›– ESDF æ›´æ–°èŒƒå›´çš„ä¸€ä¸ªéå¸¸æœ‰é™çš„å­ç©ºé—´ã€‚ æœ¬æ–‡æå‡ºäº†ä¸€ç§ æ— éœ€ESDFçš„åŸºäºæ¢¯åº¦çš„è§„åˆ’æ¡†æ¶ï¼ˆESDF-free gradient-based planning frameworkï¼‰ï¼Œå¤§å¤§å‡å°‘äº†è®¡ç®—æ—¶é—´ã€‚ ä¸»è¦æ”¹è¿›åœ¨äºé€šè¿‡å°† ç¢°æ’è½¨è¿¹ä¸ æ— ç¢°æ’å¼•å¯¼è·¯å¾„è¿›è¡Œ æ¯”è¾ƒ æ¥åˆ¶å®šæƒ©ç½šå‡½æ•°ä¸­çš„ ç¢°æ’é¡¹ã€‚ ä»…å½“è½¨è¿¹ä¸æ–°éšœç¢ç‰©ç¢°æ’æ—¶ï¼Œæ‰ä¼šå­˜å‚¨ç”Ÿæˆçš„éšœç¢ä¿¡æ¯ï¼Œä½¿è§„åˆ’å™¨ä»…æå–å¿…è¦çš„éšœç¢ä¿¡æ¯ã€‚ç„¶åï¼Œå¦‚æœè¿åäº†åŠ¨åŠ›å­¦å¯è¡Œæ€§ï¼Œæˆ‘ä»¬ä¼šå»¶é•¿æ—¶é—´åˆ†é…ã€‚ å¼•å…¥ä¸€ç§ å„å‘å¼‚æ€§æ›²çº¿æ‹Ÿåˆç®—æ³•ï¼Œä»¥è°ƒæ•´è½¨è¿¹çš„é«˜é˜¶å¯¼æ•°ï¼ŒåŒæ—¶ä¿æŒåŸå§‹å½¢çŠ¶ã€‚ åŸºå‡†æ¯”è¾ƒå’Œå®é™…å®éªŒéªŒè¯äº†å…¶é²æ£’æ€§å’Œé«˜æ€§èƒ½ã€‚æºä»£ç ä»¥ ROS è½¯ä»¶åŒ…å½¢å¼å‘å¸ƒã€‚ 1 Introduction Traditionally, gradient-based planners rely on a pre-built ESDF map to evaluate the gradient magnitude and direction, and use numerical optimization to generate a local optimal solution. Although the optimization programs enjoy fast convergence, they suffer a lot from constructing the required ESDF beforehand. As the statistics (TABLE II from EWOK[2]) states, the ESDF computation takes up to about 70% of total processing time for conducting local planning. Therefore, we can safely claim that, building ESDF has become the bottleneck of gradient-based planners, preventing the method from being applied to resource-limited platforms. ä¼ ç»Ÿä¸Šï¼ŒåŸºäºæ¢¯åº¦çš„è§„åˆ’å™¨ä¾é é¢„å…ˆæ„å»ºçš„ ESDF å›¾æ¥è¯„ä¼°æ¢¯åº¦å¤§å°å’Œæ–¹å‘ï¼Œå¹¶ä½¿ç”¨æ•°å€¼ä¼˜åŒ–æ¥ç”Ÿæˆå±€éƒ¨æœ€ä¼˜è§£ã€‚å°½ç®¡ä¼˜åŒ–ç¨‹åºå…·æœ‰å¿«é€Ÿæ”¶æ•›çš„ä¼˜ç‚¹ï¼Œä½†ç”±äºé¢„å…ˆæ„å»ºæ‰€éœ€çš„ ESDFï¼Œå®ƒä»¬å—åˆ°å¾ˆå¤§å½±å“ã€‚æ­£å¦‚ç»Ÿè®¡æ•°æ®ï¼ˆæ¥è‡ª EWOK [ 2 ]çš„è¡¨ II ï¼‰æ‰€è¿°ï¼ŒESDF è®¡ç®—å ç”¨äº†è¿›è¡Œæœ¬åœ°è§„åˆ’çš„æ€»å¤„ç†æ—¶é—´çš„çº¦ 70%ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥æœ‰æŠŠæ¡åœ°è¯´ï¼Œæ„å»º ESDF å·²æˆä¸ºåŸºäºæ¢¯åº¦çš„è§„åˆ’å™¨çš„ç“¶é¢ˆï¼Œé˜»æ­¢è¯¥æ–¹æ³•åº”ç”¨äºèµ„æºæœ‰é™çš„å¹³å°ã€‚ å°½ç®¡ ESDF è¢«å¹¿æ³›ä½¿ç”¨ï¼Œä½†å¾ˆå°‘æœ‰äººç ”ç©¶å…¶å¿…è¦æ€§ã€‚é€šå¸¸æ¥è¯´ï¼Œæœ‰ä¸¤ç§æ–¹å¼æ¥æ„å»º ESDFã€‚å¦‚ç¬¬ 2 èŠ‚æ‰€è¿°ï¼Œè¿™äº›æ–¹æ³•å¯ä»¥åˆ†ä¸º å¢é‡å…¨å±€æ›´æ–°æ–¹æ³• å’Œ æ‰¹å¤„ç†å±€éƒ¨è®¡ç®—æ–¹æ³•ã€‚ç„¶è€Œï¼Œè¿™ä¸¤ç§æ–¹æ³•éƒ½æ²¡æœ‰ å…³æ³¨è½¨è¿¹æœ¬èº« ã€‚å› æ­¤ï¼Œè®¡ç®— ESDF å€¼ä¸ŠèŠ±è´¹äº†å¤ªå¤šçš„è®¡ç®—é‡ï¼Œè¿™äº› ESDF å€¼å¯¹è§„åˆ’æ²¡æœ‰ä»»ä½•è´¡çŒ®ã€‚æ¢å¥è¯è¯´ï¼Œå½“å‰åŸºäº ESDF çš„æ–¹æ³•å¹¶æ²¡æœ‰ç›´æ¥å’Œå”¯ä¸€åœ°æœåŠ¡äºè½¨è¿¹ä¼˜åŒ–ã€‚å¦‚å›¾ 1 æ‰€ç¤ºï¼Œåœ¨ä¸€èˆ¬çš„è‡ªä¸»å¯¼èˆªåœºæ™¯ä¸­ï¼Œæ— äººæœºåªéœ€è¦é¿å…å±€éƒ¨ç¢°æ’ï¼Œè½¨è¿¹ä»…è¦†ç›–äº† ESDF æ›´æ–°èŒƒå›´çš„æœ‰é™ç©ºé—´ã€‚åœ¨å®è·µä¸­ï¼Œå°½ç®¡ä¸€äº›æ‰‹åŠ¨è§„åˆ™å¯ä»¥å†³å®šè¾ƒçª„çš„ ESDF èŒƒå›´ï¼Œå®ƒä»¬ç¼ºä¹ç†è®ºçš„åˆç†æ€§ï¼Œä»ç„¶ä¼šå¼•èµ·ä¸å¿…è¦çš„è®¡ç®—ã€‚ Figure 1: Trajectory during optimizing just covers a very limited space of the ESDF updating range. (å…·æœ‰ç¢°æ’æ£€æµ‹å’Œè½¨è¿¹ä¼˜åŒ–åŠŸèƒ½) In this paper, we design an ESDF-free Gradient-based lOcal planning framework called EGO, and we incorporate careful engineering considerations to make it lightweight and robust. The proposed algorithm is composed of a gradient-based spline optimizer and a post-refinement procedure. åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ä¸ª æ— ESDFçš„åŸºäºæ¢¯åº¦çš„æœ¬åœ°è§„åˆ’æ¡†æ¶ï¼Œç§°ä¸º EGOï¼Œå¹¶ç»“åˆç²¾å¿ƒçš„å·¥ç¨‹è€ƒè™‘ä½¿å…¶è½»å·§ä¸”é²æ£’ã€‚ æ‰€æå‡ºçš„ç®—æ³•ç”±åŸºäºæ¢¯åº¦çš„ æ ·æ¡ä¼˜åŒ–å™¨ï¼ˆspline optimizerï¼‰å’Œ åå¤„ç†ç¨‹åºï¼ˆa post-refinement procedureï¼‰ç»„æˆã€‚ Firstly, we optimize the trajectory with smoothness, collision, and dynamical feasibility terms. Unlike traditional approaches that query pre-computed ESDF, we model the collision cost by comparing the trajectory inside obstacles with a guiding collision-free path. é¦–å…ˆï¼Œæˆ‘ä»¬é€šè¿‡å¹³æ»‘åº¦ã€ç¢°æ’å’ŒåŠ¨åŠ›å¯è¡Œæ€§ç­‰é¡¹è¿›è¡Œäº†è½¨è¿¹ä¼˜åŒ–ã€‚ ä¸ä¼ ç»Ÿæ–¹æ³•ä¸åŒï¼Œæˆ‘ä»¬é€šè¿‡å°†éšœç¢ç‰©å†…çš„è½¨è¿¹ä¸å¼•å¯¼çš„æ— ç¢°æ’è·¯å¾„è¿›è¡Œæ¯”è¾ƒæ¥å¯¹ç¢°æ’æˆæœ¬è¿›è¡Œå»ºæ¨¡ã€‚ We then project the forces onto the colliding trajectory and generate estimated gradient to wrap the trajectory out of obstacles. During the optimization, the trajectory will rebound a few times between nearby obstacles and finally terminate in a safe region. In this way, we only calculate the gradient when necessary, and avoid computing ESDF in regions irrelevant to the local trajectory. If the resulted trajectory violates dynamical limits, which is usually caused by unreasonable time allocation, the refinement process is activated. During the refinement, trajectory time is reallocated when the limits are exceeded. With the enlarged time allocation, a new B-spline that fits the previous dynamical infeasible one while balancing the feasibility and fitting accuracy is generated. To improve robustness, the fitting accuracy is modeled anisotropically with different penalties on axial and radial directions. ç„¶åï¼Œæˆ‘ä»¬å°†åŠ›æŠ•å½±åˆ°ç¢°æ’è½¨è¿¹ä¸Šï¼Œç”Ÿæˆé¢„ä¼°çš„æ¢¯åº¦ä»¥å°†è½¨è¿¹åŒ…è£¹åœ¨éšœç¢ç‰©å¤–éƒ¨ã€‚ åœ¨ä¼˜åŒ–è¿‡ç¨‹ä¸­ï¼Œè½¨è¿¹å°†åœ¨é™„è¿‘éšœç¢ç‰©ä¹‹é—´åå¼¹å‡ æ¬¡ï¼Œæœ€ååœåœ¨ä¸€ä¸ªå®‰å…¨åŒºåŸŸã€‚ é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬ åªåœ¨å¿…è¦æ—¶è®¡ç®—æ¢¯åº¦ ï¼Œå¹¶é¿å…åœ¨ä¸å±€éƒ¨è½¨è¿¹æ— å…³çš„åŒºåŸŸè®¡ç®— ESDFã€‚ å¦‚æœç”Ÿæˆçš„è½¨è¿¹è¿ååŠ¨åŠ›å­¦é™åˆ¶ï¼Œé€šå¸¸æ˜¯ç”±äºä¸åˆç†çš„æ—¶é—´åˆ†é…ï¼Œå°†å¯åŠ¨ åç»­ä¼˜åŒ– ã€‚ åœ¨ä¼˜åŒ–è¿‡ç¨‹ä¸­ï¼Œè¶…å‡ºæ—¶é—´é™åˆ¶æ—¶ï¼Œä¼šé‡æ–°åˆ†é…è½¨è¿¹çš„æ—¶é—´ã€‚ é€šè¿‡å¢åŠ æ—¶é—´åˆ†é…ï¼Œæˆ‘ä»¬ç”Ÿæˆä¸€ä¸ªæ–°çš„ B æ ·æ¡æ›²çº¿ï¼Œå®ƒå¯ä»¥æ‹Ÿåˆå…ˆå‰çš„åŠ¨æ€ä¸å¯è¡Œæ ·æ¡ï¼ŒåŒæ—¶å¹³è¡¡å¯è¡Œæ€§å’Œæ‹Ÿåˆç²¾åº¦ã€‚ä¸ºäº†æé«˜é²æ£’æ€§ï¼Œæ‹Ÿåˆç²¾åº¦é‡‡ç”¨å„å‘å¼‚æ€§å»ºæ¨¡ï¼Œåœ¨è½´å‘å’Œå¾„å‘ä¸Šå…·æœ‰ä¸åŒçš„æƒ©ç½šã€‚ æ®æˆ‘ä»¬æ‰€çŸ¥ï¼Œè¿™ç§æ–¹æ³•æ˜¯é¦–æ¬¡å®ç°äº†æ—  ESDF çš„åŸºäºæ¢¯åº¦çš„å±€éƒ¨è§„åˆ’ã€‚ ä¸ç°æœ‰çš„æœ€å…ˆè¿›æ–¹æ³•ç›¸æ¯”ï¼Œæ‰€æå‡ºçš„æ–¹æ³•åœ¨å¿½ç•¥ ESDF ç»´æŠ¤çš„åŒæ—¶ç”Ÿæˆå…·æœ‰ç›¸å½“å¹³æ»‘åº¦å’Œä¾µç•¥æ€§çš„å®‰å…¨è½¨è¿¹ï¼Œè®¡ç®—æ—¶é—´é™ä½äº†ä¸€ä¸ªæ•°é‡çº§ã€‚ æˆ‘ä»¬è¿›è¡Œäº†å…¨é¢çš„ä»¿çœŸå’Œå®é™…æµ‹è¯•ï¼Œä»¥éªŒè¯æˆ‘ä»¬çš„æ–¹æ³•ã€‚ æœ¬æ–‡çš„è´¡çŒ®åŒ…æ‹¬ï¼š We propose a novel and robust gradient-based quadrotor local planning method, which evaluates and projects gradient information directly from obstacles instead of a pre-built ESDF. æˆ‘ä»¬æå‡ºäº†ä¸€ç§æ–°é¢–ä¸”ç¨³å¥çš„åŸºäºæ¢¯åº¦çš„å››æ—‹ç¿¼å±€éƒ¨è§„åˆ’æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç›´æ¥è¯„ä¼°å’ŒæŠ•å½±æ¥è‡ªéšœç¢ç‰©çš„æ¢¯åº¦ä¿¡æ¯ï¼Œè€Œä¸æ˜¯é¢„å…ˆæ„å»ºçš„ ESDFã€‚ We propose a lightweight yet effective trajectory refinement algorithm, which generates smoother trajectories by formulating the trajectory fitting problem with anisotropic error penalization. æˆ‘ä»¬æå‡ºäº†ä¸€ç§è½»é‡çº§ä½†æœ‰æ•ˆçš„è½¨è¿¹ä¼˜åŒ–ç®—æ³•ï¼Œé€šè¿‡é‡‡ç”¨å„å‘å¼‚æ€§è¯¯å·®æƒ©ç½šæ¥å»ºæ¨¡è½¨è¿¹æ‹Ÿåˆé—®é¢˜ï¼Œä»è€Œç”Ÿæˆæ›´åŠ å¹³æ»‘çš„è½¨è¿¹ã€‚ We integrate the proposed method into a fully autonomous quadrotor system, and release our software for the reference of the community. æˆ‘ä»¬å°†æå‡ºçš„æ–¹æ³•é›†æˆåˆ°ä¸€ä¸ªå®Œå…¨è‡ªä¸»çš„å››æ—‹ç¿¼ç³»ç»Ÿä¸­ï¼Œå¹¶å°†æˆ‘ä»¬çš„è½¯ä»¶å‘å¸ƒç»™ç¤¾åŒºå‚è€ƒã€‚ 2 Related Work A. Gradient-based Motion Planning åŸºäºæ¢¯åº¦çš„è¿åŠ¨è§„åˆ’æ˜¯æ— äººæœºå±€éƒ¨è½¨è¿¹ç”Ÿæˆçš„ä¸»æµæ–¹æ³•ï¼Œå®ƒå°†é—®é¢˜å»ºæ¨¡ä¸ºæ— çº¦æŸçš„éçº¿æ€§ä¼˜åŒ–ã€‚ Ratliff ç­‰äººé¦–æ¬¡å°† ESDFå¼•å…¥æœºå™¨äººè¿åŠ¨è§„åˆ’ä¸­ã€‚è®¸å¤šè§„åˆ’æ¡†æ¶åˆ©ç”¨å…¶ä¸°å¯Œçš„æ¢¯åº¦ä¿¡æ¯ï¼Œç›´æ¥åœ¨é…ç½®ç©ºé—´ä¸­ä¼˜åŒ–è½¨è¿¹ã€‚ ç„¶è€Œï¼Œå¯¹è½¨è¿¹è¿›è¡Œ ç¦»æ•£æ—¶é—´ä¼˜åŒ–å¯¹äºæ— äººæœºæ¥è¯´ä¸å¤ªé€‚ç”¨ï¼Œå› ä¸ºå®ƒæ›´åŠ æ•æ„ŸäºåŠ¨åŠ›å­¦çº¦æŸã€‚ å› æ­¤ï¼Œ[7] æå‡ºäº†ä¸€ç§é€‚ç”¨äºæ— äººæœºè§„åˆ’çš„è¿ç»­æ—¶é—´å¤šé¡¹å¼è½¨è¿¹ä¼˜åŒ–æ–¹æ³•ã€‚ ç„¶è€Œï¼Œæ½œåœ¨å‡½æ•°çš„ç§¯åˆ†å¯¼è‡´äº†è¾ƒé‡çš„è®¡ç®—è´Ÿæ‹…ã€‚ æ­¤å¤–ï¼Œå³ä½¿è¿›è¡Œäº†éšæœºé‡å¯ï¼Œè¯¥æ–¹æ³•çš„æˆåŠŸç‡ä¹Ÿåªè¾¾åˆ°çº¦ 70%ã€‚ é‰´äºè¿™äº›ç¼ºç‚¹ï¼Œ[2] å¼•å…¥äº†è½¨è¿¹çš„ B æ ·æ¡å‚æ•°åŒ–ï¼Œå……åˆ†åˆ©ç”¨äº†å‡¸åŒ…ç‰¹æ€§ã€‚ åœ¨ [8] ä¸­ï¼Œé€šè¿‡æ‰¾åˆ°ä¸€ä¸ªæ— ç¢°æ’çš„åˆå§‹è·¯å¾„ä½œä¸ºå‰ç«¯ï¼ŒæˆåŠŸç‡æ˜¾è‘—æé«˜ã€‚ æ­¤å¤–ï¼Œå½“è€ƒè™‘åˆ°è¿åŠ¨åŠ¨åŠ›å­¦çº¦æŸæ—¶ï¼Œåˆå§‹æ— ç¢°æ’è·¯å¾„çš„ç”Ÿæˆè¿›ä¸€æ­¥æ”¹è¿›ã€‚ å‘¨ç­‰äºº[11] å°†æ„ŸçŸ¥æ„è¯†çº³å…¥ç³»ç»Ÿä¸­ï¼Œä½¿å…¶æ›´åŠ é²æ£’ã€‚ åœ¨ä¸Šè¿°æ–¹æ³•ä¸­ï¼ŒESDF åœ¨è¯„ä¼°ä¸é™„è¿‘éšœç¢ç‰©çš„è·ç¦»ã€æ¢¯åº¦å¹…åº¦å’Œæ–¹å‘æ–¹é¢èµ·ç€é‡è¦ä½œç”¨ã€‚ B. Euclidean Signed Distance Field (ESDF) ESDF åœ¨è¿‡å»çš„äºŒåå¤šå¹´ä¸­ä¸€ç›´è¢«ç”¨äºä»å˜ˆæ‚çš„ä¼ æ„Ÿå™¨æ•°æ®ä¸­æ„å»ºå¯¹è±¡ [12], å¹¶è‡ªä» [5] ä¹‹åé‡æ–°å¼•èµ· äº†æœºå™¨äººè¿åŠ¨è§„åˆ’çš„å…´è¶£ã€‚ Felzenszwalb ç­‰äºº [4] æå‡º äº†ä¸€ç§é€šè¿‡å°†æ—¶é—´å¤æ‚åº¦é™ä½åˆ° $O(n)$ æ¥æ„å»º ESDF çš„åŒ…ç»œç®—æ³•, å…¶ä¸­ n è¡¨ç¤ºä½“ç´ æ•°ã€‚è™½ç„¶è¯¥ç®—æ³•ä¸é€‚ç”¨äºå¢é‡å¼å»ºç«‹ ESDF, ä½†åœ¨å››æ—‹ç¿¼é£è¡Œè¿‡ç¨‹ä¸­ç»å¸¸éœ€è¦åŠ¨æ€ æ›´æ–°åœºåŸŸã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜, Oleynikova [13] å’Œ Han [3] æå‡ºäº†å¢é‡å¼ ESDF ç”Ÿæˆæ–¹æ³•, å³ Voxblox å’Œ FIESTAã€‚ å°½ç®¡è¿™äº›æ–¹æ³•åœ¨åŠ¨æ€æ›´æ–°æƒ…å†µä¸‹éå¸¸é«˜æ•ˆ, ä½†ç”Ÿæˆ çš„ ESDF å‡ ä¹æ€»æ˜¯åŒ…å«å¯èƒ½åœ¨è§„åˆ’è¿‡ç¨‹ä¸­æ ¹æœ¬ä¸ä¼šä½¿ ç”¨çš„è§‰ä½™ä¿¡æ¯ã€‚å¦‚å›¾ 1 æ‰€ç¤º, è¯¥è½¨è¿¹ä»…åœ¨æ•´ä¸ª ESDF æ›´æ–°èŒƒå›´çš„éå¸¸æœ‰é™çš„å­ç©ºé—´ä¸Šæ‰«æã€‚å› æ­¤, è®¾è®¡ä¸€ç§æ›´åŠ  æ™ºèƒ½å’Œè½»é‡çº§çš„æ–¹æ³•, è€Œä¸æ˜¯ç»´æŠ¤æ•´ä¸ªåœºåŸŸ, å…·æœ‰å¾ˆé«˜çš„ä»·å€¼ã€‚ 3 Collision Avoidance Force Estimation é¿ç¢°åŠ›ä¼°è®¡ a) é€šè¿‡éšœç¢ç‰©çš„è½¨è¿¹ $\\mathbf{\\Phi}$ ä¼šäº§ç”Ÿå¤šä¸ª ${\\mathbf{p},\\mathbf{v}}$ é…å¯¹ç”¨äºæ§åˆ¶ç‚¹ã€‚å…¶ä¸­ï¼Œ $\\mathbf{p}$ æ˜¯éšœç¢ç‰©è¡¨é¢çš„ç‚¹ï¼Œ $\\mathbf{v}$ æ˜¯ä»æ§åˆ¶ç‚¹æŒ‡å‘ $\\mathbf{p}$ çš„å•ä½å‘é‡ã€‚ b) ä¸åˆ‡å‘é‡ $\\mathbf{R}_i$ å‚ç›´çš„å¹³é¢ $\\mathbf{\\Psi}$ ä¸ $\\mathbf{\\Gamma}$ ç›¸äº¤ï¼Œå½¢æˆä¸€æ¡çº¿$l$ï¼Œä»ä¸­ç¡®å®šå‡ºä¸€ä¸ª ${\\mathbf{p},\\mathbf{v}}$ é…å¯¹ã€‚ c) è·ç¦»åœºå®šä¹‰çš„åˆ‡ç‰‡å¯è§†åŒ–è¡¨ç¤ºä¸º $d_{ij}=(\\mathbf{Q}{i}-\\mathbf{p}{ij}) \\cdot \\mathbf{v}_{ij}$ ã€‚é¢œè‰²è¡¨ç¤ºè·ç¦»ï¼Œç®­å¤´è¡¨ç¤ºç›¸åŒçš„æ¢¯åº¦ï¼Œå³ $\\mathbf{v}$ ã€‚å…¶ä¸­ï¼Œ $\\mathbf{p}$ ä½äºé›¶è·ç¦»å¹³é¢ä¸Šã€‚ åœ¨æœ¬æ–‡ä¸­ï¼Œå†³ç­–å˜é‡æ˜¯B æ ·æ¡æ›²çº¿çš„æ§åˆ¶ç‚¹ $\\mathbf{Q}$ ã€‚ æ¯ä¸ª $\\mathbf{Q}$ éƒ½ç‹¬ç«‹åœ°æ‹¥æœ‰è‡ªå·±çš„ç¯å¢ƒä¿¡æ¯ã€‚ ä¸€å¼€å§‹ï¼Œç»™å®šä¸€ä¸ªæ»¡è¶³ç»ˆç«¯çº¦æŸæ¡ä»¶çš„æœ´ç´ B æ ·æ¡æ›²çº¿ $\\mathbf{\\Phi}$ ï¼Œä¸è€ƒè™‘ç¢°æ’æƒ…å†µã€‚ ç„¶åï¼Œä¼˜åŒ–è¿‡ç¨‹å¼€å§‹ã€‚ åœ¨æ¯æ¬¡è¿­ä»£ä¸­æ£€æµ‹åˆ°ç¢°æ’æ®µåï¼Œç”Ÿæˆä¸€ä¸ªæ— ç¢°æ’è·¯å¾„ $\\mathbf{\\Gamma}$ ã€‚ æ¥ç€ï¼Œå°†æ¯ä¸ªç¢°æ’æ®µçš„æ§åˆ¶ç‚¹ $\\mathbf{Q}i$ åˆ†é…åˆ°éšœç¢ç‰©è¡¨é¢çš„é”šç‚¹ $\\mathbf{p}{ij}$ ï¼Œå¹¶å¸¦æœ‰ç›¸åº”çš„æ–¥åŠ›æ–¹å‘å‘é‡ $\\mathbf{v}{ij} =\\overrightarrow{Q{i} p_{i j}}$ ï¼Œå¦‚å›¾ 2.a æ‰€ç¤ºã€‚ å…¶ä¸­ï¼Œ$i \\in \\mathbb{N}_+$ä¸ºæ§åˆ¶ç‚¹çš„ç´¢å¼•ï¼Œ$j \\in \\mathbb{N}$ ä¸º ${\\mathbf{p},\\mathbf{v}}$ å¯¹çš„ç´¢å¼•ã€‚ æ³¨æ„ï¼Œæ¯ä¸ª ${\\mathbf{p},\\mathbf{v}}$ å¯¹åªå±äºä¸€ä¸ªç‰¹å®šçš„æ§åˆ¶ç‚¹ã€‚ä¸ºäº†ç®€æ´èµ·è§ï¼Œæˆ‘ä»¬åœ¨ä¸å¼•èµ·æ­§ä¹‰çš„æƒ…å†µä¸‹çœç•¥ä¸‹æ ‡ $ij$ ã€‚ æœ¬æ–‡ä¸­è¯¦ç»†çš„ ${\\mathbf{p},\\mathbf{v}}$ å¯¹ç”Ÿæˆè¿‡ç¨‹æ¦‚è¿°åœ¨ç®—æ³•1ä¸­ï¼Œå¹¶åœ¨å›¾ 3.b ä¸­è¿›è¡Œäº†è¯´æ˜ã€‚ ç„¶åï¼Œå°†ä» $\\mathbf{Q}_i$ åˆ°ç¬¬ $j$ ä¸ªéšœç¢ç‰©çš„éšœç¢ç‰©è·ç¦»å®šä¹‰ä¸º dij=(Qiâˆ’pij)â‹…vij d_{i j}=\\left(\\mathbf{Q}_{i}-\\mathbf{p}_{i j}\\right) \\cdot \\mathbf{v}_{i j} dijâ€‹=(Qiâ€‹âˆ’pijâ€‹)â‹…vijâ€‹ def CheckAndAddObstacleInfo(E, Q): \"\"\" Function to check and add obstacle information. Args: - E: The environment - Q: Control Points Struct Returns: - Q: Updated Control Points Struct after adding obstacle info \"\"\" S = [] # Colliding segments # Check for colliding segments in each control point for Q_i in Q: if FindConsecutiveCollidingSegment(Q_i): S.append(GetCollisionSegment()) # Process each colliding segment for S_i in S: Gamma = PathSearch(E, S_i) # Not sure how `begin` and `end` are defined for S_i, # but assuming they are integer indices for j in range(S_i.begin, S_i.end + 1): p, v = FindPVpairs(Q[j], Gamma) Q[j].append((p, v)) return Q ä¸ºäº†é˜²æ­¢è½¨è¿¹è¢«æ‹‰å‡ºå½“å‰éšœç¢ç‰©å‰ã€è¿­ä»£è¿‡ç¨‹ä¸­åå¤ç”Ÿæˆ ${p, v}$ å¯¹ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºæ–°éšœç¢ç‰©çš„æ ‡å‡†æ˜¯: å¦‚æœæ§åˆ¶ç‚¹ $Q_{i}$ å¤„äºéšœç¢ç‰©ä¸­æ—¶ï¼Œå¹¶ä¸”å¯¹äºå½“å‰å¾—åˆ°çš„æ‰€æœ‰éšœç¢ç‰© $j$ æ»¡è¶³ $d_{i j}>0$ ï¼Œåˆ™è¯¥éšœ ç¢ç‰©ä¸ºæ–°å‘ç°çš„éšœç¢ç‰©ã€‚ä»è€Œåªè®¡ç®—å½±å“è½¨è¿¹çš„éšœç¢ç‰©ä¿¡æ¯ï¼Œå‡å°‘è¿è¡Œæ—¶é—´ã€‚ To incorporate necessary environmental awareness into the local planner, we need to explicitly construct an objective function that keeps the trajectory away from obstacles. ESDF provides this vital collision information but with the price of a heavy computation burden. In addition, as shown in Fig.\\ref{pic:local_min}, ESDF-based planners can easily fall into a local minimum and fail to escape from obstacles, due to the insufficient or even wrong information from ESDF. To avoid such situations, an additional front-end is always needed to provide a collision-free initial trajectory. The above methodology outperforms ESDF in providing the vital information for collision avoidance, since the explicitly designed repulsive force can be fairly effective regarding various missions and environments. Moreover, the proposed method has no requirement for collision-free initialization. ä¸ºäº†å°†å¿…è¦çš„ç¯å¢ƒæ„è¯†èå…¥å±€éƒ¨è§„åˆ’å™¨ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ˜ç¡®æ„å»ºä¸€ä¸ªç›®æ ‡å‡½æ•°ï¼Œä½¿è½¨è¿¹è¿œç¦»éšœç¢ç‰©ã€‚ ESDF æä¾›äº†è¿™ä¸ªé‡è¦çš„ç¢°æ’ä¿¡æ¯ï¼Œä½†ä»˜å‡ºäº†æ²‰é‡çš„è®¡ç®—è´Ÿæ‹…ã€‚ æ­¤å¤–ï¼Œå¦‚å›¾ 2 æ‰€ç¤ºï¼ŒåŸºäº ESDF çš„è§„åˆ’å™¨å¾ˆå®¹æ˜“é™·å…¥å±€éƒ¨æœ€å°å€¼ï¼Œå¹¶ä¸èƒ½é€ƒç¦»éšœç¢ç‰©ï¼Œè¿™æ˜¯ç”±äº ESDF æä¾›çš„ä¿¡æ¯ä¸è¶³ç”šè‡³é”™è¯¯ã€‚ ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œé¢å¤–çš„å‰ç«¯å§‹ç»ˆéœ€è¦æä¾›ä¸€ä¸ªæ— ç¢°æ’çš„åˆå§‹è½¨è¿¹ã€‚ ä¸Šè¿°æ–¹æ³•åœ¨æä¾›ç”¨äºé¿éšœçš„é‡è¦ä¿¡æ¯æ–¹é¢ä¼˜äº ESDFï¼Œå› ä¸ºæ˜ç¡®è®¾è®¡çš„æ–¥åŠ›å¯¹äºå„ç§ä»»åŠ¡å’Œç¯å¢ƒéƒ½éå¸¸æœ‰æ•ˆã€‚ æ­¤å¤–ï¼Œæ‰€æå‡ºçš„æ–¹æ³•å¯¹æ— ç¢°æ’çš„åˆå§‹åŒ–æ²¡æœ‰è¦æ±‚ã€‚ image 2: è·¯å¾„é™·å…¥äº†ä¸€ä¸ªå±€éƒ¨æœ€å°å€¼ï¼Œè¿™æ˜¯éå¸¸å¸¸è§çš„æƒ…å†µï¼Œå› ä¸ºç›¸æœºæ— æ³•çœ‹åˆ°éšœç¢ç‰©çš„èƒŒé¢ã€‚ 4 Gradient-Based Trajectory Optimization åŸºäºæ¢¯åº¦çš„è½¨è¿¹ä¼˜åŒ–å™¨ A. Problem Formulation åœ¨æœ¬æ–‡ä¸­ï¼Œè½¨è¿¹ç”±å‡åŒ€ B æ ·æ¡æ›²çº¿ (uniform B-spline curve) $\\mathbf{\\Phi}$ å‚æ•°åŒ–ï¼Œè¯¥æ›²çº¿ç”±ï¼š å…¶æ¬¡æ•° $p_b$ï¼Œ $N_c$ ä¸ªæ§åˆ¶ç‚¹ $\\left\\lbrace \\mathbf{Q}1, \\mathbf{Q}_2, \\cdots, \\mathbf{Q}{N_c} \\right\\rbrace$ å’Œ èŠ‚ç‚¹å‘é‡ $\\left{ t_1, t_2, \\cdots, t_M \\right}$ å”¯ä¸€ç¡®å®šï¼Œ å…¶ä¸­ $\\mathbf{Q}_i \\in \\mathbb{R}^3$ï¼Œ$t_m \\in \\mathbb{R}$ï¼Œ$M=N_c+p_b$ ã€‚ ä¸ºäº†ç®€åŒ–å’Œæé«˜è½¨è¿¹è¯„ä¼°çš„æ•ˆç‡ï¼Œæˆ‘ä»¬æ–¹æ³•ä¸­ä½¿ç”¨çš„B æ ·æ¡æ˜¯å‡åŒ€çš„ï¼Œè¿™æ„å‘³ç€æ¯ä¸ªèŠ‚ç‚¹ä¸å…¶å‰ä¸€ä¸ªèŠ‚ç‚¹ä¹‹é—´æœ‰ç›¸åŒçš„æ—¶é—´é—´éš” $\\triangle t=t_{m+1}-t_m$ ã€‚ æœ¬æ–‡çš„é—®é¢˜å½¢å¼åŒ–åŸºäºå½“å‰æœ€å…ˆè¿›çš„å››æ—‹ç¿¼æœºå™¨äººå±€éƒ¨è§„åˆ’æ¡†æ¶ Fast-Planner-19ã€‚ B-æ ·æ¡å…·æœ‰å‡¸åŒ…æ€§è´¨ã€‚ è¯¥æ€§è´¨è¡¨æ˜ B-æ ·æ¡æ›²çº¿çš„å•ä¸ªåŒºé—´ä»…ç”± $p_b+1$ ä¸ªè¿ç»­æ§åˆ¶ç‚¹æ§åˆ¶ï¼Œå¹¶ä½äºè¿™äº›ç‚¹çš„å‡¸åŒ…å†…ã€‚ ä¾‹å¦‚ï¼Œåœ¨ $(t_i, t_{i+1})$ åŒºé—´å†…çš„ä¸€ä¸ªåŒºæ®µä½äºç”± ${\\mathbf{Q}{i-p_b}, \\mathbf{Q}{i-p_b+1}, \\cdots, \\mathbf{Q}_i}$ å½¢æˆçš„å‡¸åŒ…å†…ã€‚ å¦ä¸€ä¸ªæ€§è´¨æ˜¯ B-æ ·æ¡çš„ $k$ é˜¶å¯¼æ•°ä»ç„¶æ˜¯ä¸€ä¸ªå…·æœ‰æ¬¡æ•° $p_{b,k}=p_b-k$ çš„ B-æ ·æ¡ã€‚ ç”±äº $\\triangle t$ ä¸ $\\mathbf{\\Phi}$ ç‹¬ç«‹ï¼Œé€Ÿåº¦ $\\mathbf{V}_i$ã€åŠ é€Ÿåº¦ $\\mathbf{A}_i$ å’ŒåŠ åŠ é€Ÿåº¦ $\\mathbf{J}_i$ æ›²çº¿çš„æ§åˆ¶ç‚¹å¯ä»¥é€šè¿‡å¦‚ä¸‹å…¬å¼è·å¾—ï¼š Vi=Qi+1âˆ’Qiâ–³t,Ai=Vi+1âˆ’Viâ–³t,Ji=Ai+1âˆ’Aiâ–³t \\mathbf{V}_{i}=\\frac{\\mathbf{Q}_{i+1}-\\mathbf{Q}_{i}}{\\triangle t}, \\quad \\mathbf{A}_{i}=\\frac{\\mathbf{V}_{i+1}-\\mathbf{V}_{i}}{\\triangle t}, \\quad \\mathbf{J}_{i}=\\frac{\\mathbf{A}_{i+1}-\\mathbf{A}_{i}}{\\triangle t} Viâ€‹=â–³tQi+1â€‹âˆ’Qiâ€‹â€‹,Aiâ€‹=â–³tVi+1â€‹âˆ’Viâ€‹â€‹,Jiâ€‹=â–³tAi+1â€‹âˆ’Aiâ€‹â€‹ æˆ‘ä»¬éµå¾ª [15] çš„å·¥ä½œï¼Œåœ¨å·®åˆ†å¹³å¦è¾“å‡ºç©ºé—´çš„ç¼©å‡ç©ºé—´ (reduced space of differentially flat output) ä¸­è§„åˆ’æ§åˆ¶ç‚¹ $\\mathbf{Q} \\in \\mathbb{R}^3$ï¼ˆæ ¹æ®æ— äººæœºçš„å¾®åˆ†å¹³å¦ç‰¹æ€§é™ä½è¦è§„åˆ’çš„å˜é‡ï¼‰ã€‚ ä¼˜åŒ–é—®é¢˜çš„è¡¨è¿°å¦‚ä¸‹ï¼š minâ¡QJ=Î»sJs+Î»cJc+Î»dJd \\min _{\\mathbf{Q}} J=\\lambda_{s} J_{s}+\\lambda_{c} J_{c}+\\lambda_{d} J_{d} Qminâ€‹J=Î»sâ€‹Jsâ€‹+Î»câ€‹Jcâ€‹+Î»dâ€‹Jdâ€‹ å…¶ä¸­ $J_s$ æ˜¯å¹³æ»‘åº¦æƒ©ç½šé¡¹ï¼Œ$J_c$ æ˜¯ç¢°æ’æƒ©ç½šé¡¹ï¼Œè€Œ $J_d$ è¡¨ç¤ºåŠ¨åŠ›å­¦å¯è¡Œé¡¹ã€‚ $\\lambda_s, \\lambda_c, \\lambda_d$ æ˜¯æ¯ä¸ªæƒ©ç½šé¡¹çš„æƒé‡ã€‚ 1ï¼‰å¹³æ»‘åº¦æƒ©ç½šé¡¹ $J_s$ the smoothness penalty is formulized as the time integral over square derivatives of the trajectory (acceleration, jerk, etc.) åœ¨\\cite{Usenko2017ewok}ä¸­ï¼Œå¹³æ»‘æƒ©ç½šè¢«å®šä¹‰ä¸ºè½¨è¿¹äºŒé˜¶å¯¼æ•°ï¼ˆåŠ é€Ÿåº¦ã€ jerk ç­‰ï¼‰çš„æ—¶é—´ç§¯åˆ†ã€‚ åœ¨\\cite{zhou2019robust}ä¸­ï¼Œåªè€ƒè™‘è½¨è¿¹çš„å‡ ä½•ä¿¡æ¯ï¼Œä¸è€ƒè™‘æ—¶é—´åˆ†é…ã€‚ åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬ç»“åˆäº†ä¸¤ç§æ–¹æ³•æ¥å¯¹åŠ é€Ÿåº¦å’Œ jerk è¿›è¡Œå¹³æ–¹æƒ©ç½šï¼Œè€Œä¸è¿›è¡Œæ—¶é—´ç§¯åˆ†ã€‚ æœ€å°åŒ–é«˜é˜¶å¯¼æ•°èƒ½å¤Ÿä½¿å¾—æ•´æ®µè½¨è¿¹å…‰æ»‘ã€‚æ‰€ä»¥å…‰æ»‘é¡¹ç”±åŠ é€Ÿåº¦å’ŒåŠ åŠ é€Ÿåº¦çš„å¹³æ–¹å’Œæ„æˆã€‚ é€šè¿‡å‡¸åŒ…æ€§è´¨çš„ä¼˜åŠ¿ï¼Œåªè¦æœ€å°åŒ– B æ ·æ¡è½¨è¿¹çš„äºŒé˜¶å¯¼å’Œä¸‰é˜¶å¯¼æ§åˆ¶ç‚¹çš„å¹³æ–¹å’Œ å°±è¶³ä»¥å‡å°æ•´ä¸ªæ›²çº¿ä¸Šçš„è¿™äº›å¯¼æ•°ã€‚ å› æ­¤ï¼Œå¹³æ»‘æƒ©ç½šå‡½æ•°çš„å…¬å¼ä¸ºï¼š Js=âˆ‘i=1Ncâˆ’1âˆ¥Aiâˆ¥22+âˆ‘i=1Ncâˆ’2âˆ¥Jiâˆ¥22, J_{s}=\\sum_{i=1}^{N_{c}-1}\\left\\|\\mathbf{A}_{i}\\right\\|_{2}^{2}+\\sum_{i=1}^{N_{c}-2}\\left\\|\\mathbf{J}_{i}\\right\\|_{2}^{2}, Jsâ€‹=i=1âˆ‘Ncâ€‹âˆ’1â€‹âˆ¥Aiâ€‹âˆ¥22â€‹+i=1âˆ‘Ncâ€‹âˆ’2â€‹âˆ¥Jiâ€‹âˆ¥22â€‹, æœ€å°åŒ–é«˜é˜¶å¯¼æ•°ï¼Œä½¿æ•´ä¸ªè½¨è¿¹å˜å¾—å¹³æ»‘ã€‚ 2ï¼‰ç¢°æ’æƒ©ç½šé¡¹ $J_c$ ç¢°æ’æƒ©ç½šå°†æ§åˆ¶ç‚¹è¿œç¦»éšœç¢ç‰©ã€‚ è¿™æ˜¯é€šè¿‡é‡‡ç”¨å®‰å…¨é—´éš™ $s_f$ å¹¶æƒ©ç½šæ»¡è¶³ $d_{ij} æƒ©ç½šå‡½æ•° $j_c$ï¼Œéšç€ $d_{ij}$ å‡å°ï¼Œ$j_c$ çš„æ–œç‡å°±è¶Šå°ï¼Œä»è€Œå¾—åˆ°åˆ†æ®µå‡½æ•°ï¼š jc(i,j)={0(cijâ‰¤0)cij3(0cijâ‰¤sf)3sfcij2âˆ’3sf2cij+sf3(cij>sf) \\begin{array}{rlr}j_{c}(i, j) & =\\left\\{\\begin{array}{lr}0 & \\left(c_{i j} \\leq 0\\right) \\\\\\\\ c_{i j}^{3} & \\left(0s_{f}\\right)\\end{array}\\right.\\end{array} jcâ€‹(i,j)â€‹=â©âªâªâªâªâªâ¨âªâªâªâªâªâ§â€‹0cij3â€‹3sfâ€‹cij2â€‹âˆ’3sf2â€‹cijâ€‹+sf3â€‹â€‹(cijâ€‹â‰¤0)(0cijâ€‹â‰¤sfâ€‹)(cijâ€‹>sfâ€‹)â€‹â€‹ å…¶ä¸­ $c_{i j} =s_{f}-d_{i j}$, $j_c(i,j)$ æ˜¯ç”± ${\\mathbf{p},\\mathbf{v}}_j$ å¯¹äº $\\mathbf{Q}_i$ äº§ç”Ÿçš„ costã€‚ æ¯ä¸ª $\\mathbf{Q}_i$ çš„æˆæœ¬æ˜¯ç‹¬ç«‹è¯„ä¼°çš„ï¼Œå¹¶ä¸”ä»æ‰€æœ‰å¯¹åº”çš„ ${\\mathbf{p},\\mathbf{v}}_j$ å¯¹ä¸­ç´¯ç§¯ã€‚ å› æ­¤ï¼Œå¦‚æœä¸€ä¸ªæ§åˆ¶ç‚¹å‘ç°äº†æ›´å¤šçš„éšœç¢ç‰©ï¼Œå®ƒå°†è·å¾—æ›´é«˜çš„è½¨è¿¹å˜å½¢æƒé‡ã€‚ å…·ä½“æ¥è¯´ï¼Œç¬¬ $i$ ä¸ªæ§åˆ¶ç‚¹çš„æˆæœ¬å€¼ä¸º $j_c(\\mathbf{Q}i)=\\sum{j=1}^{N_p} j_c(i,j)$ï¼Œå…¶ä¸­ $N_p$ æ˜¯å±äº $\\mathbf{Q}_i$ çš„ ${\\mathbf{p},\\mathbf{v}}_j$ å¯¹çš„æ•°é‡ã€‚ å°†æ‰€æœ‰ $\\mathbf{Q}_i$ ä¸Šçš„æˆæœ¬ç»„åˆåœ¨ä¸€èµ·å¾—åˆ°æ€»æˆæœ¬ $J_c$ï¼Œå³ï¼š Jc=âˆ‘i=1Ncjc(Qi). J_{c}=\\sum_{i=1}^{N_{c}} j_{c}\\left(\\mathbf{Q}_{i}\\right). Jcâ€‹=i=1âˆ‘Ncâ€‹â€‹jcâ€‹(Qiâ€‹). ä¸ä¼ ç»Ÿçš„åŸºäº ESDF çš„æ–¹æ³•ï¼ˆUsenko et al., 2017; Zhou et al., 2019ï¼‰ä¸åŒï¼Œä¼ ç»Ÿæ–¹æ³•é€šè¿‡åœ¨åœºä¸Šè¿›è¡Œä¸‰çº¿æ€§æ’å€¼æ¥è®¡ç®—æ¢¯åº¦ï¼Œè€Œæˆ‘ä»¬é€šè¿‡ç›´æ¥é—­å¼è®¡ç®— $J_c$ ç›¸å¯¹äº $\\mathbf{Q}_i$ çš„å¯¼æ•°æ¥è·å¾—æ¢¯åº¦ï¼š âˆ‚Jcâˆ‚Qi=âˆ‘i=1Ncâˆ‘j=1Npvij{0(cijâ‰¤0)âˆ’3cij2(0cijâ‰¤sf)âˆ’6sfcij+3sf2(cij>sf) \\frac{\\partial J_{c}}{\\partial \\mathbf{Q}_{i}}= \\sum_{i=1}^{N_{c}} \\sum_{j=1}^{N_{p}} \\mathbf{v}_{i j}\\left\\{\\begin{array}{lr} 0 & \\left(c_{i j} \\leq 0\\right) \\\\ -3 c_{i j}^{2} & \\left(0s_{f}\\right) \\end{array}\\right. âˆ‚Qiâ€‹âˆ‚Jcâ€‹â€‹=i=1âˆ‘Ncâ€‹â€‹j=1âˆ‘Npâ€‹â€‹vijâ€‹â©âªâ¨âªâ§â€‹0âˆ’3cij2â€‹âˆ’6sfâ€‹cijâ€‹+3sf2â€‹â€‹(cijâ€‹â‰¤0)(0cijâ€‹â‰¤sfâ€‹)(cijâ€‹>sfâ€‹)â€‹ 3ï¼‰å¯è¡Œæ€§æƒ©ç½šé¡¹ $J_d$ åŠ¨åŠ›å­¦å¯è¡Œé¡¹é€šè¿‡é™åˆ¶è½¨è¿¹åœ¨ä¸‰ä¸ªè½´ä¸Šçš„ $k$ é˜¶å¯¼æ•°æ¥å®ç°ã€‚å¾—ç›Šäº B æ ·æ¡æ›²çº¿çš„å‡¸åŒ…æ€§è´¨ï¼Œåªè¦å¯¹æ§åˆ¶ç‚¹è¿›è¡Œé™åˆ¶å³å¯æ»¡è¶³åŠ¨åŠ›å­¦å¯è¡Œæ€§ã€‚ é€šè¿‡é™åˆ¶æ¯ä¸ªç»´åº¦ä¸Šè½¨è¿¹çš„é«˜é˜¶å¯¼æ•°æ¥ç¡®ä¿å¯è¡Œæ€§ï¼Œå³å¯¹æ‰€æœ‰ $t$ åº”ç”¨ âˆ£Î¦r(k)(t)âˆ£Î¦r,max(k) |\\mathbf{\\Phi}^{(k)}_r(t)| âˆ£Î¦r(k)â€‹(t)âˆ£Î¦r,max(k)â€‹ å…¶ä¸­$r \\in {x, y, z}$ è¡¨ç¤ºæ¯ä¸ªç»´åº¦ã€‚ ç”±äºå‡¸åŒ…æ€§è´¨ï¼Œé™åˆ¶æ§åˆ¶ç‚¹çš„å¯¼æ•°å°±è¶³ä»¥é™åˆ¶æ•´ä¸ª B æ ·æ¡æ›²çº¿ã€‚ å› æ­¤ï¼Œç½šå‡½æ•°å¯ä»¥è¡¨ç¤ºä¸ºï¼š Jd=âˆ‘i=1NcwvF(Vi)+âˆ‘i=1Ncâˆ’1waF(Ai)+âˆ‘i=1Ncâˆ’2wjF(Ji) J_{d}= \\sum_{i=1}^{N_{c}} w_{v} F\\left(\\mathbf{V}_{i}\\right)+ \\sum_{i=1}^{N_{c}-1} w_{a} F\\left(\\mathbf{A}_{i}\\right)+ \\sum_{i=1}^{N_{c}-2} w_{j} F\\left(\\mathbf{J}_{i}\\right) Jdâ€‹=i=1âˆ‘Ncâ€‹â€‹wvâ€‹F(Viâ€‹)+i=1âˆ‘Ncâ€‹âˆ’1â€‹waâ€‹F(Aiâ€‹)+i=1âˆ‘Ncâ€‹âˆ’2â€‹wjâ€‹F(Jiâ€‹) å…¶ä¸­ $w_v, w_a, w_j$ æ˜¯æ¯ä¸ªé¡¹çš„æƒé‡ï¼Œè€Œ $F(\\cdot)$ æ˜¯å¯¹æ§åˆ¶ç‚¹é«˜é˜¶å¯¼æ•°çš„ä¸¤æ¬¡è¿ç»­å¯å¾®åº¦é‡å‡½æ•°ã€‚ F(C)=âˆ‘r=x,y,zf(cr) F(\\mathbf{C})=\\sum_{r=x, y, z} f\\left(c_{r}\\right) F(C)=r=x,y,zâˆ‘â€‹f(crâ€‹) f(cr)={a1cr2+b1cr+c1(crâ‰¤âˆ’cj)(âˆ’Î»cmâˆ’cr)3(âˆ’cjcrâˆ’Î»cm)0(âˆ’Î»cmâ‰¤crâ‰¤Î»cm)(crâˆ’Î»cm)3(Î»cmcrcj)a2cr2+b2cr+c2(crâ‰¥cj) f\\left(c_{r}\\right)=\\left\\{\\begin{array}{lr}a_{1} c_{r}^{2}+b_{1} c_{r}+c_{1} & \\left(c_{r} \\leq-c_{j}\\right) \\\\\\\\ \\left(-\\lambda c_{m}-c_{r}\\right)^{3} & \\left(-c_{j}f(crâ€‹)=â©âªâªâªâªâªâªâªâªâªâªâªâªâªâ¨âªâªâªâªâªâªâªâªâªâªâªâªâªâ§â€‹a1â€‹cr2â€‹+b1â€‹crâ€‹+c1â€‹(âˆ’Î»cmâ€‹âˆ’crâ€‹)30(crâ€‹âˆ’Î»cmâ€‹)3a2â€‹cr2â€‹+b2â€‹crâ€‹+c2â€‹â€‹(crâ€‹â‰¤âˆ’cjâ€‹)(âˆ’cjâ€‹crâ€‹âˆ’Î»cmâ€‹)(âˆ’Î»cmâ€‹â‰¤crâ€‹â‰¤Î»cmâ€‹)(Î»cmâ€‹crâ€‹cjâ€‹)(crâ€‹â‰¥cjâ€‹)â€‹ å…¶ä¸­ï¼Œ$c_r \\in \\mathbf{C} \\in {\\mathbf{V}{i}, \\mathbf{A}{i}, \\mathbf{J}_{i}}$ ï¼Œ$a_1,b_1,c_1,a_2,b_2,c_2$ ç”¨äºæ»¡è¶³å‡½æ•°äºŒé˜¶è¿ç»­æ€§çš„æ¡ä»¶ï¼Œ$c_m$ æ˜¯å¯¼æ•°çš„é™åˆ¶ï¼Œ$c_j$ æ˜¯äºŒæ¬¡åŒºé—´å’Œä¸‰æ¬¡åŒºé—´çš„åˆ†å‰²ç‚¹ã€‚ $\\lambda B. Numerical Optimization æ•°å€¼ä¼˜åŒ– ç›®æ ‡å‡½æ•° $J$ä¼šéšç€æ–°éšœç¢ç‰©çš„åŠ å…¥è€Œä¸æ–­æ”¹å˜ï¼Œè¿™å°±è¦æ±‚æ±‚è§£å™¨èƒ½å¤Ÿå¿«é€Ÿé‡å¯ï¼Œå¹¶ä¸”ç›®æ ‡å‡½æ•°ä¸»è¦ç”±äºŒæ¬¡é¡¹ç»„æˆï¼Œæ‰€ä»¥ Hessian çŸ©é˜µä¿¡æ¯èƒ½å¤ŸåŠ å¿«æ”¶æ•›é€Ÿåº¦ã€‚ä½†å¾—åˆ°ç²¾ç¡®çš„ Hessian æ¶ˆè€—å¤§é‡è®¡ç®—æœºèµ„æºã€‚æ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨æ‹Ÿç‰›é¡¿æ³•ï¼ˆ quasi-Newton methodsï¼‰ä»æ¢¯åº¦ä¿¡æ¯ä¸­æ¥è¿‘ä¼¼è®¡ç®— Hessianã€‚ æœ¬æ–‡ä¸­æå‡ºçš„é—®é¢˜å…·æœ‰ä¸¤ä¸ªæ–¹é¢çš„ç‰¹ç‚¹ã€‚ é¦–å…ˆï¼Œç›®æ ‡å‡½æ•° $J$ æ ¹æ®æ–°å‘ç°çš„éšœç¢ç‰©è¿›è¡Œè‡ªé€‚åº”åœ°æ”¹å˜ã€‚ è¿™è¦æ±‚æ±‚è§£å™¨èƒ½å¤Ÿå¿«é€Ÿé‡å¯ã€‚ å…¶æ¬¡ï¼ŒäºŒæ¬¡é¡¹åœ¨ç›®æ ‡å‡½æ•°çš„åˆ¶å®šä¸­å ä¸»å¯¼åœ°ä½ï¼Œä½¿å¾— $J$ è¿‘ä¼¼ä¸ºäºŒæ¬¡å‡½æ•°ã€‚ è¿™æ„å‘³ç€åˆ©ç”¨æµ·æ£®çŸ©é˜µä¿¡æ¯å¯ä»¥æ˜¾è‘—åŠ å¿«æ”¶æ•›é€Ÿåº¦ã€‚ ç„¶è€Œï¼Œåœ¨å®æ—¶åº”ç”¨ä¸­è·å–ç²¾ç¡®çš„é€†æµ·æ£®çŸ©é˜µæ˜¯ä¸å¯è¡Œçš„ï¼Œå› ä¸ºå®ƒæ¶ˆè€—äº†ç›¸å½“å¤šçš„è®¡ç®—èµ„æºã€‚ ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œé‡‡ç”¨äº†ä»æ¢¯åº¦ä¿¡æ¯ä¸­è¿‘ä¼¼é€†æµ·æ£®çŸ©é˜µçš„æ‹Ÿç‰›é¡¿æ–¹æ³•ã€‚ ç”±äºæ±‚è§£å™¨çš„æ€§èƒ½ä¸é—®é¢˜æœ‰å…³ï¼Œæˆ‘ä»¬æ¯”è¾ƒäº†å±äºæ‹Ÿç‰›é¡¿æ–¹æ³•çš„ä¸‰ç§ç®—æ³•ã€‚ å®ƒä»¬åˆ†åˆ«æ˜¯ï¼š Barzilai-Borwein æ–¹æ³•\\cite{barzilai1988two}ï¼Œè¯¥æ–¹æ³•èƒ½å¤Ÿå¿«é€Ÿé‡å¯ï¼Œå¹¶å…·æœ‰æœ€ç²—ç•¥çš„æµ·æ£®çŸ©é˜µä¼°è®¡ï¼› æˆªæ–­ç‰›é¡¿æ³•\\cite{steiha1983truncatednewton}ï¼Œè¯¥æ–¹æ³•é€šè¿‡å¯¹ç»™å®šçŠ¶æ€æ·»åŠ å¤šä¸ªå¾®å°æ‰°åŠ¨æ¥ä¼°è®¡æµ·æ£®çŸ©é˜µï¼› L-BFGS æ–¹æ³•\\cite{liu1989limited}ï¼Œè¯¥æ–¹æ³•é€šè¿‡ä¹‹å‰çš„ç›®æ ‡å‡½æ•°è¯„ä¼°æ¥è¿‘ä¼¼ä¼°è®¡æµ·æ£®çŸ©é˜µï¼Œä½†éœ€è¦ä¸€ç³»åˆ—è¿­ä»£æ‰èƒ½è¾¾åˆ°ç›¸å¯¹å‡†ç¡®çš„ä¼°è®¡ã€‚ åœ¨ç¬¬ \\ref{sec:solver_comp} èŠ‚çš„æ¯”è¾ƒä¸­è¡¨æ˜ï¼ŒL-BFGS æ–¹æ³•åœ¨é€‚å½“é€‰æ‹©å†…å­˜å¤§å°çš„æƒ…å†µä¸‹ä¼˜äºå…¶ä»–ä¸¤ç§ç®—æ³•ï¼Œå¹³è¡¡äº†é‡å¯çš„æŸå¤±å’Œé€†æµ·æ£®çŸ©é˜µä¼°è®¡çš„å‡†ç¡®æ€§ã€‚ è¯¥ç®—æ³•çš„ç®€è¦è§£é‡Šå¦‚ä¸‹ã€‚ å¯¹äºä¸€ä¸ªæ— çº¦æŸä¼˜åŒ–é—®é¢˜ $\\mathop{min}_{\\mathbf{x} \\in {\\mathbb{R}^n}} f(\\mathbf{x})$ï¼Œæ›´æ–° $\\mathbf{x}$ éµå¾ªè¿‘ä¼¼ç‰›é¡¿æ­¥éª¤ã€‚ xk+1=xkâˆ’Î±kHkâˆ‡fkHk+1=VkTHkVk+ÏkskskT \\begin{array}{c}x_{k+1}=x k-\\alpha_{k} H_{k} \\nabla f_{k} \\\\\\\\ H_{k+1}=V_{k}^{T} H_{k} V_{k}+\\rho_{k} s_{k} s_{k}^{T}\\end{array} xk+1â€‹=xkâˆ’Î±kâ€‹Hkâ€‹âˆ‡fkâ€‹Hk+1â€‹=VkTâ€‹Hkâ€‹Vkâ€‹+Ïkâ€‹skâ€‹skTâ€‹â€‹ å…¶ä¸­ $\\alpha_{k}$ ä¸ºæ­¥é•¿ï¼Œ $\\rho_{k}=\\left(y_{k}^{T} s_{k}\\right)^{-1}$ ï¼Œ$V_{k}=I-\\rho_{k} y_{k} s_{k}^{T}$ï¼Œ$s_{k}=x_{k+1}-x_{k}$ ï¼Œ$y_{k}=\\nabla f_{k+1}-\\nabla f_{k}$ ã€‚ ç®—æ³•å°†å¼ å³ä¹˜$ \\nabla f_{k}$ ï¼Œé€’å½’æ‰©å±• m æ­¥åå¾—åˆ°äº†æœ‰æ•ˆçš„ã€çº¿æ€§æ—¶é—´/ç©ºé—´å¤æ‚åº¦çš„åŒç¯é€’å½’æ›´æ–°æ–¹æ³•ã€‚L-BFGS çš„å§‹åŒ–é€† Hessian $H_{k}^{0}$ ç”± Barzilai-Borwein step çš„æƒé‡æ¥å¾—åˆ° Hk0=skâˆ’1Tykâˆ’1ykâˆ’1Tykâˆ’1Iorskâˆ’1Tskâˆ’1skâˆ’1Tykâˆ’1I H_{k}^{0}=\\frac{s_{k-1}^{T} y_{k-1}}{y_{k-1}^{T} y_{k-1}} I \\quad or \\quad \\frac{s_{k-1}^{T} s_{k-1}}{s_{k-1}^{T} y_{k-1}} I Hk0â€‹=ykâˆ’1Tâ€‹ykâˆ’1â€‹skâˆ’1Tâ€‹ykâˆ’1â€‹â€‹Iorskâˆ’1Tâ€‹ykâˆ’1â€‹skâˆ’1Tâ€‹skâˆ’1â€‹â€‹I 5 Time Re-allocation and Trajectory Refinement æ—¶é—´é‡åˆ†é…å’Œè½¨è¿¹ç»†åŒ– åœ¨ä¼˜åŒ–ä¹‹å‰åˆ†é…ä¸€ä¸ªå‡†ç¡®çš„æ—¶é—´ç•Œé™æ˜¯ä¸åˆç†çš„ï¼Œå› ä¸ºè§„åˆ’å™¨å¯¹æœ€ç»ˆè½¨è¿¹æ²¡æœ‰ä»»ä½•ä¿¡æ¯ã€‚ å› æ­¤ï¼Œé¢å¤–çš„æ—¶é—´é‡æ–°åˆ†é…ç¨‹åºå¯¹äºç¡®ä¿åŠ¨åŠ›å­¦å¯è¡Œæ€§è‡³å…³é‡è¦ã€‚ å…ˆå‰çš„ç ”ç©¶\\cite{gao2020teach, zhou2019robust}å°†è½¨è¿¹å‚æ•°åŒ–ä¸ºéå‡åŒ€ B æ ·æ¡ï¼Œå¹¶åœ¨ä¸€äº›æ®µè¶…è¿‡å¯¼æ•°é™åˆ¶æ—¶è¿­ä»£åœ°å»¶é•¿ä¸€ç»„èŠ‚ç‚¹è·¨åº¦ã€‚ ç„¶è€Œï¼Œä¸€ä¸ªèŠ‚ç‚¹è·¨åº¦ $\\triangle t_n$ä¼šå½±å“å¤šä¸ªæ§åˆ¶ç‚¹ï¼Œåä¹‹äº¦ç„¶ï¼Œå½“è°ƒæ•´é è¿‘èµ·å§‹çŠ¶æ€çš„èŠ‚ç‚¹è·¨åº¦æ—¶ï¼Œä¼šå¯¼è‡´ä¸ä¹‹å‰è½¨è¿¹çš„é«˜é˜¶ä¸è¿ç»­æ€§ã€‚ åœ¨æœ¬èŠ‚ä¸­ï¼Œæ ¹æ®ç¬¬å››èŠ‚ä¸­å¾—åˆ°çš„å®‰å…¨è½¨è¿¹ $\\mathbf{\\Phi}{s}$ ï¼Œç”Ÿæˆä¸€æ¡æ—¶é—´åˆ†é…åˆç†çš„å‡åŒ€ B æ ·æ¡è½¨è¿¹ $\\mathbf{\\Phi}{f}$ ã€‚ç„¶åï¼Œæå‡ºäº†ä¸€ç§å„å‘å¼‚æ€§æ›²çº¿æ‹Ÿåˆæ–¹æ³•ï¼ˆan anisotropic curve fifitting methodï¼‰ï¼Œä½¿ $\\mathbf{\\Phi}{f}$ å¯ä»¥è‡ªç”±åœ°ä¼˜åŒ–å…¶æ§åˆ¶ç‚¹ï¼Œä»¥æ»¡è¶³æ›´é«˜é˜¶å¯¼æ•°çº¦æŸï¼ŒåŒæ—¶ä¿æŒä¸ $\\mathbf{\\Phi}{s}$ å‡ ä¹ç›¸åŒçš„å½¢çŠ¶ã€‚ é¦–å…ˆï¼Œä¸ Fast-Planner ç±»ä¼¼ï¼Œæˆ‘ä»¬è®¡ç®—è¶…å‡ºé™åˆ¶çš„æ¯”ç‡ã€‚ re=maxâ¡{âˆ£Vi,r/vmâˆ£,âˆ£Aj,r/amâˆ£,âˆ£Jk,r/jmâˆ£3,1} r_{e}=\\max \\left\\{\\left|\\mathbf{V}_{i, r} / v_{m}\\right|, \\sqrt{\\left|\\mathbf{A}_{j, r} / a_{m}\\right|}, \\sqrt[3]{\\left|\\mathbf{J}_{k, r} / j_{m}\\right|}, 1\\right\\} reâ€‹=max{âˆ£Vi,râ€‹/vmâ€‹âˆ£,âˆ£Aj,râ€‹/amâ€‹âˆ£â€‹,3âˆ£Jk,râ€‹/jmâ€‹âˆ£â€‹,1} å…¶ä¸­ï¼Œ$i\\in{1,\\cdots, N_c-1}$ ï¼Œ$j\\in{1,\\cdots, N_c-2}$ ï¼Œ$k\\in{1,\\cdots, N_c-3}$ å’Œ $r\\in{x,y,z}$ è½´ã€‚ ä¸‹æ ‡ä¸º$m$çš„æ¦‚å¿µè¡¨ç¤ºå¯¼æ•°çš„é™åˆ¶ã€‚ $r_e$ è¡¨ç¤ºç›¸å¯¹äº $\\mathbf{\\Phi}{s}$ ï¼Œæˆ‘ä»¬åº”è¯¥å»¶é•¿ $\\mathbf{\\Phi}{f}$ çš„æ—¶é—´åˆ†é…é‡ã€‚ æ³¨æ„ï¼Œ $\\mathbf{V}_i$ï¼Œ $\\mathbf{A}_j$ å’Œ $\\mathbf{J}_k$ ä¸ $\\triangle t$ çš„å¹³æ–¹å’Œ $\\triangle t$ çš„ç«‹æ–¹æˆåæ¯”ï¼Œå‚è§å¼ï¼ˆ\\ref{equ:v_a_j}ï¼‰ã€‚ ç„¶åæˆ‘ä»¬å¾—åˆ°äº† $\\mathbf{\\Phi}_{f}$ çš„æ–°æ—¶é—´é—´éš”ã€‚ Î”tâ€²=reÎ”t. \\Delta t^{\\prime}=r_{e} \\Delta t. Î”tâ€²=reâ€‹Î”t. $\\mathbf{\\Phi}{f}$ åœ¨æ»¡è¶³è¾¹ç•Œçº¦æŸçš„æƒ…å†µä¸‹ï¼Œé€šè¿‡è§£ä¸€ä¸ªé—­å¼æœ€å°äºŒä¹˜é—®é¢˜ï¼Œåˆå§‹åŒ–ç”Ÿæˆæ—¶é—´è·¨åº¦ä¸º $\\Delta t^{\\prime}$ çš„è½¨è¿¹ $\\mathbf{\\Phi}{f}$ ï¼Œå¹¶ä¿æŒä¸ $\\mathbf{\\Phi}_s$ç›¸åŒçš„å½¢çŠ¶å’Œæ§åˆ¶ç‚¹æ•°é‡ã€‚ ç„¶åé€šè¿‡ä¼˜åŒ–è¿›ä¸€æ­¥ä¼˜åŒ–å…¶å¹³æ»‘æ€§å’Œå¯è¡Œæ€§ã€‚ ç”±å¹³æ»‘æ€§ã€å¯è¡Œæ€§å’Œæ›²çº¿æ‹Ÿåˆï¼ˆç¨åä»‹ç»ï¼‰çš„çº¿æ€§ç»„åˆæ‰€æ„é€ çš„æƒ©ç½šå‡½æ•°$J'$è¢«ç”¨äºä¼˜åŒ–ã€‚ minâ¡QJâ€²=Î»sJs+Î»dJd+Î»fJf \\min _{\\mathbf{Q}} J^{\\prime}=\\lambda_{s} J_{s}+\\lambda_{d} J_{d}+\\lambda_{f} J_{f} Qminâ€‹Jâ€²=Î»sâ€‹Jsâ€‹+Î»dâ€‹Jdâ€‹+Î»fâ€‹Jfâ€‹ å…¶ä¸­ï¼Œ $\\lambda_f$ æ˜¯æ‹Ÿåˆé¡¹çš„æƒé‡ã€‚ æ‹Ÿåˆæƒ©ç½šå‡½æ•° $J_f$ çš„å½¢å¼æ˜¯ä»ç‚¹ $\\mathbf{\\Phi}_f (\\alpha T')$ åˆ°ç›¸åº”ç‚¹ $\\mathbf{\\Phi}_s (\\alpha T)$ çš„å„å‘å¼‚æ€§ä½ç§»çš„ç§¯åˆ†ï¼Œå…¶ä¸­ $T$ å’Œ $T'$ æ˜¯ $\\mathbf{\\Phi}_s$ å’Œ $\\mathbf{\\Phi}_f$ çš„è½¨è¿¹æŒç»­æ—¶é—´ï¼Œ $\\alpha \\in [0,1]$ã€‚ ç”±äºæ‹Ÿåˆçš„æ›²çº¿ $\\mathbf{\\Phi}_{s}$ å·²ç»æ²¡æœ‰ç¢°æ’ï¼Œå¯¹äºä¸¤æ¡æ›²çº¿ï¼Œæˆ‘ä»¬ç”¨å¸¦æœ‰ä½æƒé‡çš„è½´å‘ä½ç§»æ¥æ”¾å®½å…‰æ»‘è°ƒæ•´é™åˆ¶ï¼Œç”¨é«˜æƒé‡çš„å¾„å‘ä½ç§»æ¥é˜²æ­¢ç¢°æ’ã€‚ ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬ä½¿ç”¨çƒåº¦é‡ï¼Œå¦‚å›¾\\ref{pic:fitting}æ‰€ç¤ºï¼Œä½¿å¾—åœ¨ç›¸åŒçš„çƒé¢ä¸Šçš„ä½ç§»äº§ç”Ÿç›¸åŒçš„æƒ©ç½šã€‚ æˆ‘ä»¬ç”¨ä¸€ä¸ªæ¤­åœ†ç»•å…¶ä¸»è½´ä¹‹ä¸€ï¼Œå³åˆ‡çº¿ $\\dot{\\mathbf{\\Phi}}_s(\\alpha T)$ æ—‹è½¬æ¥å¾—åˆ° $\\mathbf{\\Phi}_f(\\alpha T')$ çš„æ¤­çƒé¢ã€‚ å› æ­¤ï¼Œè½´å‘ä½ç§» $d_a$ å’Œå¾„å‘ä½ç§» $d_r$ å¯ä»¥é€šè¿‡è®¡ç®—å¾—åˆ°ã€‚ da=(Î¦fâˆ’Î¦s)â‹…Î¦Ë™sâˆ¥Î¦Ë™sâˆ¥,dr=âˆ¥(Î¦fâˆ’Î¦s)Ã—Î¦Ë™sâˆ¥Î¦Ë™sâˆ¥âˆ¥. \\begin{array}{l}d_{a}=\\left(\\boldsymbol{\\Phi}_{f}-\\boldsymbol{\\Phi}_{s}\\right) \\cdot \\frac{\\dot{\\boldsymbol{\\Phi}}_{s}}{\\left\\|\\dot{\\boldsymbol{\\Phi}}_{s}\\right\\|}, \\\\ d_{r}=\\left\\|\\left(\\boldsymbol{\\Phi}_{f}-\\boldsymbol{\\Phi}_{s}\\right) \\times \\frac{\\dot{\\boldsymbol{\\Phi}}_{s}}{\\left\\|\\dot{\\boldsymbol{\\Phi}}_{s}\\right\\|}\\right\\| .\\end{array} daâ€‹=(Î¦fâ€‹âˆ’Î¦sâ€‹)â‹…âˆ¥Î¦Ë™sâ€‹âˆ¥Î¦Ë™sâ€‹â€‹,drâ€‹=âˆ¥âˆ¥âˆ¥âˆ¥âˆ¥â€‹(Î¦fâ€‹âˆ’Î¦sâ€‹)Ã—âˆ¥Î¦Ë™sâ€‹âˆ¥Î¦Ë™sâ€‹â€‹âˆ¥âˆ¥âˆ¥âˆ¥âˆ¥â€‹.â€‹ åŒ¹é…ç¨‹åº¦æƒ©ç½šé¡¹å‡½æ•°ä¸ºï¼š Jf=âˆ«01[da(Î±Tâ€²)2a2+dr(Î±Tâ€²)2b2]dÎ± J_{f}=\\int_{0}^{1}\\left[\\frac{d_{a}\\left(\\alpha T^{\\prime}\\right)^{2}}{a^{2}}+\\frac{d_{r}\\left(\\alpha T^{\\prime}\\right)^{2}}{b^{2}}\\right] \\mathrm{d} \\alpha Jfâ€‹=âˆ«01â€‹[a2daâ€‹(Î±Tâ€²)2â€‹+b2drâ€‹(Î±Tâ€²)2â€‹]dÎ± å…¶ä¸­$a$å’Œ$b$åˆ†åˆ«ä»£è¡¨æ¤­åœ†çš„åŠé•¿è½´å’ŒåŠçŸ­è½´ã€‚ è¯¥é—®é¢˜é€šè¿‡L-BFGS ç®—æ³•æ±‚è§£ã€‚ 6 å®éªŒç»“æœ A. Implementation Details è§„åˆ’æ¡†æ¶æ€»ç»“å¦‚ ç®—æ³•2 æ‰€ç¤ºã€‚ æˆ‘ä»¬å°† B æ ·æ¡æ¬¡æ•°è®¾ç½®ä¸º $p_b=3$ã€‚ æ§åˆ¶ç‚¹çš„æ•°é‡ $N_c$ å¤§çº¦åœ¨ 25ä¸ªå·¦å³ï¼Œè¿™æ˜¯ç”±è§„åˆ’æ°´å¹³ï¼ˆçº¦ä¸º 7mï¼‰å’Œç›¸é‚»ç‚¹ä¹‹é—´çš„åˆå§‹è·ç¦»é—´éš”ï¼ˆçº¦ä¸º 0.3mï¼‰å†³å®šçš„ã€‚ è¿™äº›æ˜¯ä¸ºäº†åœ¨é—®é¢˜çš„å¤æ‚æ€§å’Œè‡ªç”±åº¦ä¹‹é—´å–å¾—å¹³è¡¡è€Œè®¾ç½®çš„ç»éªŒå‚æ•°ã€‚ ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(N_c)$ ï¼Œå› ä¸ºæ ¹æ® B æ ·æ¡çš„å±€éƒ¨æ”¯æŒå±æ€§ï¼Œä¸€ä¸ªæ§åˆ¶ç‚¹åªä¼šå½±å“é™„è¿‘çš„çº¿æ®µã€‚ L-BFGS çš„å¤æ‚æ€§åœ¨ç›¸åŒçš„ç›¸å¯¹å…¬å·®ä¸Šä¹Ÿæ˜¯çº¿æ€§çš„ã€‚ å¯¹äºæ— ç¢°æ’è·¯å¾„æœç´¢ï¼Œæˆ‘ä»¬é‡‡ç”¨ $A^*$ ç®—æ³•ï¼Œåœ¨è·¯å¾„ $\\mathbf{\\Gamma}$ æ€»æ˜¯è‡ªç„¶åœ°é è¿‘éšœç¢ç‰©è¡¨é¢çš„ä¼˜ç‚¹ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥åœ¨ $\\mathbf{\\Gamma}$ å¤„é€‰æ‹© $\\mathbf{p}$ ï¼Œè€Œæ— éœ€æœç´¢éšœç¢ç‰©è¡¨é¢ã€‚ å¯¹äºåœ¨ Fig.\\ref{pic:3d_p_v_pairs}ä¸­å®šä¹‰çš„å‘é‡ $\\mathbf{R}_i$ï¼Œå¯ä»¥é€šè¿‡å‡åŒ€ B æ ·æ¡å‚æ•°åŒ–çš„æ€§è´¨æ¨å¯¼å‡ºï¼Œ $\\mathbf{R}_i$æ»¡è¶³ Ri=Qi+1âˆ’Qiâˆ’12Î”t \\mathbf{R}_{i}=\\frac{\\mathbf{Q}_{i+1}-\\mathbf{Q}_{i-1}}{2 \\Delta t} Riâ€‹=2Î”tQi+1â€‹âˆ’Qiâˆ’1â€‹â€‹ å¯ä»¥é«˜æ•ˆåœ°è®¡ç®—ã€‚ å¼\\ref{equ:fitness}è¢«ç¦»æ•£åŒ–ä¸ºæœ‰é™æ•°é‡çš„ç‚¹ $\\mathbf{\\Phi}_f(k\\triangle t')$ å’Œ $\\mathbf{\\Phi}_s(k\\triangle t)$ï¼Œå…¶ä¸­$k \\in \\mathbb{N}, 0 \\leq k \\leq \\lfloor{T/\\triangle t}\\rfloor$ã€‚ ä¸ºäº†è¿›ä¸€æ­¥ä¿è¯å®‰å…¨ï¼Œåœ¨æœ€ç»ˆè½¨è¿¹å‘¨å›´æ‰§è¡Œäº†ä¸€ä¸ªåŠå¾„å›ºå®šçš„åœ†ç®¡çš„ç¢°æ’æ£€æŸ¥ï¼Œä»¥æä¾›è¶³å¤Ÿçš„éšœç¢ç‰©é—´éš™ã€‚ åªæœ‰å½“æ²¡æœ‰æ£€æµ‹åˆ°ç¢°æ’æ—¶ï¼Œä¼˜åŒ–å™¨æ‰åœæ­¢ã€‚ æˆ‘ä»¬åœ¨ä¸\\cite{gao2020teach}ç›¸åŒçš„é£è¡Œå¹³å°ä¸Šè¿›è¡Œäº†çœŸå®ä¸–ç•Œçš„å®éªŒï¼Œè¯¥å¹³å°ä½¿ç”¨ Intel RealSense D435 è·å–æ·±åº¦\\footnote{https://www.intelrealsense.com/depth-camera-d435/}ã€‚ æ­¤å¤–ï¼Œæˆ‘ä»¬ä¿®æ”¹äº† Intel RealSense çš„ ROS é©±åŠ¨ç¨‹åºï¼Œä½¿å…¶èƒ½å¤Ÿè®©æ¿€å…‰å‘å°„å™¨ä»¥æ¯éš”ä¸€å¸§çš„æ–¹å¼è§¦å‘ã€‚ è¿™æ ·å¯ä»¥åœ¨æ¿€å…‰å‘å°„å™¨çš„å¸®åŠ©ä¸‹è¾“å‡ºé«˜è´¨é‡çš„æ·±åº¦å›¾åƒï¼Œå¹¶ä¸”ä¸å—æ¿€å…‰å¹²æ‰°çš„åŒç›®å›¾åƒã€‚ ä¿®æ”¹åçš„é©±åŠ¨ç¨‹åºä¹Ÿå·²ç»å¼€æºã€‚ def ReboundPlanning(E, Q_last, G): \"\"\" This function implements the Rebound Planning algorithm. Args: - E: The environment - Q_last: The previous control point struct - G: The goal Returns: - Q: The optimized control point struct after rebound planning \"\"\" Q = FindInit(Q_last, G) while not IsCollisionFree(E, Q): CheckAndAddObstacleInfo(E, Q) J, gradient_G = EvaluatePenalty(Q) Q = OneStepOptimize(J, gradient_G) if not IsFeasible(Q): Q = ReAllocateTime(Q) Q = CurveFittingOptimize(Q) return Q B. Optimization Algorithms Comparison åœ¨æœ¬èŠ‚ä¸­æˆ‘ä»¬å°†è®¨è®ºä¸‰ç§ä¸åŒçš„ä¼˜åŒ–ç®—æ³•ï¼ŒåŒ…æ‹¬ Barzilai-Borweinï¼ˆBBï¼‰æ–¹æ³•ï¼Œæœ‰é™å­˜å‚¨ BFGSï¼ˆL-BFGSï¼‰å’Œæˆªæ–­ç‰›é¡¿ï¼ˆT-NEWTONï¼‰æ–¹æ³•ã€‚å…·ä½“æ¥è¯´ï¼Œæ¯ç§ç®—æ³•åœ¨éšæœºåœ°å›¾ä¸Šç‹¬ç«‹è¿è¡Œ 100 æ¬¡ã€‚æ‰€æœ‰ç›¸å…³çš„å‚æ•°ï¼ŒåŒ…æ‹¬è¾¹ç•Œçº¦æŸï¼Œæ—¶é—´åˆ†é…ï¼Œå†³ç­–å˜é‡åˆå§‹åŒ–å’Œéšæœºç§å­ï¼Œéƒ½è®¾ç½®ä¸ºä¸åŒç®—æ³•ä¹‹é—´ç›¸åŒã€‚è®°å½•äº†æˆåŠŸç‡ï¼Œè®¡ç®—æ—¶é—´å’Œç›®æ ‡å‡½æ•°è¯„ä¼°æ¬¡æ•°çš„æ•°æ®ã€‚ç”±äºå¤±è´¥æ¡ˆä¾‹ä¸­çš„æ•°æ®æ˜¯æ— æ„ä¹‰çš„ï¼Œåªæœ‰æˆåŠŸçš„æ¡ˆä¾‹è¢«è®¡æ•°ã€‚ç›¸å…³ç»“æœæ˜¾ç¤ºåœ¨è¡¨\\ref{tab:solver_comparison}ä¸­ï¼Œè¡¨æ˜ L-BFGS æ˜æ˜¾ä¼˜äºå¦å¤–ä¸¤ç§ç®—æ³•ã€‚L-BFGS ä½¿ç”¨äºŒé˜¶æ³°å‹’å±•å¼€çš„æ–¹å¼æ¥è¿‘ä¼¼æè¿°ç±»å‹çš„é€¼è¿‘ï¼Œé€‚ç”¨äºåœ¨ç¬¬\\ref{sec::problem_optimization}èŠ‚ä¸­æè¿°çš„ç›®æ ‡å‡½æ•°ä¼˜åŒ–ã€‚æˆªæ–­ç‰›é¡¿æ–¹æ³•ä¹Ÿå¯¹äºŒé˜¶ä¼˜åŒ–æ–¹å‘ $\\mathbf{H}^{-1} \\nabla \\mathbf{f}_k$è¿›è¡Œè¿‘ä¼¼ã€‚ç„¶è€Œï¼Œè¿‡å¤šçš„ç›®æ ‡å‡½æ•°è¯„ä¼°ä¼šå¢åŠ ä¼˜åŒ–æ—¶é—´ã€‚BB æ–¹æ³•é€šè¿‡æ ‡é‡ $\\lambda$ä¹˜ä»¥ $\\mathbf{I}$ æ¥ä¼°è®¡ Hessianã€‚ç„¶è€Œï¼Œå¯¹ Hessian çš„ä¸å……åˆ†ä¼°è®¡ä»ç„¶å¯¼è‡´æ”¶æ•›é€Ÿåº¦è¾ƒä½ã€‚ C. Trajectory Generation With & Without ESDF æˆ‘ä»¬ä½¿ç”¨ä¸ç¬¬\\ref{sec:solver_comp}èŠ‚ç›¸åŒçš„è®¾ç½®æ¥è¿›è¡Œæ¯”è¾ƒã€‚ è€ƒè™‘åˆ°ä½¿ç”¨åŸºäº ESDF çš„è½¨è¿¹ç”Ÿæˆå™¨çš„ç›´çº¿åˆå§‹åŒ–æ—¶åœ¨\\cite{boyu2019ral}ä¸­è§£é‡Šçš„æˆåŠŸç‡è¾ƒä½ï¼Œæˆ‘ä»¬é‡‡ç”¨äº†ä¸€ç§æ— ç¢°æ’çš„åˆå§‹åŒ–æ–¹æ³•ã€‚ æ¯”è¾ƒç»“æœè§è¡¨\\ref{tab:ESDF_comparison}ã€‚ ä¸ºäº†æ¸…æ¥šèµ·è§ï¼ŒåŸºäº ESDF ä¸”å¸¦æœ‰æ— ç¢°æ’åˆå§‹åŒ–çš„æ–¹æ³•ç®€ç§°ä¸º\\textit{EI}å’Œ\\textit{ENI}ã€‚ æ¯”è¾ƒç»“æœæ˜¾ç¤ºï¼Œæ‰€æå‡ºçš„ EGO ç®—æ³•åœ¨æˆåŠŸç‡ä¸Šä¸å¸¦æœ‰æ— ç¢°æ’åˆå§‹åŒ–çš„ ESDF æ–¹æ³•ç›¸å½“ã€‚ ç„¶è€Œï¼ŒEGO äº§ç”Ÿçš„è½¨è¿¹èƒ½é‡ï¼ˆåŠ é€Ÿåº¦ç§¯åˆ†ï¼‰ç¨å¾®æ›´é«˜ã€‚ è¿™æ˜¯å› ä¸º EGO çš„æ§åˆ¶ç‚¹ä¸­åŒ…å«å¤šä¸ªå¯¹ï¼Œç›¸æ¯” EIï¼Œå®ƒäº§ç”Ÿçš„è½¨è¿¹å˜å½¢åŠ›æ›´å¼ºï¼Œå¦‚ Sec.\\ref{sec::colli_fun}ä¸­æ‰€è¿°ã€‚ å¦ä¸€æ–¹é¢ï¼Œæ›´å¼ºçš„åŠ›åŠ é€Ÿäº†æ”¶æ•›è¿‡ç¨‹ï¼Œä»è€Œç¼©çŸ­äº†ä¼˜åŒ–æ—¶é—´ã€‚ ENI çš„æŸäº›ç»Ÿè®¡æ•°æ®ï¼ˆç°è‰²æ˜¾ç¤ºï¼‰å¯èƒ½ä¸å¤ªæœ‰è¯´æœåŠ›ï¼Œå› ä¸ºä¸ EI å’Œ EGO ç›¸æ¯”ï¼ŒENI æµ‹è¯•åªåœ¨å°‘æ•°æƒ…å†µä¸‹æˆåŠŸï¼Œè¿™äº›æƒ…å†µä¸‹ç”Ÿæˆçš„è½¨è¿¹åœ¨èƒ½é‡æˆæœ¬å’Œé€Ÿåº¦æ–¹é¢æ›´åŠ å¹³æ»‘ã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå°½ç®¡å°† ESDF æ›´æ–°å¤§å°å‡å°åˆ°$10 \\times 4 \\times 2~m^3$ï¼Œåˆ†è¾¨ç‡ä¸º$0.1m$ï¼Œé€‚ç”¨äº$9m$çš„è½¨è¿¹ï¼ŒESDF æ›´æ–°ä»ç„¶å æ®äº†å¤§éƒ¨åˆ†è®¡ç®—æ—¶é—´ã€‚ D. Multiple Planners Comparison æˆ‘ä»¬å°†æå‡ºçš„è§„åˆ’å™¨ä¸ä¸¤ç§æœ€å…ˆè¿›çš„æ–¹æ³•ï¼ŒFast-Planner\\cite{boyu2019ral}å’Œ EWOK\\cite{Usenko2017ewok}è¿›è¡Œæ¯”è¾ƒï¼Œå®ƒä»¬åˆ©ç”¨ ESDF æ¥è¯„ä¼°éšœç¢ç‰©çš„è·ç¦»å’Œæ¢¯åº¦ã€‚ æ¯ä¸ªè§„åˆ’å™¨ä»ç›¸åŒçš„èµ·ç‚¹åˆ°ç»ˆç‚¹è¿è¡Œåæ¬¡ï¼Œä½¿ç”¨ä¸åŒå¯†åº¦çš„éšœç¢ç‰©ã€‚ å¹³å‡æ€§èƒ½ç»Ÿè®¡æ•°æ®å’Œ ESDF è®¡ç®—æ—¶é—´å¦‚è¡¨\\ref{tab:plan_cmp2}å’Œå›¾\\ref{pic:plan_cmp}æ‰€ç¤ºã€‚ ä¸‰ç§æ–¹æ³•åœ¨ 0.5 éšœç¢ç‰©/$m^2$åœ°å›¾ä¸Šç”Ÿæˆçš„è½¨è¿¹å¦‚å›¾\\ref{pic:traj_cmp}æ‰€ç¤ºã€‚ æ ¹æ®è¡¨\\ref{tab:plan_cmp2}ï¼Œæˆ‘ä»¬å¾—å‡ºç»“è®ºï¼šä¸ Fast-Planner ç›¸æ¯”ï¼Œæ‰€æå‡ºçš„æ–¹æ³•åœ¨é£è¡Œæ—¶é—´å’Œè½¨è¿¹é•¿åº¦ä¸Šæ›´çŸ­ï¼Œä½†èƒ½é‡æˆæœ¬æ›´é«˜ã€‚ è¿™ä¸»è¦æ˜¯ç”±\\cite{boyu2019ral}ä¸­çš„å‰ç«¯åŠ¨åŠ›å­¦è·¯å¾„æœç´¢å¼•èµ·çš„ã€‚ åœ¨å¯†é›†ç¯å¢ƒä¸­ï¼ŒEWOK ä¼šå¯¼è‡´æ‰­æ›²çš„è½¨è¿¹ï¼Œå› ä¸ºç›®æ ‡å‡½æ•°åŒ…å«æŒ‡æ•°é¡¹ï¼Œå¯¼è‡´ä¼˜åŒ–è¿‡ç¨‹ä¸ç¨³å®šã€‚ æ­¤å¤–ï¼Œæˆ‘ä»¬å¾—å‡ºç»“è®ºï¼šæ‰€æå‡ºçš„æ–¹æ³•èŠ‚çœäº†å¤§é‡åœ¨ä¸æ›´æ–° ESDF æ—¶çš„è®¡ç®—æ—¶é—´ã€‚ E. Real-world Experiments æˆ‘ä»¬åœ¨æœ‰é™ç›¸æœºè§†é‡ä¸‹çš„æ‚ä¹±æœªçŸ¥ç¯å¢ƒä¸­è¿›è¡Œäº†å‡ é¡¹å®éªŒã€‚ å…¶ä¸­ä¸€ä¸ªå®éªŒæ˜¯æŒ‰ç…§é¢„å…ˆç»™å®šçš„èˆªç‚¹é£è¡Œã€‚ åœ¨è¿™ä¸ªå®éªŒä¸­ï¼Œæ— äººæœºä»ä¸€ä¸ªå°åŠå…¬å®¤èµ·é£ï¼Œé€šè¿‡é—¨ï¼Œç»•ç€ä¸€ä¸ªå¤§çš„æ‚ä¹±æˆ¿é—´é£è¡Œï¼Œç„¶åè¿”å›åŠå…¬å®¤ï¼Œå¦‚å›¾\\ref{pic:realworld_exp}a å’Œå›¾\\ref{pic:traj_indoor}æ‰€ç¤ºã€‚ å®¤å†…å®éªŒä¸­æœ€çª„çš„é€šé“å°äºä¸€ç±³ï¼Œå¦‚å›¾\\ref{pic:traj_gen}æ‰€ç¤ºã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œæ— äººæœºåœ¨è¿™æ ·ä¸€ä¸ªæ‚ä¹±çš„ç¯å¢ƒä¸­è¾¾åˆ°äº† 3.56 ç±³/ç§’çš„é€Ÿåº¦ã€‚ å¦ä¸€ä¸ªå®¤å†…å®éªŒæ˜¯åœ¨é£è¡Œè¿‡ç¨‹ä¸­éšæœºå’Œçªç„¶è¿½è¸ªç›®æ ‡ï¼Œå¦‚å›¾\\ref{pic:realworld_exp}c æ‰€ç¤ºã€‚ åœ¨è¿™ä¸ªæµ‹è¯•ä¸­ï¼Œæœ‰é™çš„è§†é‡å¸¦æ¥æ›´å¤§çš„æŒ‘æˆ˜ï¼Œå³åœ¨æ¥æ”¶åˆ°æ–°ç›®æ ‡æˆ–æ£€æµ‹åˆ°ç¢°æ’å¨èƒåå¿…é¡»ç«‹å³ç”Ÿæˆå¯è¡Œçš„è½¨è¿¹ã€‚ å› æ­¤ï¼Œè¿™ä¸ªå®éªŒéªŒè¯äº†æ‰€æå‡ºçš„è§„åˆ’å™¨åœ¨å¯è¡Œæ€§çš„å‰æä¸‹èƒ½å¤Ÿè¿›è¡Œæ¿€è¿›çš„é£è¡Œã€‚ åœ¨æˆ·å¤–å®éªŒä¸­ï¼Œæ— äººæœºç©¿è¿‡å¯†é›†çš„æ ‘æ—å’Œä½çŸ®çš„çŒæœ¨ä¸›ï¼Œå¦‚å›¾\\ref{pic:realworld_exp}b å’Œå›¾\\ref{pic:traj_outdoor}æ‰€ç¤ºã€‚ å°½ç®¡æ— äººæœºå‘¨å›´çš„é£æµå¯¼è‡´æ ‘æå’Œå¶å­æ‘‡æ‘†ï¼Œä½¿åœ°å›¾ä¸å¤ªå¯é ï¼Œä½†æ— äººæœºä»ç„¶èƒ½å¤Ÿè¾¾åˆ° 3 ç±³/ç§’ä»¥ä¸Šçš„é€Ÿåº¦ã€‚ å› æ­¤ï¼Œæ‰€æå‡ºçš„è§„åˆ’å™¨å¯ä»¥å¤„ç†å®éªŒå’Œç°åœºç¯å¢ƒã€‚ æ›´å¤šä¿¡æ¯è¯·å‚è€ƒè§†é¢‘\\footnote{https://youtu.be/UKoaGW7t7Dk}ã€‚ 7 ç»“è®º åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬ç ”ç©¶äº† ESDF åœ¨åŸºäºæ¢¯åº¦çš„è½¨è¿¹è§„åˆ’ä¸­çš„å¿…è¦æ€§ï¼Œå¹¶æå‡ºäº†ä¸€ç§ä¸éœ€è¦ ESDF çš„å±€éƒ¨è§„åˆ’å™¨ã€‚ å®ƒçš„æ€§èƒ½ä¸ä¸€äº›æœ€å…ˆè¿›çš„åŸºäº ESDF çš„è§„åˆ’å™¨ç›¸å½“ï¼Œä½†è®¡ç®—æ—¶é—´å‡å°‘äº†ä¸€ä¸ªæ•°é‡çº§ã€‚ åŸºå‡†æ¯”è¾ƒå’Œå®é™…å®éªŒéªŒè¯äº†å…¶é²æ£’æ€§å’Œé«˜æ•ˆæ€§ã€‚ æ‰€æå‡ºçš„æ–¹æ³•ä»ç„¶å­˜åœ¨ä¸€äº›ç¼ºé™·ï¼Œå…¶ä¸­åŒ…æ‹¬ $A^*$ æœç´¢å¼•å…¥çš„å±€éƒ¨æœ€å°å€¼å’Œç»Ÿä¸€æ—¶é—´é‡æ–°åˆ†é…å¼•å…¥çš„ä¿å®ˆè½¨è¿¹ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬å°†è‡´åŠ›äºè¿›è¡Œæ‹“æ‰‘è§„åˆ’ä»¥é¿å…å±€éƒ¨æœ€å°å€¼ï¼Œå¹¶é‡æ–°æ„å»ºé—®é¢˜ä»¥ç”Ÿæˆè¿‘ä¼¼æœ€ä¼˜è½¨è¿¹ã€‚ è¯¥è§„åˆ’å™¨é€‚ç”¨äºé™æ€ç¯å¢ƒï¼Œå¹¶ä¸”å¯ä»¥å¤„ç†ç¼“æ…¢ç§»åŠ¨çš„éšœç¢ç‰©ï¼ˆé€Ÿåº¦ä½äº 0.5m/sï¼‰è€Œæ— éœ€ä»»ä½•ä¿®æ”¹ã€‚ æˆ‘ä»¬å°†æ¥å°†ç ”ç©¶é€šè¿‡ç§»åŠ¨ç‰©ä½“æ£€æµ‹å’Œæ‹“æ‰‘è§„åˆ’æ¥åº”å¯¹åŠ¨æ€ç¯å¢ƒå¯¼èˆªçš„é—®é¢˜ã€‚ "},"Learn/LearnDrones/Planner/Gradient-Based-Motion-Planning.html":{"url":"Learn/LearnDrones/Planner/Gradient-Based-Motion-Planning.html","title":"Gradient-Based-Motion-Planning","keywords":"","body":"åŸºäºæ¢¯åº¦çš„è¿åŠ¨è§„åˆ’ CHOMP CHOMP: Gradient Optimization Techniques for Efficient Motion Planning 2009 IEEE International Conference on Robotics and Automation Covariant Hamiltonian Optimization for Motion Planning (CHOMP) è¿åŠ¨è§„åˆ’çš„åå˜å“ˆå¯†é¡¿ä¼˜åŒ– æ‘˜è¦ï¼š ç°æœ‰çš„é«˜ç»´è¿åŠ¨è§„åˆ’ç®—æ³•åœ¨æŸç§ç¨‹åº¦ä¸Šæ—¢è¿‡åº¦åˆä¸è¶³ã€‚åœ¨éšœç¢ç‰©ç¨€ç–åˆ†å¸ƒçš„é¢†åŸŸä¸­ï¼ŒåŸºäºé‡‡æ ·çš„è§„åˆ’å™¨ç”¨äºå¯¼èˆªâ€œç‹­çª„é€šé“â€çš„å¯å‘å¼æ–¹æ³•å¯èƒ½è¿‡äºå¤æ‚ï¼›æ­¤å¤–ï¼Œè¿˜éœ€è¦è¿›ä¸€æ­¥åå¤„ç†ï¼Œä»¥å»é™¤è¿™äº›è§„åˆ’å™¨ç”Ÿæˆè·¯å¾„ä¸­çš„é¢ ç°¸æˆ–å¤šä½™çš„åŠ¨ä½œã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»äº† CHOMPï¼Œä¸€ç§ä½¿ç”¨ åå˜æ¢¯åº¦æŠ€æœ¯ covariant gradient techniques æŒç»­ä¼˜åŒ–è·¯å¾„çš„æ–°æ–¹æ³•ï¼Œç”¨äºæé«˜é‡‡æ ·è½¨è¿¹çš„è´¨é‡ã€‚æˆ‘ä»¬çš„ä¼˜åŒ–æŠ€æœ¯æ—¢å¯ä»¥ä¼˜åŒ–é«˜é˜¶åŠ¨æ€æ€§ï¼Œåˆå¯ä»¥ç›¸å¯¹äºä»¥å‰çš„è·¯å¾„ä¼˜åŒ–ç­–ç•¥åœ¨æ›´å¹¿æ³›çš„è¾“å…¥è·¯å¾„ä¸Šæ”¶æ•›ã€‚ç‰¹åˆ«åœ°ï¼Œæˆ‘ä»¬æ”¾å®½äº†è¿™äº›ç­–ç•¥è¦æ±‚çš„è¾“å…¥è·¯å¾„ä¸Šçš„æ— ç¢°æ’å¯è¡Œæ€§å…ˆå†³æ¡ä»¶ã€‚å› æ­¤ï¼ŒCHOMP å¯ä»¥ç”¨ä½œè®¸å¤šå®é™…è§„åˆ’æŸ¥è¯¢ä¸­çš„ç‹¬ç«‹è¿åŠ¨è§„åˆ’å™¨ã€‚æˆ‘ä»¬æ¼”ç¤ºäº†æˆ‘ä»¬æè®®çš„æ–¹æ³•åœ¨ä¸€ä¸ª 6-DOF æœºå™¨è‡‚çš„æ“çºµè§„åˆ’ä»¥åŠåœ¨ä¸€ä¸ªè¡Œèµ°çš„å››è¶³æœºå™¨äººçš„è½¨è¿¹ç”Ÿæˆä¸­çš„æœ‰æ•ˆæ€§ã€‚ Left: the initial straight-line trajectory through configuration space. Middle: the final trajectory post optimization. Right: the 15 end point configurations used to create the 105 planning problems discussed in section III. CHOMP Algorithm Covariant gradient descent åå˜æ¢¯åº¦ä¸‹é™ Understanding the update rule ç†è§£æ›´æ–°è§„åˆ™ Obstacles and distance fields éšœç¢ç‰©å’Œè·ç¦»åœº Defining an obstacle potential å®šä¹‰æ½œåœ¨éšœç¢ Smooth projection for joint limits å…³èŠ‚é™åˆ¶çš„å¹³æ»‘æŠ•å½± CHOMP In this section, we present CHOMP, a new trajectory optimization procedure based on covariant gradient descent. An important theme throughout this exposition is the proper use of geometrical relations, particularly as they apply to inner products. This is a particularly important idea in differential geometry [8]. These considerations appear in three primary locations within our technique. First, we find that in order to encourage smoothness we must measure the size of an update to our hypothesis in terms of the amount of a particular dynamical quantity (such as total velocity or total acceleration) it adds to the trajectory. Second, measurements of obstacle costs should be taken in the workspace so as to correctly account for the geometrical relationship between the robot and the surrounding environment. And finally, the same geometrical considerations used to update a trajectory should be used when correcting any joint limit violations that may occur. Sections II-A, II-D, and II-E detail each of these points in turn. åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä»‹ç» CHOMPï¼Œä¸€ç§åŸºäºåå˜æ¢¯åº¦ä¸‹é™çš„æ–°è½¨è¿¹ä¼˜åŒ–ç¨‹åºã€‚æ•´ä¸ªé˜è¿°çš„ä¸€ä¸ªé‡è¦ä¸»é¢˜æ˜¯å‡ ä½•å…³ç³»çš„æ­£ç¡®ä½¿ç”¨ï¼Œç‰¹åˆ«æ˜¯å½“å®ƒä»¬åº”ç”¨äºå†…ç§¯æ—¶ã€‚è¿™æ˜¯å¾®åˆ†å‡ ä½•ä¸­ä¸€ä¸ªç‰¹åˆ«é‡è¦çš„æ€æƒ³ [8] ã€‚è¿™äº›è€ƒè™‘å› ç´ å‡ºç°åœ¨æˆ‘ä»¬æŠ€æœ¯ä¸­çš„ä¸‰ä¸ªä¸»è¦ä½ç½®ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬å‘ç°ï¼Œä¸ºäº†é¼“åŠ±å¹³æ»‘æ€§ï¼Œæˆ‘ä»¬å¿…é¡»æ ¹æ®æ·»åŠ åˆ°è½¨è¿¹ä¸­çš„ç‰¹å®šåŠ¨æ€é‡ï¼ˆä¾‹å¦‚æ€»é€Ÿåº¦æˆ–æ€»åŠ é€Ÿåº¦ï¼‰çš„é‡æ¥è¡¡é‡å‡è®¾æ›´æ–°çš„å¤§å°ã€‚ å…¶æ¬¡ï¼Œåº”åœ¨å·¥ä½œç©ºé—´ä¸­æµ‹é‡éšœç¢ç‰©æˆæœ¬ï¼Œä»¥ä¾¿æ­£ç¡®è€ƒè™‘æœºå™¨äººä¸å‘¨å›´ç¯å¢ƒä¹‹é—´çš„å‡ ä½•å…³ç³»ã€‚ æœ€åï¼Œåœ¨çº æ­£å¯èƒ½å‘ç”Ÿçš„ä»»ä½•å…³èŠ‚é™åˆ¶è¿è§„æ—¶ï¼Œåº”ä½¿ç”¨ä¸æ›´æ–°è½¨è¿¹ç›¸åŒçš„å‡ ä½•è€ƒè™‘å› ç´ ã€‚ Sections II-A, II-D, å’Œ II-E ä¾æ¬¡è¯¦ç»†è¯´æ˜æ¯ä¸€ç‚¹ã€‚ Covariant gradient descent åå˜æ¢¯åº¦ä¸‹é™ æˆ‘ä»¬ä½¿ç”¨ä¸¤é¡¹å¯¹è½¨è¿¹æˆæœ¬è¿›è¡Œå»ºæ¨¡ï¼šéšœç¢é¡¹ fobs ï¼Œè¡¡é‡é è¿‘éšœç¢ç‰©çš„æˆæœ¬ï¼›å’Œå‰ä¸€ä¸ªæœ¯è¯­ fprior ï¼Œå®ƒæµ‹é‡æœºå™¨äººçš„åŠ¨æ€é‡ï¼Œä¾‹å¦‚å¹³æ»‘åº¦å’ŒåŠ é€Ÿåº¦ã€‚æˆ‘ä»¬ä¸€èˆ¬å‡è®¾ fprior æ˜¯ç‹¬ç«‹äºç¯å¢ƒçš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„ç›®æ ‡å¯ä»¥å†™æˆ U(Î¾)=fprior(Î¾)+fobs(Î¾) U(\\xi) = f_{prior}(\\xi) + f_{obs}(\\xi) U(Î¾)=fpriorâ€‹(Î¾)+fobsâ€‹(Î¾) Stomp Stomp: Stochastic trajectory optimization for motion planning æ‘˜è¦ â€” æˆ‘ä»¬æå‡ºäº†ä¸€ç§ä½¿ç”¨ éšæœºè½¨è¿¹ä¼˜åŒ–æ¡†æ¶è¿›è¡Œè¿åŠ¨è§„åˆ’çš„æ–°æ–¹æ³•ã€‚æ­¤æ–¹æ³•ä¾èµ–äºç”Ÿæˆå™ªå£°è½¨è¿¹æ¥æ¢ç´¢åˆå§‹ï¼ˆå¯èƒ½ä¸å¯è¡Œï¼‰è½¨è¿¹å‘¨å›´çš„ç©ºé—´ï¼Œç„¶åç»“åˆå®ƒä»¬äº§ç”Ÿä¸€ä¸ªæˆæœ¬æ›´ä½çš„æ›´æ–°è½¨è¿¹ã€‚åœ¨æ¯æ¬¡è¿­ä»£ä¸­ï¼ŒåŸºäºéšœç¢å’Œå¹³æ»‘æ€§æˆæœ¬çš„ç»„åˆä¼˜åŒ–ä¸€ä¸ªæˆæœ¬å‡½æ•°ã€‚æˆ‘ä»¬ä½¿ç”¨çš„ç‰¹å®šä¼˜åŒ–ç®—æ³•ä¸éœ€è¦æ¢¯åº¦ä¿¡æ¯ï¼Œå› æ­¤å¯ä»¥åœ¨æˆæœ¬å‡½æ•°ä¸­åŒ…æ‹¬å¯èƒ½æ— æ³•è·å¾—å¯¼æ•°çš„ä¸€èˆ¬æˆæœ¬ï¼ˆä¾‹å¦‚ï¼Œå¯¹åº”äºçº¦æŸå’Œç”µæœºæ‰­çŸ©çš„æˆæœ¬ï¼‰ã€‚æˆ‘ä»¬åœ¨æ¨¡æ‹Ÿå’Œç§»åŠ¨æ“ä½œç³»ç»Ÿä¸Šå±•ç¤ºäº†è¿™ç§æ–¹æ³•ï¼Œç”¨äºæ— çº¦æŸå’Œå—çº¦æŸçš„ä»»åŠ¡ã€‚æˆ‘ä»¬å®éªŒæ€§åœ°æ˜¾ç¤ºï¼ŒSTOMP çš„éšæœºæ€§ä½¿å…¶èƒ½å¤Ÿå…‹æœ CHOMP è¿™æ ·çš„åŸºäºæ¢¯åº¦çš„æ–¹æ³•å¯èƒ½é™·å…¥çš„å±€éƒ¨æœ€å°å€¼ã€‚ Continuous-time trajectory optimization for online uav replanning Realtime trajectory replanning for mavs using uniform b-splines and a 3d circular buffer An efficient b-spline-based kinodynamic replanning framework for quadrotors Robust and efficient quadrotor trajectory generation for fast autonomous flight Raptor: Robust and perception aware trajectory replanning for quadrotor fast flight "},"Learn/LearnDrones/Planner/MicroFlyingRobots-2021.html":{"url":"Learn/LearnDrones/Planner/MicroFlyingRobots-2021.html","title":"MicroFlyingRobots-2021","keywords":"","body":"Swarm of micro flying robots in the wild Science Robotics Xin Zhou, Xiangyong Wen, Zhepei Wang, Yuman Gao, Haojia Li, Qianhao Wang, Tiankai Yang, Haojian Lu, Yanjun Cao, Chao Xu, Fei Gao æ•´ä½“ç»“è®º ä¼ ç»Ÿçš„ä¼˜åŒ–ç®—æ³•å¯¹é›†ç¾¤è§„åˆ’è€—æ—¶é•¿ï¼Œè™½ç„¶é€šè¿‡å°†å…¶åˆ†ç»„èƒ½ç®€åŒ–åˆ°æŸä¸ªç¨‹åº¦ï¼Œä½†ä»æœ‰é™ã€‚è€Œå»ä¸­å¿ƒåŒ–ã€å°†é—®é¢˜é€‚å½“è®¾å®šï¼Œè€—æ—¶æ˜¾è‘—ä¸‹é™ï¼Œä¸”è·Ÿæ— äººæœºæ•°é‡æˆæ­£æ¯”ã€‚ é‡‡ç”¨è®¾å®š é‡‡ç”¨é™æ€çš„æ …æ ¼åœ°å›¾ï¼Œå¹¶åœ¨å…¶ä¸Šå åŠ ç”±æ·±åº¦å›¾è¯†åˆ«çš„åŠ¨æ€ç‰©ä½“ã€‚ å®šä½æ ¹æ® è§†è§‰æƒ¯æ€§çš„é‡Œç¨‹è®¡ï¼ˆåŸºäºé™æ€ç¯å¢ƒçš„ç°åº¦å›¾ï¼‰å®ç°ï¼Œæ²¡æœ‰ GPSã€‚ æ— äººæœºçš„è¯†åˆ«ä¸ä¾é æ·±åº¦å­¦ä¹ ï¼Œè€Œæ˜¯æ·±åº¦å›¾çš„ pixel gatheringï¼ˆé‡‡ç”¨ boundingbox å¹¶æ®æ­¤è®¡ç®—æ— äººæœºä¹‹é—´çš„è·ç¦»ï¼‰ã€‚ åˆ†æˆä¸åŒåœºæ™¯å’Œä»»åŠ¡ï¼Œé‡‡ç”¨ä¸åŒçš„é€šè®¯æ–¹å¼ã€å‚æ•°é…ç½®ï¼Œè€Œä¸æ˜¯ä¸€å¥—æ–¹æ¡ˆé€šç”¨ã€‚ å…³é”®è§‚ç‚¹ é€šä¿¡æ–¹å¼ï¼š ä¸­å¿ƒåŒ–åœ¨å¯†é›†é˜µå‹è¡¨ç°å¾—æ›´å¥½ï¼Œéšç€æ•°é‡å¢åŠ å…¶å¤æ‚åº¦çº¿æ€§æé«˜ï¼› ç‚¹å¯¹ç‚¹é€šä¿¡åœ¨ç¨€ç–æ—¶æ•°é‡å¢åŠ å‡ ä¹ä¸å¢åŠ å¤æ‚åº¦ï¼ˆå› ä¸ºè¶…å‡ºä¸€å®šè·ç¦»å°±ä¸é€šè®¯ï¼‰ï¼Œä½†åœ¨å¯†é›†æ—¶å¤æ‚åº¦å°†æŒ‡æ•°æé«˜ã€‚ è½¨è¿¹å‚æ•°åŒ–ï¼ˆå®ç°éš¾åº¦ä¾åºæé«˜ï¼‰ï¼š åˆ†æ®µå¤šé¡¹å¼ï¼šéœ€è¦å¤§é‡çŸ©é˜µè¿ç®—è€Œå¯¹è®¡ç®—æœºè´Ÿæ‹…è¾ƒé‡ï¼›åˆ†æ®µçš„å…³é”®ç‚¹ä½ç½®çš„é€‰æ‹©å¯¹æ•ˆæœå’Œç®—åŠ›å½±å“å¾ˆå¤§ï¼›è¦åŠ å…¥è¿ç»­æ€§çº¦æŸã€‚ Bezier å’Œ B-Spline æ›²çº¿ï¼šconvex hull ç‰¹æ€§è®©å¢åŠ çº¦æŸå¾ˆæ–¹ä¾¿ï¼Œè€Œä¸”å¤©ç„¶å…·å¤‡è¿ç»­æ€§ï¼›ç¼ºç‚¹æ˜¯åå‘ä¿å®ˆï¼Œæ— æ³•å‘æŒ¥æé™æœºåŠ¨èƒ½åŠ›ã€‚ MINCOï¼ˆä¸€ç§å¤šé¡¹å¼è½¨è¿¹ç±»ï¼‰ï¼šé’ˆå¯¹é›†æˆé“¾è·¯ç³»ç»Ÿè®¾è®¡çš„æ–°æ–¹æ³•ï¼Œèƒ½æ¥å—å¤§é‡çº¦æŸæ¡ä»¶è®¾ç½®çš„åŒæ—¶ï¼Œä¿æŒæ—¶ç©ºæœ€ä¼˜æ€§èƒ½ï¼›ä½†å¿…é¡»å¯¹å…¶ç»“æœè¿›è¡Œå……åˆ†çš„å†æ£€æŸ¥ï¼Œè€Œä¸”å®ç°èµ·æ¥å¾ˆå¤æ‚ã€‚ é€šä¿¡å†…å®¹ï¼šæ ¹æ®æ‰§è¡Œçš„ä»»åŠ¡è€Œä¸åŒã€‚ä¾‹å¦‚\"é£è¶Šæ£®æ—\"ä»»åŠ¡ä¸­ï¼Œç›®çš„åœ°å·²ç»ä½œä¸ºå‚æ•°æå‰å†™å…¥æ¯ä¸ªæ— äººæœºä¹‹ä¸­ï¼Œå› æ­¤æ— äººæœºä¹‹é—´åªéœ€è¦äº¤æµ\"å®æ—¶çš„è½¨è¿¹\"ã€‚ é€šè®¯è·ç¦»å¿…é¡»å¤§äºä¸¤å€çš„è§„åˆ’è·ç¦»ï¼šå°äºè¿™ä¸ªè·ç¦»çš„æ— äººæœºå°†äº’ç›¸å½±å“ï¼Œå¤§äºè¿™ä¸ªè·ç¦»çš„åœ¨ç‰©ç†ä¸Šå°±ç•™æœ‰è¶³å¤Ÿçš„ååº”ç©ºé—´ã€‚ é‡‡ç”¨è§¦å‘è€Œéå‘¨æœŸå¼çš„é€šä¿¡ï¼Œåœ¨ 65m çš„ç«¹æ—ç©¿è¶Šä»»åŠ¡ä¸­ï¼Œ10 æ¶æ— äººæœºå¹³å‡å‘é€äº† 100 æ¡è½¨è¿¹ï¼Œæ¥å— 1000 æ¡è½¨è¿¹ã€‚ï¼ˆæ³¨ï¼šåº”è¯¥æ˜¯è½¨è¿¹å‘ç”Ÿé‡è§„åˆ’æ—¶æ‰å¯¹å¤–å‘é€ï¼Œä»¥å‡å°‘é€šè®¯é‡ã€‚å¯ä»¥çœ‹åˆ°éƒ¨åˆ†çš„æ— äººæœºå‘é€é‡æ¯”å…¶ä»–çš„é«˜ 50%ä»¥ä¸Šã€‚ï¼‰ æ‘˜è¦ï¼šç©ºä¸­æœºå™¨äººè¢«å¹¿æ³›éƒ¨ç½²ï¼Œä½†é«˜åº¦æ‚ä¹±çš„ç¯å¢ƒï¼Œå¦‚ èŒ‚å¯†çš„æ£®æ— ï¼Œæ— äººæœºä»ç„¶æ— æ³•è¿›å…¥ï¼Œå¯¹æˆç¾¤çš„æ— äººæœºæ¥è¯´æ›´æ˜¯å¦‚æ­¤ã€‚ åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œä»¥å‰æœªçŸ¥çš„ç¯å¢ƒå’Œç‹­çª„çš„èµ°å»Šä»¥åŠç¾¤ä½“åè°ƒçš„è¦æ±‚å¯èƒ½ä¼šå¸¦æ¥æŒ‘æˆ˜ã€‚ ä¸ºäº†åœ¨é‡å¤–å®ç°ç¾¤ä½“å¯¼èˆªï¼Œæˆ‘ä»¬å¼€å‘äº† å…·æœ‰è½¨è¿¹è§„åˆ’å™¨çš„å¾®å‹ä½†å®Œå…¨è‡ªä¸»çš„æ— äººæœºï¼Œè¯¥æ— äººæœºå¯ä»¥æ ¹æ®æ¥è‡ªæœºè½½ä¼ æ„Ÿå™¨çš„æœ‰é™ä¿¡æ¯åŠæ—¶å‡†ç¡®åœ°è¿è¡Œã€‚ è§„åˆ’é—®é¢˜æ»¡è¶³é£è¡Œæ•ˆç‡ã€é¿éšœã€æœºå™¨äººé—´é¿ç¢°ã€åŠ¨æ€å¯è¡Œæ€§ã€ç¾¤ä½“åè°ƒç­‰å¤šç§ä»»åŠ¡è¦æ±‚ï¼Œå®ç°äº†å¯æ‰©å±•çš„è§„åˆ’å™¨ã€‚ æ­¤å¤–ï¼Œæ‰€æå‡ºçš„è§„åˆ’å™¨åŸºäºæ—¶ç©ºè”åˆä¼˜åŒ–åŒæ­¥å˜å½¢è½¨è¿¹å½¢çŠ¶å¹¶è°ƒæ•´æ—¶é—´åˆ†é…ã€‚ å› æ­¤ï¼Œå³ä½¿åœ¨æœ€å—é™åˆ¶çš„ç¯å¢ƒä¸­ï¼Œä¹Ÿå¯ä»¥åœ¨å‡ æ¯«ç§’å†…å½»åº•åˆ©ç”¨è§£ç©ºé—´åè·å¾—é«˜è´¨é‡çš„è½¨è¿¹ã€‚ è§„åˆ’å™¨æœ€ç»ˆé›†æˆåˆ°å¼€å‘çš„æ‰‹æŒå¤§å°çš„ç¾¤å¹³å°ä¸­ï¼Œå…·æœ‰æ¿è½½æ„ŸçŸ¥ã€å®šä½å’Œæ§åˆ¶åŠŸèƒ½ã€‚ åŸºå‡†æ¯”è¾ƒéªŒè¯äº†è§„åˆ’å™¨åœ¨è½¨è¿¹è´¨é‡å’Œè®¡ç®—æ—¶é—´æ–¹é¢çš„å“è¶Šæ€§èƒ½ã€‚ å„ç§çœŸå®ä¸–ç•Œçš„ç°åœºå®éªŒè¯æ˜äº†æˆ‘ä»¬ç³»ç»Ÿçš„å¯æ‰©å±•æ€§ã€‚ æˆ‘ä»¬çš„æ–¹æ³•åœ¨ä¸‰ä¸ªæ–¹é¢å‘å±•äº†ç©ºä¸­æœºå™¨äººæŠ€æœ¯ï¼šæ‚ä¹±ç¯å¢ƒå¯¼èˆªçš„èƒ½åŠ›ã€å¯¹ä¸åŒä»»åŠ¡è¦æ±‚çš„å¯æ‰©å±•æ€§ä»¥åŠåœ¨æ²¡æœ‰å¤–éƒ¨è®¾æ–½çš„æƒ…å†µä¸‹ä½œä¸ºç¾¤çš„åè°ƒã€‚ "},"Learn/LearnDrones/Planner/Distributed-Swarm-Trajectory-Opt-for-Formation-Flight-in-Dense-Envs-2022.html":{"url":"Learn/LearnDrones/Planner/Distributed-Swarm-Trajectory-Opt-for-Formation-Flight-in-Dense-Envs-2022.html","title":"Distributed-Swarm-Trajectory-Opt-for-Formation-Flight-in-Dense-Envs-2022","keywords":"","body":"åœ¨ç¨ å¯†ç¯å¢ƒä¸­çš„åˆ†å¸ƒå¼é›†ç¾¤è·¯å¾„è§„åˆ’ä¼˜åŒ–-2022 Distributed swarm trajectory optimization for formation flight in dense environments é’ˆå¯¹ç©ºä¸­ç¼–é˜Ÿï¼Œé¢„å®šå½¢å¼å¯¼èˆªåœ¨å„ç§åœºæ™¯ä¸­è¢«å¹¿æ³›åº”ç”¨ã€‚ç„¶è€Œï¼Œç›¸å…³çš„è§„åˆ’ç­–ç•¥é€šå¸¸ç¼ºä¹åœ¨ç¹æ‚ç¯å¢ƒä¸­é¿å…éšœç¢ç‰©çš„èƒ½åŠ›ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§åŸºäºä¼˜åŒ–çš„æ–¹æ³•ï¼Œç¡®ä¿ç¼–é˜Ÿé£è¡Œçš„è½¨è¿¹ç”Ÿæˆä¸ä¼šå‘ç”Ÿç¢°æ’ã€‚æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§æ–°é¢–çš„ å¯å¾®åº¦é‡æ¥è¡¡é‡ç¼–é˜Ÿä¹‹é—´çš„ æ•´ä½“ç›¸ä¼¼è·ç¦»ã€‚ç„¶åï¼Œæˆ‘ä»¬å°†è¿™ä¸ªåº¦é‡è½¬åŒ–ä¸ºä¸€ä¸ªä¼˜åŒ–æ¡†æ¶ï¼Œé€šè¿‡å¤šé¡¹å¼è½¨è¿¹æ¥å®ç° ç©ºé—´-æ—¶é—´è§„åˆ’ã€‚åœ¨è¯¥æ¡†æ¶ä¸­è¿˜åŠ å…¥äº†é¿å…ç¢°æ’çš„æœ€å°åŒ–æƒ©ç½šï¼Œä»¥ä¾¿åŒæ—¶å¤„ç†ç¼–é˜Ÿä¿æŒå’Œéšœç¢ç‰©é¿è®©ã€‚ä¸ºäº†éªŒè¯æˆ‘ä»¬æ–¹æ³•çš„æ•ˆç‡ï¼Œæˆ‘ä»¬ä¸å…¶ä»–å‰æ²¿ä½œå“è¿›è¡Œäº†åŸºå‡†æ¯”è¾ƒã€‚ç»“åˆè‡ªä¸»åˆ†å¸ƒå¼ç©ºä¸­ç¼–é˜Ÿç³»ç»Ÿï¼Œæˆ‘ä»¬æå‡ºçš„æ–¹æ³•åœ¨å¯Œæœ‰éšœç¢ç‰©çš„å®é™…ç¯å¢ƒå®éªŒä¸­å±•ç¤ºäº†å…¶é«˜æ•ˆæ€§å’Œç¨³å¥æ€§ã€‚æˆ‘ä»¬å°†å‘å¸ƒæºä»£ç ä¾›ç¤¾åŒºå‚è€ƒã€‚ "},"Learn/LearnDrones/Planner/Robust-Efficient-Trajectory-Planning-for-Formation-Flight-in-Dense-Environments-2023.html":{"url":"Learn/LearnDrones/Planner/Robust-Efficient-Trajectory-Planning-for-Formation-Flight-in-Dense-Environments-2023.html","title":"Robust-Efficient-Trajectory-Planning-for-Formation-Flight-in-Dense-Environments-2023","keywords":"","body":"å¯†é›†ç¯å¢ƒä¸‹ç¼–é˜Ÿé£è¡Œçš„ç¨³å¥é«˜æ•ˆçš„è½¨è¿¹è§„åˆ’-2023 Robust and Efficient Trajectory Planning for Formation Flight in Dense Environments IEEE Transactions on Robotics https://arxiv.org/abs/2210.04048 ç¼–é˜Ÿé£è¡Œåœ¨ç©ºä¸­æœºå™¨äººç¾¤çš„å„ç§åº”ç”¨ä¸­å…·æœ‰å·¨å¤§æ½œåŠ›ã€‚ç„¶è€Œï¼Œç°æœ‰æ–¹æ³•ç¼ºä¹åœ¨å¯†é›†ç¯å¢ƒä¸­å®ç°å®Œå…¨è‡ªä¸»çš„å¤§è§„æ¨¡ç¼–é˜Ÿé£è¡Œçš„èƒ½åŠ›ã€‚ä¸ºäº†å¼¥è¡¥è¿™ä¸€å·®è·ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ä¸ªå®Œæ•´çš„ç¼–é˜Ÿé£è¡Œç³»ç»Ÿï¼Œè¯¥ç³»ç»Ÿèƒ½æœ‰æ•ˆåœ°å°†ç°å®ä¸–ç•Œçš„çº¦æŸæ¡ä»¶æ•´åˆåˆ°ç©ºä¸­ç¼–é˜Ÿå¯¼èˆªä¸­ã€‚æœ¬æ–‡æå‡ºäº†ä¸€ç§ å¯å¾®åˆ†çš„åŸºäºå›¾çš„åº¦é‡æ–¹æ³• (differentiable graph-based metric)ï¼Œç”¨äºé‡åŒ–ç¼–é˜Ÿä¹‹é—´çš„ æ•´ä½“ç›¸ä¼¼åº¦è¯¯å·® ã€‚è¯¥æŒ‡æ ‡ä¸å—æ—‹è½¬ã€å¹³ç§»å’Œç¼©æ”¾çš„å½±å“ï¼Œä¸ºç¼–é˜Ÿåè°ƒæä¾›äº†æ›´å¤§çš„è‡ªç”±åº¦ã€‚ æˆ‘ä»¬è®¾è®¡äº†ä¸€ä¸ª åˆ†å¸ƒå¼è½¨è¿¹ä¼˜åŒ–æ¡†æ¶ï¼Œè¯¥æ¡†æ¶è€ƒè™‘äº†ç¼–é˜Ÿç›¸ä¼¼æ€§ã€é¿éšœå’ŒåŠ¨æ€å¯è¡Œæ€§ã€‚é€šè¿‡å°†ä¼˜åŒ–è¿‡ç¨‹è§£è€¦ï¼Œä½¿å¤§è§„æ¨¡ç¼–é˜Ÿé£è¡Œåœ¨è®¡ç®—ä¸Šå¯è¡Œã€‚ ä¸ºäº†æé«˜ç¼–é˜Ÿåœ¨é«˜åº¦å—é™åœºæ™¯ä¸­çš„å¯¼èˆªå¼¹æ€§ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§ èœ‚ç¾¤é‡ç»„æ–¹æ³•ï¼Œ é€šè¿‡ç”Ÿæˆå±€éƒ¨å¯¼èˆªç›®æ ‡ï¼Œè‡ªé€‚åº”åœ°è°ƒæ•´ç¼–é˜Ÿå‚æ•°å’Œä»»åŠ¡åˆ†é… ã€‚æœ¬ç ”ç©¶æå‡ºäº†ä¸€ç§åä¸º \"å…¨å±€é‡æ˜ å°„-å±€éƒ¨é‡è§„åˆ’ \"ï¼ˆglobal-remap-local-replanï¼‰çš„ æ–°å‹èœ‚ç¾¤åè®®ç­–ç•¥ï¼Œå¹¶æå‡ºäº†ä¸€ä¸ª ç¼–é˜Ÿçº§è·¯å¾„è§„åˆ’å™¨ï¼Œä»¥åè°ƒå…¨å±€è§„åˆ’å’Œå±€éƒ¨è½¨è¿¹ä¼˜åŒ–ã€‚ ä¸ºäº†éªŒè¯æ‰€æå‡ºçš„æ–¹æ³•ï¼Œæˆ‘ä»¬ä»é€‚åº”æ€§ã€å¯é¢„æµ‹æ€§ã€å¼¹æ€§ã€å¤åŸåŠ›å’Œæ•ˆç‡ç­‰æ–¹é¢è®¾è®¡äº†ç»¼åˆåŸºå‡†ï¼Œå¹¶ä¸å…¶ä»–å‰æ²¿å·¥ä½œè¿›è¡Œäº†æ¨¡æ‹Ÿã€‚æœ€åï¼Œé€šè¿‡ä¸å¸¦æœ‰æœºè½½è®¡ç®—æœºå’Œä¼ æ„Ÿå™¨çš„æ‰‹æŒå¤§å°çš„èœ‚ç¾¤å¹³å°é›†æˆï¼Œæˆ‘ä»¬æå‡ºçš„æ–¹æ³•åœ¨å¯†é›†çš„å®¤å¤–ç¯å¢ƒä¸­å®ç°äº†æœ€å¤§è§„æ¨¡çš„ç¼–é˜Ÿé£è¡Œï¼Œè¯æ˜äº†å®ƒçš„é«˜æ•ˆæ€§å’Œé²æ£’æ€§ã€‚ ç©ºä¸­ç¾¤èšã€ç¼–é˜Ÿé£è¡Œã€é¿éšœã€è¿åŠ¨è§„åˆ’ã€åˆ†å¸ƒå¼è½¨è¿¹ä¼˜åŒ–ã€‚ å°½ç®¡å¤§é‡çš„ç ”ç©¶å·¥ä½œé›†ä¸­åœ¨ç¼–é˜Ÿé£è¡Œå¯¼èˆªä¸Šï¼Œä½†åœ¨å……æ»¡éšœç¢ç‰©çš„åŒºåŸŸä¸­å®ç°ç¨³å¥çš„ç¼–é˜Ÿé£è¡Œçš„ç ”ç©¶è¿˜å¾ˆå°‘ã€‚å®é™…åº”ç”¨ä¸­å­˜åœ¨ä¸‰ä¸ªæ ¸å¿ƒæŒ‘æˆ˜ï¼š ï¼ˆaï¼‰ç¼–é˜Ÿç»´æŒä¸éšœç¢ç‰©é¿å…ä¹‹é—´çš„å›ºæœ‰å†²çªæ˜¯ä¸å¯é¿å…ä¸”éš¾ä»¥ç¼“è§£çš„ã€‚ ï¼ˆbï¼‰é¢„å®šä¹‰ç¼–é˜Ÿåœ¨å—é™ç¯å¢ƒä¸­ç¼ºä¹å¼¹æ€§é€‚åº”èƒ½åŠ›ã€‚ ï¼ˆcï¼‰ç”±äºæœªçŸ¥éšœç¢ç‰©æˆ–æœŸæœ›ç¼–é˜Ÿå½¢çŠ¶çš„çªç„¶å˜åŒ–è€Œå¯¼è‡´çš„æ— åºçŠ¶æ€ï¼Œç¾¤ä½“ç³»ç»Ÿéš¾ä»¥è¿…é€Ÿæ¢å¤ã€‚ åŸºäºä¸Šè¿°æŒ‘æˆ˜ï¼Œæˆ‘ä»¬å¾—å‡ºç»“è®ºï¼Œç†æƒ³çš„ç¼–é˜Ÿé£è¡Œç³»ç»Ÿåº”å…·å¤‡åœ¨é¿å…éšœç¢ç‰©çš„åŒæ—¶ç»´æŒç¼–é˜Ÿçš„èƒ½åŠ›ï¼Œæ ¹æ®å—é™ç¯å¢ƒè°ƒæ•´ç¾¤ä½“ç¼–é˜Ÿåˆ†å¸ƒï¼Œå¹¶åœ¨ç´§æ€¥æƒ…å†µä¸‹å¿«é€Ÿé‡ç»„ç¼–é˜Ÿçš„èƒ½åŠ›ã€‚ è¿™äº›ç‰¹å¾è¢«æ¦‚æ‹¬ä¸º PAPER å‡†åˆ™ï¼š Portability ç§»åŠ¨æ€§ ï¼šç©ºä¸­æœºå™¨äººé›†ç¾¤åº”ç”±è½»å‹å¹³å°ã€å¯æ‰©å±•ç³»ç»Ÿå’Œåˆ†å¸ƒå¼æ¶æ„ç»„æˆã€‚ å¯æ‰©å±•ç³»ç»Ÿæ„å‘³ç€ä¸»è¦ç»„ä»¶ï¼ˆå¦‚ä¼°è®¡ã€å†³ç­–ã€è§„åˆ’å’Œæ§åˆ¶æ¨¡å—ï¼‰åœ¨æ¯ä¸ªæœºå™¨äººä¸Šéƒ½æ˜¯ç›¸åŒçš„ã€‚ åˆ†å¸ƒå¼æ¶æ„èƒ½å¤Ÿå¤©ç„¶åœ°æŠµå¾¡ä¸ªä½“ç¡¬ä»¶æ•…éšœã€‚ è¿™æ˜¯å®ç°å¤§è§„æ¨¡ç¼–é˜Ÿé£è¡Œçš„åŸºç¡€ã€‚ Adaptability é€‚åº”æ€§ï¼šå½“é¢ä¸´éšœç¢æ—¶ï¼Œæœºå™¨äººåº”å½“åœ¨å±€éƒ¨é€‚åº”å…¶è½¨è¿¹ï¼Œä»¥é¿å…ç¢°æ’ï¼Œå¹¶å°½é‡å‡å°‘å¯¹æ•´ä½“ç¼–é˜Ÿæ€§èƒ½çš„å½±å“ã€‚è¿™ç§èƒ½åŠ›å¯ä»¥ç¼“è§£ç¼–é˜Ÿç»´æŒå’Œéšœç¢ç‰©é¿è®©ä¹‹é—´çš„å†²çªã€‚ Predictability å¯é¢„æµ‹æ€§ï¼šååº”å¼çš„å±€éƒ¨åé¦ˆæ–¹æ³•çš„è§†é‡çŸ­æµ…ï¼Œæ— æ³•æå‰è€ƒè™‘åˆ°çº¦æŸæ¡ä»¶ã€‚æœºå™¨äººåº”è¯¥åœ¨é¢„æµ‹çš„æ—¶é—´èŒƒå›´å†…ä¼˜åŒ–è¿åŠ¨ï¼Œä½¿å¾—å½¢æˆèƒ½å¤Ÿå¯¹å…¶å‘¨å›´æœªæ¥ç¯å¢ƒçš„å˜åŒ–åšå‡ºå¹³ç¨³å“åº”ï¼Œè¿™å¯¹äºå¯†é›†åŒºåŸŸæ˜¯å¿…è¦çš„ã€‚ Elasticity å¼¹æ€§ï¼šåœ¨å—é™ç¯å¢ƒä¸­ï¼Œå¦‚ç‹­çª„çš„èµ°å»Šæˆ–æ´ç©´ä¸­ï¼Œå¯èƒ½ä¸å­˜åœ¨é€‚ç”¨äºå›ºå®šç¼–é˜Ÿå½¢çŠ¶çš„å¯è¡Œä¸”å®‰å…¨çš„è·¯å¾„ã€‚å› æ­¤ï¼Œç¾¤ä½“æœºå™¨äººéœ€è¦é€šè¿‡è°ƒæ•´ç¼–é˜Ÿåˆ†å¸ƒï¼ˆå¦‚å½¢çŠ¶çš„è§„æ¨¡æˆ–ä»»åŠ¡åˆ†é…ï¼‰æ¥å…·å¤‡å¼¹æ€§å’Œçµæ´»çš„å˜å½¢èƒ½åŠ›ï¼ŒåŒæ—¶ä¿æŒç¼–é˜Ÿçš„å®Œå…¨æ“çºµæ€§ã€‚ Resilience å¯æ¢å¤æ€§ï¼šç¼–é˜Ÿé£è¡Œå¯èƒ½ä¼šé‡åˆ°ç”±æœªçŸ¥éšœç¢ç‰©æˆ–è€…æœŸæœ›ç¼–é˜Ÿå½¢çŠ¶çš„çªç„¶æ”¹å˜å¼•å‘çš„ä¸åˆ©æƒ…å†µã€‚å¯¼èˆªç³»ç»Ÿåº”å…·å¤‡å¼¹æ€§é‡æ–°ç»„ç»‡å’Œå¼•å¯¼æ•´ä¸ªç¼–é˜Ÿçš„èƒ½åŠ›ï¼Œä»¥ä½¿é£è¡Œèƒ½å¤ŸåŠæ—¶ä»æ— åºçŠ¶æ€ä¸­æ¢å¤ã€‚ ä¸€ä¸ªå®Œæ•´çš„ç¼–é˜Ÿé£è¡Œç³»ç»Ÿåº”æ»¡è¶³ä¸Šè¿° PAPER æ ‡å‡†ï¼Œå¹¶ç¡®ä¿æ¯ä¸ªæ ‡å‡†çš„æ¡ä»¶ä¸å…¶ä»–æ¡ä»¶ç›¸å®¹ã€‚ æˆ‘ä»¬ä¹‹å‰çš„å·¥ä½œ\\cite{quan2022formation}åªéƒ¨åˆ†æ»¡è¶³äº†\\textit{PAPER}æ ‡å‡†çš„å‰ä¸‰ä¸ªæ¡æ¬¾ã€‚ æˆ‘ä»¬å°†ç¼–é˜Ÿé£è¡Œé—®é¢˜ä½œä¸ºä¸€ç§ è€¦åˆçš„ååŒè½¨è¿¹ä¼˜åŒ–é—®é¢˜æ¥è§£å†³ï¼Œä¸»è¦é€‚ç”¨äºå°è§„æ¨¡ç¼–é˜Ÿåœºæ™¯ã€‚ ç„¶è€Œï¼Œä½¿ç”¨åŸºäºå›¾çš„ç›¸ä¼¼åº¦åº¦é‡è§£å†³ç¼–é˜Ÿçš„åä½œçº¦æŸè®¡ç®—é‡è¾ƒå¤§ï¼Œå¯¼è‡´æ¯æ¬¡ä¼˜åŒ–è¿­ä»£è¿‡ç¨‹ä¸­çš„å¼€é”€å¢åŠ ã€‚ æ­¤å¤–ï¼Œå°†åŠ¨æ€çš„æœºå™¨äººé—´å…³ç³»é›†æˆåˆ°è€¦åˆè½¨è¿¹ä¼˜åŒ–é—®é¢˜ä¸­ä¼šæ˜¾è‘—å½±å“ä¼˜åŒ–è¿‡ç¨‹çš„æ•ˆç‡ï¼Œä½¿å…¶åœ¨æ›´å¤§è§„æ¨¡çš„ç¼–é˜Ÿæˆ–æ›´å¤æ‚çš„åœºæ™¯ä¸­ä¸å¤ªé€‚ç”¨ã€‚ åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ä¸ªå®Œæ•´çš„ç¼–é˜Ÿé£è¡Œç³»ç»Ÿï¼Œæ»¡è¶³æ‰€æœ‰\\textit{PAPER}æ ‡å‡†ã€‚ ä¸ºè§£å†³[4]ä¸­çš„æŒ‘æˆ˜ï¼Œæˆ‘ä»¬å¼•å…¥äº†ä¸€ç§ è§£è€¦çš„ç¼–é˜Ÿä¼˜åŒ–æ–¹æ³• ï¼Œä»¥æ˜¾è‘—æé«˜è®¡ç®—æ•ˆç‡ã€‚ è¯¥æ–¹æ³•åŒ…æ‹¬ä¸¤ä¸ªç»„æˆéƒ¨åˆ†ã€‚ é¦–å…ˆï¼Œé¢„å…ˆè®¡ç®— æœ€ä¼˜ç¼–é˜Ÿä½ç½®åºåˆ— ï¼Œé¿å…äº†ä¼˜åŒ–è¿‡ç¨‹ä¸­é‡å¤çš„åº¦é‡è®¡ç®—ã€‚ å…¶æ¬¡ï¼Œé‡‡ç”¨å›ºå®šæ—¶é—´é—´éš”é‡‡æ ·æ–¹æ³•å°†åŠ¨æ€çš„æœºå™¨äººé—´å…³ç³»è½¬åŒ–ä¸º é™æ€çº¦æŸï¼Œæå¤§åœ°é™ä½äº†ä¼˜åŒ–é—®é¢˜çš„å¤æ‚æ€§ã€‚ è¿™äº›æ”¹è¿›ä½¿å¾—æˆ‘ä»¬çš„æ–¹æ³•é€‚ç”¨äºå¤§è§„æ¨¡çš„ç¾¤ä½“ã€‚ æ­¤å¤–ï¼Œä¹‹å‰çš„æ–¹æ³•ç¼ºä¹é‡æ–°ç»„ç»‡ç¾¤ä½“ç¼–é˜Ÿçš„èƒ½åŠ›ï¼Œåœ¨æ¶åŠ£æ¡ä»¶ä¸‹ï¼Œç‰¹åˆ«æ˜¯å½“åˆå§‹ä½ç½®æˆ–ä»»åŠ¡åˆ†é…ä¸å½“æ—¶ï¼Œå¯èƒ½å¯¼è‡´ç¼–é˜Ÿé£è¡Œæ— åºã€‚ ä¸ºè§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§ ç¾¤ä½“é‡æ–°ç»„ç»‡æ–¹æ³•ï¼Œå¯ä»¥é€šè¿‡ä¼˜åŒ–ç¼–é˜Ÿå‚æ•°å’Œä»»åŠ¡åˆ†é…æ¥å¼¹æ€§åœ°è°ƒæ•´ç¼–é˜Ÿåˆ†å¸ƒï¼Œä»¥å“åº”å¤–éƒ¨çº¦æŸã€‚ éšåï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§ ç¾¤ä½“ä¸€è‡´æ€§ç­–ç•¥ï¼Œç§°ä¸º å…¨å±€é‡æ˜ å°„-å±€éƒ¨é‡æ–°è§„åˆ’ï¼Œè¯¥ç­–ç•¥å¯ä½¿ç¾¤ä½“é‡æ–°ç»„ç»‡çš„ç»“æœå¾—åˆ°å¿«é€Ÿå®æ–½ï¼Œä»è€Œåœ¨ç¾¤ä½“æ™ºèƒ½ä½“ä¹‹é—´å®ç°å…±è¯†ã€‚ æ­¤å¤–ï¼Œè¿˜è®¾è®¡äº†ä¸€ç§ä»¥ç¼–é˜Ÿä¸ºæ•´ä½“çš„ å…¨å±€è·¯å¾„è§„åˆ’æ–¹æ³•ï¼Œç”¨äºå¼•å¯¼ç¾¤ä½“èµ°å‡ºéšœç¢ç‰©çš„æ­»é”ã€‚ æœ€åï¼Œæˆ‘ä»¬å°†ä¼°è®¡ã€å»ºå›¾ã€å†³ç­–ã€è§„åˆ’å’Œæ§åˆ¶æ¨¡å—æ•´åˆåˆ°äº†å¸¦æœ‰æœºè½½è®¡ç®—æœºå’Œä¼ æ„Ÿå™¨çš„æ‰‹æŒå¤§å°ç¼–é˜Ÿå¹³å°ä¸­ Micro Flying Robots-21ï¼Œå®ç°äº†åœ¨å¯†é›†ç¯å¢ƒä¸­çš„å¤§è§„æ¨¡ç¼–é˜Ÿé£è¡Œã€‚ å…·ä½“è´¡çŒ®å¦‚ä¸‹ã€‚ æˆ‘ä»¬å¼•å…¥äº†ä¸€ç§ æœ€ä¼˜ å½¢æˆä½ç½®åºåˆ— ï¼ˆformation position sequenceï¼‰ï¼Œè¯¥åºåˆ—æ˜¯ä½¿ç”¨å¯å¾®çš„åŸºäºå›¾çš„åº¦é‡æ–¹æ³•é¢„å…ˆè®¡ç®—å¾—å‡ºçš„~\\cite{quan2022formation}ã€‚è¿™ä¸ªåºåˆ—ä»£è¡¨äº†å…·æœ‰æœ€ä½ç›¸ä¼¼åº¦è¯¯å·®çš„æœ€ä¼˜ä½ç½®ï¼Œå‡å°‘äº†ä¼˜åŒ–è¿‡ç¨‹ä¸­é‡å¤è®¡ç®—çš„éœ€æ±‚ã€‚ æˆ‘ä»¬è®¾è®¡äº†ä¸€ä¸ª è§£è€¦çš„ç©ºé—´-æ—¶é—´è½¨è¿¹ä¼˜åŒ–æ¡†æ¶ï¼Œæœ‰æ•ˆå¤„ç†åŠ¨æ€çš„æœºå™¨äººä¹‹é—´çš„å…³ç³»ã€é¿éšœå’ŒåŠ¨æ€å¯è¡Œæ€§ã€‚ ä¸æˆ‘ä»¬ä¹‹å‰çš„ç ”ç©¶æˆæœ~\\cite{quan2022formation}ç›¸æ¯”ï¼Œæˆ‘ä»¬åœ¨å¤§è§„æ¨¡ç¾¤ä½“ä¸­å®ç°äº†æ›´é«˜çš„è®¡ç®—æ•ˆç‡ã€‚ æˆ‘ä»¬æå‡ºäº†ä¸€ç§ç¾¤é›†é‡æ–°ç»„ç»‡æ–¹æ³•ï¼Œå®ç°ç¾¤é›†åˆ†å¸ƒçš„å¼¹æ€§å˜å½¢ï¼ŒåŒæ—¶è§£å†³æœ€ä½³å½¢æ€å¯¹é½å’Œä»»åŠ¡åˆ†é…é—®é¢˜ï¼ˆç®€ç§° ALASï¼‰ã€‚è¯¥æ–¹æ³•æé«˜äº†ç¾¤é›†å½¢æˆå¯¹å—é™ç¯å¢ƒçš„å¼¹æ€§ã€‚å®ƒå‡è½»äº†å¯¹é€‚å½“çš„å½¢æ€å¯¹é½å’Œä»»åŠ¡åˆ†é…çš„ä¾èµ–ã€‚ "},"Learn/LearnDrones/TaskAssignment/":{"url":"Learn/LearnDrones/TaskAssignment/","title":"index","keywords":"","body":"Task Assignment survey 2018.10: Should We Compete or Should We Cooperate? Applying Game Theory to Task Allocation in Drone Swarms æœºå™¨äººåº”è¯¥åˆä½œä»¥å®Œæˆå°½å¯èƒ½å¤šçš„ä»»åŠ¡ IROS 2019: A Mission Planning and Task Allocation Framework For Multi-UAV Swarm Coordination 2020.08: Energy Efficient Task Cooperation for Multi-UAV Networks: A Coalition Formation Game Approach å¤šæ— äººæœºç½‘ç»œçš„èŠ‚èƒ½ä»»åŠ¡åˆä½œï¼šè”ç›Ÿå½¢æˆåšå¼ˆæ–¹æ³• IEEE Access College of Communications Engineering, Army of PLA, Nanjing, NUDT 2022.06: Task assignment algorithms for unmanned aerial vehicle networks: A comprehensive survey æ— äººæœºç½‘ç»œçš„ä»»åŠ¡åˆ†é…ç®—æ³•: å…¨é¢çš„ç»¼è¿° Vehicular Communications cited 78 2022.10: A Survey of UAV Swarm Task Allocation Based on the Perspective of Coalition Formation IJSIR åŸºäºè”ç›Ÿç»„å»ºè§†è§’çš„æ— äººæœºé›†ç¾¤ä»»åŠ¡åˆ†é…ç ”ç©¶ç»¼è¿° Engineering University of PAP, China 2023.11: A Review of Task Allocation Methods for UAVs 2024: A Heuristic Task Allocation Method Based on Overlapping Coalition Formation Game for Heterogeneous UAVs 2024.06: Distributed dynamic task allocation for unmanned aerial vehicle swarm systems: A networked evolutionary game-theoretic approach 2024.12: Application of Task Allocation Algorithms in Multi-UAV Intelligent Transportation Systems: A Critical Review ä»»åŠ¡åˆ†é…ç®—æ³•åœ¨å¤šæ— äººæœºæ™ºèƒ½äº¤é€šç³»ç»Ÿä¸­çš„åº”ç”¨: æ‰¹åˆ¤æ€§å›é¡¾ éƒ½çµç†å·¥å­¦é™¢æœºæ¢°ä¸èˆªç©ºèˆªå¤©å·¥ç¨‹ç³» BDCC IF(3.7) papers 2024: Distributed task allocation algorithm for heterogeneous unmanned aerial vehicle swarm based on coalition formation game åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„å¼‚æ„æ— äººæœºé›†ç¾¤åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³• projects and codes github: mission_planning RACER, a RApid Collaborative ExploRation approach using a fleet of decentralized UAVs. Policies æ— äººæœºé›†ç¾¤ä»»åŠ¡åˆ†é…æŠ€æœ¯ç ”ç©¶ç»¼è¿° ç³»ç»Ÿå·¥ç¨‹ä¸ç”µå­æŠ€æœ¯, 2024, 46(3): 922-934 doi: 10.12305/j.issn.1001-506X.2024.03.18 US Small unmanned aircraft systems (SUAS) flight plan OTTO R P. Small unmanned aircraft systems (SUAS) flight plan: 2016-2036[R]. Washington, DC: United States Air Force, 2016. 2016 å¹´ 5 æœˆ, ç¾å›½ç©ºå†›å‘å¸ƒçš„å°å‹æ— äººæœºç³»ç»Ÿå‘å±•è·¯çº¿å›¾ã€Š2016-2036 å¹´å°å‹æ— äººæœºç³»ç»Ÿé£è¡Œè§„åˆ’ã€‹ ä¸ºç¡®ä¿æˆ˜äº‰çš„åˆ¶èƒœèƒ½åŠ›ä¸å¼ºå†›äº‹å¯¹æŠ—ç¯å¢ƒä¸‹çš„éå¯¹ç§°ä¼˜åŠ¿, åº”é‡ç‚¹ç ”ç©¶æ›´å…·æˆæœ¬æ•ˆç›Šå’Œä½œæˆ˜å¨åŠ›çš„é›†ç¾¤å¼æ— äººæœºä½œæˆ˜æ ·å¼ã€‚ è¯¦ç»†é˜è¿°äº†â€œæ— äººæœºèœ‚ç¾¤â€çš„æ¦‚å¿µ, å¹¶è®¡åˆ’åœ¨ 2036 å¹´å»ºæˆæ¨ªè·¨èˆªç©ºã€å¤ªç©ºã€ç½‘ç©ºä¸‰å¤§ä½œæˆ˜é¢†åŸŸçš„æ— äººæœºé›†ç¾¤ä½œæˆ˜ç³»ç»Ÿã€‚ Unmanned systems integrated roadmap 2017-2042 FACHEY K M, MILLER M J. Unmanned systems integrated roadmap 2017-2042[R]. Arlington Country: Office of the Secretary of Defense, 2018. 2018 å¹´ 8 æœˆ, ç¾å›½å›½é˜²éƒ¨å‘å¸ƒçš„ã€Šæ— äººç³»ç»Ÿç»¼åˆè·¯çº¿å›¾ 2017-2042ã€‹ æŒ‡å‡ºäº† 19 é¡¹è¿‘ã€è¿œæœŸéœ€è¦é‡ç‚¹å‘å±•çš„é¢å‘å†›äº‹ä½œæˆ˜éœ€æ±‚ã€èƒ½å¤§å¹…æå‡æ— äººæœºé›†ç¾¤ä½œæˆ˜æ•ˆèƒ½çš„å…³é”®æŠ€æœ¯, åŒ…æ‹¬å¼€æ”¾å¼ä½“ç³»æ¶æ„ã€æœºå™¨å­¦ä¹ ã€äººå·¥æ™ºèƒ½ç­‰ã€‚ ç¾å›½æµ·å†›ç ”ç©¶ç”Ÿé™¢ GIAMMARCO K, HUNT S, WHITCOMB C. An instructional design reference mission for search and rescue operations[R]. Monterey, California: Naval Postgraduate School, 2015. GILES C K. A framework for integrating the development of swarm unmanned aerial system doctrine and design[R]. Monterey, California: Department of Systems Engineering Naval Postgraduate School, 2017. æå‡ºäº†ä¸€ç§é¢å‘æ— äººé›†ç¾¤ä½œæˆ˜ä½“ç³»è®¾è®¡çš„ä¸€ä½“åŒ–æ¡†æ¶, è¯¥æ¡†æ¶é’ˆå¯¹æœªæ¥æ— äººæœºé›†ç¾¤ä½œæˆ˜çš„å»ä¸­å¿ƒåŒ–ã€è‡ªç»„ç½‘ã€æ‰å¹³åŒ–ç»“æ„ç­‰ç‰¹ç‚¹, æ„å»ºäº†æ— äººæœºé›†ç¾¤â€œä½¿å‘½-æˆ˜æœ¯-è¡ŒåŠ¨-ç®—æ³•-æ•°æ®â€äº”å±‚ä»»åŠ¡æ¡†æ¶, å¹¶ä»¥æ— äººæœºé›†ç¾¤æ‰§è¡Œæƒ…æŠ¥ã€ç›‘è§†ã€ä¾¦å¯Ÿå’Œç©ºæˆ˜ä»»åŠ¡ä¸ºä¾‹åˆ†æäº†æ— äººæœºé›†ç¾¤åœ¨æ¯å±‚ä¸­çš„å…·ä½“ä»»åŠ¡, ç»™å‡ºäº†å…·ä½“çš„å†›äº‹æ¦‚å¿µæ¨¡å‹ã€‚ CN 2017-07ã€Šæ–°ä¸€ä»£äººå·¥æ™ºèƒ½å‘å±•è§„åˆ’ã€‹ å¤šæ¬¡æåŠâ€œç¾¤ä½“æ„ŸçŸ¥ã€ååŒä¸æ¼”åŒ–â€â€œç¾¤ä½“é›†æˆæ™ºèƒ½â€â€œè‡ªä¸»æ— äººç³»ç»Ÿâ€ç­‰æ¦‚å¿µ, åŒæ—¶æ˜ç¡®æŒ‡å‡ºåº”å°†äººå·¥æ™ºèƒ½ä¸æ— äººæœºé›†ç¾¤ç´§å¯†èåˆ, å€ŸåŠ©äººå·¥æ™ºèƒ½é‡ç‚¹çªç ´æ— äººç³»ç»Ÿç›¸å…³æ ¸å¿ƒæŠ€æœ¯, å®ç°æ— äººæœºé›†ç¾¤ç›¸å…³æŠ€æœ¯çš„è·¨è¶Šå¼å‘å±•ã€‚ PLA è§£æ”¾å†›æŠ¥ 2019 å¹´ 10 æœˆå‘è¡¨ã€ŠåŠ é€Ÿæ¨è¿›å†›äº‹æ™ºèƒ½åŒ–ã€‹æ–‡ç« , å°†æ™ºèƒ½é›†ç¾¤ä½œæˆ˜ååŒæŠ€æœ¯åˆ—ä¸ºæ™ºèƒ½åŒ–æˆ˜äº‰çš„åŸºçŸ³; "},"Learn/LearnDrones/TaskAssignment/2018.10-Should_We_Compete_or_Should_We_Cooperate_Applying_Game_Theory_to_Task_Allocation_in_Drone_Swarms.html":{"url":"Learn/LearnDrones/TaskAssignment/2018.10-Should_We_Compete_or_Should_We_Cooperate_Applying_Game_Theory_to_Task_Allocation_in_Drone_Swarms.html","title":"2018.10 Should_We_Compete_or_Should_We_Cooperate_Applying_Game_Theory_to_Task_Allocation_in_Drone_Swarms","keywords":"","body":"Should We Compete or Should We Cooperate? Applying Game Theory to Task Allocation in Drone Swarms æˆ‘ä»¬åº”è¯¥ç«äº‰è¿˜æ˜¯åº”è¯¥åˆä½œï¼Ÿå°†åšå¼ˆè®ºåº”ç”¨äºæ— äººæœºé›†ç¾¤ä¸­çš„ä»»åŠ¡åˆ†é… Published in: 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) Date of Conference: 01-05 October 2018 ieeexplore swarmcityproject bitbucket: SwarmCity Abstract: Let's imagine a swarm of drones that has to visit some locations and build a map in a disaster area. Let's assume the drones only can communicate to their neighbors and manage partial information of the mission. A relevant question in this scenario is â€œShould the robots compete or should they cooperate?â€. This work analyzes the described scenario to answer this question. Two game theoretical algorithms have been developed: one competitive and another cooperative. The competitive algorithm poses games among each drone and its neighbors and searches the Nash Equilibrium. The cooperative one defines electoral systems that allow the drones to vote their preferred task allocations for their neighbors. Both algorithms are extensively tested in multiple scenarios with different features. After the experiments the question can be answered â€œThe robots should cooperate!â€. è®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸‹ï¼Œä¸€ç¾¤æ— äººæœºå¿…é¡»è®¿é—®ä¸€äº›ä½ç½®å¹¶åœ¨ç¾åŒºæ„å»ºåœ°å›¾ã€‚å‡è®¾æ— äººæœºåªèƒ½ä¸é‚»å±…é€šä¿¡å¹¶ç®¡ç†ä»»åŠ¡çš„éƒ¨åˆ†ä¿¡æ¯ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸€ä¸ªç›¸å…³çš„é—®é¢˜æ˜¯â€œæœºå™¨äººåº”è¯¥ç«äº‰è¿˜æ˜¯åº”è¯¥åˆä½œï¼Ÿè¿™é¡¹å·¥ä½œåˆ†æäº†æ‰€æè¿°çš„åœºæ™¯æ¥å›ç­”è¿™ä¸ªé—®é¢˜ã€‚å·²ç»å¼€å‘äº†ä¸¤ç§åšå¼ˆè®ºç®—æ³•ï¼šä¸€ç§æ˜¯ç«äº‰ç®—æ³•ï¼Œå¦ä¸€ç§æ˜¯åˆä½œç®—æ³•ã€‚ç«äº‰ç®—æ³•åœ¨æ¯æ¶æ— äººæœºåŠå…¶é‚»å±…ä¹‹é—´è¿›è¡Œåšå¼ˆï¼Œå¹¶æœç´¢çº³ä»€å‡è¡¡ã€‚åˆä½œè€…å®šä¹‰äº†é€‰ä¸¾ç³»ç»Ÿï¼Œå…è®¸æ— äººæœºä¸ºé‚»å±…æŠ•ç¥¨å†³å®šä»–ä»¬å–œæ¬¢çš„ä»»åŠ¡åˆ†é…ã€‚è¿™ä¸¤ç§ç®—æ³•éƒ½åœ¨å…·æœ‰ä¸åŒåŠŸèƒ½çš„å¤šä¸ªåœºæ™¯ä¸­è¿›è¡Œäº†å¹¿æ³›çš„æµ‹è¯•ã€‚å®éªŒç»“æŸåï¼Œå¯ä»¥å›ç­”é—®é¢˜â€œæœºå™¨äººåº”è¯¥åˆä½œï¼ I. Introduction II. State of Art III. Scenario IV. Algorithms V. Experiments and Results VI. Conclusions Introdution This work proposes two game theoretical algorithms: one competitive and another cooperative. The competitive algorithm poses games among each drone and its neighbors and searches the Nash Equilibrium. The cooperative one defines electoral systems that allow the drones to vote their preferred task allocations for their neighbors. Both algorithms are exhaustively tested in multiple scenarios with different features to make conclusions about their performances. State of Art Multi-robot task allocation is a well-known problem where a set of tasks (NT) are allocated to a set of robots (NR) looking for maximizing a certain utility (U) [3]. This basic problem can be applied in multiple scenarios by defining utility (e.g. mission time, covered distance and energy consumption) and adding restrictions (e.g. requirements about payloads and relationships among tasks).å¤šæœºå™¨äººä»»åŠ¡åˆ†é…æ˜¯ä¸€ä¸ªä¼—æ‰€å‘¨çŸ¥çš„é—®é¢˜ï¼Œå…¶ä¸­ä¸€ç»„ä»»åŠ¡ (NT) è¢«åˆ†é…ç»™ä¸€ç»„æœºå™¨äºº (NR) å¯»æ‰¾æœ€å¤§åŒ–æŸç§æ•ˆç”¨ (U) [3] ã€‚é€šè¿‡å®šä¹‰æ•ˆç”¨ï¼ˆä¾‹å¦‚ä»»åŠ¡æ—¶é—´ã€è¦†ç›–è·ç¦»å’Œèƒ½é‡æ¶ˆè€—ï¼‰å¹¶æ·»åŠ é™åˆ¶ï¼ˆä¾‹å¦‚å…³äºæœ‰æ•ˆè´Ÿè½½å’Œä»»åŠ¡ä¹‹é—´å…³ç³»çš„è¦æ±‚ï¼‰ï¼Œè¿™ä¸ªåŸºæœ¬é—®é¢˜å¯ä»¥åº”ç”¨äºå¤šç§åœºæ™¯ã€‚ The literature contains a huge variety of algorithms to deal with this problem (exhaustive surveys can be found in references [4], [5] and [6]). These algorithms can be classified into two categories: centralized, which have a central agent that manages the information of scenario and allocates the tasks to robots, and distributed, which rely on a series of equal agents that share information and negotiate tasks. Among the centralized algorithms there are deterministic and stochastic techniques, whereas among the distributed ones there are agent, market and society-based methods.æ–‡çŒ®ä¸­åŒ…å«äº†å„ç§å„æ ·çš„ç®—æ³•æ¥å¤„ç†è¿™ä¸ªé—®é¢˜ï¼ˆè¯¦å°½çš„è°ƒæŸ¥å¯ä»¥åœ¨å‚è€ƒæ–‡çŒ®ä¸­æ‰¾åˆ°ï¼‰ [4] , [5] å’Œ [6] ï¼‰ã€‚è¿™äº›ç®—æ³•å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼šé›†ä¸­å¼ï¼Œæœ‰ä¸€ä¸ªä¸­å¤®ä»£ç†æ¥ç®¡ç†åœºæ™¯ä¿¡æ¯å¹¶å°†ä»»åŠ¡åˆ†é…ç»™æœºå™¨äººï¼›åˆ†å¸ƒå¼ï¼Œä¾é ä¸€ç³»åˆ—å¹³ç­‰çš„ä»£ç†æ¥å…±äº«ä¿¡æ¯å’Œåå•†ä»»åŠ¡ã€‚é›†ä¸­å¼ç®—æ³•æœ‰ç¡®å®šæ€§å’Œéšæœºæ€§æŠ€æœ¯ï¼Œè€Œåˆ†å¸ƒå¼ç®—æ³•æœ‰åŸºäºä»£ç†ã€å¸‚åœºå’Œç¤¾ä¼šçš„æ–¹æ³•ã€‚ Some requirements for task allocation algorithms in the context of large multi-robot systems are collected in reference [7]; they should be decentralized, scalable for a high number of agents, predictable by the operators, flexible to changes in robots and tasks, robust in asynchronous environments and able to accommodate different interests of agents. Additionally, some guidelines for the design of algorithms for environments with different types of communication and information can be found in reference [8]. This work proposes two game theoretical algorithms that satisfy these requirements to work in a scenario with limited communications and partial information.å‚è€ƒèµ„æ–™ä¸­æ”¶é›†äº†å¤§å‹å¤šæœºå™¨äººç³»ç»ŸèƒŒæ™¯ä¸‹ä»»åŠ¡åˆ†é…ç®—æ³•çš„ä¸€äº›éœ€æ±‚ [7] ;å®ƒä»¬åº”è¯¥æ˜¯å»ä¸­å¿ƒåŒ–çš„ã€å¯æ‰©å±•çš„ã€å¯ç”¨äºå¤§é‡ä»£ç†ã€æ“ä½œå‘˜å¯é¢„æµ‹ã€çµæ´»åœ°é€‚åº”æœºå™¨äººå’Œä»»åŠ¡çš„å˜åŒ–ã€åœ¨å¼‚æ­¥ç¯å¢ƒä¸­å…·æœ‰é²æ£’æ€§ï¼Œå¹¶ä¸”èƒ½å¤Ÿé€‚åº”ä»£ç†çš„ä¸åŒå…´è¶£ã€‚æ­¤å¤–ï¼Œå¯ä»¥åœ¨å‚è€ƒæ–‡çŒ®ä¸­æ‰¾åˆ°é’ˆå¯¹å…·æœ‰ä¸åŒç±»å‹çš„é€šä¿¡å’Œä¿¡æ¯çš„ç¯å¢ƒçš„ç®—æ³•è®¾è®¡çš„ä¸€äº›æŒ‡å— [8] ã€‚è¿™é¡¹å·¥ä½œæå‡ºäº†ä¸¤ç§åšå¼ˆè®ºç®—æ³•ï¼Œå¯ä»¥æ»¡è¶³åœ¨é€šä¿¡æœ‰é™å’Œéƒ¨åˆ†ä¿¡æ¯çš„åœºæ™¯ä¸­å·¥ä½œçš„è¿™äº›è¦æ±‚ã€‚ Game Theory has been used in several applications in the world of Robotics, such as multi-robot patrolling [9] or surveillance [10] and human-robot cooperation [11]. In the context of multi-robot task allocation, there are works about forming coalitions to perform tasks [12], deciding whether take part or not in a task with restricted information [13], allocating tasks with complete information [14], negotiating the distribution of tasks in a robot team [15] and improving the distributions generated by other methods [16]. However, as far as we know, there are not precedents for the algorithms proposed in this work.åšå¼ˆè®ºå·²åœ¨æœºå™¨äººé¢†åŸŸçš„å¤šç§åº”ç”¨ä¸­å¾—åˆ°åº”ç”¨ï¼Œä¾‹å¦‚å¤šæœºå™¨äººå·¡é€» [9] æˆ–ç›‘è§† [10] ä»¥åŠäººæœºåˆä½œ [11] ã€‚åœ¨å¤šæœºå™¨äººä»»åŠ¡åˆ†é…çš„èƒŒæ™¯ä¸‹ï¼Œæœ‰å…³äºå½¢æˆè”ç›Ÿæ¥æ‰§è¡Œä»»åŠ¡çš„å·¥ä½œ [12] ï¼Œå†³å®šæ˜¯å¦å‚ä¸ä¿¡æ¯å—é™çš„ä»»åŠ¡ [13] ï¼Œåˆ†é…å…·æœ‰å®Œæ•´ä¿¡æ¯çš„ä»»åŠ¡ [14] ï¼Œåå•†æœºå™¨äººå›¢é˜Ÿä¸­çš„ä»»åŠ¡åˆ†é… [15] å¹¶æ”¹è¿›å…¶ä»–æ–¹æ³•ç”Ÿæˆçš„åˆ†å¸ƒ [16] ã€‚ç„¶è€Œï¼Œæ®æˆ‘ä»¬æ‰€çŸ¥ï¼Œè¿™é¡¹å·¥ä½œä¸­æå‡ºçš„ç®—æ³•è¿˜æ²¡æœ‰å…ˆä¾‹ã€‚ Algorithms Distributed Competitive Algorithm The first step is the definition of the problem: i.e. the generation of robots and tasks and the computation of utility matrix. Then, the algorithm can be executed completely distributed in the robots. First, each robot gets information about its competitors (i.e. the robots that are communicated with it) and its preferred tasks (i.e. the tasks that provide more payoffs for itself). Then, it searches the best Nash Equilibrium within the possible task allocations for it and its competitors. Finally, it selects the task that corresponds to it according to this Nash Equilibrium. The task allocation for the swarm is just the fusion of the task selections of the robots. é¦–å…ˆï¼Œæ¯ä¸ªæœºå™¨äººè·å–å…¶ç«äº‰å¯¹æ‰‹ï¼ˆå³ä¸ä¹‹é€šä¿¡çš„æœºå™¨äººï¼‰å’Œå…¶é¦–é€‰ä»»åŠ¡ï¼ˆå³ä¸ºè‡ªå·±æä¾›æ›´å¤šå›æŠ¥çš„ä»»åŠ¡ï¼‰çš„ä¿¡æ¯ã€‚ ç„¶åï¼Œå®ƒåœ¨å¯èƒ½çš„ä»»åŠ¡åˆ†é…ä¸­æœç´¢å¯¹å…¶åŠå…¶ç«äº‰å¯¹æ‰‹çš„æœ€ä½³çº³ä»€å‡è¡¡ã€‚ æœ€åï¼Œå®ƒæ ¹æ®è¿™ä¸ªçº³ä»€å‡è¡¡é€‰æ‹©å¯¹åº”äºè‡ªå·±çš„ä»»åŠ¡ã€‚ ç¾¤çš„ä»»åŠ¡åˆ†é…åªæ˜¯æœºå™¨äººçš„ä»»åŠ¡é€‰æ‹©çš„èåˆã€‚ Hybrid Cooperative Algorithm B. æ··åˆåä½œç®—æ³• The cooperative algorithm defines voting and counting systems to allow the robots to assign the tasks. This algorithm is hybrid instead of distributed, since it requires two types of robots: citizens and leaders. The citizens have the right to vote which robots are the best to perform each task. The leaders can not only vote but also count the votes and determine the task allocation. This work considers the leaders and citizens are chosen before the deployment of swarm in the way that every citizen is connected to one leader and every leader is not connected to another leader. ååŒç®—æ³•å®šä¹‰äº†æŠ•ç¥¨å’Œè®¡æ•°ç³»ç»Ÿï¼Œä»¥å…è®¸æœºå™¨äººåˆ†é…ä»»åŠ¡ã€‚è¯¥ç®—æ³•æ˜¯æ··åˆå‹è€Œéåˆ†å¸ƒå¼ï¼Œå› ä¸ºå®ƒéœ€è¦ä¸¤ç§ç±»å‹çš„æœºå™¨äººï¼šå¸‚æ°‘å’Œé¢†å¯¼è€…ã€‚å¸‚æ°‘æœ‰æƒæŠ•ç¥¨å†³å®šå“ªäº›æœºå™¨äººæœ€é€‚åˆæ‰§è¡Œæ¯é¡¹ä»»åŠ¡ã€‚é¢†å¯¼è€…ä¸ä»…å¯ä»¥æŠ•ç¥¨ï¼Œè¿˜å¯ä»¥è®¡æ•°æŠ•ç¥¨å¹¶ç¡®å®šä»»åŠ¡åˆ†é…ã€‚è¿™é¡¹å·¥ä½œè€ƒè™‘äº†åœ¨éƒ¨ç½²ç¾¤ä½“ä¹‹å‰é€‰æ‹©é¢†å¯¼è€…å’Œå¸‚æ°‘çš„æ–¹å¼ï¼Œå³æ¯ä¸ªå¸‚æ°‘éƒ½è¿æ¥åˆ°ä¸€ä¸ªé¢†å¯¼è€…ï¼Œæ¯ä¸ªé¢†å¯¼è€…éƒ½ä¸è¿æ¥åˆ°å¦ä¸€ä¸ªé¢†å¯¼è€…ã€‚ The cooperative algorithm developed following this scheme is shown in Algorithm 1. The first steps are similar to the competitive algorithm: the generation of robots and tasks and the computation of utility matrix. However, then the algorithm classifies the robots into leaders and citizens and perform different steps according to these types. è¯¥æ–¹æ¡ˆå¼€å‘çš„ååŒç®—æ³•å¦‚å›¾ Algorithm 1 æ‰€ç¤ºã€‚å‰å‡ æ­¥ä¸ç«äº‰ç®—æ³•ç±»ä¼¼ï¼šç”Ÿæˆæœºå™¨äººå’Œä»»åŠ¡ä»¥åŠè®¡ç®—æ•ˆç”¨çŸ©é˜µã€‚ç„¶è€Œï¼Œç„¶åç®—æ³•å°†æœºå™¨äººåˆ†ä¸ºé¢†å¯¼è€…å’Œå¹³æ°‘ï¼Œå¹¶æŒ‰ç…§è¿™äº›ç±»å‹æ‰§è¡Œä¸åŒçš„æ­¥éª¤ã€‚ Each leader gets awareness of its dependent citizens and closest tasks, votes its preferred allocation for the FT closest tasks and requests the votes of the dependent citizens for these tasks. In a similar way, each citizen gets awareness of its neighbor robots and tasks, votes its preferred task allocation and sends this vote to its leader. Then, each leader counts the votes by using a certain system (Borda count, plurality rule, approval voting and cumulative voting [18]) and search the best Nash Equilibrium in the results. In this case, the leader obtains not only its own task, but also the tasks for its dependent citizens. æ¯ä¸ªé¢†å¯¼è€…éƒ½äº†è§£å…¶ä¾èµ–çš„å…¬æ°‘å’Œæœ€æ¥è¿‘çš„ä»»åŠ¡ï¼ŒæŠ•ç¥¨é€‰å‡ºå…¶é¦–é€‰çš„åˆ†é… FT æœ€æ¥è¿‘çš„ä»»åŠ¡ï¼Œå¹¶è¯·æ±‚é™„å±å…¬æ°‘å¯¹è¿™äº›ä»»åŠ¡è¿›è¡ŒæŠ•ç¥¨ã€‚ä»¥ç±»ä¼¼çš„æ–¹å¼ï¼Œæ¯ä¸ªå…¬æ°‘éƒ½ä¼šäº†è§£å…¶é‚»å±…çš„æœºå™¨äººå’Œä»»åŠ¡ï¼Œå¯¹å…¶é¦–é€‰çš„ä»»åŠ¡åˆ†é…è¿›è¡ŒæŠ•ç¥¨ï¼Œå¹¶å°†æ­¤æŠ•ç¥¨å‘é€ç»™å…¶é¢†å¯¼è€…ã€‚ç„¶åï¼Œæ¯ä¸ªé¢†å¯¼è€…ä½¿ç”¨ä¸€å®šçš„ç³»ç»Ÿï¼ˆåšè¾¾è®¡æ•°ã€å¤šæ•°è§„åˆ™ã€æ‰¹å‡†æŠ•ç¥¨å’Œç´¯ç§¯æŠ•ç¥¨ï¼‰æ¥è®¡ç¥¨ [18] ï¼‰å¹¶åœ¨ç»“æœä¸­æœç´¢æœ€ä½³çº³ä»€å‡è¡¡ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé¢†å¯¼è€…ä¸ä»…è·å¾—è‡ªå·±çš„ä»»åŠ¡ï¼Œè¿˜è·å¾—å…¶é™„å±å…¬æ°‘çš„ä»»åŠ¡ã€‚ C. Optimization Cã€ä¼˜åŒ– The allocation of T tasks to R robots addresses a search of the optimum among T!/(Tâˆ’R)! configurations (T! when R=T). Although the developed algorithms limit the problem to each robot and their neighbors instead of the whole swarm (Râ‰ªNR and Tâ‰¤NT), the search of the optimal solution when the number of connections reach certain values implies a high computational cost and memory utilization. For instance, the allocation of 10 tasks to 10 robots generates a space of 3,522,880 permutations of 10 numbers. For these reasons, a genetic algorithm was used to find a suboptimal Nash Equilibrum in the competitive algorithm and a suboptimal allocation of preferences in the cooperative one. The algorithm terminates when 100 generations are computed, the fitness of the best individual reaches the 95% of best possible result (i.e. the targets of the robots coincide with their initial positions), the average fitness of the population reaches the 90% of this best possible result, the improvement of the best individual is less than 1% in 10 generations or the improvement of the mean of population is less than 1% in 10 generations. å½“è®¡ç®— 100 ä»£æ—¶ï¼Œç®—æ³•ç»ˆæ­¢ï¼Œæœ€ä½³ä¸ªä½“çš„é€‚åº”åº¦è¾¾åˆ°æœ€ä½³ç»“æœçš„ 95%ï¼ˆå³æœºå™¨äººçš„ç›®æ ‡ä¸å…¶åˆå§‹ä½ç½®ä¸€è‡´ï¼‰ï¼Œç¾¤ä½“çš„å¹³å‡é€‚åº”åº¦è¾¾åˆ°æœ€ä½³ç»“æœçš„ 90%å¯èƒ½çš„ç»“æœæ˜¯ï¼Œæœ€å¥½çš„ä¸ªä½“åœ¨ 10 ä»£ä¸­çš„æ”¹è¿›å°äº 1%ï¼Œæˆ–è€…ç¾¤ä½“çš„å¹³å‡å€¼åœ¨ 10 ä»£ä¸­çš„æ”¹è¿›å°äº 1%ã€‚ A total of 1,000 simulations with 10 robots and 10 tasks generated randomly were performed to estimate the optimality of the genetic algorithm. The suboptimal solutions had an average social utility of 1,165.8, whereas the optimal solutions had an average social utility of 1,157.3. Therefore, the genetic algorithm reached a 99.27% of the optimal social utility in this problem, which is an excellent result that allows its application in the game theoretical algorithms. æ€»å…±ä½¿ç”¨ 10 ä¸ªæœºå™¨äººå’Œéšæœºç”Ÿæˆçš„ 10 ä¸ªä»»åŠ¡è¿›è¡Œäº† 1,000 æ¬¡æ¨¡æ‹Ÿï¼Œä»¥ä¼°è®¡é—ä¼ ç®—æ³•çš„æœ€ä¼˜æ€§ã€‚æ¬¡ä¼˜è§£å†³æ–¹æ¡ˆçš„å¹³å‡ç¤¾ä¼šæ•ˆç”¨ä¸º 1,165.8ï¼Œè€Œæœ€ä¼˜è§£å†³æ–¹æ¡ˆçš„å¹³å‡ç¤¾ä¼šæ•ˆç”¨ä¸º 1,157.3ã€‚å› æ­¤ï¼Œé—ä¼ ç®—æ³•åœ¨è¿™ä¸ªé—®é¢˜ä¸Šè¾¾åˆ°äº† 99.27%çš„æœ€ä¼˜ç¤¾ä¼šæ•ˆç”¨ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ç»“æœï¼Œä½¿å¾—å®ƒèƒ½å¤Ÿåœ¨åšå¼ˆè®ºç®—æ³•ä¸­å¾—åˆ°åº”ç”¨ã€‚ Results B. Comparison Bã€æ¯”è¾ƒ Multiple numbers of robots, tasks and connections were considered during these tests (NR,NT and NC), whereas the generation patterns of robots and tasks were set to random (NR=0 and NT=0). In this manner, the impact of the problem scale on the algorithms' performance could be studied, as well as the overfitting to certain scenarios was avoided. Two types of simulations were performed: to determine the influence of the size of scenario (number of robots and tasks), and to determine the geometry of the graph (number of connections between robots). åœ¨è¿™äº›æµ‹è¯•ä¸­è€ƒè™‘äº†å¤šä¸ªæœºå™¨äººã€ä»»åŠ¡å’Œè¿æ¥ (NR,NT å’Œ NC) ï¼Œè€Œæœºå™¨äººå’Œä»»åŠ¡çš„ç”Ÿæˆæ¨¡å¼è¢«è®¾ç½®ä¸ºéšæœº (NR=0 å’Œ NT=0) ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œå¯ä»¥ç ”ç©¶é—®é¢˜è§„æ¨¡å¯¹ç®—æ³•æ€§èƒ½çš„å½±å“ï¼Œå¹¶é¿å…å¯¹æŸäº›åœºæ™¯çš„è¿‡åº¦æ‹Ÿåˆã€‚è¿›è¡Œäº†ä¸¤ç§ç±»å‹çš„æ¨¡æ‹Ÿï¼šç¡®å®šåœºæ™¯å¤§å°ï¼ˆæœºå™¨äººå’Œä»»åŠ¡çš„æ•°é‡ï¼‰çš„å½±å“ï¼Œå¹¶ç¡®å®šå›¾å½¢çš„å‡ ä½•å½¢çŠ¶ï¼ˆæœºå™¨äººä¹‹é—´çš„è¿æ¥æ•°é‡ï¼‰ã€‚ In the first case, a total of 1,000 simulations were performed: 100 simulations for each size (NR=NT {20, 40, 60, 80, 100, 120, 140, 160, 180, 200}), all of them with 10 connections for each robot (NC=10). The results are shown in table IV: in both algorithms, the greater size of the problem, the lower ratio of completed tasks (CT) - it seems to converge to a certain value - and the higher levels of social utility (SU). The study of results reveals that the cooperative algorithm is better in terms of completed tasks, whereas the competitive one is better in terms of social utility. åœ¨ç¬¬ä¸€ç§æƒ…å†µä¸‹ï¼Œæ€»å…±æ‰§è¡Œäº† 1,000 æ¬¡æ¨¡æ‹Ÿï¼šæ¯ä¸ªå°ºå¯¸ 100 æ¬¡æ¨¡æ‹Ÿ (NR=NT {20, 40, 60, 80, 100, 120, 140, 160, 180, 200})ï¼Œæ¯ä¸ªæœºå™¨äººéƒ½æœ‰ 10 ä¸ªè¿æ¥ (NC=10) ã€‚ç»“æœæ˜¾ç¤ºåœ¨ table IV ï¼šåœ¨ä¸¤ç§ç®—æ³•ä¸­ï¼Œé—®é¢˜è§„æ¨¡è¶Šå¤§ï¼Œå·²å®Œæˆä»»åŠ¡çš„æ¯”ç‡ (CT) è¶Šä½ï¼ˆä¼¼ä¹æ”¶æ•›åˆ°æŸä¸ªå€¼ï¼‰ï¼Œè€Œç¤¾ä¼šæ•ˆç”¨ (SU) æ°´å¹³è¶Šé«˜ã€‚ç»“æœç ”ç©¶è¡¨æ˜ï¼Œåˆä½œç®—æ³•åœ¨å®Œæˆä»»åŠ¡æ–¹é¢æ›´å¥½ï¼Œè€Œç«äº‰ç®—æ³•åœ¨ç¤¾ä¼šæ•ˆç”¨æ–¹é¢æ›´å¥½ã€‚ è¯¥æµ‹è¯•è€ƒè™‘äº†ç¾¤ä½“çš„å®é™…åº”ç”¨ï¼šæ‹æ‘„ç…§ç‰‡å¹¶æ„å»º SwarmCity çš„é©¬èµ›å…‹ï¼ŒSwarmCity æ˜¯ä¸€ä¸ªä½¿ç”¨æ¸¸æˆå¼•æ“å¼€å‘çš„å…·æœ‰äº¤é€šå’Œè¡Œäººçš„è™šæ‹ŸåŸå¸‚ã€‚å¦‚å›¾æ‰€ç¤º figure 1 ï¼Œåº”ç”¨åœºæ™¯é…ç½®ä¸º NR=400 æœºå™¨äºº (GR=1) ä»é£æœºä¸Šæ²¿ç›´çº¿å‘å°„ï¼Œæ¯ä¸ªéƒ½è¿æ¥åˆ° NC=10 é‚»å±…ï¼Œä»¥åŠ NT=400 ä»»åŠ¡æŒ‰ç…§ç½‘æ ¼åˆ†å¸ƒ (GT=1) ã€‚ Conclusions ç»“è®º This work tries to answer a common question when a group has to face a problem: â€œShould we compete or should we cooperate?â€ This time the problem is the allocation of tasks to robots in a swarm under limited communications and partial information. For this purpose, a competitive algorithm and a cooperative one are designed, developed, configured and tested in multiple scenarios. Finally, a realistic application where the swarm is launched from an aircraft and has to build the map of a city is presented. è¿™é¡¹å·¥ä½œè¯•å›¾å›ç­”ä¸€ä¸ªç¾¤ä½“å¿…é¡»é¢å¯¹é—®é¢˜æ—¶çš„ä¸€ä¸ªå¸¸è§é—®é¢˜ï¼šâ€œæˆ‘ä»¬åº”è¯¥ç«äº‰è¿˜æ˜¯åº”è¯¥åˆä½œï¼Ÿâ€è¿™æ¬¡çš„é—®é¢˜æ˜¯åœ¨æœ‰é™çš„é€šä¿¡å’Œéƒ¨åˆ†ä¿¡æ¯ä¸‹å°†ä»»åŠ¡åˆ†é…ç»™ç¾¤ä¸­çš„æœºå™¨äººã€‚ä¸ºæ­¤ï¼Œè®¾è®¡ã€å¼€å‘ã€é…ç½®å¹¶åœ¨å¤šä¸ªåœºæ™¯ä¸­æµ‹è¯•äº†ç«äº‰ç®—æ³•å’Œåˆä½œç®—æ³•ã€‚æœ€åï¼Œæå‡ºäº†ä¸€ä¸ªç°å®çš„åº”ç”¨ç¨‹åºï¼Œå…¶ä¸­é›†ç¾¤ä»é£æœºä¸Šå‘å°„å¹¶å¿…é¡»æ„å»ºåŸå¸‚åœ°å›¾ã€‚ The results show the cooperative algorithm allocates more tasks in all the scenarios. Conversely, the competitive algorithm reaches a slightly higher social utility in most of them. These scenarios consider from 10 to 200 robots and tasks, as well as from 2 to 20 connections between each robot and the rest. It must be remarked that completing more tasks is more important than consuming less resources in the considered applications. Therefore, we can assure â€œDear robots, you should cooperate!â€. ç»“æœè¡¨æ˜ï¼Œåä½œç®—æ³•åœ¨æ‰€æœ‰åœºæ™¯ä¸­åˆ†é…äº†æ›´å¤šçš„ä»»åŠ¡ã€‚ç›¸åï¼Œç«äº‰ç®—æ³•åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹éƒ½è¾¾åˆ°äº†ç¨é«˜çš„ç¤¾ä¼šæ•ˆç”¨ã€‚è¿™äº›åœºæ™¯è€ƒè™‘äº† 10 åˆ° 200 ä¸ªæœºå™¨äººå’Œä»»åŠ¡ï¼Œä»¥åŠæ¯ä¸ªæœºå™¨äººä¸å…¶ä»–æœºå™¨äººä¹‹é—´çš„ 2 åˆ° 20 ä¸ªè¿æ¥ã€‚å¿…é¡»æŒ‡å‡ºçš„æ˜¯ï¼Œåœ¨æ‰€è€ƒè™‘çš„åº”ç”¨ç¨‹åºä¸­å®Œæˆæ›´å¤šçš„ä»»åŠ¡æ¯”æ¶ˆè€—æ›´å°‘çš„èµ„æºæ›´é‡è¦ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä¿è¯â€œäº²çˆ±çš„æœºå™¨äººï¼Œä½ åº”è¯¥åˆä½œï¼â€ã€‚ At the time of evaluating these results and searching possible improvements, it must be considered that the competitive algorithm requires less communications than the cooperative one. In the first case the robots only send their locations to their neighbors, whereas in the second case the citizens also send the votes to the leaders and these ones send back the results to the citizens. Additionally, it reached better results in social utility than completed tasks, so it is a suitable option in scenarios with limited resources (e.g. energy supplies). Therefore, a modification of competitive algorithm to take advantage of this communications will be studied in future works. åœ¨è¯„ä¼°è¿™äº›ç»“æœå¹¶å¯»æ‰¾å¯èƒ½çš„æ”¹è¿›æ—¶ï¼Œå¿…é¡»è€ƒè™‘åˆ°ç«äº‰ç®—æ³•æ¯”åˆä½œç®—æ³•éœ€è¦æ›´å°‘çš„é€šä¿¡ã€‚åœ¨ç¬¬ä¸€ç§æƒ…å†µä¸‹ï¼Œæœºå™¨äººä»…å°†å…¶ä½ç½®å‘é€ç»™é‚»å±…ï¼Œè€Œåœ¨ç¬¬äºŒç§æƒ…å†µä¸‹ï¼Œå…¬æ°‘è¿˜å°†é€‰ç¥¨å‘é€ç»™é¢†å¯¼äººï¼Œç„¶åè¿™äº›é¢†å¯¼äººå°†ç»“æœå‘é€å›å…¬æ°‘ã€‚æ­¤å¤–ï¼Œå®ƒåœ¨ç¤¾ä¼šæ•ˆç”¨æ–¹é¢æ¯”å·²å®Œæˆçš„ä»»åŠ¡å–å¾—äº†æ›´å¥½çš„æ•ˆæœï¼Œå› æ­¤åœ¨èµ„æºï¼ˆä¾‹å¦‚èƒ½æºä¾›åº”ï¼‰æœ‰é™çš„æƒ…å†µä¸‹æ˜¯ä¸€ä¸ªåˆé€‚çš„é€‰æ‹©ã€‚å› æ­¤ï¼Œåœ¨æœªæ¥çš„å·¥ä½œä¸­å°†ç ”ç©¶ä¿®æ”¹ç«äº‰ç®—æ³•ä»¥åˆ©ç”¨è¿™ç§é€šä¿¡ã€‚ "},"Learn/LearnDrones/TaskAssignment/2019.11-A_Mission_Planning_and_Task_Allocation_Framework_For_Multi-UAV_Swarm_Coordination.html":{"url":"Learn/LearnDrones/TaskAssignment/2019.11-A_Mission_Planning_and_Task_Allocation_Framework_For_Multi-UAV_Swarm_Coordination.html","title":"2019 A Mission Planning and Task Allocation Framework For Multi-UAV Swarm Coordination","keywords":"","body":"A Mission Planning and Task Allocation Framework For Multi-UAV Swarm Coordination ä¸€ç§ç”¨äºå¤šæ— äººæœºé›†ç¾¤åè°ƒçš„ä»»åŠ¡è§„åˆ’å’Œä»»åŠ¡åˆ†é…æ¡†æ¶ Abstract: This paper presents a multi-agent mission planning and task allocation framework designed to coordinate autonomous aerial vehicles engaged in a competition scenario. The development was a part of an inter-university UAV Swarm competition that was supported by BAE Systems. The proposed centralised system was developed with the main objectives of robustness and scalability. The system consists of a general mission planning module which decomposes the overall mission into identified sub-stages to achieve the overall mission goal. In order to enable autonomous defence actions a dynamic task allocation approach is proposed. The dynamic task allocation is using received information of detected enemies and utilises the information for a further combinatorial optimisation problem. In this work, we discuss the structure of the framework and present results obtained in a high-fidelity simulation environment. Moreover, a comparative study of the performance of three different optimization algorithms for the given combinatorial problem, namely Kuhn-Munkres, Jonker-Volgenant and Gale-Shapley, implemented in the system is included. The results demonstrate that the best allocation result performances, in terms of minimal costs, are obtained with utilising, both Kuhn-Munkres or Jonker-Volgenant methods, while the Gale-Shapley algorithms have benefits in terms of time efficiency for cases in which minimal costs are not the highest priority. æœ¬æ–‡æå‡ºäº†ä¸€ä¸ªå¤šæ™ºèƒ½ä½“ä»»åŠ¡è§„åˆ’å’Œä»»åŠ¡åˆ†é…æ¡†æ¶ï¼Œæ—¨åœ¨åè°ƒå‚ä¸æ¯”èµ›åœºæ™¯çš„è‡ªåŠ¨é©¾é©¶é£è¡Œå™¨ã€‚è¯¥å¼€å‘é¡¹ç›®æ˜¯ BAE Systems æ”¯æŒçš„å¤§å­¦é—´æ— äººæœº Swarm ç«èµ›çš„ä¸€éƒ¨åˆ†ã€‚æ‹Ÿè®®çš„é›†ä¸­å¼ç³»ç»Ÿçš„ä¸»è¦ç›®æ ‡æ˜¯ç¨³å¥æ€§å’Œå¯æ‰©å±•æ€§ã€‚è¯¥ç³»ç»Ÿç”±ä¸€ä¸ªé€šç”¨ä»»åŠ¡è§„åˆ’æ¨¡å—ç»„æˆï¼Œè¯¥æ¨¡å—å°†æ•´ä¸ªä»»åŠ¡åˆ†è§£ä¸ºç¡®å®šçš„å­é˜¶æ®µï¼Œä»¥å®ç°æ€»ä½“ä»»åŠ¡ç›®æ ‡ã€‚ä¸ºäº†å®ç°è‡ªä¸»é˜²å¾¡è¡ŒåŠ¨ï¼Œæå‡ºäº†ä¸€ç§åŠ¨æ€ä»»åŠ¡åˆ†é…æ–¹æ³•ã€‚åŠ¨æ€ä»»åŠ¡åˆ†é…ä½¿ç”¨æ¥æ”¶åˆ°çš„æ£€æµ‹åˆ°çš„æ•Œäººçš„ä¿¡æ¯ï¼Œå¹¶å°†è¿™äº›ä¿¡æ¯ç”¨äºè¿›ä¸€æ­¥çš„ç»„åˆä¼˜åŒ–é—®é¢˜ã€‚åœ¨è¿™é¡¹å·¥ä½œä¸­ï¼Œæˆ‘ä»¬è®¨è®ºäº†æ¡†æ¶çš„ç»“æ„ï¼Œå¹¶å±•ç¤ºäº†åœ¨é«˜ä¿çœŸä»¿çœŸç¯å¢ƒä¸­è·å¾—çš„ç»“æœã€‚æ­¤å¤–ï¼Œè¿˜åŒ…æ‹¬å¯¹ç³»ç»Ÿä¸­å®ç°çš„ç»™å®šç»„åˆé—®é¢˜çš„ä¸‰ç§ä¸åŒä¼˜åŒ–ç®—æ³•çš„æ€§èƒ½çš„æ¯”è¾ƒç ”ç©¶ï¼Œå³ Kuhn-Munkresã€Jonker-Volgenant å’Œ Gale-Shapleyã€‚ç»“æœè¡¨æ˜ï¼Œå°±æœ€å°æˆæœ¬è€Œè¨€ï¼Œä½¿ç”¨ Kuhn-Munkres æˆ– Jonker-Volgenant æ–¹æ³•å¯ä»¥è·å¾—æœ€ä½³åˆ†é…ç»“æœæ€§èƒ½ï¼Œè€Œ Gale-Shapley ç®—æ³•åœ¨æœ€å°æˆæœ¬ä¸æ˜¯æœ€é«˜ä¼˜å…ˆçº§çš„æƒ…å†µä¸‹åœ¨æ—¶é—´æ•ˆç‡æ–¹é¢å…·æœ‰ä¼˜åŠ¿ã€‚ Published in: 2019 Workshop on Research, Education and Development of Unmanned Aerial Systems (RED UAS) å‘å¸ƒäºï¼š 2019 å¹´æ— äººæœºç³»ç»Ÿç ”ç©¶ã€æ•™è‚²å’Œå¼€å‘ç ”è®¨ä¼š ï¼ˆRED UASï¼‰ "},"Learn/LearnDrones/TaskAssignment/2020.08-Energy_Efficient_Task_Cooperation_for_Multi-UAV_Networks:_A_Coalition_Formation_Game_Approach.html":{"url":"Learn/LearnDrones/TaskAssignment/2020.08-Energy_Efficient_Task_Cooperation_for_Multi-UAV_Networks:_A_Coalition_Formation_Game_Approach.html","title":"2020 Energy Efficient Task Cooperation for Multi-UAV Networks: A Coalition Formation Game Approach","keywords":"","body":"Energy Efficient Task Cooperation for Multi-UAV Networks: A Coalition Formation Game Approach å¤šæ— äººæœºç½‘ç»œçš„èŠ‚èƒ½ä»»åŠ¡åˆä½œï¼šè”ç›Ÿå½¢æˆåšå¼ˆæ–¹æ³• ieeexplore Published in: IEEE Access ( Volume: 8) Heyu Luan; Yitao Xu; Dianxiong Liu; Zhiyong Du; Huiming Qian; Xiaodu Liu é¸¾å’Œé›¨;å¾ä¸€æ¶›;åˆ˜æ®¿é›„;æœå¿—å‹‡;é’±æ…§æ˜;åˆ˜æ™“éƒ½ 1 College of Communications Engineering, Army of PLA, Nanjing 210000, China 2 Academy of Military Science, Beijing 100036, China 3 College of Information and Communication, National University of Defense Technology, Wuhan 430010, China 4 PLA 32369 Troops, Beijing 100000, China 2020.08.12 38 citations Abstract: In this paper, we study the multi-task cooperation problem for unmanned aerial vehicle (UAV) swarms, where the UAV energy consumption is taken into consideration during location scheduling and task implementation. One task may need the cooperation of several UAVs with specific capabilities. To avoid unreasonable task allocation, we quantify the mission properties of UAVs and task areas. We comprehensively consider the overlapping and complementary relationship of the UAV's task types, so that UAVs can form corresponding collective execution tasks according to the task attributes. Based on the coalition game theory, we model the distributed task assignment problem of UAVs as a coalition formation game (CFG). We propose a task allocation algorithm, and then prove that it can achieve the joint optimization of energy and task completion by decision-making of UAVs in finite iterations. With the equilibrium properties of coalition formation in UAV networks, we further optimize the position of UAVs to minimize the network energy consumption. Simulation results verify that the proposed method can reduce the flight loss with high task completion degree. åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬ç ”ç©¶äº†æ— äººæœº ï¼ˆUAVï¼‰ é›†ç¾¤çš„å¤šä»»åŠ¡åä½œé—®é¢˜ï¼Œå…¶ä¸­åœ¨ä½ç½®è°ƒåº¦å’Œä»»åŠ¡å®æ–½è¿‡ç¨‹ä¸­è€ƒè™‘äº†æ— äººæœºèƒ½è€—ã€‚ä¸€é¡¹ä»»åŠ¡å¯èƒ½éœ€è¦å‡ æ¶å…·æœ‰ç‰¹å®šèƒ½åŠ›çš„æ— äººæœºçš„åˆä½œã€‚ä¸ºé¿å…ä¸åˆç†çš„ä»»åŠ¡åˆ†é…ï¼Œæˆ‘ä»¬å¯¹æ— äººæœºå’Œä»»åŠ¡åŒºçš„ä»»åŠ¡å±æ€§è¿›è¡Œäº†é‡åŒ–ã€‚æˆ‘ä»¬ç»¼åˆè€ƒè™‘äº†æ— äººæœºä»»åŠ¡ç±»å‹çš„é‡å å’Œäº’è¡¥å…³ç³»ï¼Œä½¿æ— äººæœºèƒ½å¤Ÿæ ¹æ®ä»»åŠ¡å±æ€§å½¢æˆç›¸åº”çš„é›†ä½“æ‰§è¡Œä»»åŠ¡ã€‚åŸºäºè”ç›Ÿåšå¼ˆè®ºï¼Œæˆ‘ä»¬å°†æ— äººæœºçš„åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…é—®é¢˜å»ºæ¨¡ä¸ºè”ç›Ÿå½¢æˆåšå¼ˆ ï¼ˆCFGï¼‰ã€‚æˆ‘ä»¬æå‡ºäº†ä¸€ç§ä»»åŠ¡åˆ†é…ç®—æ³•ï¼Œè¿›è€Œè¯æ˜å®ƒå¯ä»¥é€šè¿‡æ— äººæœºçš„æœ‰é™è¿­ä»£å†³ç­–æ¥å®ç°èƒ½é‡çš„è”åˆä¼˜åŒ–å’Œä»»åŠ¡å®Œæˆã€‚åˆ©ç”¨æ— äººæœºç½‘ç»œä¸­è”ç›Ÿå½¢æˆçš„å‡è¡¡ç‰¹æ€§ï¼Œæˆ‘ä»¬è¿›ä¸€æ­¥ä¼˜åŒ–äº†æ— äººæœºçš„ä½ç½®ï¼Œä»¥æœ€å¤§é™åº¦åœ°é™ä½ç½‘ç»œèƒ½è€—ã€‚ä»¿çœŸç»“æœéªŒè¯äº†æ‰€ææ–¹æ³•èƒ½å¤Ÿåœ¨ä»»åŠ¡å®Œæˆåº¦é«˜çš„æƒ…å†µä¸‹é™ä½é£è¡ŒæŸå¤±ã€‚ Introduction Therefore, we propose an energy-efficient task cooperation scheme for heterogeneous multi-UAV in view of cooperative task assignment and energy optimization of heterogeneous UAVs. Firstly, a task relationship model is proposed to quantify the task attribute of ground task areas, the capabilities of UAVs in terms of task types they can run, in order to define a general satisfaction function to quantify the task completion degree. Then, the energy consumption model is proposed to account for the energy loss during flight and hovering stages. å› æ­¤ï¼Œä»å¼‚æ„æ— äººæœºååŒä»»åŠ¡åˆ†é…å’Œèƒ½é‡ä¼˜åŒ–çš„è§’åº¦ï¼Œæˆ‘ä»¬æå‡ºä¸€ç§å¼‚æ„å¤šæ— äººæœºèŠ‚èƒ½ä»»åŠ¡åä½œæ–¹æ¡ˆã€‚é¦–å…ˆï¼Œæå‡ºä»»åŠ¡å…³ç³»æ¨¡å‹æ¥é‡åŒ–åœ°é¢ä»»åŠ¡åŒºåŸŸçš„ä»»åŠ¡å±æ€§ã€æ— äººæœºå¯è¿è¡Œçš„ä»»åŠ¡ç±»å‹çš„èƒ½åŠ›ï¼Œä»è€Œå®šä¹‰é€šç”¨çš„æ»¡æ„åº¦å‡½æ•°æ¥é‡åŒ–ä»»åŠ¡å®Œæˆç¨‹åº¦ã€‚ç„¶åï¼Œæå‡ºäº†èƒ½é‡æ¶ˆè€—æ¨¡å‹æ¥è§£é‡Šé£è¡Œå’Œæ‚¬åœé˜¶æ®µçš„èƒ½é‡æŸå¤±ã€‚ To achieve automatic and self-organizing task cooperation with energy constraints, we establish a distributed task assignment model for UAVs based on the coalition formation game (CFG) [14]â€“â€‹[17]. Aiming at characteristics of cooperation and complementary relationships among UAVs brought by location and mission attributes, we develop the coalition formation game with the peer effects among UAVs [18]â€“â€‹[20]. We propose the coalition formation algorithm based on cooperation rule, where coalition merge rules and coalition split rules are designed. Moreover, we prove the convergence of the algorithm based on the potential game theory [21]â€“â€‹[23]. The contributions of this paper are summarized as follows: ä¸ºäº†å®ç°èƒ½é‡çº¦æŸä¸‹çš„è‡ªåŠ¨è‡ªç»„ç»‡ä»»åŠ¡åä½œï¼Œå»ºç«‹äº†åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆï¼ˆCFGï¼‰çš„æ— äººæœºåˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…æ¨¡å‹ [14] â€“â€‹ [17] ã€‚é’ˆå¯¹ä½ç½®å’Œä»»åŠ¡å±æ€§å¸¦æ¥çš„æ— äººæœºé—´åˆä½œå’Œäº’è¡¥å…³ç³»çš„ç‰¹ç‚¹ï¼Œå¼€å‘äº†æ— äººæœºé—´åŒä¼´æ•ˆåº”çš„è”ç›Ÿå½¢æˆåšå¼ˆ [18] â€“â€‹ [20] ã€‚æˆ‘ä»¬æå‡ºäº†åŸºäºåˆä½œè§„åˆ™çš„è”ç›Ÿå½¢æˆç®—æ³•ï¼Œè®¾è®¡äº†è”ç›Ÿåˆå¹¶è§„åˆ™å’Œè”ç›Ÿåˆ†è£‚è§„åˆ™ã€‚å¹¶åŸºäºåŠ¿åšå¼ˆç†è®ºè¯æ˜äº†ç®—æ³•çš„æ”¶æ•›æ€§ [21] â€“â€‹ [23] ã€‚æœ¬æ–‡çš„è´¡çŒ®æ€»ç»“å¦‚ä¸‹ï¼š We study the problem of UAV assignment in multi-UAV and multi-task scenario. The UAVsâ€™ task types, energy loss and the time of performing tasks are considered to improve the task completion degree in the task area while reducing the energy loss of UAVs. æˆ‘ä»¬ç ”ç©¶å¤šæ— äººæœºã€å¤šä»»åŠ¡åœºæ™¯ä¸‹çš„æ— äººæœºåˆ†é…é—®é¢˜ã€‚ç»¼åˆè€ƒè™‘æ— äººæœºçš„ä»»åŠ¡ç±»å‹ã€èƒ½é‡æŸè€—ä»¥åŠæ‰§è¡Œä»»åŠ¡çš„æ—¶é—´ï¼Œåœ¨é™ä½æ— äººæœºèƒ½é‡æŸè€—çš„åŒæ—¶ï¼Œæé«˜ä»»åŠ¡åŒºåŸŸçš„ä»»åŠ¡å®Œæˆåº¦ã€‚ We define a quantitative amount for each type of task. The definition of task completion degree includes the task performing time and the implementation of all types of tasks in the task areas. æˆ‘ä»¬ä¸ºæ¯ç§ç±»å‹çš„ä»»åŠ¡å®šä¹‰äº†ä¸€ä¸ªæ•°é‡ã€‚ä»»åŠ¡å®Œæˆåº¦çš„å®šä¹‰åŒ…æ‹¬ä»»åŠ¡æ‰§è¡Œæ—¶é—´å’Œä»»åŠ¡åŒºåŸŸå†…å„ç±»ä»»åŠ¡çš„æ‰§è¡Œæƒ…å†µã€‚ The coalition formation game is applied to the task assignment scenario of UAVs, and a coalition formation algorithm based on cooperative rule is proposed. The overlapping and complementary relationships of UAVsâ€™ tasks are considered, which can reduce the energy loss of the UAVs and improve the task completion degree in the task area. å°†è”ç›Ÿå½¢æˆåšå¼ˆåº”ç”¨äºæ— äººæœºä»»åŠ¡åˆ†é…åœºæ™¯ï¼Œæå‡ºä¸€ç§åŸºäºåˆä½œè§„åˆ™çš„è”ç›Ÿå½¢æˆç®—æ³•ã€‚è€ƒè™‘æ— äººæœºä»»åŠ¡çš„é‡å å’Œäº’è¡¥å…³ç³»ï¼Œå¯ä»¥å‡å°‘æ— äººæœºçš„èƒ½é‡æŸå¤±ï¼Œæé«˜ä»»åŠ¡åŒºåŸŸå†…çš„ä»»åŠ¡å®Œæˆåº¦ã€‚ With the equilibrium properties of coalition formation in UAV networks, we further optimize the position of UAVs within the task coverage to minimize the network energy consumption. åˆ©ç”¨æ— äººæœºç½‘ç»œä¸­è”ç›Ÿå½¢æˆçš„å‡è¡¡ç‰¹æ€§ï¼Œæˆ‘ä»¬è¿›ä¸€æ­¥ä¼˜åŒ–æ— äººæœºåœ¨ä»»åŠ¡è¦†ç›–èŒƒå›´å†…çš„ä½ç½®ï¼Œä»¥æœ€å°åŒ–ç½‘ç»œèƒ½è€—ã€‚ Related Work 1) Coalition Formation Game Theory è”ç›Ÿå½¢æˆåšå¼ˆè®º This paper focuses on the problem of task cooperation and mutual influence among multiple UAVs. Because the game theory is an effective tool to solve the problem of resource optimization in distributed systems [24], [25], an appropriate coalition formation game was used in this paper to model the task assignment problem of UAVs. æœ¬æ–‡é‡ç‚¹ç ”ç©¶å¤šæ— äººæœºä¹‹é—´çš„ä»»åŠ¡åä½œå’Œç›¸äº’å½±å“é—®é¢˜ã€‚å› ä¸ºåšå¼ˆè®ºæ˜¯è§£å†³åˆ†å¸ƒå¼ç³»ç»Ÿèµ„æºä¼˜åŒ–é—®é¢˜çš„æœ‰æ•ˆå·¥å…· [24] , [25] ï¼Œæœ¬æ–‡ä½¿ç”¨é€‚å½“çš„è”ç›Ÿå½¢æˆåšå¼ˆæ¥æ¨¡æ‹Ÿæ— äººæœºçš„ä»»åŠ¡åˆ†é…é—®é¢˜ã€‚ Coalition formation game can accurately and completely describe the cooperative relationships among users in sharing networks. In [16], the authors proposed a context-aware group buying mechanism to reduce usersâ€™ data costs based on the coalition formation game. In [26], coalition formation game theory is used to obtain a solution to a resource allocation problem for a team of UAVs prosecuting a target. In [27], the authors proposed a reputation-based mechanism for coalition formation aiming to complete the designated tasks with minimal resource utilization. In [28], the authors studied the data clustering scheme based on the coalition formation game to improve the data collection efficiency in UAV-enabled wireless sensor networks. è”ç›Ÿå½¢æˆåšå¼ˆèƒ½å¤Ÿå‡†ç¡®ã€å®Œæ•´åœ°æè¿°å…±äº«ç½‘ç»œä¸­ç”¨æˆ·ä¹‹é—´çš„åˆä½œå…³ç³»ã€‚åœ¨ [16] è®ºæ–‡ä¸­ï¼Œä½œè€…æå‡ºäº†ä¸€ç§åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„æƒ…å¢ƒæ„ŸçŸ¥å›¢è´­æœºåˆ¶ï¼Œä»¥é™ä½ç”¨æˆ·çš„æ•°æ®æˆæœ¬ã€‚åœ¨ [26] ï¼Œè”ç›Ÿå½¢æˆåšå¼ˆè®ºç”¨äºè·å¾—æ— äººæœºå›¢é˜Ÿèµ·è¯‰ç›®æ ‡çš„èµ„æºåˆ†é…é—®é¢˜çš„è§£å†³æ–¹æ¡ˆã€‚åœ¨ [27] ï¼Œä½œè€…æå‡ºäº†ä¸€ç§åŸºäºå£°èª‰çš„è”ç›Ÿå½¢æˆæœºåˆ¶ï¼Œæ—¨åœ¨ä»¥æœ€å°çš„èµ„æºåˆ©ç”¨ç‡å®ŒæˆæŒ‡å®šçš„ä»»åŠ¡ã€‚åœ¨ [28] ï¼Œä½œè€…ç ”ç©¶äº†åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„æ•°æ®èšç±»æ–¹æ¡ˆï¼Œä»¥æé«˜æ— äººæœºæ— çº¿ä¼ æ„Ÿå™¨ç½‘ç»œçš„æ•°æ®æ”¶é›†æ•ˆç‡ã€‚ Based on the existing work, an appropriate coalition formation game with peer effects is developed in this paper to model the task assignment problem of UAVs. åŸºäºç°æœ‰å·¥ä½œï¼Œæœ¬æ–‡å¼€å‘äº†ä¸€ç§å…·æœ‰åŒä¼´æ•ˆåº”çš„é€‚å½“è”ç›Ÿå½¢æˆåšå¼ˆæ¥æ¨¡æ‹Ÿæ— äººæœºçš„ä»»åŠ¡åˆ†é…é—®é¢˜ã€‚ 2) Energy Consumption Model èƒ½æºæ¶ˆè€—æ¨¡å‹ The endurance and performance of UAV systems are fundamentally limited by the on-board energy, which is practically finite due to the aircraftâ€™s size and weight constraints [29]. Thus, energy consumption should be an important concern for UAV task cooperation [30]. æ— äººæœºç³»ç»Ÿçš„ç»­èˆªèƒ½åŠ›å’Œæ€§èƒ½ä»æ ¹æœ¬ä¸Šå—åˆ°æœºè½½èƒ½é‡çš„é™åˆ¶ï¼Œè€Œç”±äºé£æœºçš„å°ºå¯¸å’Œé‡é‡é™åˆ¶ï¼Œæœºè½½èƒ½é‡å®é™…ä¸Šæ˜¯æœ‰é™çš„ [29] ã€‚å› æ­¤ï¼Œèƒ½æºæ¶ˆè€—åº”æˆä¸ºæ— äººæœºä»»åŠ¡åä½œçš„é‡è¦å…³æ³¨ç‚¹ [30] ã€‚ In [31], The authors investigated an uplink power control problem for UAV-assisted wireless communications. The flying altitude, antenna bandwidth and location of UAVs, as well as allocated bandwidth of ground terminals were jointly optimized to achieve good performance in uplink sum power saving. In [32], the authors considered the jointly optimizing user association, power control, computation capacity allocation, and location planning in a mobile edge computing network with multiple UAVs to minimize the total power effectively. In [33], the authors formulated the energy minimization problem by jointly optimizing the UAV trajectory and communication time allocation among ground nodes. In [34], the author considered the problem of high-efficiency coverage deployment of UAVs and controlled the launch power of UAVs to achieve the purpose of energy conservation. In [35], an efficient algorithm was proposed for maximizing the UAVâ€™s energy efficiency with general constraints on the trajectory. åœ¨ [31] ï¼Œä½œè€…ç ”ç©¶äº†æ— äººæœºè¾…åŠ©æ— çº¿é€šä¿¡çš„ä¸Šè¡Œé“¾è·¯åŠŸç‡æ§åˆ¶é—®é¢˜ã€‚å¯¹æ— äººæœºçš„é£è¡Œé«˜åº¦ã€å¤©çº¿å¸¦å®½å’Œä½ç½®ä»¥åŠåœ°é¢ç»ˆç«¯çš„åˆ†é…å¸¦å®½è¿›è¡Œè”åˆä¼˜åŒ–ï¼Œåœ¨ä¸Šè¡Œæ€»çœç”µæ–¹é¢å–å¾—äº†è‰¯å¥½çš„æ•ˆæœã€‚åœ¨ [32] ï¼Œä½œè€…è€ƒè™‘äº†åœ¨å…·æœ‰å¤šä¸ªæ— äººæœºçš„ç§»åŠ¨è¾¹ç¼˜è®¡ç®—ç½‘ç»œä¸­è”åˆä¼˜åŒ–ç”¨æˆ·å…³è”ã€åŠŸç‡æ§åˆ¶ã€è®¡ç®—èƒ½åŠ›åˆ†é…å’Œä½ç½®è§„åˆ’ï¼Œä»¥æœ‰æ•ˆåœ°æœ€å°åŒ–æ€»åŠŸç‡ã€‚åœ¨ [33] ï¼Œä½œè€…é€šè¿‡è”åˆä¼˜åŒ–æ— äººæœºè½¨è¿¹å’Œåœ°é¢èŠ‚ç‚¹ä¹‹é—´çš„é€šä¿¡æ—¶é—´åˆ†é…ï¼Œæå‡ºäº†èƒ½é‡æœ€å°åŒ–é—®é¢˜ã€‚åœ¨ [34] ç¬”è€…è€ƒè™‘äº†æ— äººæœºé«˜æ•ˆè¦†ç›–éƒ¨ç½²çš„é—®é¢˜ï¼Œé€šè¿‡æ§åˆ¶æ— äººæœºçš„å‘å°„åŠŸç‡æ¥è¾¾åˆ°èŠ‚èƒ½çš„ç›®çš„ã€‚åœ¨ [35] ï¼Œæå‡ºäº†ä¸€ç§æœ‰æ•ˆçš„ç®—æ³•ï¼Œç”¨äºåœ¨è½¨è¿¹çš„ä¸€èˆ¬çº¦æŸä¸‹æœ€å¤§åŒ–æ— äººæœºçš„èƒ½é‡æ•ˆç‡ã€‚ In this paper, we take the energy consumption of UAVs as part of the optimization in the process of the task assignment, which is important for the energy efficiency of task execution. æœ¬æ–‡å°†æ— äººæœºçš„èƒ½è€—ä½œä¸ºä»»åŠ¡åˆ†é…è¿‡ç¨‹ä¸­ä¼˜åŒ–çš„ä¸€éƒ¨åˆ†ï¼Œè¿™å¯¹äºä»»åŠ¡æ‰§è¡Œçš„èƒ½æºæ•ˆç‡å…·æœ‰é‡è¦æ„ä¹‰ã€‚ "},"Learn/LearnDrones/TaskAssignment/2022.06-Task_assignment_algorithms_for_unmanned_aerial_vehicle_networks_A_comprehensive_survey.html":{"url":"Learn/LearnDrones/TaskAssignment/2022.06-Task_assignment_algorithms_for_unmanned_aerial_vehicle_networks_A_comprehensive_survey.html","title":"2022.06 Task_assignment_algorithms_for_unmanned_aerial_vehicle_networks_A_comprehensive_survey","keywords":"","body":"Task assignment algorithms for unmanned aerial vehicle networks: A comprehensive survey 2022.06 æ— äººæœºç½‘ç»œçš„ä»»åŠ¡åˆ†é…ç®—æ³•: å…¨é¢çš„ç»¼è¿° Department of Computer Engineering, Chosun University, Gwangju 61452, South Korea è®¡ç®—æœºå·¥ç¨‹å­¦é™¢ï¼Œæœé²œå¤§å­¦ï¼ŒéŸ©å›½å…‰å· 61452 Vehicular Communications sciencedirect doi Abstract Unmanned aerial vehicles (UAVs) have significant prospects in a plethora of public and civic spheres. Recently, UAVs have focused primarily on applications where human presence is either impossible or hazardous. A swarm of small UAVs can cooperatively complete operations more proficiently and economically than a single large UAV. However, many issues must be resolved before stable and reliable multi-UAV networks can be realized. Task assignment in fleets of UAVs is concerned with cooperative decision-making and control. UAVs possess various functional abilities and kinematic constraints while carrying limited resources onboard. UAVs are nominated to execute multiple sequential tasks supportively on numerous ground targets. The prime objective of task assignment is to minimalize the task accomplishment time and UAV energy consumption. To date, several task assignment algorithms have been designed for UAV networks, and they are comprehensively surveyed in this paper in terms of their main ideas, operational features, advantages, and limitations. These task assignment algorithms are then compared in terms of their significant characteristics and performance factors. To the best of the authors' knowledge, no survey on task assignment techniques for different UAV missions currently exists in the literature. We also discuss open issues and challenges and then suggest projections for task assignment algorithms concerning possible future directions. æ— äººæœºï¼ˆUAVï¼‰åœ¨ä¼—å¤šå…¬å…±å’Œå…¬æ°‘é¢†åŸŸå…·æœ‰å¹¿é˜”çš„å‰æ™¯ã€‚æœ€è¿‘ï¼Œæ— äººæœºä¸»è¦å…³æ³¨äººç±»ä¸å¯èƒ½å­˜åœ¨æˆ–å­˜åœ¨å±é™©çš„åº”ç”¨ã€‚ä¸€ç¾¤å°å‹æ— äººæœºå¯ä»¥æ¯”å•ä¸ªå¤§å‹æ— äººæœºæ›´é«˜æ•ˆã€æ›´ç»æµåœ°ååŒå®Œæˆè¡ŒåŠ¨ã€‚ç„¶è€Œï¼Œè¦å®ç°ç¨³å®šå¯é çš„å¤šæ— äººæœºç½‘ç»œï¼Œè¿˜å¿…é¡»è§£å†³è®¸å¤šé—®é¢˜ã€‚æ— äººæœºæœºé˜Ÿçš„ä»»åŠ¡åˆ†é…æ¶‰åŠåä½œå†³ç­–å’Œæ§åˆ¶ã€‚æ— äººæœºå…·æœ‰å¤šç§åŠŸèƒ½å’Œè¿åŠ¨å­¦é™åˆ¶ï¼Œä½†æœºè½½èµ„æºæœ‰é™ã€‚æ— äººæœºè¢«æŒ‡å®šåœ¨ä¼—å¤šåœ°é¢ç›®æ ‡ä¸Šæ‰§è¡Œå¤šé¡¹è¿ç»­ä»»åŠ¡ã€‚ä»»åŠ¡åˆ†é…çš„é¦–è¦ç›®æ ‡æ˜¯æœ€å°åŒ–ä»»åŠ¡å®Œæˆæ—¶é—´å’Œæ— äººæœºèƒ½è€—ã€‚è¿„ä»Šä¸ºæ­¢ï¼Œå·²ç»è®¾è®¡äº†å‡ ç§é’ˆå¯¹æ— äººæœºç½‘ç»œçš„ä»»åŠ¡åˆ†é…ç®—æ³•ï¼Œæœ¬æ–‡å¯¹å®ƒä»¬çš„ä¸»è¦æ€æƒ³ã€æ“ä½œç‰¹ç‚¹ã€ä¼˜ç‚¹å’Œå±€é™æ€§è¿›è¡Œäº†å…¨é¢çš„ç»¼è¿°ã€‚ç„¶åå¯¹è¿™äº›ä»»åŠ¡åˆ†é…ç®—æ³•çš„æ˜¾ç€ç‰¹å¾å’Œæ€§èƒ½å› ç´ è¿›è¡Œæ¯”è¾ƒã€‚æ®ä½œè€…æ‰€çŸ¥ï¼Œç›®å‰æ–‡çŒ®ä¸­è¿˜æ²¡æœ‰é’ˆå¯¹ä¸åŒæ— äººæœºä»»åŠ¡çš„ä»»åŠ¡åˆ†é…æŠ€æœ¯çš„è°ƒæŸ¥ã€‚æˆ‘ä»¬è¿˜è®¨è®ºäº†æ‚¬è€Œæœªå†³çš„é—®é¢˜å’ŒæŒ‘æˆ˜ï¼Œç„¶åå°±æœ‰å…³æœªæ¥å¯èƒ½æ–¹å‘çš„ä»»åŠ¡åˆ†é…ç®—æ³•æå‡ºäº†é¢„æµ‹ã€‚ Keywords å…³é”®è¯ Unmanned aerial vehicle; Multi-UAV networks; UAV autonomy; Task assignment; Task coordination; Heterogeneity; æ— äººæœº å¤šæ— äººæœºç½‘ç»œ æ— äººæœºè‡ªä¸»æ€§ ä»»åŠ¡åˆ†é… ä»»åŠ¡åè°ƒ å¼‚è´¨æ€§ Introduction Challanges Motivation Contribution of the study Organization of the paper Overviw of existing surveys on UAVs and our contributions Considerations fo UAV task assignment Single- and multi-UAV systems Classification of UAVs Background study Design issues for task assignment algorithm Multi-UAV system formation Computational complexity Collision-free UAV operation Backhaul network Uniform load balancing Antenna designs Task Assignment Algorithms Centralized task assignment algorithms Distributed task assignment algorithms Bio-inspired task assignment algorithms Comparsion of task assignment algorithms for UAVs Open issues, research challenges, and future directions Conclusion 1. Introduction 1. ç®€ä»‹ The remarkable and prompt growth of unmanned aerial vehicles (UAVs) in many different applications has recently fascinated many researchers and operators. The incorporation of UAVs is noticeable in such applications, which are either dangerous or impossible for a human. UAVs can be deployed quickly and easily, possess high maneuverability, are cost-efficient, have the self-organizing ability, and are flexible and scalable. Hence, UAVs have received momentous consideration for civil and military applications. The applications of UAVs include but are not limited to emergency and crisis management [1], [2], [3], search and rescue operations in disastrous environments [4], [5], monitoring agricultural fields [6], post-disaster operations [7], remote sensing [8], [9], wildfire monitoring [10], traffic monitoring [11], freight transportation [12], and relay networks [13], [14], [15]. In the present day, UAVs have also shown wide use in pandemic environments to enforce social distancing [16], spread disinfectants in infected areas [17], carry testing kits and other medical supplies [18], and more. UAVs communication can be distinguished from other ad-hoc communication in the following ways: a) dynamic channel for air-to-air (A2A) and air-to-ground (A2G) propagations; b) spatial as well as temporal inconsistencies induced by high UAV mobility; c) shadowing effect due to design structure and rotation of UAV. UAVs of different sizes and specifications are available. Generally, single-UAV-based applications prefer large UAVs with higher abilities, while small UAVs are chosen for UAV formations and swarms. A multi-UAV operation scenario is illustrated in Fig. 1 and is expected to increase significantly in the future. As shown in the figure, several UAVs are assigned different tasks and are supposed to execute tasks with proper coordination with other UAVs. æ— äººæœºï¼ˆUAVï¼‰åœ¨ä¼—å¤šä¸åŒåº”ç”¨ä¸­çš„æ˜¾è‘—ä¸”è¿…é€Ÿå¢é•¿æœ€è¿‘å¸å¼•äº†ä¼—å¤šç ”ç©¶äººå‘˜å’Œæ“ä½œè€…çš„å…´è¶£ã€‚æ— äººæœºåœ¨è¿™äº›åº”ç”¨ä¸­çš„èå…¥å°¤ä¸ºæ˜æ˜¾ï¼Œè¿™äº›åº”ç”¨è¦ä¹ˆå±é™©ï¼Œè¦ä¹ˆå¯¹äººç±»æ¥è¯´ä¸å¯èƒ½ã€‚æ— äººæœºå¯ä»¥å¿«é€Ÿã€è½»æ¾åœ°éƒ¨ç½²ï¼Œå…·æœ‰é«˜æœºåŠ¨æ€§ï¼Œæˆæœ¬ä½å»‰ï¼Œå…·æœ‰è‡ªç»„ç»‡èƒ½åŠ›ï¼Œä¸”çµæ´»å¯æ‰©å±•ã€‚å› æ­¤ï¼Œæ— äººæœºåœ¨æ°‘ç”¨å’Œå†›äº‹åº”ç”¨ä¸­å—åˆ°äº†æå¤§çš„å…³æ³¨ã€‚æ— äººæœºåº”ç”¨åŒ…æ‹¬ä½†ä¸é™äºç´§æ€¥å’Œå±æœºç®¡ç†[1]ã€[2]ã€[3]ã€ç¾éš¾ç¯å¢ƒä¸­çš„æœæ•‘è¡ŒåŠ¨[4]ã€[5]ã€ç›‘æµ‹å†œç”°[6]ã€ç¾åè¡ŒåŠ¨[7]ã€é¥æ„Ÿ[8]ã€[9]ã€é‡ç«ç›‘æµ‹[10]ã€äº¤é€šç›‘æ§[11]ã€è´§ç‰©è¿è¾“[12]å’Œæ¥åŠ›ç½‘ç»œ[13]ã€[14]ã€[15]ã€‚åœ¨å½“ä»Šæ—¶ä»£ï¼Œæ— äººæœºåœ¨ç–«æƒ…ç¯å¢ƒä¸­ä¹Ÿæ˜¾ç¤ºå‡ºå¹¿æ³›çš„åº”ç”¨ï¼Œä»¥æ‰§è¡Œç¤¾äº¤è·ç¦»[16]ã€åœ¨æ„ŸæŸ“åŒºåŸŸå–·æ´’æ¶ˆæ¯’å‰‚[17]ã€æºå¸¦æ£€æµ‹å¥—ä»¶å’Œå…¶ä»–åŒ»ç–—ç”¨å“[18]ç­‰ã€‚ æ— äººæœºé€šä¿¡å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼ä¸å…¶ä»–ä¸´æ—¶é€šä¿¡åŒºåˆ†å¼€æ¥ï¼š aï¼‰åŠ¨æ€ä¿¡é“ç”¨äºç©ºå¯¹ç©ºï¼ˆA2Aï¼‰å’Œç©ºå¯¹åœ°ï¼ˆA2Gï¼‰ä¼ æ’­ï¼› bï¼‰ç”±äºé«˜æ— äººæœºç§»åŠ¨æ€§å¼•èµ·çš„æ—¶é—´å’Œç©ºé—´ä¸ä¸€è‡´æ€§ï¼› cï¼‰ç”±äºæ— äººæœºè®¾è®¡ç»“æ„å’Œæ—‹è½¬äº§ç”Ÿçš„é˜´å½±æ•ˆåº”ã€‚ ä¸åŒå°ºå¯¸å’Œè§„æ ¼çš„æ— äººæœºå¯ä¾›é€‰æ‹©ã€‚é€šå¸¸ï¼ŒåŸºäºå•æ¶æ— äººæœºçš„åº”ç”¨æ›´å€¾å‘äºé€‰æ‹©èƒ½åŠ›æ›´å¼ºçš„å¤§å‹æ— äººæœºï¼Œè€Œå°å‹æ— äººæœºåˆ™ç”¨äºæ— äººæœºç¼–é˜Ÿå’Œé›†ç¾¤ã€‚å›¾ 1 å±•ç¤ºäº†å¤šæ¶æ— äººæœºæ“ä½œåœºæ™¯ï¼Œé¢„è®¡æœªæ¥å°†æ˜¾è‘—å¢åŠ ã€‚å¦‚å›¾æ‰€ç¤ºï¼Œå‡ æ¶æ— äººæœºè¢«åˆ†é…ä¸åŒçš„ä»»åŠ¡ï¼Œå¹¶åº”ä¸å…¶ä»–æ— äººæœºè¿›è¡Œé€‚å½“çš„åè°ƒä»¥æ‰§è¡Œä»»åŠ¡ã€‚ 1.1. Challenges of UAV networks 1.1. æ— äººæœºç½‘ç»œçš„æŒ‘æˆ˜ The progress made in microchip technology has helped widen the application range of UAVs [19]. Though the UAV network has been promising, some challenges need to be resolved for effective UAVs based on reliable networks. Significant research has been done in the literature that analyzes the challenges and prospects for successful UAVs operations. In [20], [21], a study focusing on the challenges faced by UAVs during deployment, interference, UAV-based relaying, regulations, energy consumption, collision avoidance, and security is made. Various challenges regarding spectral efficiency in multi-UAVs operations are reviewed in [22]. Different issues faced in UAV communication, i.e., routing, handover, and energy efficiency, are deliberated in [23]. Furthermore, some studies have focused on UAVs and UAV-based communications, and state-of-the-art works consider UAVs' particular domain or efficacy [24], [25]. UAV flights can be understood as several degrees of autonomy. Obtaining autonomy for UAVs is a complicated issue, and the complication level depends on different phases in the decision-making process and the necessary level of cooperation between UAVs [26], [27]. å¾®èŠ¯ç‰‡æŠ€æœ¯çš„è¿›æ­¥æœ‰åŠ©äºæ‰©å¤§æ— äººæœºï¼ˆUAVsï¼‰çš„åº”ç”¨èŒƒå›´[19]ã€‚å°½ç®¡æ— äººæœºç½‘ç»œå‰æ™¯å¹¿é˜”ï¼Œä½†ä¸ºäº†å®ç°åŸºäºå¯é ç½‘ç»œçš„æ— äººæœºæœ‰æ•ˆè¿è¡Œï¼Œä»éœ€è§£å†³ä¸€äº›æŒ‘æˆ˜ã€‚æ–‡çŒ®ä¸­å·²å¯¹æˆåŠŸæ— äººæœºæ“ä½œçš„æŒ‘æˆ˜å’Œå‰æ™¯è¿›è¡Œäº†å¤§é‡ç ”ç©¶ã€‚åœ¨[20]ã€[21]ä¸­ï¼Œå¯¹æ— äººæœºéƒ¨ç½²ã€å¹²æ‰°ã€åŸºäºæ— äººæœºçš„ä¸­ç»§ã€æ³•è§„ã€èƒ½è€—ã€é¿éšœå’Œå®‰å…¨ç­‰æ–¹é¢é¢ä¸´çš„æŒ‘æˆ˜è¿›è¡Œäº†ç ”ç©¶ã€‚åœ¨[22]ä¸­ï¼Œå›é¡¾äº†å¤šæ— äººæœºæ“ä½œä¸­å…³äºé¢‘è°±æ•ˆç‡çš„å„ç§æŒ‘æˆ˜ã€‚åœ¨[23]ä¸­ï¼Œè®¨è®ºäº†æ— äººæœºé€šä¿¡ä¸­é¢ä¸´çš„ä¸åŒé—®é¢˜ï¼Œå³è·¯ç”±ã€åˆ‡æ¢å’Œèƒ½æ•ˆã€‚æ­¤å¤–ï¼Œä¸€äº›ç ”ç©¶ä¸“æ³¨äºæ— äººæœºåŠå…¶åŸºäºæ— äººæœºçš„é€šä¿¡ï¼Œè€Œæœ€å…ˆè¿›çš„å·¥ä½œåˆ™è€ƒè™‘äº†æ— äººæœºç‰¹å®šçš„é¢†åŸŸæˆ–åŠŸæ•ˆ[24]ã€[25]ã€‚æ— äººæœºé£è¡Œå¯ä»¥ç†è§£ä¸ºå‡ ä¸ªçº§åˆ«çš„è‡ªä¸»æ€§ã€‚ä¸ºæ— äººæœºè·å¾—è‡ªä¸»æ€§æ˜¯ä¸€ä¸ªå¤æ‚çš„é—®é¢˜ï¼Œå…¶å¤æ‚ç¨‹åº¦å–å†³äºå†³ç­–è¿‡ç¨‹ä¸­çš„ä¸åŒé˜¶æ®µä»¥åŠæ— äººæœºä¹‹é—´å¿…è¦çš„åˆä½œæ°´å¹³[26]ã€[27]ã€‚ The maximum cooperation level is essential for task assignment algorithms [28], [29], [30], where UAVs are expected to share information, allocate tasks amongst each other, and consign responsibilities with suitable timing and organization. Task assignment can be described as a graph theory problem and explained using deterministic search algorithms. Due to their computational complexity, traditional deterministic algorithms can handle only small and simple issues. Tasks of a heuristic nature can be solved, but suitable efficiency may not be achieved [31]. Proper communication and exchange of information among UAV groups can improve UAV competence to encounter performance necessities associated with the speedy and trustworthy implementation of tasks. Appropriate collaboration among UAVs is complex and very challenging to implement. An optimization algorithm that considers task superiority and synchronization, flightworthy trajectories, and other constraints of real-world scenarios are highly desired. Furthermore, UAVs differ in their operating abilities, and the cooperation of multiple heterogeneous UAVs can complement mission environments with different types of tasks [32]. æœ€å¤§åˆä½œçº§åˆ«å¯¹äºä»»åŠ¡åˆ†é…ç®—æ³•[28]ã€[29]ã€[30]è‡³å…³é‡è¦ï¼Œåœ¨è¿™äº›ç®—æ³•ä¸­ï¼Œæ— äººæœºé¢„è®¡å°†å…±äº«ä¿¡æ¯ï¼Œç›¸äº’åˆ†é…ä»»åŠ¡ï¼Œå¹¶åœ¨é€‚å½“çš„æ—¶æœºå’Œç»„ç»‡ä¸‹å§”æ‰˜è´£ä»»ã€‚ä»»åŠ¡åˆ†é…å¯ä»¥æè¿°ä¸ºä¸€ä¸ªå›¾è®ºé—®é¢˜ï¼Œå¹¶ä½¿ç”¨ç¡®å®šæ€§æœç´¢ç®—æ³•è¿›è¡Œè§£é‡Šã€‚ç”±äºå®ƒä»¬çš„è®¡ç®—å¤æ‚æ€§ï¼Œä¼ ç»Ÿçš„ç¡®å®šæ€§ç®—æ³•åªèƒ½å¤„ç†å°è€Œç®€å•çš„é—®é¢˜ã€‚å¯ä»¥è§£å†³å¯å‘å¼ä»»åŠ¡ï¼Œä½†å¯èƒ½æ— æ³•è¾¾åˆ°åˆé€‚çš„æ•ˆç‡[31]ã€‚åœ¨æ— äººæœºç¾¤ä½“ä¹‹é—´è¿›è¡Œé€‚å½“çš„æ²Ÿé€šå’Œä¿¡æ¯äº¤æµå¯ä»¥æé«˜æ— äººæœºåº”å¯¹ä¸å¿«é€Ÿå’Œå¯é ä»»åŠ¡æ‰§è¡Œç›¸å…³çš„æ€§èƒ½éœ€æ±‚çš„èƒ½åŠ›ã€‚æ— äººæœºä¹‹é—´çš„é€‚å½“åä½œå¤æ‚ä¸”æå…·æŒ‘æˆ˜æ€§ã€‚ä¸€ç§è€ƒè™‘ä»»åŠ¡ä¼˜å…ˆçº§å’ŒåŒæ­¥ã€é£è¡Œè½¨è¿¹ä»¥åŠç°å®åœºæ™¯å…¶ä»–çº¦æŸçš„ä¼˜åŒ–ç®—æ³•éå¸¸å—æ¬¢è¿ã€‚æ­¤å¤–ï¼Œæ— äººæœºåœ¨æ“ä½œèƒ½åŠ›ä¸Šå­˜åœ¨å·®å¼‚ï¼Œå¤šä¸ªå¼‚æ„æ— äººæœºçš„åˆä½œå¯ä»¥è¡¥å……å…·æœ‰ä¸åŒç±»å‹ä»»åŠ¡çš„ä½¿å‘½ç¯å¢ƒ[32]ã€‚ 1.2. Motivation 1.2. åŠ¨æœº UAV communication imposes many challenges owing to the outstanding issues present in different constituents of UAV networks, as discussed in the previous section. On the other hand, these challenges motivate many researchers to focus their studies on unsolved issues. Real-world UAV-based operations rely on collaboration between UAVs to manage the threat of attrition. Cooperation is fundamental for planning efficient missions in profoundly vulnerable environments. Efficient task allocation algorithms act as they are designed and account for uncertainties in the dynamic environment [33]. Task assignment is a combinatorial optimization process by which a UAV or swarm of UAVs is allocated to accomplish many tasks. Fig. 2 shows how a task assignment algorithm assigns a sequence of tasks within a target region to available UAVs such that the overall cost of the task is minimized. æ— äººæœºé€šä¿¡ç”±äºæ— äººæœºç½‘ç»œä¸åŒç»„æˆéƒ¨åˆ†ä¸­å­˜åœ¨çªå‡ºçš„é—®é¢˜è€Œé¢ä¸´è®¸å¤šæŒ‘æˆ˜ï¼Œå¦‚å‰èŠ‚æ‰€è¿°ã€‚å¦ä¸€æ–¹é¢ï¼Œè¿™äº›æŒ‘æˆ˜æ¿€åŠ±è®¸å¤šç ”ç©¶äººå‘˜å°†ä»–ä»¬çš„ç ”ç©¶é›†ä¸­åœ¨æœªè§£å†³çš„é—®é¢˜ä¸Šã€‚ç°å®ä¸­çš„åŸºäºæ— äººæœºçš„æ“ä½œä¾èµ–äºæ— äººæœºä¹‹é—´çš„åä½œæ¥ç®¡ç†æŸè€—å¨èƒã€‚åœ¨æå…¶è„†å¼±çš„ç¯å¢ƒä¸­ï¼Œåˆä½œå¯¹äºè§„åˆ’é«˜æ•ˆä»»åŠ¡è‡³å…³é‡è¦ã€‚æœ‰æ•ˆçš„ä»»åŠ¡åˆ†é…ç®—æ³•æŒ‰è®¾è®¡è¿è¡Œï¼Œå¹¶è€ƒè™‘åŠ¨æ€ç¯å¢ƒä¸­çš„ä¸ç¡®å®šæ€§[33]ã€‚ä»»åŠ¡åˆ†é…æ˜¯ä¸€ä¸ªç»„åˆä¼˜åŒ–è¿‡ç¨‹ï¼Œé€šè¿‡è¯¥è¿‡ç¨‹ï¼Œæ— äººæœºæˆ–æ— äººæœºç¾¤è¢«åˆ†é…ä»¥å®Œæˆè®¸å¤šä»»åŠ¡ã€‚å›¾ 2 æ˜¾ç¤ºäº†ä»»åŠ¡åˆ†é…ç®—æ³•å¦‚ä½•å°†ä¸€ç³»åˆ—ä»»åŠ¡åˆ†é…ç»™å¯ç”¨çš„æ— äººæœºï¼Œä»¥ä½¿ä»»åŠ¡çš„æ€»æˆæœ¬æœ€å°åŒ–ã€‚ The task allocation process for UAVs has become an emergent issue in the past few years with the widespread use of multi-UAV-based mission planning systems [34], [35]. A task manager is accountable for identifying all tasks and decides the availability and capability of UAVs to assign tasks to other UAVs proficiently. Several task assignment algorithms have been studied in the literature over several decades. Task assignments can be broadly categorized into coordinated, distributed, stochastic, deterministic, evolutionary, and multi-fusion-based algorithms. æ— äººæœºä»»åŠ¡åˆ†é…è¿‡ç¨‹åœ¨è¿‡å»å‡ å¹´éšç€åŸºäºå¤šæ— äººæœºä»»åŠ¡è§„åˆ’ç³»ç»Ÿçš„å¹¿æ³›åº”ç”¨è€Œæˆä¸ºä¸€ä¸ªæ–°å…´é—®é¢˜[34]ï¼Œ[35]ã€‚ä»»åŠ¡ç®¡ç†å™¨è´Ÿè´£è¯†åˆ«æ‰€æœ‰ä»»åŠ¡ï¼Œå¹¶å†³å®šæ— äººæœºåˆ†é…ä»»åŠ¡ç»™å…¶ä»–æ— äººæœºçš„èƒ½åŠ›å’Œå¯ç”¨æ€§ã€‚å‡ åå¹´æ¥ï¼Œæ–‡çŒ®ä¸­å·²ç»ç ”ç©¶äº†å¤šç§ä»»åŠ¡åˆ†é…ç®—æ³•ã€‚ä»»åŠ¡åˆ†é…å¯ä»¥å¹¿æ³›åˆ†ä¸ºåè°ƒã€åˆ†å¸ƒå¼ã€éšæœºã€ç¡®å®šæ€§ã€è¿›åŒ–ä»¥åŠåŸºäºå¤šèåˆçš„ç®—æ³•ã€‚ In this survey, we extensively investigated task assignment optimization algorithms designed for UAV networks to address their key features and characteristics. In addition, we provide detailed explanations of the basic operational principles. In the near future, UAVs may require an ever-increasing number of higher-level planning capabilities to accomplish their missions effectively. Their missions are expected to be complex, necessitating the use of multiple heterogeneous UAVs to cooperate efficaciously while achieving the overall mission objective. The main contributions of our study are discussed in the following subsection. åœ¨æœ¬è°ƒæŸ¥ä¸­ï¼Œæˆ‘ä»¬å¹¿æ³›ç ”ç©¶äº†é’ˆå¯¹æ— äººæœºç½‘ç»œçš„ä½œä¸šåˆ†é…ä¼˜åŒ–ç®—æ³•ï¼Œä»¥è§£å†³å…¶å…³é”®ç‰¹æ€§å’Œç‰¹å¾ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜æä¾›äº†åŸºæœ¬æ“ä½œåŸç†çš„è¯¦ç»†è§£é‡Šã€‚åœ¨ä¸ä¹…çš„å°†æ¥ï¼Œæ— äººæœºå¯èƒ½éœ€è¦è¶Šæ¥è¶Šå¤šçš„æ›´é«˜çº§åˆ«çš„è§„åˆ’èƒ½åŠ›ï¼Œä»¥æœ‰æ•ˆåœ°å®Œæˆå…¶ä»»åŠ¡ã€‚é¢„è®¡ä»–ä»¬çš„ä»»åŠ¡å°†æ˜¯å¤æ‚çš„ï¼Œéœ€è¦ä½¿ç”¨å¤šä¸ªå¼‚æ„æ— äººæœºæœ‰æ•ˆåœ°åˆä½œï¼ŒåŒæ—¶å®ç°æ•´ä½“ä»»åŠ¡ç›®æ ‡ã€‚æˆ‘ä»¬ç ”ç©¶çš„ä¸»è¦è´¡çŒ®å°†åœ¨ä¸‹ä¸€ä¸ªå°èŠ‚ä¸­è®¨è®ºã€‚ 1.3. Contribution of the study 1.3. ç ”ç©¶è´¡çŒ® UAVs essentially depend on sensors' information to categorize targets, discard false tasks, and determine comprehensible sequences of decisions and actions to achieve their objectives. The significant contributions of our survey are as follows. æ— äººæœºæœ¬è´¨ä¸Šä¾èµ–äºä¼ æ„Ÿå™¨çš„ä¿¡æ¯æ¥åˆ†ç±»ç›®æ ‡ã€ä¸¢å¼ƒé”™è¯¯ä»»åŠ¡ï¼Œå¹¶ç¡®å®šå¯ç†è§£çš„å†³ç­–å’Œè¡ŒåŠ¨åºåˆ—ä»¥å®ç°å…¶ç›®æ ‡ã€‚æœ¬è°ƒæŸ¥çš„æ˜¾è‘—è´¡çŒ®å¦‚ä¸‹ã€‚ Based on their main ideas, existing surveys on UAVs and their applications are reviewed. åŸºäºå®ƒä»¬çš„ä¸»è¦æ€æƒ³ï¼Œå¯¹ç°æœ‰å…³äºæ— äººæœºåŠå…¶åº”ç”¨çš„è°ƒæŸ¥è¿›è¡Œäº†å›é¡¾ã€‚ The motivation behind the study of task assignment algorithms is elaborated on along with design considerations. ç ”ç©¶ä»»åŠ¡åˆ†é…ç®—æ³•èƒŒåçš„åŠ¨æœºä»¥åŠè®¾è®¡è€ƒè™‘è¢«è¯¦ç»†é˜è¿°ã€‚ Existing task assignment optimizations for UAV networks are classified and compared based on their main ideas, advantages, limitations, and possible enhancements. No other earlier works have surveyed the task assignment algorithms proposed for the single and multi-UAVs applications. ç°æœ‰æ— äººæœºç½‘ç»œçš„ä»»åŠ¡åˆ†é…ä¼˜åŒ–è¢«æ ¹æ®å…¶ä¸»è¦æ€æƒ³ã€ä¼˜ç‚¹ã€å±€é™æ€§å’Œå¯èƒ½çš„æ”¹è¿›è¿›è¡Œåˆ†ç±»å’Œæ¯”è¾ƒã€‚æ²¡æœ‰å…¶ä»–æ—©æœŸå·¥ä½œå¯¹ä¸ºå•æ— äººæœºå’Œå¤šæ— äººæœºåº”ç”¨æå‡ºçš„ä»»åŠ¡åˆ†é…ç®—æ³•è¿›è¡Œäº†è°ƒæŸ¥ã€‚ State-of-the-art task assignment optimizations are extensively compared and contrasted in terms of their principles, features, advantages, and limitations. æœ€å…ˆè¿›çš„ä»»åŠ¡åˆ†é…ä¼˜åŒ–åœ¨åŸç†ã€ç‰¹æ€§ã€ä¼˜ç‚¹å’Œå±€é™æ€§æ–¹é¢è¿›è¡Œäº†å¹¿æ³›çš„æ¯”è¾ƒå’Œå¯¹æ¯”ã€‚ Task assignment optimizations are qualitatively compared with various features and characteristics with a comprehensive and comparative discussion. ä»»åŠ¡åˆ†é…ä¼˜åŒ–ä¸å„ç§ç‰¹å¾å’Œç‰¹æ€§è¿›è¡Œäº†å®šæ€§æ¯”è¾ƒï¼Œå¹¶è¿›è¡Œäº†å…¨é¢å’Œæ¯”è¾ƒæ€§çš„è®¨è®ºã€‚ Finally, critical open issues and research challenges faced during task assignments in multi-UAV systems are summarized and deliberated for further enhancement and improvement. æœ€ç»ˆï¼Œå¤šæ— äººæœºç³»ç»Ÿä»»åŠ¡åˆ†é…è¿‡ç¨‹ä¸­é‡åˆ°çš„å…³é”®å¼€æ”¾é—®é¢˜å’Œç ”ç©¶æŒ‘æˆ˜è¢«æ€»ç»“å¹¶è®¨è®ºï¼Œä»¥è¿›ä¸€æ­¥æ”¹è¿›å’Œæé«˜ã€‚ 1.4. Organization of the paper 1.4. è®ºæ–‡ç»„ç»‡ç»“æ„ The remainder of this paper is organized as follows. Section 2 provides an overview of the state-of-the-art surveys conducted in different fields of UAVs. Section 3 introduces and discusses additional considerations for UAV task assignment algorithms. Task assignments suggested for UAV networks are classified in to different categories and extensively reviewed in Section 4. The task assignment algorithms studied in Section 4 are qualitatively compared and discussed in Section 5. In Section 6, open issues, research challenges, and future projections are summarized and discussed. Finally, concluding remarks are presented in Section 7. The organizational structure of the paper is depicted in Fig. 3. æœ¬æ–‡å‰©ä½™éƒ¨åˆ†ç»„ç»‡å¦‚ä¸‹ã€‚ ç¬¬ 2 èŠ‚æ¦‚è¿°äº†åœ¨ä¸åŒæ— äººæœºé¢†åŸŸè¿›è¡Œçš„æœ€æ–°è°ƒæŸ¥ã€‚ ç¬¬ 3 èŠ‚ä»‹ç»äº†æ— äººæœºä»»åŠ¡åˆ†é…ç®—æ³•çš„é™„åŠ è€ƒè™‘å› ç´ å¹¶è¿›è¡Œè®¨è®ºã€‚ ç¬¬ 4 èŠ‚å¯¹æ— äººæœºç½‘ç»œä¸­å»ºè®®çš„ä»»åŠ¡åˆ†é…è¿›è¡Œäº†åˆ†ç±»å’Œå¹¿æ³›å®¡æŸ¥ã€‚ ç¬¬ 4 èŠ‚ä¸­ç ”ç©¶è¿‡çš„ä»»åŠ¡åˆ†é…ç®—æ³•åœ¨ç¬¬ 5 èŠ‚ä¸­è¿›è¡Œäº†å®šæ€§æ¯”è¾ƒå’Œè®¨è®ºã€‚ åœ¨ç¬¬ 6 èŠ‚ä¸­ï¼Œæ€»ç»“äº†å¼€æ”¾æ€§é—®é¢˜ã€ç ”ç©¶æŒ‘æˆ˜å’Œæœªæ¥å±•æœ›ï¼Œå¹¶è¿›è¡Œäº†è®¨è®ºã€‚ æœ€åï¼Œåœ¨ç¬¬ 7 èŠ‚ä¸­æå‡ºäº†ç»“è®ºæ€§è¯„è¿°ã€‚ æœ¬æ–‡çš„ç»„ç»‡ç»“æ„å¦‚å›¾ 3 æ‰€ç¤ºã€‚ 2. Overview of existing surveys on UAVs and our contributions å…³äºæ— äººæœºç°æœ‰è°ƒæŸ¥çš„æ¦‚è¿°åŠæˆ‘ä»¬çš„è´¡çŒ® Some surveys and tutorials for UAVs and UAV-based communications have existed in the literature of the past several decades. Most of them have focused on the different issues faced in UAV communication, such as energy and other resource efficiency, security aspects, charging techniques, and channel modeling. Existing surveys on various aspects of UAV and UAV-based applications are summarized in Table 1 to validate the distinctiveness of our study. ä¸€äº›å…³äºæ— äººæœºåŠå…¶é€šä¿¡çš„è°ƒç ”å’Œæ•™ç¨‹åœ¨è¿‡å»å‡ åå¹´æ–‡çŒ®ä¸­å·²æœ‰å­˜åœ¨ã€‚å…¶ä¸­å¤§éƒ¨åˆ†èšç„¦äºæ— äººæœºé€šä¿¡ä¸­é¢ä¸´çš„ä¸åŒé—®é¢˜ï¼Œå¦‚èƒ½æºå’Œå…¶ä»–èµ„æºæ•ˆç‡ã€å®‰å…¨æ–¹é¢ã€å……ç”µæŠ€æœ¯å’Œä¿¡é“å»ºæ¨¡ã€‚è¡¨ 1 æ€»ç»“äº†å…³äºæ— äººæœºåŠå…¶åŸºäºæ— äººæœºåº”ç”¨å„æ–¹é¢ç°æœ‰è°ƒç ”ï¼Œä»¥éªŒè¯æˆ‘ä»¬ç ”ç©¶çš„ç‹¬ç‰¹æ€§ã€‚ Table 1. Summary of existing surveys. Reference Year Description Classification of UAVs Challenges Topic discussed Intelligent decision IoT Collision avoidance Flight control UAV Networking Path planning Channel modeling Application Mobility [36] 2019 Presents an ample tutorial on using the UAVs in wireless networks âœ• âœ“ Smart cities âœ“ âœ“ âœ• âœ• âœ• âœ“ âœ• âœ“ âœ• [37] 2021 A survey of security for critical UAV applications âœ• âœ“ UAV security âœ“ âœ• âœ• âœ• âœ• âœ• âœ• âœ“ âœ• [38] 2016 Surveys UAV-based civil applications âœ• âœ“ UAV for civil application âœ• âœ• âœ“ âœ• âœ“ âœ• âœ• âœ“ âœ“ [39] 2020 A survey of routing protocols for UAVs âœ“ âœ“ Routing in UAVs âœ“ âœ• âœ“ âœ• âœ“ âœ• âœ• âœ“ âœ“ [40] 2019 A survey of UAVs from a cyber-physical system perspective âœ• âœ“ UAV networks âœ“ âœ• âœ“ âœ“ âœ• âœ“ âœ“ âœ“ âœ“ [41] 2018 Surveys the methods of UAV channel modeling âœ• âœ“ Channel modeling in UAVs âœ• âœ• âœ• âœ• âœ• âœ• âœ“ âœ• âœ• [42] 2021 Survey of MAC protocols for FANETs âœ“ âœ“ MAC for UAVs âœ“ âœ• âœ• âœ• âœ• âœ“ âœ• âœ• âœ• [43] 2017 Overview of the communication architecture as well as routing protocols for UAVs is presented âœ• âœ• UAV communication architectures âœ• âœ• âœ• âœ• âœ“ âœ• âœ• âœ• âœ“ [44] 2016 UAVs and UAVs related issues are discussed âœ“ âœ“ UAV based IoTs âœ• âœ• âœ• âœ• âœ“ âœ“ âœ• âœ• âœ“ Our work â€“ Extensively surveys task assignment algorithms for UAVs along with task assignment considerations âœ“ âœ“ Task Assignment in UAVs âœ“ âœ“ âœ“ âœ“ âœ“ âœ“ âœ“ âœ“ âœ“ The authors in [36] reviewed the challenges encountered during the cooperation of UAVs with the Internet of Things (IoT) devices. A detailed study of security for critical UAV applications, such as denial of service attacks, man-in-the-middle attacks, and de-authentication attacks, was presented in [37]. Besides this, blockchain, software-defined networks, machine learning techniques, and edge computing have been studied as emerging technologies. Different features and provisions anticipated for networks of UAVs envisioned from the viewpoint of networking and communications were reported in [38]. UAV applications are classified based on their communication necessities, such as search and rescue, construction, coverage, and delivering goods. Existing UAV applications are categorized as shortâ€“long-range, highâ€“low capacity, and real-time vs. delay tolerant. The exclusive features of UAV networks (such as high maneuverability dispersed UAV nodes and frequently changing network topology) present challenges during network design and routing. As a result, the classification of UAVs, the design of communications and applications, and an exhaustive review of the prevailing routing protocols proposed for UAVs were presented [39]. ä½œè€…åœ¨[36]ä¸­å›é¡¾äº†æ— äººæœºä¸ç‰©è”ç½‘ï¼ˆIoTï¼‰è®¾å¤‡åˆä½œè¿‡ç¨‹ä¸­é‡åˆ°çš„é—®é¢˜ã€‚åœ¨[37]ä¸­ï¼Œå¯¹å…³é”®æ— äººæœºåº”ç”¨çš„å®‰å…¨è¿›è¡Œäº†è¯¦ç»†ç ”ç©¶ï¼ŒåŒ…æ‹¬æ‹’ç»æœåŠ¡æ”»å‡»ã€ä¸­é—´äººæ”»å‡»å’Œå»è®¤è¯æ”»å‡»ã€‚æ­¤å¤–ï¼ŒåŒºå—é“¾ã€è½¯ä»¶å®šä¹‰ç½‘ç»œã€æœºå™¨å­¦ä¹ æŠ€æœ¯å’Œè¾¹ç¼˜è®¡ç®—è¢«ç ”ç©¶ä¸ºæ–°å…´æŠ€æœ¯ã€‚åœ¨[38]ä¸­ï¼Œä»ç½‘ç»œå’Œé€šä¿¡çš„è§’åº¦æŠ¥å‘Šäº†é’ˆå¯¹æ— äººæœºç½‘ç»œé¢„æœŸçš„ä¸€äº›åŠŸèƒ½å’Œè§„å®šã€‚æ— äººæœºåº”ç”¨æ ¹æ®å…¶é€šä¿¡éœ€æ±‚è¿›è¡Œåˆ†ç±»ï¼Œä¾‹å¦‚æœç´¢å’Œæ•‘æ´ã€å»ºç­‘ã€è¦†ç›–å’Œé€è´§ã€‚ç°æœ‰çš„æ— äººæœºåº”ç”¨è¢«åˆ†ä¸ºçŸ­è·ç¦»-é•¿è·ç¦»ã€é«˜å®¹é‡-ä½å®¹é‡ä»¥åŠå®æ—¶-å»¶è¿Ÿå®¹å¿ã€‚æ— äººæœºç½‘ç»œï¼ˆå¦‚é«˜æœºåŠ¨æ€§åˆ†æ•£æ— äººæœºèŠ‚ç‚¹å’Œé¢‘ç¹å˜åŒ–çš„ç½‘ç»œæ‹“æ‰‘ï¼‰çš„ç‹¬ç‰¹ç‰¹æ€§åœ¨è®¾è®¡å’Œè·¯ç”±è¿‡ç¨‹ä¸­æå‡ºäº†æŒ‘æˆ˜ã€‚ å› æ­¤ï¼Œæ— äººæœºåˆ†ç±»ã€é€šä¿¡è®¾è®¡åŠåº”ç”¨ï¼Œä»¥åŠå¯¹ä¸ºæ— äººæœºæå‡ºçš„ç°æœ‰è·¯ç”±åè®®çš„å…¨é¢å®¡æŸ¥éƒ½å¾—åˆ°äº†ä»‹ç»[39]ã€‚ A comprehensive study of UAV systems from a cyber-physical system (CPS) perspective was presented, considering three different CPS components [40]. Different channel classification for UAVs, measurement operations, and statistical channel models were studied and comprehensively surveyed [41]. It includes the following: (1) The UAV channel measuring operations in low-altitude platforms (LAPs) created on narrow-band or wide-band channels, low cost or low power channels, and broadly organized ground infrastructures. (2) The experimental methods for A2G and A2A propagation channels. (3) Finally, the channel modeling approaches for UAVs are classified as deterministic, stochastic, and geometricâ€“stochastic models and reviewed extensively. A survey of state-of-the-art medium access control (MAC) protocols proposed for UAV networks was presented from the viewpoint of main features, working ideologies, benefits, and limitations [42]. An extensive analysis of the latest use of UAVs in different IoT devices is made, along with challenges faced and design requirements [43]. Decentralized architectures of multi-layer UAV communication with prospects are discussed in [44]. å¯¹æ— äººæœºç³»ç»Ÿä»ç½‘ç»œç‰©ç†ç³»ç»Ÿï¼ˆCPSï¼‰è§’åº¦çš„å…¨é¢ç ”ç©¶è¢«æå‡ºï¼Œè€ƒè™‘äº†ä¸‰ä¸ªä¸åŒçš„ CPS ç»„ä»¶[40]ã€‚ç ”ç©¶äº†æ— äººæœºã€æµ‹é‡æ“ä½œå’Œç»Ÿè®¡ä¿¡é“æ¨¡å‹çš„ä¸åŒä¿¡é“åˆ†ç±»ï¼Œå¹¶è¿›è¡Œäº†å…¨é¢è°ƒæŸ¥[41]ã€‚åŒ…æ‹¬ä»¥ä¸‹å†…å®¹ï¼šï¼ˆ1ï¼‰åœ¨çª„å¸¦æˆ–å®½å¸¦ä¿¡é“ã€ä½æˆæœ¬æˆ–ä½åŠŸè€—ä¿¡é“ä»¥åŠå¹¿æ³›ç»„ç»‡çš„åœ°é¢åŸºç¡€è®¾æ–½ä¸Šåˆ›å»ºçš„ä½ç©ºå¹³å°ï¼ˆLAPsï¼‰ä¸­çš„æ— äººæœºä¿¡é“æµ‹é‡æ“ä½œã€‚ï¼ˆ2ï¼‰A2G å’Œ A2A ä¼ æ’­ä¿¡é“çš„å®éªŒæ–¹æ³•ã€‚ï¼ˆ3ï¼‰æœ€åï¼Œå°†æ— äººæœºä¿¡é“å»ºæ¨¡æ–¹æ³•åˆ†ä¸ºç¡®å®šæ€§ã€éšæœºæ€§å’Œå‡ ä½•-éšæœºæ¨¡å‹ï¼Œå¹¶è¿›è¡Œäº†å¹¿æ³›å®¡æŸ¥ã€‚ä»ä¸»è¦ç‰¹å¾ã€å·¥ä½œç†å¿µã€ä¼˜åŠ¿å’Œå±€é™æ€§ç­‰æ–¹é¢å¯¹ä¸ºæ— äººæœºç½‘ç»œæå‡ºçš„æœ€æ–°ä¸­ç»§æ¥å…¥æ§åˆ¶ï¼ˆMACï¼‰åè®®è¿›è¡Œäº†è°ƒæŸ¥[42]ã€‚å¯¹æ— äººæœºåœ¨ä¸åŒç‰©è”ç½‘è®¾å¤‡ä¸­çš„æœ€æ–°åº”ç”¨è¿›è¡Œäº†å¹¿æ³›åˆ†æï¼ŒåŒ…æ‹¬é¢ä¸´çš„æŒ‘æˆ˜å’Œè®¾è®¡è¦æ±‚[43]ã€‚åœ¨[44]ä¸­è®¨è®ºäº†å¤šå±‚æ— äººæœºé€šä¿¡çš„å»ä¸­å¿ƒåŒ–æ¶æ„åŠå…¶å‰æ™¯ã€‚ 3. Considerations for UAV task assignment æ— äººæœºä»»åŠ¡åˆ†é…çš„è€ƒè™‘å› ç´  Recently, UAVs have been widely deployed in many sectors due to the unprecedented progress in drone and wireless technologies. The proper deployment and operation of UAVs offers reliable and effective solutions to a variety of real-world scenarios. UAVs can be used as base stations (BSs) to collect and deliver on-demand wireless communications in anticipated regions. In particular, UAVs as flying BSs support and maintain connectivity between wireless networks. In comparison to traditional ground BSs, by using UAVs as aerial BSs, network performance can be improved by adjusting their heights, avoiding static and dynamic obstacles, providing line-of-sight (LoS) links to ground nodes, etc. [45], [46]. Owing to the attributes inherent in UAVs, such as maneuverability, flexibility, and adaptive altitude, they can excellently complement existing wireless and ad hoc networks. It can be observed that there has been a tremendous increase in the number of UAV-based applications. According to a TechSci study [47], it is expected that the tentative revenue from UAV-based applications will rise from 69 billion dollars in 2018 to 141 billion dollars in 2023. Different aspects affect the task assignment process in UAVs. Hence, the factors influencing the UAV task assignment are briefly studied in the subsections below. è¿‘æœŸï¼Œç”±äºæ— äººæœºå’Œæ— çº¿æŠ€æœ¯çš„ç©ºå‰è¿›æ­¥ï¼Œæ— äººæœºåœ¨è®¸å¤šé¢†åŸŸå¾—åˆ°äº†å¹¿æ³›åº”ç”¨ã€‚æ— äººæœºæ°å½“çš„éƒ¨ç½²å’Œè¿è¡Œä¸ºå„ç§ç°å®åœºæ™¯æä¾›äº†å¯é æœ‰æ•ˆçš„è§£å†³æ–¹æ¡ˆã€‚æ— äººæœºå¯ä»¥ä½œä¸ºåŸºç«™ï¼ˆBSï¼‰åœ¨é¢„æœŸåŒºåŸŸæ”¶é›†å’Œæä¾›æŒ‰éœ€æ— çº¿é€šä¿¡ã€‚ç‰¹åˆ«æ˜¯ï¼Œä½œä¸ºç©ºä¸­åŸºç«™çš„æ— äººæœºæ”¯æŒå¹¶ç»´æŠ¤æ— çº¿ç½‘ç»œä¹‹é—´çš„è¿æ¥ã€‚ä¸ä¼ ç»Ÿçš„åœ°é¢åŸºç«™ç›¸æ¯”ï¼Œé€šè¿‡ä½¿ç”¨æ— äººæœºä½œä¸ºç©ºä¸­åŸºç«™ï¼Œå¯ä»¥é€šè¿‡è°ƒæ•´å…¶é«˜åº¦ã€é¿å…é™æ€å’ŒåŠ¨æ€éšœç¢ç‰©ã€ä¸ºåœ°é¢èŠ‚ç‚¹æä¾›è§†è·ï¼ˆLoSï¼‰é“¾è·¯ç­‰æ–¹å¼æ¥æé«˜ç½‘ç»œæ€§èƒ½ã€‚[45]ï¼Œ[46]ã€‚ç”±äºæ— äººæœºå›ºæœ‰çš„å±æ€§ï¼Œå¦‚æœºåŠ¨æ€§ã€çµæ´»æ€§å’Œè‡ªé€‚åº”é«˜åº¦ï¼Œå®ƒä»¬å¯ä»¥å¾ˆå¥½åœ°è¡¥å……ç°æœ‰çš„æ— çº¿å’Œè‡ªç»„ç»‡ç½‘ç»œã€‚å¯ä»¥è§‚å¯Ÿåˆ°ï¼ŒåŸºäºæ— äººæœºåº”ç”¨çš„æ•°é‡æ€¥å‰§å¢åŠ ã€‚æ ¹æ® TechSci çš„ç ”ç©¶[47]ï¼Œé¢„è®¡åŸºäºæ— äººæœºåº”ç”¨çš„æ”¶å…¥å°†ä» 2018 å¹´çš„ 690 äº¿ç¾å…ƒå¢é•¿åˆ° 2023 å¹´çš„ 1410 äº¿ç¾å…ƒã€‚ ä¸åŒæ–¹é¢å½±å“æ— äººæœºä»»åŠ¡åˆ†é…è¿‡ç¨‹ã€‚å› æ­¤ï¼Œä»¥ä¸‹å°èŠ‚ç®€è¦ç ”ç©¶äº†å½±å“æ— äººæœºä»»åŠ¡åˆ†é…çš„å› ç´ ã€‚ 3.1. Single- and multi-UAV systems 3.1. å•æœºå’Œå¤šæ— äººæœºç³»ç»Ÿ Previously, single UAVs were commonly used to achieve missions [48], [49]. Single and large UAVs are used in single UAV-based systems, which directly communicate with ground infrastructures. However, any problems with that one UAV can terminate the entire mission. Utilizing technological advancements and immense research, the integration of multiple small UAVs has been widely considered recently. Multiple UAV-based systems add reliability, multi-tasking ability, and survivability to wireless communications [50], [51]. A comparison of single- and multi-UAV operations is given in Table 2. ä¹‹å‰ï¼Œå•ä¸ªæ— äººæœºé€šå¸¸ç”¨äºå®Œæˆä»»åŠ¡[48]ï¼Œ[49]ã€‚å•ä¸ªå’Œå¤§å‹æ— äººæœºç”¨äºåŸºäºå•ä¸ªæ— äººæœºçš„ç³»ç»Ÿä¸­ï¼Œå®ƒä»¬ç›´æ¥ä¸åœ°é¢åŸºç¡€è®¾æ–½é€šä¿¡ã€‚ç„¶è€Œï¼Œä»»ä½•å•ä¸ªæ— äººæœºçš„é—®é¢˜éƒ½å¯èƒ½ç»ˆæ­¢æ•´ä¸ªä»»åŠ¡ã€‚åˆ©ç”¨æŠ€æœ¯è¿›æ­¥å’Œå¤§é‡ç ”ç©¶ï¼Œæœ€è¿‘å¹¿æ³›è€ƒè™‘äº†å¤šä¸ªå°å‹æ— äººæœºçš„é›†æˆã€‚åŸºäºå¤šä¸ªæ— äººæœºçš„ç³»ç»Ÿå¢åŠ äº†æ— çº¿é€šä¿¡çš„å¯é æ€§ã€å¤šä»»åŠ¡èƒ½åŠ›å’Œç”Ÿå­˜èƒ½åŠ›[50]ï¼Œ[51]ã€‚è¡¨ 2 ç»™å‡ºäº†å•æ— äººæœºå’Œå¤šæ— äººæœºæ“ä½œçš„æ¯”è¾ƒã€‚ Table 2. Comparison of single- and multi-UAV operation. Parameters Single-UAV operation Multi-UAV operation Failure probability High Low Survivability Very low High Antenna used Omni-directional Directional System reconfiguration No Yes Complexity Low High Cost High Low Coverage Limited High Coordination issues Very low High Execution time Slow Fast Furthermore, multi-UAV-based systems can achieve tasks in much less time and efficiently. In multi-UAV systems, UAVs are assigned either homogeneous or heterogeneous tasks. In both cases, each UAV requires a continually increasing number of high-level directing and planning competencies to accomplish missions. Most missions are very complex and need effective collaboration to achieve mission objectives. UAVs mainly rely on information from onboard sensors to effectively identify, classify, and select proper targets and determine an understandable sequence of choices. æ­¤å¤–ï¼ŒåŸºäºå¤šæ— äººæœºï¼ˆUAVï¼‰çš„ç³»ç»Ÿå¯ä»¥åœ¨æ›´çŸ­çš„æ—¶é—´å†…é«˜æ•ˆåœ°å®Œæˆä»»åŠ¡ã€‚åœ¨å¤š UAV ç³»ç»Ÿä¸­ï¼Œæ— äººæœºè¢«åˆ†é…æ‰§è¡ŒåŒè´¨æˆ–å¼‚è´¨ä»»åŠ¡ã€‚åœ¨ä¸¤ç§æƒ…å†µä¸‹ï¼Œæ¯æ¶æ— äººæœºéƒ½éœ€è¦ä¸æ–­å¢åŠ çš„é«˜çº§æŒ‡å¯¼å’Œè§„åˆ’èƒ½åŠ›æ¥å®Œæˆä½¿å‘½ã€‚å¤§å¤šæ•°ä»»åŠ¡éƒ½éå¸¸å¤æ‚ï¼Œéœ€è¦æœ‰æ•ˆçš„åä½œæ¥å®ç°ä»»åŠ¡ç›®æ ‡ã€‚æ— äººæœºä¸»è¦ä¾é æœºè½½ä¼ æ„Ÿå™¨çš„ä¿¡æ¯æ¥æœ‰æ•ˆåœ°è¯†åˆ«ã€åˆ†ç±»å’Œé€‰æ‹©åˆé€‚çš„é¶æ ‡ï¼Œå¹¶ç¡®å®šå¯ç†è§£çš„å†³ç­–åºåˆ—ã€‚ 3.2. Classification of UAVs 3.2. æ— äººæœºåˆ†ç±» Depending on the application and mission objectives, an appropriate UAV type must be designated to meet several requirements and achieve the anticipated quality of service (QoS). UAV selection for a particular application must consider several factors, such as the capability of the UAV, maximum height it can fly up to, and available onboard devices. UAVs can thus be classified based on altitudes they can fly as high-altitude platforms (HAPs) and LAPs. HAPs can fly above 17 km, are almost stationary, have high coverage, and are durable. Alternatively, LAPs have high mobility, can fly in the range of 10 m to a few kilometers, can fly for a few hours, and are cheaper. UAVs are also categorized based on type, such as fixed-wing and rotary-wing. In comparison to rotary-wing UAVs, fixed-wing UAVs, such as small aircrafts have more weight, higher speed, and must move forward to remain airborne. In contrast, rotary-wing UAVs can hover and stay static over a given area [52], [53]. An overview of UAV categorization based on types and altitudes with their functions and capabilities is shown in Fig. 4. æ ¹æ®åº”ç”¨å’Œä»»åŠ¡ç›®æ ‡ï¼Œå¿…é¡»æŒ‡å®šä¸€ç§é€‚å½“çš„æ— äººæœºç±»å‹ä»¥æ»¡è¶³å¤šä¸ªè¦æ±‚å¹¶å®ç°é¢„æœŸçš„æœåŠ¡è´¨é‡ï¼ˆQoSï¼‰ã€‚é’ˆå¯¹ç‰¹å®šåº”ç”¨çš„æ— äººæœºé€‰æ‹©å¿…é¡»è€ƒè™‘å‡ ä¸ªå› ç´ ï¼Œå¦‚æ— äººæœºçš„æ€§èƒ½ã€å®ƒèƒ½é£åˆ°çš„æœ€å¤§é«˜åº¦ä»¥åŠå¯ç”¨çš„æœºè½½è®¾å¤‡ã€‚å› æ­¤ï¼Œæ— äººæœºå¯ä»¥æ ¹æ®å…¶é£è¡Œé«˜åº¦åˆ†ä¸ºé«˜ç©ºå¹³å°ï¼ˆHAPï¼‰å’Œä½ç©ºå¹³å°ï¼ˆLAPï¼‰ã€‚HAP å¯ä»¥é£è¡Œåœ¨ 17 å…¬é‡Œä»¥ä¸Šï¼Œå‡ ä¹é™æ­¢ï¼Œè¦†ç›–èŒƒå›´å¹¿ï¼Œè€ç”¨ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼ŒLAP å…·æœ‰é«˜æœºåŠ¨æ€§ï¼Œå¯ä»¥åœ¨ 10 ç±³åˆ°å‡ å…¬é‡Œçš„èŒƒå›´å†…é£è¡Œï¼Œå¯ä»¥é£è¡Œå‡ å°æ—¶ï¼Œä¸”æˆæœ¬è¾ƒä½ã€‚æ— äººæœºè¿˜å¯ä»¥æ ¹æ®ç±»å‹åˆ†ç±»ï¼Œå¦‚å›ºå®šç¿¼å’Œæ—‹ç¿¼ã€‚ä¸æ—‹ç¿¼æ— äººæœºç›¸æ¯”ï¼Œå›ºå®šç¿¼æ— äººæœºï¼Œå¦‚å°å‹é£æœºï¼Œé‡é‡æ›´å¤§ï¼Œé€Ÿåº¦æ›´å¿«ï¼Œå¿…é¡»å‘å‰ç§»åŠ¨æ‰èƒ½ä¿æŒç©ºä¸­é£è¡Œã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œæ—‹ç¿¼æ— äººæœºå¯ä»¥åœ¨æŒ‡å®šåŒºåŸŸå†…æ‚¬åœå¹¶ä¿æŒé™æ­¢[52]ï¼Œ[53]ã€‚å›¾ 4 å±•ç¤ºäº†åŸºäºç±»å‹å’Œé«˜åº¦å¯¹æ— äººæœºè¿›è¡Œåˆ†ç±»çš„æ¦‚è¿°ï¼ŒåŒ…æ‹¬å…¶åŠŸèƒ½å’Œèƒ½åŠ›ã€‚ 3.3. Background study 3.3. èƒŒæ™¯ç ”ç©¶ A task assignment is a combinatorial and open-loop optimization process that minimizes a predefined objective function by assigning single or multiple agents to multiple tasks. Task assignment is efficient if all the tasks are completed appropriately, satisfying the constraints, and is fundamental in many multi-agent-based applications. Only a few restrictions are optimized in most existing research works, ignoring other factors that deteriorate network performance. In multi-agent systems, agents with distinct capabilities and types are selected to deal with heterogeneous tasks. While assigning tasks to the agents, the capabilities of agents can be an essential constraint. Another critical factor that determines the efficiency of task assignments is time constraints. Most of the practical applications anticipate real-time task accomplishment. During task execution, risks and uncertainties present in the environment provide yet other conditions for efficient task assignment algorithms. ä¸€é¡¹ä»»åŠ¡åˆ†é…æ˜¯ä¸€ä¸ªç»„åˆå’Œå¼€ç¯ä¼˜åŒ–è¿‡ç¨‹ï¼Œé€šè¿‡å°†å•ä¸ªæˆ–å¤šä¸ªä»£ç†åˆ†é…åˆ°å¤šä¸ªä»»åŠ¡æ¥æœ€å°åŒ–é¢„å®šä¹‰çš„ç›®æ ‡å‡½æ•°ã€‚å¦‚æœæ‰€æœ‰ä»»åŠ¡éƒ½å¾—åˆ°é€‚å½“å®Œæˆï¼Œæ»¡è¶³çº¦æŸæ¡ä»¶ï¼Œåˆ™ä»»åŠ¡åˆ†é…æ˜¯é«˜æ•ˆçš„ï¼Œè¿™åœ¨è®¸å¤šåŸºäºå¤šä»£ç†çš„åº”ç”¨ä¸­æ˜¯åŸºæœ¬çš„ã€‚å¤§å¤šæ•°ç°æœ‰ç ”ç©¶å·¥ä½œä¸­åªä¼˜åŒ–äº†å°‘æ•°é™åˆ¶ï¼Œå¿½ç•¥äº†å…¶ä»–é™ä½ç½‘ç»œæ€§èƒ½çš„å› ç´ ã€‚åœ¨å¤šä»£ç†ç³»ç»Ÿä¸­ï¼Œé€‰æ‹©å…·æœ‰ä¸åŒèƒ½åŠ›å’Œç±»å‹çš„ä»£ç†æ¥å¤„ç†å¼‚æ„ä»»åŠ¡ã€‚åœ¨åˆ†é…ä»»åŠ¡ç»™ä»£ç†æ—¶ï¼Œä»£ç†çš„èƒ½åŠ›å¯èƒ½æ˜¯ä¸€ä¸ªåŸºæœ¬çº¦æŸã€‚å†³å®šä»»åŠ¡åˆ†é…æ•ˆç‡çš„å¦ä¸€ä¸ªå…³é”®å› ç´ æ˜¯æ—¶é—´çº¦æŸã€‚å¤§å¤šæ•°å®é™…åº”ç”¨éƒ½é¢„è®¡å®æ—¶å®Œæˆä»»åŠ¡ã€‚åœ¨ä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œç¯å¢ƒä¸­å­˜åœ¨çš„é£é™©å’Œä¸ç¡®å®šæ€§ä¸ºæœ‰æ•ˆçš„ä»»åŠ¡åˆ†é…ç®—æ³•æä¾›äº†å…¶ä»–æ¡ä»¶ã€‚ Task assignment has been studied for many other wireless networks in the literature. Satisfying decision theory [54] for balancing the necessities of the team with requests of individuals, traveling salesman problem (TSP) [55], dynamic programming [56], mixed-integer linear programming (MILP) [57], weapon target assignment (WTA) [58] are some optimization algorithms that have been applied to solve task assignment. Complex task assignment can be solved by using multi-objective genetic algorithms (GA) [59], ant colony optimization (ACO) [60], reinforcement learning (RL) [61] and particle swarm optimization (PSO) [62]. However, due to the inadequacies of constrained resources in agents, decisions are sometimes impacted, resulting in target misinterpretation. In such circumstances, the capability of agents to configure a prompt solution is highly desired. The ability to integrate ambiguities while executing robust missions to indeterminate actions is an important consideration in the design of task assigning algorithms. Meanwhile, evidence on the environment must be updated and react to the substantial alterations in the mission environment while properly rejecting confrontational incorrect information. Nevertheless, cooperation and collaboration among agents are most likely to achieve better network performance, which is challenging [63], [64], [65]. ä»»åŠ¡åˆ†é…åœ¨æ–‡çŒ®ä¸­å·²è¢«ç ”ç©¶äº†è®¸å¤šå…¶ä»–æ— çº¿ç½‘ç»œã€‚ä¸ºäº†å¹³è¡¡å›¢é˜Ÿçš„éœ€æ±‚ä¸ä¸ªäººçš„è¯·æ±‚ï¼Œæ»¡è¶³å†³ç­–ç†è®º[54]ï¼Œæ—…è¡Œå•†é—®é¢˜ï¼ˆTSPï¼‰[55]ï¼ŒåŠ¨æ€è§„åˆ’[56]ï¼Œæ··åˆæ•´æ•°çº¿æ€§è§„åˆ’ï¼ˆMILPï¼‰[57]ï¼Œæ­¦å™¨ç›®æ ‡åˆ†é…ï¼ˆWTAï¼‰[58]æ˜¯ä¸€äº›åº”ç”¨äºè§£å†³ä»»åŠ¡åˆ†é…çš„ä¼˜åŒ–ç®—æ³•ã€‚å¯ä»¥é€šè¿‡ä½¿ç”¨å¤šç›®æ ‡é—ä¼ ç®—æ³•ï¼ˆGAï¼‰[59]ï¼Œèšç¾¤ä¼˜åŒ–ï¼ˆACOï¼‰[60]ï¼Œå¼ºåŒ–å­¦ä¹ ï¼ˆRLï¼‰[61]å’Œç²’å­ç¾¤ä¼˜åŒ–ï¼ˆPSOï¼‰[62]æ¥è§£å†³å¤æ‚ä»»åŠ¡åˆ†é…ã€‚ç„¶è€Œï¼Œç”±äºä»£ç†ä¸­çº¦æŸèµ„æºçš„ä¸è¶³ï¼Œå†³ç­–æœ‰æ—¶å—åˆ°å½±å“ï¼Œå¯¼è‡´ç›®æ ‡è¯¯è§£ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä»£ç†é…ç½®å¿«é€Ÿè§£å†³æ–¹æ¡ˆçš„èƒ½åŠ›éå¸¸å—æ¬¢è¿ã€‚åœ¨æ‰§è¡Œé²æ£’ä»»åŠ¡çš„åŒæ—¶æ•´åˆæ¨¡ç³Šæ€§ï¼Œå¯¹ä¸ç¡®å®šåŠ¨ä½œçš„èƒ½åŠ›æ˜¯ä»»åŠ¡åˆ†é…ç®—æ³•è®¾è®¡ä¸­ä¸€ä¸ªé‡è¦çš„è€ƒè™‘å› ç´ ã€‚ ä¸æ­¤åŒæ—¶ï¼Œå¿…é¡»æ›´æ–°å…³äºç¯å¢ƒçš„è¯æ®ï¼Œå¹¶é’ˆå¯¹ä»»åŠ¡ç¯å¢ƒçš„å®è´¨æ€§å˜åŒ–åšå‡ºååº”ï¼ŒåŒæ—¶é€‚å½“æ‹’ç»å¯¹æŠ—æ€§çš„é”™è¯¯ä¿¡æ¯ã€‚ç„¶è€Œï¼Œä»£ç†ä¹‹é—´çš„åˆä½œå’Œåä½œæœ€æœ‰å¯èƒ½å®ç°æ›´å¥½çš„ç½‘ç»œæ€§èƒ½ï¼Œè¿™å…·æœ‰æŒ‘æˆ˜æ€§[63]ï¼Œ[64]ï¼Œ[65]ã€‚ To boost escalating UAV applications and continue their working reliability, task assignment algorithms are compulsory in deliberating the concerns of UAV communications. The maximum collaboration level is required during task assignment, where UAVs can promptly share information, tasks and allot tasks to other UAVs with apposite task scheduling and arrangement. This level of cooperation and information sharing complicates the autonomous task assignment process. Task assignment algorithms for a swarm of UAVs have become the subject of much research, and many algorithms have been suggested for UAV task assignment. Hence, a brief review of all state-of-the-art task assignment algorithms proposed for multiple UAVs is presented in this paper, which will help researchers and engineers to explore this topic further. ä¸ºäº†æé«˜ä¸æ–­å¢é•¿çš„æ— äººæœºåº”ç”¨å¹¶ä¿æŒå…¶å·¥ä½œå¯é æ€§ï¼Œä»»åŠ¡åˆ†é…ç®—æ³•åœ¨è€ƒè™‘æ— äººæœºé€šä¿¡é—®é¢˜æ—¶æ˜¯å¿…ä¸å¯å°‘çš„ã€‚åœ¨ä»»åŠ¡åˆ†é…è¿‡ç¨‹ä¸­éœ€è¦è¾¾åˆ°æœ€å¤§åä½œæ°´å¹³ï¼Œæ­¤æ—¶æ— äººæœºå¯ä»¥è¿…é€Ÿå…±äº«ä¿¡æ¯ã€ä»»åŠ¡ï¼Œå¹¶é€šè¿‡é€‚å½“çš„ä»»åŠ¡è°ƒåº¦å’Œå®‰æ’å°†ä»»åŠ¡åˆ†é…ç»™å…¶ä»–æ— äººæœºã€‚è¿™ç§åˆä½œå’Œä¿¡æ¯å…±äº«ç¨‹åº¦ä½¿å¾—è‡ªä¸»ä»»åŠ¡åˆ†é…è¿‡ç¨‹å˜å¾—å¤æ‚ã€‚é’ˆå¯¹æ— äººæœºç¾¤çš„ä»»åŠ¡åˆ†é…ç®—æ³•å·²æˆä¸ºç ”ç©¶çƒ­ç‚¹ï¼Œè®¸å¤šç®—æ³•å·²è¢«æå‡ºç”¨äºæ— äººæœºä»»åŠ¡åˆ†é…ã€‚å› æ­¤ï¼Œæœ¬æ–‡ç®€è¦å›é¡¾äº†ä¸ºå¤šæ— äººæœºæå‡ºçš„æ‰€æœ‰æœ€å…ˆè¿›çš„ä»»åŠ¡åˆ†é…ç®—æ³•ï¼Œè¿™å°†æœ‰åŠ©äºç ”ç©¶äººå‘˜å’Œå·¥ç¨‹å¸ˆè¿›ä¸€æ­¥æ¢è®¨è¿™ä¸€ä¸»é¢˜ã€‚ The symbols and acronyms used in this paper are listed alongside their descriptions in Table 3. è¯¥è®ºæ–‡ä¸­ä½¿ç”¨çš„ç¬¦å·å’Œç¼©å†™åŠå…¶æè¿°åˆ—äºè¡¨ 3 ä¸­ã€‚ Table 3. List of notations and abbreviations. Symbol Description $N_v$ Number of UAVs $N_t$ Number of targets $X^k_{i,j}$ Decision variable in the range of 0â€“1 $k$ Order of UAV $L^k_{i,j}$ Shortest path length $f^k_{i,j}$ Waiting time $p_i(t)$ Survival probability $S(u_t)$ Score of targets $r_t$ Remaining targets at time t $m_t$ Remaining weapons at time t $u_t$ Number of targets to be hit at time t $Î»$ Time discount coefficient $cij(xi,pi)$ Score function $t_u $ Time required to complete allocated task $Ckâ€¾$ Minimal value at time k $âŠ•$ Exclusive OR $x_{k}$ Decision variable at time k $N_{Lim}^k$ Maximum flight path $L_{Lim}^k$ Maximum limit of number of tasks CPS Cyber-physical system LAPs Low-altitude platforms A2G Air-to-ground A2A Air-to-air MAC Medium access control LoS Line-of-sight BS Base station DE Differential evolution QoS Quality of service HAPs High-altitude platforms MEC Mobile edge computing SO System orchestrator VAIoTS Value added IoTs EAUS Energy-aware UAV selection DAUS Delay-aware UAV selection FTUS Fair tradeoff UAV selection IVHM Integrated vehicle health management RUL Residual useful life BCD Block coordinate descent EAT Earliest available time G2G Ground-to-ground TOT Time over target IoTs Internet of things FTA Fault tree analysis BSUM Block successive upper-bound minimization MILP Mixed integer linear programming TSP Traveling salesman problem WTA Weapon target assignment RL Reinforcement learning GA Genetic algorithm PSO Particle swarm optimization ACO Ant colony optimization DE Differential evolution ANN Artificial neural network 4. Design issues of task assignment algorithms ä»»åŠ¡åˆ†é…ç®—æ³•çš„è®¾è®¡é—®é¢˜ Task assignment algorithms for UAVs face significant difficulties, such as unacceptable computation time for real-time implementation and degraded performance due to uncertain environmental aspects. This section addresses the primary design issues of task assignment algorithms for different mission planning systems for fleets of UAVs. æ— äººæœºçš„ä»»åŠ¡åˆ†é…ç®—æ³•é¢ä¸´ç€å·¨å¤§çš„å›°éš¾ï¼Œä¾‹å¦‚å®æ—¶æ‰§è¡Œçš„è®¡ç®—æ—¶é—´ä¸å¯æ¥å—ï¼Œä»¥åŠç”±äºä¸ç¡®å®šçš„ç¯å¢ƒå› ç´ è€Œå¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚æœ¬èŠ‚è®¨è®ºæ— äººæœºæœºé˜Ÿä¸åŒä»»åŠ¡è§„åˆ’ç³»ç»Ÿçš„ä»»åŠ¡åˆ†é…ç®—æ³•çš„ä¸»è¦è®¾è®¡é—®é¢˜ã€‚ 4.1. Multi-UAV system formation 4.1. å¤šæ— äººæœºç³»ç»Ÿç¼–é˜Ÿ Multiple UAVs should be systematically formed for the task assignment in numerous UAVs. Developing a multi-UAV system is required to accomplish a task cooperatively. Recently, the issues faced during the formation of multi-UAV systems are getting substantial research attention in many studies. The collaborative use of a multi-UAV system offers many advantages over a single UAV in large-scale applications, such as accomplishing complex and large-scaled tasks, improving the probability of successful task accomplishment even during the failure of some UAVs. Moreover, multi-UAV systems provide diverse competencies in various application circumstances. However, designing multi-UAV systems and using them cooperatively to achieve the mission objectives brings particular challenges and complexities [66], [67]. å¤šæ¶æ— äººæœºåº”ç³»ç»Ÿæ€§åœ°ç»„æˆä»¥å®Œæˆä¼—å¤šæ— äººæœºä¸­çš„ä»»åŠ¡åˆ†é…ã€‚å¼€å‘å¤šæ— äººæœºç³»ç»Ÿä»¥ååŒå®Œæˆä»»åŠ¡æ˜¯å¿…è¦çš„ã€‚æœ€è¿‘ï¼Œåœ¨è®¸å¤šç ”ç©¶ä¸­ï¼Œå¤šæ— äººæœºç³»ç»Ÿå½¢æˆè¿‡ç¨‹ä¸­é‡åˆ°çš„é—®é¢˜å—åˆ°äº†å®è´¨æ€§çš„ç ”ç©¶å…³æ³¨ã€‚å¤šæ— äººæœºç³»ç»Ÿçš„åä½œä½¿ç”¨åœ¨å¤§å‹åº”ç”¨ä¸­æ¯”å•æ— äººæœºå…·æœ‰è®¸å¤šä¼˜åŠ¿ï¼Œä¾‹å¦‚å®Œæˆå¤æ‚å’Œå¤§è§„æ¨¡çš„ä»»åŠ¡ï¼Œå³ä½¿åœ¨æŸäº›æ— äººæœºå¤±è´¥çš„æƒ…å†µä¸‹ä¹Ÿèƒ½æé«˜ä»»åŠ¡æˆåŠŸçš„æ¦‚ç‡ã€‚æ­¤å¤–ï¼Œå¤šæ— äººæœºç³»ç»Ÿåœ¨å„ç§åº”ç”¨ç¯å¢ƒä¸­æä¾›å¤šæ ·åŒ–çš„èƒ½åŠ›ã€‚ç„¶è€Œï¼Œè®¾è®¡å’Œä½¿ç”¨å¤šæ— äººæœºç³»ç»Ÿä»¥ååŒå®ç°ä»»åŠ¡ç›®æ ‡å¸¦æ¥äº†ç‰¹å®šçš„æŒ‘æˆ˜å’Œå¤æ‚æ€§[66]ï¼Œ[67]ã€‚ åº”ç³»ç»Ÿåœ°ç»„å»ºå¤šæ¶æ— äººæœºï¼Œåœ¨ä¼—å¤šæ— äººæœºä¸­å®Œæˆä»»åŠ¡åˆ†é…ã€‚å¼€å‘å¤šæ— äººæœºç³»ç»Ÿéœ€è¦ååŒå®Œæˆä»»åŠ¡ã€‚è¿‘å¹´æ¥ï¼Œå¤šæ— äººæœºç³»ç»Ÿç»„å»ºè¿‡ç¨‹ä¸­é¢ä¸´çš„é—®é¢˜å—åˆ°è®¸å¤šç ”ç©¶çš„å¹¿æ³›å…³æ³¨ã€‚åœ¨å¤§è§„æ¨¡åº”ç”¨ä¸­ï¼Œå¤šæ— äººæœºç³»ç»Ÿçš„ååŒä½¿ç”¨æ¯”å•æ¶æ— äººæœºå…·æœ‰è®¸å¤šä¼˜åŠ¿ï¼Œä¾‹å¦‚å®Œæˆå¤æ‚å’Œå¤§è§„æ¨¡çš„ä»»åŠ¡ï¼Œå³ä½¿åœ¨æŸäº›æ— äººæœºå‘ç”Ÿæ•…éšœçš„æƒ…å†µä¸‹ä¹Ÿèƒ½æé«˜æˆåŠŸå®Œæˆä»»åŠ¡çš„æ¦‚ç‡ã€‚æ­¤å¤–ï¼Œå¤šæ— äººæœºç³»ç»Ÿåœ¨ä¸åŒçš„åº”ç”¨ç¯å¢ƒä¸­æä¾›ä¸åŒçš„èƒ½åŠ›ã€‚ç„¶è€Œï¼Œè®¾è®¡å¤šæ— äººæœºç³»ç»Ÿå¹¶ååŒä½¿ç”¨å®ƒä»¬æ¥å®ç°ä»»åŠ¡ç›®æ ‡å¸¦æ¥äº†ç‰¹æ®Šçš„æŒ‘æˆ˜å’Œå¤æ‚æ€§[66] ï¼Œ [67] ã€‚ 4.2. Computational complexity 4.2. è®¡ç®—å¤æ‚åº¦ Having autonomous capacity allows UAVs to execute assignments with negligible or no human interference. Cooperative UAVs are expected to outperform the sum of individual UAVs. The interdependency of multiple tasks and trajectory optimization determines the simultaneous operations of UAVs. To confirm the proper dependence among UAVs, the coordination of path plans and task assignments is required in real-time. Complexity is the focal aspect in designing cooperative UAV missions [68], [69]. å…·æœ‰è‡ªä¸»èƒ½åŠ›ä½¿æ— äººæœºèƒ½å¤Ÿæ‰§è¡Œä»»åŠ¡ï¼Œå‡ ä¹æ— éœ€æˆ–æ— éœ€äººç±»å¹²é¢„ã€‚é¢„è®¡åä½œæ— äººæœºå°†ä¼˜äºå•ä¸ªæ— äººæœºçš„æ€»å’Œã€‚å¤šä¸ªä»»åŠ¡å’Œè½¨è¿¹ä¼˜åŒ–çš„ç›¸äº’ä¾èµ–æ€§å†³å®šäº†æ— äººæœºçš„ååŒä½œä¸šã€‚ä¸ºäº†ç¡®è®¤æ— äººæœºä¹‹é—´çš„é€‚å½“ä¾èµ–å…³ç³»ï¼Œéœ€è¦å®æ—¶åè°ƒè·¯å¾„è®¡åˆ’å’Œä»»åŠ¡åˆ†é…ã€‚å¤æ‚æ€§æ˜¯è®¾è®¡åä½œæ— äººæœºä»»åŠ¡çš„å…³é”®æ–¹é¢[68]ï¼Œ[69]ã€‚ Along with the kinematic constraints of UAVs, factors such as problem size and level of cooperation expected in different types of mission operations induce complexities. Moreover, UAVs are expected to operate in harsh and critical environments, where real-time service is desired. In such scenarios, UAVs must handle the uncertainties and constraints of dynamic environments. UAVs must compute and make decisions at the local level to handle these adversities, which add to the complexity of UAV networks. Recently, cloud computing and edge computing techniques have been extensively used to address the computational complexities of UAV communication [70], [71]. éšç€æ— äººæœºè¿åŠ¨å­¦çº¦æŸï¼Œé—®é¢˜è§„æ¨¡å’Œä¸åŒç±»å‹ä»»åŠ¡æ“ä½œä¸­æœŸæœ›çš„åˆä½œæ°´å¹³ç­‰å› ç´ å¯¼è‡´å¤æ‚æ€§ã€‚æ­¤å¤–ï¼Œæ— äººæœºé¢„è®¡å°†åœ¨æ¶åŠ£å’Œå…³é”®ç¯å¢ƒä¸­è¿è¡Œï¼Œéœ€è¦å®æ—¶æœåŠ¡ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ— äººæœºå¿…é¡»å¤„ç†åŠ¨æ€ç¯å¢ƒçš„ä¸å¯ç¡®å®šæ€§å’Œçº¦æŸã€‚æ— äººæœºå¿…é¡»åœ¨æœ¬åœ°çº§åˆ«è¿›è¡Œè®¡ç®—å’Œå†³ç­–ä»¥åº”å¯¹è¿™äº›æŒ‘æˆ˜ï¼Œè¿™å¢åŠ äº†æ— äººæœºç½‘ç»œçš„å¤æ‚æ€§ã€‚æœ€è¿‘ï¼Œäº‘è®¡ç®—å’Œè¾¹ç¼˜è®¡ç®—æŠ€æœ¯å·²è¢«å¹¿æ³›ç”¨äºè§£å†³æ— äººæœºé€šä¿¡çš„è®¡ç®—å¤æ‚æ€§[70]ï¼Œ[71]ã€‚ 4.3. Collision-free UAV operation 4.3. æ— ç¢°æ’æ— äººæœºæ“ä½œ The existence of multiple UAVs in a network surges the chance of collision. Collision among UAVs can occur when UAVs come across each other's way during their operation when they lack autonomy to handle obstacles and are time-constrained. Hence, one of the furthermost significant necessities in multi-UAV networks is that UAVs should not clash each other on their flight route and also their signal should not interfere with each other's. A number of collision avoidance mechanisms are studied and used in the literature [72]. Mixed-integer based model is studied to obtain the collision-free plan for multiple UAVs in [73]. Operating UAVs in different altitudes is considered to avoid collision among UAVs in [74]. Clustering can help to minimize collision to some extent. Another significant aspect in determining the collision-free UAV operation is the trajectory planning. ç½‘ç»œä¸­å¤šä¸ªæ— äººæœºï¼ˆUAVï¼‰çš„å­˜åœ¨å¢åŠ äº†ç¢°æ’çš„æœºä¼šã€‚å½“æ— äººæœºåœ¨æ“ä½œè¿‡ç¨‹ä¸­é‡åˆ°å½¼æ­¤çš„è·¯å¾„ï¼Œç¼ºä¹å¤„ç†éšœç¢ç‰©çš„è‡ªä¸»æ€§ä¸”æ—¶é—´å—é™æ—¶ï¼Œæ— äººæœºä¹‹é—´å¯èƒ½ä¼šå‘ç”Ÿç¢°æ’ã€‚å› æ­¤ï¼Œåœ¨å¤šæ— äººæœºç½‘ç»œä¸­ï¼Œæœ€è¿«åˆ‡çš„éœ€æ±‚ä¹‹ä¸€æ˜¯æ— äººæœºåœ¨é£è¡Œè·¯çº¿ä¸Šä¸åº”ç›¸äº’ç¢°æ’ï¼Œå¹¶ä¸”å®ƒä»¬çš„ä¿¡å·ä¹Ÿä¸åº”ç›¸äº’å¹²æ‰°ã€‚æ–‡çŒ®[72]ä¸­ç ”ç©¶äº†å¤šç§ç¢°æ’é¿å…æœºåˆ¶ã€‚æ–‡çŒ®[73]ç ”ç©¶äº†åŸºäºæ··åˆæ•´æ•°æ¨¡å‹ï¼Œä»¥è·å¾—å¤šä¸ªæ— äººæœºçš„æ— ç¢°æ’è®¡åˆ’ã€‚æ–‡çŒ®[74]ä¸­è€ƒè™‘äº†åœ¨ä¸åŒé«˜åº¦æ“ä½œæ— äººæœºä»¥é¿å…æ— äººæœºä¹‹é—´çš„ç¢°æ’ã€‚èšç±»å¯ä»¥åœ¨ä¸€å®šç¨‹åº¦ä¸Šå¸®åŠ©å‡å°‘ç¢°æ’ã€‚ç¡®å®šæ— ç¢°æ’æ— äººæœºæ“ä½œçš„å¦ä¸€é‡è¦æ–¹é¢æ˜¯è½¨è¿¹è§„åˆ’ã€‚ The existence of multiple UAVs in a network surges the chance of collision. Collision among UAVs can occur when UAVs come across each other's way during their operation when they lack the autonomy to handle obstacles and are time-constrained. Hence, one of the furthermost significant necessities in multi-UAV networks is that UAVs should not clash on their flight route and their signal should not interfere with each other's. Some collision avoidance mechanisms are studied and used in the literature [72]. Mixed-integer based model is studied to obtain the collision-free plan for multiple UAVs in [73]. Operating UAVs in different altitudes is considered to avoid collision among UAVs in [74]. Clustering can help to minimize collision to some extent. Another significant aspect in determining the collision-free UAV operation is the trajectory planning. ç½‘ç»œä¸­å¤šä¸ªæ— äººæœºï¼ˆUAVï¼‰çš„å­˜åœ¨å¢åŠ äº†ç¢°æ’çš„æœºä¼šã€‚å½“æ— äººæœºåœ¨æ“ä½œè¿‡ç¨‹ä¸­é‡åˆ°å½¼æ­¤çš„è·¯å¾„ï¼Œç¼ºä¹å¤„ç†éšœç¢ç‰©çš„è‡ªä¸»æ€§ä¸”æ—¶é—´å—é™æ—¶ï¼Œæ— äººæœºä¹‹é—´å¯èƒ½ä¼šå‘ç”Ÿç¢°æ’ã€‚å› æ­¤ï¼Œåœ¨å¤šæ— äººæœºç½‘ç»œä¸­ï¼Œæœ€è¿«åˆ‡çš„éœ€æ±‚ä¹‹ä¸€æ˜¯æ— äººæœºåœ¨é£è¡Œè·¯çº¿ä¸Šä¸åº”ç›¸æ’ï¼Œå®ƒä»¬çš„ä¿¡å·ä¹Ÿä¸åº”ç›¸äº’å¹²æ‰°ã€‚æ–‡çŒ®[72]ä¸­ç ”ç©¶äº†å¹¶ä½¿ç”¨äº†ä¸€äº›ç¢°æ’é¿å…æœºåˆ¶ã€‚æ–‡çŒ®[73]ä¸­ç ”ç©¶äº†åŸºäºæ··åˆæ•´æ•°æ¨¡å‹ï¼Œä»¥è·å¾—å¤šä¸ªæ— äººæœºçš„æ— ç¢°æ’è®¡åˆ’ã€‚æ–‡çŒ®[74]ä¸­è€ƒè™‘äº†åœ¨ä¸åŒé«˜åº¦æ“ä½œæ— äººæœºä»¥é¿å…æ— äººæœºä¹‹é—´çš„ç¢°æ’ã€‚èšç±»å¯ä»¥åœ¨ä¸€å®šç¨‹åº¦ä¸Šå¸®åŠ©å‡å°‘ç¢°æ’ã€‚ç¡®å®šæ— ç¢°æ’æ— äººæœºæ“ä½œçš„å¦ä¸€é‡è¦æ–¹é¢æ˜¯è½¨è¿¹è§„åˆ’ã€‚ 4.4. Backhaul network 4.4. å›ç¨‹ç½‘ç»œ Robust backhaul is crucial when UAVs are not fully autonomous. A backhaul network collects and disseminates information for effective UAV cooperation and decision-making processes. Information includes the status of flights, sensed data, and flight control. The limitations and requirements of backhaul links for the design and deployment of UAVs were studied in [75]. Similarly, in [76], backhaul and latency-aware UAV positioning with time complexity were discussed to calculate the optimal height. An aerial backhaul scheme was formulated to form a network with multi-hop backhaul in the sky [77]. All these studies support UAVs to create backhaul in a distributed manner. Mm-wave is a recent and widespread technique for enabling broadband backhaul in UAVs [78], [79]. ç¨³å¥çš„å›ç¨‹å¯¹äºæ— äººæœºä¸å®Œå…¨è‡ªä¸»è¿è¡Œè‡³å…³é‡è¦ã€‚å›ç¨‹ç½‘ç»œæ”¶é›†å’Œä¼ æ’­ä¿¡æ¯ï¼Œä»¥å®ç°æœ‰æ•ˆçš„æ— äººæœºåˆä½œå’Œå†³ç­–è¿‡ç¨‹ã€‚ä¿¡æ¯åŒ…æ‹¬é£è¡ŒçŠ¶æ€ã€æ„ŸçŸ¥æ•°æ®å’Œé£è¡Œæ§åˆ¶ã€‚åœ¨[75]ä¸­ç ”ç©¶äº†å›ç¨‹é“¾è·¯çš„é™åˆ¶å’Œè¦æ±‚ï¼Œä»¥è®¾è®¡æ— äººæœºéƒ¨ç½²ã€‚åœ¨[76]ä¸­ï¼Œè®¨è®ºäº†å…·æœ‰æ—¶é—´å¤æ‚åº¦çš„å›ç¨‹å’Œå»¶è¿Ÿæ„ŸçŸ¥çš„æ— äººæœºå®šä½ï¼Œä»¥è®¡ç®—æœ€ä½³é«˜åº¦ã€‚åœ¨[77]ä¸­åˆ¶å®šäº†ä¸€ç§ç©ºä¸­å›ç¨‹æ–¹æ¡ˆï¼Œä»¥åœ¨ç©ºä¸­å½¢æˆå¤šè·³å›ç¨‹ç½‘ç»œã€‚æ‰€æœ‰è¿™äº›ç ”ç©¶éƒ½æ”¯æŒæ— äººæœºä»¥åˆ†å¸ƒå¼æ–¹å¼åˆ›å»ºå›ç¨‹ã€‚æ¯«ç±³æ³¢æ˜¯ä½¿æ— äººæœºå®ç°å®½å¸¦å›ç¨‹çš„æœ€è¿‘å’Œå¹¿æ³›åº”ç”¨çš„æŠ€æœ¯[78]ï¼Œ[79]ã€‚ å½“æ— äººæœºä¸å®Œå…¨è‡ªä¸»æ—¶ï¼Œå¼ºå¤§çš„å›ç¨‹è‡³å…³é‡è¦ã€‚å›ç¨‹ç½‘ç»œæ”¶é›†å’Œä¼ æ’­ä¿¡æ¯ï¼Œä»¥å®ç°æœ‰æ•ˆçš„æ— äººæœºåˆä½œå’Œå†³ç­–è¿‡ç¨‹ã€‚ä¿¡æ¯åŒ…æ‹¬èˆªç­çŠ¶æ€ã€ä¼ æ„Ÿæ•°æ®å’Œé£è¡Œæ§åˆ¶ã€‚ [75]ç ”ç©¶äº†æ— äººæœºè®¾è®¡å’Œéƒ¨ç½²çš„å›ç¨‹é“¾è·¯çš„é™åˆ¶å’Œè¦æ±‚ã€‚ç±»ä¼¼åœ°ï¼Œåœ¨[76]ä¸­ï¼Œè®¨è®ºäº†å…·æœ‰æ—¶é—´å¤æ‚åº¦çš„å›ç¨‹å’Œå»¶è¿Ÿæ„ŸçŸ¥æ— äººæœºå®šä½ï¼Œä»¥è®¡ç®—æœ€ä½³é«˜åº¦ã€‚åˆ¶å®šç©ºä¸­å›ä¼ æ–¹æ¡ˆï¼Œå½¢æˆç©ºä¸­å¤šè·³å›ä¼ ç½‘ç»œ[77] ã€‚æ‰€æœ‰è¿™äº›ç ”ç©¶éƒ½æ”¯æŒæ— äººæœºä»¥åˆ†å¸ƒå¼æ–¹å¼åˆ›å»ºå›ç¨‹ã€‚æ¯«ç±³æ³¢æ˜¯ä¸€ç§æœ€æ–°ä¸”å¹¿æ³›åº”ç”¨çš„æŠ€æœ¯ï¼Œç”¨äºåœ¨æ— äººæœºä¸­å®ç°å®½å¸¦å›ç¨‹[78] ã€ [79] ã€‚ 4.5. Uniform load balancing 4.5. å‡åŒ€è´Ÿè½½å‡è¡¡ In multi-UAV operations, the uniform distribution of tasks among UAVs is necessary. Differential evolution (DE)-based load balancing mechanism has been discussed in [80], where accessing problem is modeled as a generalized assignment problem. Grounded on the indication of task load within a specific region of task execution, task assignment can be done approving even dissemination of tasks as far as possible. Another technique for load balancing is to assign a group of arbitrarily created non- intersecting coordinates. The load balancing technique using multi-criterion decision-making is studied [81]. The optimal user association to balance load using hybrid cognitive radio relay [82]. Task assignment methods can be helpful for load balancing in UAV-assisted IoT communication [83], [84]. åœ¨å¤š UAV æ“ä½œä¸­ï¼Œåœ¨ UAV ä¹‹é—´å‡åŒ€åˆ†é…ä»»åŠ¡æ˜¯å¿…è¦çš„ã€‚åŸºäºå·®åˆ†è¿›åŒ–ï¼ˆDEï¼‰çš„è´Ÿè½½å‡è¡¡æœºåˆ¶å·²åœ¨[80]ä¸­è®¨è®ºï¼Œå…¶ä¸­è®¿é—®é—®é¢˜è¢«å»ºæ¨¡ä¸ºå¹¿ä¹‰åˆ†é…é—®é¢˜ã€‚åŸºäºä»»åŠ¡æ‰§è¡Œç‰¹å®šåŒºåŸŸå†…çš„ä»»åŠ¡è´Ÿè½½æŒ‡ç¤ºï¼Œå¯ä»¥è¿›è¡Œä»»åŠ¡åˆ†é…ï¼Œç”šè‡³å°½å¯èƒ½å¹¿æ³›åœ°ä¼ æ’­ä»»åŠ¡ã€‚å¦ä¸€ç§è´Ÿè½½å‡è¡¡æŠ€æœ¯æ˜¯ä¸ºä»»æ„åˆ›å»ºçš„ä¸€ç»„éç›¸äº¤åæ ‡åˆ†é…ä»»åŠ¡ã€‚ä½¿ç”¨å¤šæ ‡å‡†å†³ç­–åˆ¶å®šçš„è´Ÿè½½å‡è¡¡æŠ€æœ¯å·²åœ¨[81]ä¸­ç ”ç©¶ã€‚ä½¿ç”¨æ··åˆè®¤çŸ¥æ— çº¿ç”µä¸­ç»§å¹³è¡¡è´Ÿè½½çš„æœ€ä½³ç”¨æˆ·å…³è”å·²åœ¨[82]ä¸­ç ”ç©¶ã€‚ä»»åŠ¡åˆ†é…æ–¹æ³•å¯¹äº UAV è¾…åŠ©çš„ç‰©è”ç½‘é€šä¿¡ä¸­çš„è´Ÿè½½å‡è¡¡å¯èƒ½æ˜¯æœ‰å¸®åŠ©çš„[83]ã€[84]ã€‚ 4.6. Antenna designs 4.6. å¤©çº¿è®¾è®¡ The design and number of antennas also determine the performance of UAVs, and hence they must be decided cautiously. UAVs essentially incorporate directional and omnidirectional antennas. In short, omnidirectional antennas perform better in environments with high mobility but face energy drain and security issues. In contrast, directional antennas have an improved transmission range but require complex protocols and exact antenna orientation algorithms [85], [86]. Also, different issues brought about by directional communication, such as head-of-line, deafness, and hidden terminals must be addressed. UAVs also use smart and adaptive antennas. è®¾è®¡å¤©çº¿æ•°é‡ä¹Ÿå†³å®šäº†æ— äººæœºæ€§èƒ½ï¼Œå› æ­¤å¿…é¡»è°¨æ…å†³å®šã€‚æ— äººæœºæœ¬è´¨ä¸ŠåŒ…å«å®šå‘å’Œå…¨å‘å¤©çº¿ã€‚ç®€è€Œè¨€ä¹‹ï¼Œå…¨å‘å¤©çº¿åœ¨é«˜åº¦ç§»åŠ¨çš„ç¯å¢ƒä¸­è¡¨ç°æ›´å¥½ï¼Œä½†é¢ä¸´èƒ½é‡æ¶ˆè€—å’Œå®‰å…¨é—®é¢˜ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œå®šå‘å¤©çº¿å…·æœ‰æ›´è¿œçš„ä¼ è¾“èŒƒå›´ï¼Œä½†éœ€è¦å¤æ‚çš„åè®®å’Œç²¾ç¡®çš„å¤©çº¿æ–¹å‘ç®—æ³•[85]ï¼Œ[86]ã€‚æ­¤å¤–ï¼Œå®šå‘é€šä¿¡å¸¦æ¥çš„ä¸åŒé—®é¢˜ï¼Œå¦‚å¤´èŠ‚ç‚¹ã€è‹å“‘å’Œéšè—ç»ˆç«¯ç­‰é—®é¢˜ä¹Ÿå¿…é¡»è§£å†³ã€‚æ— äººæœºè¿˜ä½¿ç”¨æ™ºèƒ½å’Œè‡ªé€‚åº”å¤©çº¿ã€‚ 5. Task assignment algorithms ä»»åŠ¡åˆ†é…ç®—æ³• The task assignment of UAVs is performed to minimize the entire cost by assigning UAVs to accomplish a number of tasks. A UAV can be assigned a single task or more. The issues faced by task assignment algorithms are computational complexities, task coupling, problem size, time constraints, and heterogeneity. Keeping this in mind, different task assignment algorithms have been designed for different application-specific UAV operations. We classify task assignment algorithms into four categories: centralized, distributed, bio-inspired, and multi-fusion, as illustrated in Fig. 5. The basic operating principles of each algorithm type are briefly discussed along with their advantages, disadvantages, and possible improvements in the subsections below. æ— äººæœºçš„ä»»åŠ¡åˆ†é…æ˜¯é€šè¿‡åˆ†é…æ— äººæœºå®Œæˆå¤šé¡¹ä»»åŠ¡æ¥æœ€å°åŒ–æ•´ä½“æˆæœ¬ã€‚æ— äººæœºå¯ä»¥è¢«åˆ†é…ä¸€ä¸ªæˆ–å¤šä¸ªä»»åŠ¡ã€‚ä»»åŠ¡åˆ†é…ç®—æ³•é¢ä¸´çš„é—®é¢˜æ˜¯è®¡ç®—å¤æ‚æ€§ã€ä»»åŠ¡è€¦åˆã€é—®é¢˜è§„æ¨¡ã€æ—¶é—´é™åˆ¶å’Œå¼‚æ„æ€§ã€‚è€ƒè™‘åˆ°è¿™ä¸€ç‚¹ï¼Œé’ˆå¯¹ä¸åŒçš„ç‰¹å®šåº”ç”¨æ— äººæœºæ“ä½œè®¾è®¡äº†ä¸åŒçš„ä»»åŠ¡åˆ†é…ç®—æ³•ã€‚æˆ‘ä»¬å°†ä»»åŠ¡åˆ†é…ç®—æ³•åˆ†ä¸ºå››ç±»ï¼šé›†ä¸­å¼ã€åˆ†å¸ƒå¼ã€ä»¿ç”Ÿå’Œå¤šé‡èåˆï¼Œå¦‚å›¾5æ‰€ç¤ºã€‚ä¸‹é¢çš„å°èŠ‚å°†ç®€è¦è®¨è®ºæ¯ç§ç®—æ³•ç±»å‹çš„åŸºæœ¬å·¥ä½œåŸç†åŠå…¶ä¼˜ç‚¹ã€ç¼ºç‚¹å’Œå¯èƒ½çš„æ”¹è¿›ã€‚ 5.1. Centralized task assignment algorithms é›†ä¸­å¼ä»»åŠ¡åˆ†é…ç®—æ³• Centralized task assignment algorithms require a central planner that gathers information from all UAVs, calculates the optimum strategy, and passes that information among the UAVs. The central planner can be a ground station receiving information from all the UAVs, calculating optimal plan, and informing all UAVs about the plan. In some cases, one of the UAVs can also act as a planner. Information sharing is straightforward in centralized task assignment schemes, where each UAV communicates with the central planning agent. Some cooperative algorithms proposed for task assignment are [87], [88], [89]. é›†ä¸­å¼ä»»åŠ¡åˆ†é…ç®—æ³•éœ€è¦ä¸€ä¸ªä¸­å¤®è§„åˆ’å™¨ï¼Œè¯¥è§„åˆ’å™¨ä»æ‰€æœ‰æ— äººæœºæ”¶é›†ä¿¡æ¯ï¼Œè®¡ç®—æœ€ä½³ç­–ç•¥ï¼Œå¹¶åœ¨æ— äººæœºä¹‹é—´ä¼ é€’è¯¥ä¿¡æ¯ã€‚ä¸­å¤®è§„åˆ’å™¨å¯ä»¥æ˜¯åœ°é¢ç«™ï¼Œæ¥æ”¶æ¥è‡ªæ‰€æœ‰æ— äººæœºçš„ä¿¡æ¯ï¼Œè®¡ç®—æœ€ä¼˜è®¡åˆ’ï¼Œå¹¶å°†è¯¥è®¡åˆ’é€šçŸ¥æ‰€æœ‰æ— äººæœºã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå…¶ä¸­ä¸€æ¶æ— äººæœºè¿˜å¯ä»¥å……å½“è§„åˆ’è€…ã€‚åœ¨é›†ä¸­å¼ä»»åŠ¡åˆ†é…æ–¹æ¡ˆä¸­ï¼Œä¿¡æ¯å…±äº«éå¸¸ç®€å•ï¼Œæ¯ä¸ªæ— äººæœºéƒ½ä¸ä¸­å¤®è§„åˆ’ä»£ç†è¿›è¡Œé€šä¿¡ã€‚æå‡ºçš„ä¸€äº›ç”¨äºä»»åŠ¡åˆ†é…çš„åä½œç®—æ³•æ˜¯[87] ã€ [88] ã€ [89] ã€‚ 5.1.1. Health-Aware Task Assignment (HA-TA) 5.1.1.å¥åº·æ„è¯†ä»»åŠ¡åˆ†é… (HA-TA) A robust decision-making process that improves the group's functioning reliability and competencies of distributed and self-directed UAVs using improved self-awareness systems and adaptive mission planning was studied in [90]. The task planner manages the list of tasks in the task assignment component, which decides and selects existing UAVs, which can perform tasks depending on the information about the tasks and proficiencies of the UAVs. After assigning tasks, they are referred to the trajectory manager, which plans possible trajectories for each UAV. The results from the trajectory manager are given as a series of waypoints to each UAV. UAV controllers compute the definite controls desired to follow the waypoints using these path coordinates. The health management issue is focused on using a response mechanism of the performance model used by the task assignment algorithm. [90]ç ”ç©¶äº†ä¸€ç§ç¨³å¥çš„å†³ç­–è¿‡ç¨‹ï¼Œè¯¥è¿‡ç¨‹ä½¿ç”¨æ”¹è¿›çš„è‡ªæˆ‘æ„è¯†ç³»ç»Ÿå’Œè‡ªé€‚åº”ä»»åŠ¡è§„åˆ’æ¥æé«˜åˆ†å¸ƒå¼å’Œè‡ªä¸»æ— äººæœºçš„å›¢é˜ŸåŠŸèƒ½å¯é æ€§å’Œèƒ½åŠ›ã€‚ ä»»åŠ¡è§„åˆ’å™¨ç®¡ç†ä»»åŠ¡åˆ†é…ç»„ä»¶ä¸­çš„ä»»åŠ¡åˆ—è¡¨ï¼Œè¯¥ç»„ä»¶å†³å®šå¹¶é€‰æ‹©ç°æœ‰çš„æ— äººæœºï¼Œè¿™äº›æ— äººæœºå¯ä»¥æ ¹æ®æœ‰å…³æ— äººæœºçš„ä»»åŠ¡å’Œç†Ÿç»ƒç¨‹åº¦çš„ä¿¡æ¯æ¥æ‰§è¡Œä»»åŠ¡ã€‚ åˆ†é…ä»»åŠ¡åï¼Œå®ƒä»¬è¢«è½¬äº¤ç»™è½¨è¿¹ç®¡ç†å™¨ï¼Œè½¨è¿¹ç®¡ç†å™¨ä¸ºæ¯æ¶æ— äººæœºè§„åˆ’å¯èƒ½çš„è½¨è¿¹ã€‚ è½¨è¿¹ç®¡ç†å™¨çš„ç»“æœä½œä¸ºæ¯æ¶æ— äººæœºçš„ä¸€ç³»åˆ—èˆªè·¯ç‚¹ç»™å‡ºã€‚æ— äººæœºæ§åˆ¶å™¨ä½¿ç”¨è¿™äº›è·¯å¾„åæ ‡è®¡ç®—éµå¾ªèˆªè·¯ç‚¹æ‰€éœ€çš„æ˜ç¡®æ§åˆ¶ã€‚ å¥åº·ç®¡ç†é—®é¢˜çš„é‡ç‚¹æ˜¯ä½¿ç”¨ä»»åŠ¡åˆ†é…ç®—æ³•æ‰€ä½¿ç”¨çš„æ€§èƒ½æ¨¡å‹çš„å“åº”æœºåˆ¶ã€‚ The developed health-aware task assignment algorithm was validated to be operative through simulation and real aeronautical experimentations. The preliminary outcomes were very favorable; nevertheless, many can be achieved in the health management sector, accounting for sensor performance and control actuator failure modes. Additionally, a robust performance in the face of uncertainty was achieved. é€šè¿‡æ¨¡æ‹Ÿå’ŒçœŸå®èˆªç©ºå®éªŒéªŒè¯äº†æ‰€å¼€å‘çš„å¥åº·æ„ŸçŸ¥ä»»åŠ¡åˆ†é…ç®—æ³•çš„æœ‰æ•ˆæ€§ã€‚åˆæ­¥ç»“æœéå¸¸æœ‰åˆ©ï¼›ç„¶è€Œï¼Œåœ¨å¥åº·ç®¡ç†é¢†åŸŸå¯ä»¥å®ç°è®¸å¤šç›®æ ‡ï¼Œè€ƒè™‘ä¼ æ„Ÿå™¨æ€§èƒ½å’Œæ§åˆ¶æ‰§è¡Œå™¨æ•…éšœæ¨¡å¼ã€‚æ­¤å¤–ï¼Œåœ¨é¢å¯¹ä¸ç¡®å®šæ€§æ—¶ä¹Ÿå–å¾—äº†ç¨³å¥çš„è¡¨ç°ã€‚ Advantages: Improves operational reliabilities and capabilities through adaptive task assignment systems and system awareness; demonstrated effective performance through simulation and experiments. ä¼˜ç‚¹ï¼šé€šè¿‡è‡ªé€‚åº”ä»»åŠ¡åˆ†é…ç³»ç»Ÿå’Œç³»ç»Ÿæ„è¯†æé«˜æ“ä½œå¯é æ€§å’Œèƒ½åŠ›ï¼›é€šè¿‡æ¨¡æ‹Ÿå’Œå®éªŒè¯æ˜äº†æœ‰æ•ˆçš„æ€§èƒ½ã€‚ Disadvantages: Randomly occurring failures provide a level of uncertainty; uncertainty present at all planning stages due to incomplete knowledge at the flight plan level, health of sensors during task assignment, and enduring maintenance at the mission planning level. ç¼ºç‚¹ï¼šéšæœºå‘ç”Ÿçš„æ•…éšœæä¾›äº†ä¸€å®šç¨‹åº¦çš„ä¸ç¡®å®šæ€§ï¼›ç”±äºé£è¡Œè®¡åˆ’å±‚é¢çš„çŸ¥è¯†ä¸å®Œæ•´ã€ä»»åŠ¡åˆ†é…æœŸé—´ä¼ æ„Ÿå™¨çš„å¥åº·çŠ¶å†µä»¥åŠä»»åŠ¡è§„åˆ’å±‚é¢çš„æŒä¹…ç»´æŠ¤ï¼Œæ‰€æœ‰è§„åˆ’é˜¶æ®µéƒ½å­˜åœ¨ä¸ç¡®å®šæ€§ã€‚ Possible enhancements: The amount and quality of feedback information can be improved, and a sophisticated stochastic model of health states like energy usage and sensors' performance can be embedded to deal with uncertainties. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¯ä»¥æé«˜åé¦ˆä¿¡æ¯çš„æ•°é‡å’Œè´¨é‡ï¼Œå¹¶ä¸”å¯ä»¥åµŒå…¥èƒ½æºä½¿ç”¨å’Œä¼ æ„Ÿå™¨æ€§èƒ½ç­‰å¥åº·çŠ¶æ€çš„å¤æ‚éšæœºæ¨¡å‹æ¥å¤„ç†ä¸ç¡®å®šæ€§ã€‚ 5.1.2. MILP-TA The issues of task assignment and optimal formulation to solve combined multi-assignment for a widespread search munition area were addressed in [91]. MILP can assign infeasible tasks by adding time to UAV paths due to timing constraints. It makes use of the discrete approximation of real-world scenarios. Ammunitions are essential to explore, categorize, attack, and confirm the demolition of achievable goals. Information on the target area is assumed to be communicated between all elements of the UAV swarm. A formulation based on MILP consists of optimization function, upper bound and lower bound on variables and constraints using the variables. A UAV is allowed to visit any target only twice to prevent looping. UAVs can visit a sink once to find new targets before reassignment occurs. This helps to avoid inconsistencies in UAVs entering and leaving the sink. Existing path planning and lengthening algorithms were detailed in [92], [93]. Through this formulation, the UAV flight path varies to ensure that the timing constraints are fulfilled and varying task completion times are integrated. [91]è§£å†³äº†ä»»åŠ¡åˆ†é…å’Œä¼˜åŒ–åˆ¶å®šé—®é¢˜ï¼Œä»¥è§£å†³å¹¿æ³›çš„æœç´¢å¼¹è¯åŒºåŸŸçš„ç»„åˆå¤šé‡åˆ†é…é—®é¢˜ã€‚ç”±äºæ—¶é—´é™åˆ¶ï¼ŒMILP å¯ä»¥é€šè¿‡å¢åŠ æ— äººæœºè·¯å¾„çš„æ—¶é—´æ¥åˆ†é…ä¸å¯è¡Œçš„ä»»åŠ¡ã€‚å®ƒåˆ©ç”¨ç°å®ä¸–ç•Œåœºæ™¯çš„ç¦»æ•£è¿‘ä¼¼ã€‚å¼¹è¯å¯¹äºæ¢ç´¢ã€åˆ†ç±»ã€æ”»å‡»å’Œç¡®è®¤æ‘§æ¯å¯å®ç°çš„ç›®æ ‡è‡³å…³é‡è¦ã€‚å‡è®¾æœ‰å…³ç›®æ ‡åŒºåŸŸçš„ä¿¡æ¯åœ¨æ— äººæœºç¾¤çš„æ‰€æœ‰å•å…ƒä¹‹é—´è¿›è¡Œé€šä¿¡ã€‚åŸºäº MILP çš„å…¬å¼ç”±ä¼˜åŒ–å‡½æ•°ã€å˜é‡çš„ä¸Šé™å’Œä¸‹é™ä»¥åŠä½¿ç”¨å˜é‡çš„çº¦æŸç»„æˆã€‚æ— äººæœºåªèƒ½è®¿é—®ä»»ä½•ç›®æ ‡ä¸¤æ¬¡ï¼Œä»¥é˜²æ­¢å¾ªç¯ã€‚æ— äººæœºå¯ä»¥åœ¨é‡æ–°åˆ†é…ä¹‹å‰è®¿é—®æ¥æ”¶å™¨ä¸€æ¬¡ä»¥å¯»æ‰¾æ–°ç›®æ ‡ã€‚è¿™æœ‰åŠ©äºé¿å…æ— äººæœºè¿›å…¥å’Œç¦»å¼€æ¥æ”¶å™¨çš„ä¸ä¸€è‡´ã€‚ç°æœ‰çš„è·¯å¾„è§„åˆ’å’Œå»¶é•¿ç®—æ³•åœ¨[92] ã€ [93]ä¸­æœ‰è¯¦ç»†ä»‹ç»ã€‚é€šè¿‡è¿™ä¸ªå…¬å¼ï¼Œæ— äººæœºçš„é£è¡Œè·¯å¾„ä¼šå‘ç”Ÿå˜åŒ–ï¼Œä»¥ç¡®ä¿æ»¡è¶³æ—¶é—´çº¦æŸå¹¶æ•´åˆä¸åŒçš„ä»»åŠ¡å®Œæˆæ—¶é—´ã€‚ Advantages: Useful in offline task assignment calculations; provides optimal solution for UAV groups with combined tasks with timing and task order limitations. ä¼˜ç‚¹ï¼šåœ¨ç¦»çº¿ä»»åŠ¡åˆ†é…è®¡ç®—ä¸­å¾ˆæœ‰ç”¨ï¼›ä¸ºå…·æœ‰æ—¶é—´å’Œä»»åŠ¡é¡ºåºé™åˆ¶çš„ç»„åˆä»»åŠ¡çš„æ— äººæœºç¾¤æä¾›æœ€ä½³è§£å†³æ–¹æ¡ˆã€‚ Disadvantages: Makes a discrete representation of real-world problems, which makes solutions impractical; solution requires high computation time and makes unreliable for real-time use. ç¼ºç‚¹ï¼šå¯¹ç°å®ä¸–ç•Œé—®é¢˜è¿›è¡Œç¦»æ•£è¡¨ç¤ºï¼Œå¯¼è‡´è§£å†³æ–¹æ¡ˆä¸åˆ‡å®é™…ï¼›è¯¥è§£å†³æ–¹æ¡ˆéœ€è¦å¤§é‡è®¡ç®—æ—¶é—´å¹¶ä¸”å¯¹äºå®æ—¶ä½¿ç”¨æ¥è¯´ä¸å¯é ã€‚ Possible enhancements: Kinematic constraints of UAVs should be focused; aspects of complex and dynamic environment such as obstacles, uncertainties, and wind speed must be considered. å¯èƒ½çš„æ”¹è¿›ï¼šåº”å…³æ³¨æ— äººæœºçš„è¿åŠ¨çº¦æŸï¼›å¿…é¡»è€ƒè™‘å¤æ‚åŠ¨æ€ç¯å¢ƒçš„å„ä¸ªæ–¹é¢ï¼Œä¾‹å¦‚éšœç¢ç‰©ã€ä¸ç¡®å®šæ€§å’Œé£é€Ÿã€‚ 5.1.3. Modified Two-Part Wolf Pack Search (MTWPS) 5.1.3.æ”¹è¿›çš„ä¸¤éƒ¨åˆ†ç‹¼ç¾¤æœç´¢ (MTWPS) MTWPS, a combinatorial optimization model-based task assignment using graph and optimization methods, was studied in [94]. An easy computing function is used for large UAVs and target sizes, and to solve the time-sensitive uncertainty; a practical online hierarchical planning algorithm is used. MTWPS includes traditional offline centralized situations and online capability with time-sensitive uncertainty. A number of UAVs are assigned to classify, reply, and verify tasks on targets sequentially. UAVs have different flight heights to avoid a collision. The combinatorial optimization problem is modeled as follows: MTWPS æ˜¯ä¸€ç§ä½¿ç”¨å›¾å’Œä¼˜åŒ–æ–¹æ³•çš„åŸºäºç»„åˆä¼˜åŒ–æ¨¡å‹çš„ä»»åŠ¡åˆ†é…ï¼Œåœ¨[94]ä¸­è¿›è¡Œäº†ç ”ç©¶ã€‚é’ˆå¯¹å¤§å‹æ— äººæœºå’Œç›®æ ‡å°ºå¯¸ä½¿ç”¨ç®€å•çš„è®¡ç®—å‡½æ•°ï¼Œè§£å†³æ—¶é—´æ•æ„Ÿçš„ä¸ç¡®å®šæ€§ï¼›ä½¿ç”¨å®ç”¨çš„åœ¨çº¿åˆ†å±‚è§„åˆ’ç®—æ³•ã€‚ MTWPS åŒ…æ‹¬ä¼ ç»Ÿçš„ç¦»çº¿é›†ä¸­æƒ…å†µå’Œå…·æœ‰æ—¶é—´æ•æ„Ÿä¸ç¡®å®šæ€§çš„åœ¨çº¿èƒ½åŠ›ã€‚å¤šæ¶æ— äººæœºè¢«åˆ†é…é¡ºåºå¯¹ç›®æ ‡è¿›è¡Œåˆ†ç±»ã€å›å¤å’ŒéªŒè¯ä»»åŠ¡ã€‚æ— äººæœºå…·æœ‰ä¸åŒçš„é£è¡Œé«˜åº¦ä»¥é¿å…ç¢°æ’ã€‚ç»„åˆä¼˜åŒ–é—®é¢˜å»ºæ¨¡å¦‚ä¸‹ï¼š Advantages: Deals with online uncertainties such as communication issues, UAV malfunction, and time-sensitive target problem; easy computing used to lessen simulation time for large-scale UAV networks. ä¼˜ç‚¹ï¼šå¤„ç†é€šä¿¡é—®é¢˜ã€æ— äººæœºæ•…éšœã€æ—¶é—´æ•æ„Ÿç›®æ ‡é—®é¢˜ç­‰çº¿ä¸Šä¸ç¡®å®šæ€§é—®é¢˜ï¼›ç®€å•çš„è®¡ç®—ç”¨äºå‡å°‘å¤§å‹æ— äººæœºç½‘ç»œçš„ä»¿çœŸæ—¶é—´ã€‚ Limitations: A UAV's waiting time depends on the performance of other UAVs, which makes waiting time complicated for large-scale networks; the deadlock problem is ignored. å±€é™æ€§ï¼šä¸€æ¶æ— äººæœºçš„ç­‰å¾…æ—¶é—´å–å†³äºå…¶ä»–æ— äººæœºçš„æ€§èƒ½ï¼Œè¿™ä½¿å¾—å¤§è§„æ¨¡ç½‘ç»œçš„ç­‰å¾…æ—¶é—´å˜å¾—å¤æ‚ï¼›æ­»é”é—®é¢˜è¢«å¿½ç•¥ã€‚ Possible enhancements: Different types of deadlocks require better handling, which can be focused on in the future; threats and other risks present in the stochastic environment should also be focused on. å¯èƒ½çš„æ”¹è¿›ï¼šä¸åŒç±»å‹çš„æ­»é”éœ€è¦æ›´å¥½çš„å¤„ç†ï¼Œå¯ä»¥åœ¨ä»¥åé‡ç‚¹å…³æ³¨ï¼›è¿˜åº”å…³æ³¨éšæœºç¯å¢ƒä¸­å­˜åœ¨çš„å¨èƒå’Œå…¶ä»–é£é™©ã€‚ 5.1.4. Dynamic Task Assignment (DTA) 5.1.4.åŠ¨æ€ä»»åŠ¡åˆ†é… (DTA) A mission planning and task assignment framework for the coordination of self-controlled UAVs to improve the robustness and scalability of multi-UAV operations was studied in [96]. An outline of the proposed framework is shown in Fig. 6. The main goal of the battlefield scenario is to eliminate enemy agents; hence, the maximum mission time includes search and attacks. For probable actions to attack enemies, n agents are used, and each agent is given a specific number for identification, i.e., agent_id. Agent information includes position coordinates, energy level, and payload status. However, enemy agents do not have prior knowledge of the size and location of UAVs. Because of the energy constraints in UAVs, a cost-effective approach is required to allocate tasks to an optimal UAV set. The cost of every attack action is determined using the position of the identified target, the position of available agents, available battery, and available payload. æ–‡çŒ®[96]ç ”ç©¶äº†ä¸€ç§ç”¨äºåè°ƒè‡ªæ§æ— äººæœºçš„ä»»åŠ¡è§„åˆ’å’Œä»»åŠ¡åˆ†é…æ¡†æ¶ï¼Œä»¥æé«˜å¤šæ— äººæœºæ“ä½œçš„é²æ£’æ€§å’Œå¯æ‰©å±•æ€§ã€‚æ‰€æå‡ºçš„æ¡†æ¶çš„æ¦‚è¦å¦‚å›¾ 6 æ‰€ç¤ºã€‚æˆ˜åœºåœºæ™¯çš„ä¸»è¦ç›®æ ‡æ˜¯æ¶ˆç­æ•Œæ–¹ç‰¹å·¥ï¼›å› æ­¤ï¼Œæœ€å¤§ä»»åŠ¡æ—¶é—´åŒ…æ‹¬æœç´¢å’Œæ”»å‡»ã€‚å¯¹äºæ”»å‡»æ•Œäººçš„å¯èƒ½åŠ¨ä½œï¼Œä½¿ç”¨ n ä¸ªä»£ç†ï¼Œå¹¶ä¸”æ¯ä¸ªä»£ç†è¢«èµ‹äºˆä¸€ä¸ªç‰¹å®šçš„ç¼–å·ç”¨äºè¯†åˆ«ï¼Œå³ agent_idã€‚ä»£ç†ä¿¡æ¯åŒ…æ‹¬ä½ç½®åæ ‡ã€èƒ½é‡æ°´å¹³å’Œè´Ÿè½½çŠ¶æ€ã€‚ç„¶è€Œï¼Œæ•Œæ–¹ç‰¹å·¥äº‹å…ˆå¹¶ä¸äº†è§£æ— äººæœºçš„å¤§å°å’Œä½ç½®ã€‚ç”±äºæ— äººæœºçš„èƒ½é‡é™åˆ¶ï¼Œéœ€è¦ä¸€ç§ç»æµé«˜æ•ˆçš„æ–¹æ³•æ¥å°†ä»»åŠ¡åˆ†é…ç»™æœ€ä½³æ— äººæœºç»„ã€‚æ¯æ¬¡æ”»å‡»è¡ŒåŠ¨çš„æˆæœ¬æ˜¯æ ¹æ®å·²è¯†åˆ«ç›®æ ‡çš„ä½ç½®ã€å¯ç”¨ä»£ç†çš„ä½ç½®ã€å¯ç”¨ç”µæ± å’Œå¯ç”¨æœ‰æ•ˆè´Ÿè½½æ¥ç¡®å®šçš„ã€‚ Advantages: Time efficiency, scalability, and robustness are achieved; achieves the mission goal with minimum cost. ä¼˜ç‚¹ï¼šå®ç°äº†æ—¶é—´æ•ˆç‡ã€å¯æ‰©å±•æ€§å’Œé²æ£’æ€§ï¼›ä»¥æœ€å°çš„æˆæœ¬å®ç°ä»»åŠ¡ç›®æ ‡ã€‚ Limitations: Does not consider the uncertainties and aspects of dynamic environments; preliminary information regarding the size and location of enemy UAVs is unknown. å±€é™æ€§ï¼šæ²¡æœ‰è€ƒè™‘åŠ¨æ€ç¯å¢ƒçš„ä¸ç¡®å®šæ€§å’Œæ–¹é¢ï¼›æœ‰å…³æ•Œæ–¹æ— äººæœºçš„å¤§å°å’Œä½ç½®çš„åˆæ­¥ä¿¡æ¯å°šä¸æ¸…æ¥šã€‚ Possible enhancements: Minimizing the combination of all costs is desired, requiring a solver algorithm; threats and uncertainties of the complex dynamic environments need consideration. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šéœ€è¦æœ€å°åŒ–æ‰€æœ‰æˆæœ¬çš„ç»„åˆï¼Œéœ€è¦æ±‚è§£å™¨ç®—æ³•ï¼›éœ€è¦è€ƒè™‘å¤æ‚åŠ¨æ€ç¯å¢ƒçš„å¨èƒå’Œä¸ç¡®å®šæ€§ã€‚ 5.1.5. Stochastic Multi-Criteria Acceptability Analysis (SMAA-2) 5.1.5ã€‚éšæœºå¤šæ ‡å‡†å¯æ¥å—æ€§åˆ†æ (SMAA-2) In [97], a group of UAVs was used to complete attacking tasks on ground targets in an uncertain environment. UAVs with different capabilities were allotted tasks to attack before starting the mission. Uncertain information led the criteria values of the task assignment process to be random, and the criteria weights were not known accurately. A novel task assignment process that relies on SMAA was presented in some previous works [98], [99], [100], [101], [102], [103], [104], [105], [106], [107], [108], [109], [110], [111] to deal with the abovementioned problem. Target attack tasks were assigned to multiple UAVs. æ–‡çŒ®[97]åˆ©ç”¨ä¸€ç»„æ— äººæœºåœ¨ä¸ç¡®å®šç¯å¢ƒä¸‹å®Œæˆå¯¹åœ°é¢ç›®æ ‡çš„æ”»å‡»ä»»åŠ¡ã€‚åœ¨å¼€å§‹ä»»åŠ¡ä¹‹å‰ï¼Œå…·æœ‰ä¸åŒèƒ½åŠ›çš„æ— äººæœºè¢«åˆ†é…äº†æ”»å‡»ä»»åŠ¡ã€‚ä¿¡æ¯çš„ä¸ç¡®å®šæ€§å¯¼è‡´ä»»åŠ¡åˆ†é…è¿‡ç¨‹çš„å‡†åˆ™å–å€¼å…·æœ‰éšæœºæ€§ï¼Œä¸”å‡†åˆ™æƒé‡æ— æ³•å‡†ç¡®å¾—çŸ¥ã€‚ä¹‹å‰çš„ä¸€äº›å·¥ä½œ[98] ã€ [99] ã€ [100] ã€ [101] ã€ [102] ã€ [ 103] ã€ [104] ã€ [105] ã€ [106]ä¸­æå‡ºäº†ä¸€ç§ä¾èµ– SMAA çš„æ–°é¢–ä»»åŠ¡åˆ†é…è¿‡ç¨‹ã€‚ ã€ [107] ã€ [108] ã€ [109] ã€ [110] ã€ [111]å¤„ç†ä¸Šè¿°å†…å®¹ é—®é¢˜ã€‚ç›®æ ‡æ”»å‡»ä»»åŠ¡åˆ†é…ç»™å¤šæ¶æ— äººæœºã€‚ Advantages: Uncertainties are analyzed; finds satisfactory solution even in severe situations. ä¼˜ç‚¹ï¼šåˆ†æä¸ç¡®å®šæ€§ï¼›å³ä½¿åœ¨ä¸¥å³»çš„æƒ…å†µä¸‹ä¹Ÿèƒ½æ‰¾åˆ°ä»¤äººæ»¡æ„çš„è§£å†³æ–¹æ¡ˆã€‚ Disadvantages: Sensor error or target movement leads to unclear localization; probability of UAVs being destroyed while handling attacks remains. ç¼ºç‚¹ï¼šä¼ æ„Ÿå™¨è¯¯å·®æˆ–ç›®æ ‡ç§»åŠ¨å¯¼è‡´å®šä½ä¸æ¸…æ™°ï¼›æ— äººæœºåœ¨åº”å¯¹æ”»å‡»æ—¶è¢«æ‘§æ¯çš„å¯èƒ½æ€§ä»ç„¶å­˜åœ¨ã€‚ Possible enhancements: Threats present in the defense system of targets can be made more apparent; a confidence factor is introduced to judge the accuracy of criteria values. å¯èƒ½çš„å¢å¼ºï¼šç›®æ ‡é˜²å¾¡ç³»ç»Ÿä¸­å­˜åœ¨çš„å¨èƒå¯ä»¥æ›´åŠ æ˜æ˜¾ï¼›å¼•å…¥ç½®ä¿¡å› å­æ¥åˆ¤æ–­æ ‡å‡†å€¼çš„å‡†ç¡®æ€§ã€‚ 5.1.6. Filter-Embedded UAV Task Assignment (FEUTA) 5.1.6ã€‚åµŒå…¥å¼æ»¤æ³¢å™¨æ— äººæœºä»»åŠ¡åˆ†é… (FEUTA) The classical task assignment problem was modified to form coordinated teams of UAVs to reduce the effect of noise in SA on the solution [112]. The degree of change during the reassignment process was limited appropriately. The measured approach performs reassignments at the degree of updated knowledge to immediately react to substantial fluctuations observed in the environment. Additionally, FEUTA embeds a sophisticated filtering operation during the task assignment process relying on modified weight coefficients that depend on environmental variations. ç»å…¸çš„ä»»åŠ¡åˆ†é…é—®é¢˜è¢«ä¿®æ”¹ä¸ºå½¢æˆåè°ƒçš„æ— äººæœºå›¢é˜Ÿï¼Œä»¥å‡å°‘ SA ä¸­çš„å™ªå£°å¯¹è§£å†³æ–¹æ¡ˆçš„å½±å“[112] ã€‚è°ƒåŠ¨è¿‡ç¨‹ä¸­çš„å˜åŠ¨ç¨‹åº¦å—åˆ°é€‚å½“é™åˆ¶ã€‚æµ‹é‡æ–¹æ³•ä»¥æ›´æ–°çŸ¥è¯†çš„ç¨‹åº¦æ‰§è¡Œé‡æ–°åˆ†é…ï¼Œä»¥ç«‹å³å¯¹ç¯å¢ƒä¸­è§‚å¯Ÿåˆ°çš„å¤§å¹…æ³¢åŠ¨åšå‡ºååº”ã€‚æ­¤å¤–ï¼ŒFEUTA åœ¨ä»»åŠ¡åˆ†é…è¿‡ç¨‹ä¸­åµŒå…¥äº†å¤æ‚çš„è¿‡æ»¤æ“ä½œï¼Œä¾èµ–äºå–å†³äºç¯å¢ƒå˜åŒ–çš„ä¿®æ”¹æƒé‡ç³»æ•°ã€‚ Advantages: Condenses the consequence of noise caused due to high-frequency on the planner; mitigates the effects of noise. ä¼˜ç‚¹ï¼šæµ“ç¼©äº†é«˜é¢‘å¸¦æ¥çš„å™ªå£°å¯¹è§„åˆ’è€…çš„å½±å“ï¼›å‡è½»å™ªéŸ³çš„å½±å“ã€‚ Limitations: Ignores the aspects such as threats and uncertainties, which makes it unreliable for the real environment; accepts noise entirely. å±€é™æ€§ï¼šå¿½ç•¥äº†å¨èƒå’Œä¸ç¡®å®šæ€§ç­‰æ–¹é¢ï¼Œå¯¼è‡´å…¶å¯¹äºçœŸå®ç¯å¢ƒä¸å¯é ï¼›å®Œå…¨æ¥å—å™ªéŸ³ã€‚ Possible enhancements: The importance of robust methods proposed for FEUTA and their connection to noise rejection algorithms must be investigated. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¿…é¡»ç ”ç©¶ä¸º FEUTA æå‡ºçš„é²æ£’æ–¹æ³•çš„é‡è¦æ€§åŠå…¶ä¸å™ªå£°æŠ‘åˆ¶ç®—æ³•çš„è”ç³»ã€‚ 5.1.7. Coordinated Target Assignment and Intercept (CTAI) 5.1.7.åè°ƒç›®æ ‡åˆ†é…å’Œæ‹¦æˆªï¼ˆCTAIï¼‰ Cooperative control solutions assign UAVs to pass through target locations known to have many threats [113]. The complete problem is divided into a target assignment, coordinated UAV, path planning, practicable trajectory design, and asymptotic trajectory based on hierarchical coordinated control. Different heights are considered for UAVs to avoid collisions. Satisfying decision theory [54], control settings, [114], [115], and multi-agent interactions [116] are used. Two levels are considered for UAV cooperation. There should be negotiation with UAVs and target assignment vector at a higher level to allocate UAVs to targets. After that, UAVs of each team coordinate to identify feasible team time of target (TOT). Coordination of TOT is resolved through the encapsulation of important myopic information for optimization. åä½œæ§åˆ¶è§£å†³æ–¹æ¡ˆåˆ†é…æ— äººæœºç©¿è¿‡å·²çŸ¥å­˜åœ¨è®¸å¤šå¨èƒçš„ç›®æ ‡ä½ç½®[113] ã€‚ å®Œæ•´çš„é—®é¢˜åˆ†ä¸ºç›®æ ‡åˆ†é…ã€æ— äººæœºåè°ƒã€è·¯å¾„è§„åˆ’ã€å¯è¡Œè½¨è¿¹è®¾è®¡ä»¥åŠåŸºäºåˆ†å±‚åè°ƒæ§åˆ¶çš„æ¸è¿‘è½¨è¿¹ã€‚ æ— äººæœºè€ƒè™‘ä¸åŒçš„é«˜åº¦ä»¥é¿å…ç¢°æ’ã€‚ ä½¿ç”¨æ»¡è¶³å†³ç­–ç†è®º[54] ã€æ§åˆ¶è®¾ç½®ã€ [114] ã€ [115]å’Œå¤šä¸»ä½“äº¤äº’[116] ã€‚ æ— äººæœºåˆä½œè€ƒè™‘ä¸¤ä¸ªå±‚é¢ã€‚åº”ä¸æ— äººæœºå’Œç›®æ ‡åˆ†é…å‘é‡åœ¨æ›´é«˜çº§åˆ«è¿›è¡Œåå•†ï¼Œä»¥å°†æ— äººæœºåˆ†é…ç»™ç›®æ ‡ã€‚ä¹‹åï¼Œæ¯ä¸ªå›¢é˜Ÿçš„æ— äººæœºè¿›è¡Œåè°ƒä»¥ç¡®å®šå¯è¡Œçš„å›¢é˜Ÿç›®æ ‡æ—¶é—´ï¼ˆTOTï¼‰ã€‚ TOT çš„åè°ƒæ˜¯é€šè¿‡å°è£…é‡è¦çš„è¿‘è§†ä¿¡æ¯è¿›è¡Œä¼˜åŒ–æ¥è§£å†³çš„ã€‚ Advantages: Decomposition of motion planning issues helps obtain a near-real-time solution; risk is mitigated by increasing distance between UAV and threats. ä¼˜ç‚¹ï¼šè¿åŠ¨è§„åˆ’é—®é¢˜çš„åˆ†è§£æœ‰åŠ©äºè·å¾—è¿‘å®æ—¶çš„è§£å†³æ–¹æ¡ˆï¼›é€šè¿‡å¢åŠ æ— äººæœºä¸å¨èƒä¹‹é—´çš„è·ç¦»æ¥é™ä½é£é™©ã€‚ Limitations: Tracking error increases due to disturbances; only static threats are considered, and thus the results obtained are suboptimal. å±€é™æ€§ï¼šç”±äºå¹²æ‰°ï¼Œè·Ÿè¸ªè¯¯å·®å¢å¤§ï¼›ä»…è€ƒè™‘é™æ€å¨èƒï¼Œå› æ­¤è·å¾—çš„ç»“æœä¸æ˜¯æœ€ä¼˜çš„ã€‚ Possible enhancements: Timing of target intersection can be considered; aspects of the dynamic, complex 3D environment such as wind speed, risks need consideration. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¯ä»¥è€ƒè™‘ç›®æ ‡äº¤å‰çš„æ—¶é—´ï¼›åŠ¨æ€ã€å¤æ‚çš„ 3D ç¯å¢ƒå¦‚é£é€Ÿã€é£é™©ç­‰æ–¹é¢éœ€è¦è€ƒè™‘ã€‚ 5.1.8. Energy-Efficient Task Assignment (EETA) 5.1.8ã€‚èŠ‚èƒ½ä»»åŠ¡åˆ†é… (EETA) To minimize the power consumption of ground devices and UAVs, assigning tasks and allocating resources were studied for UAV-assisted mobile edge computing (MEC) systems [117]. Energy minimization for IoT devices and UAVs through combined optimization of trajectory, appropriate task assignment, and resource assignment. It is quite challenging to solve the non-convex structure imposed by the proposed system using conventional convex optimization. Hence, block successive upper-bound minimization (BSUM) is used. ä¸ºäº†æœ€å¤§é™åº¦åœ°å‡å°‘åœ°é¢è®¾å¤‡å’Œæ— äººæœºçš„åŠŸè€—ï¼Œç ”ç©¶äº†æ— äººæœºè¾…åŠ©ç§»åŠ¨è¾¹ç¼˜è®¡ç®—ï¼ˆMECï¼‰ç³»ç»Ÿçš„ä»»åŠ¡åˆ†é…å’Œèµ„æºåˆ†é…[117] ã€‚é€šè¿‡ç»„åˆä¼˜åŒ–è½¨è¿¹ã€é€‚å½“çš„ä»»åŠ¡åˆ†é…å’Œèµ„æºåˆ†é…ï¼Œå®ç°ç‰©è”ç½‘è®¾å¤‡å’Œæ— äººæœºçš„èƒ½æºæœ€å°åŒ–ã€‚ä½¿ç”¨ä¼ ç»Ÿçš„å‡¸ä¼˜åŒ–æ¥è§£å†³æ‰€æå‡ºçš„ç³»ç»Ÿæ‰€æ–½åŠ çš„éå‡¸ç»“æ„æ˜¯ç›¸å½“å…·æœ‰æŒ‘æˆ˜æ€§çš„ã€‚å› æ­¤ï¼Œä½¿ç”¨å—è¿ç»­ä¸Šé™æœ€å°åŒ–ï¼ˆBSUMï¼‰ã€‚ Advantages: Lessens energy depletion, and optimizes task offloading, resource sharing, and trajectory without increasing delay; minimizes UAV's propulsion and computation power. ä¼˜ç‚¹ï¼šå‡å°‘èƒ½é‡æ¶ˆè€—ï¼Œåœ¨ä¸å¢åŠ å»¶è¿Ÿçš„æƒ…å†µä¸‹ä¼˜åŒ–ä»»åŠ¡å¸è½½ã€èµ„æºå…±äº«å’Œè½¨è¿¹ï¼›æœ€å¤§é™åº¦åœ°å‡å°‘æ— äººæœºçš„æ¨è¿›åŠ›å’Œè®¡ç®—èƒ½åŠ›ã€‚ Limitations: Single UAV is used, which increases the risk of mission failure. å±€é™æ€§ï¼šä½¿ç”¨å•æ¶æ— äººæœºï¼Œå¢åŠ äº†ä»»åŠ¡å¤±è´¥çš„é£é™©ã€‚ Possible enhancements: UAVs' kinematic constraints such as external forces, motions, and physical limitations of the dynamic environment such as threats and uncertainties must be considered during the assignment process. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šåœ¨ä»»åŠ¡è¿‡ç¨‹ä¸­å¿…é¡»è€ƒè™‘æ— äººæœºçš„è¿åŠ¨å­¦çº¦æŸï¼ˆä¾‹å¦‚å¤–åŠ›ã€è¿åŠ¨ï¼‰ä»¥åŠåŠ¨æ€ç¯å¢ƒçš„ç‰©ç†é™åˆ¶ï¼ˆä¾‹å¦‚å¨èƒå’Œä¸ç¡®å®šæ€§ï¼‰ã€‚ 5.1.9. Energy and Delay Aware Task Assignment (EDATA) 5.1.9.èƒ½é‡å’Œå»¶è¿Ÿæ„ŸçŸ¥ä»»åŠ¡åˆ†é… (EDATA) A robust system orchestrator (SO) to achieve value-added IoTs (VAIoTS) attained by incorporating UAVs with IoT payloads was presented in [118]. The flight of UAVs is organized using a central, SO that holds the complete information of UAVs, current positions, energy levels, flight operations, and their onboard IoT devices. SO employs energy-aware UAV selection (EAUS), delay-aware UAV selection (DAUS), and fair tradeoff UAV selection (FTUS). EAUS aims to reduce the total energy depletion by the UAVs, DAUS seeks to decrease the UAV time of operation, and FTUS aims to find a fair solution between the two conflicting objectives of energy and time. The power and time required for traveling, sensing, processing, and data transmission are considered and optimized. [118]ä¸­æå‡ºäº†ä¸€ç§å¼ºå¤§çš„ç³»ç»Ÿåè°ƒå™¨ï¼ˆSOï¼‰ï¼Œé€šè¿‡å°†æ— äººæœºä¸ç‰©è”ç½‘æœ‰æ•ˆè´Ÿè½½ç›¸ç»“åˆæ¥å®ç°å¢å€¼ç‰©è”ç½‘ï¼ˆVAIoTSï¼‰ã€‚æ— äººæœºçš„é£è¡Œæ˜¯ä½¿ç”¨ä¸­å¤® SO æ¥ç»„ç»‡çš„ï¼Œè¯¥ SO ä¿å­˜ç€æ— äººæœºçš„å®Œæ•´ä¿¡æ¯ã€å½“å‰ä½ç½®ã€èƒ½é‡æ°´å¹³ã€é£è¡Œæ“ä½œåŠå…¶æœºè½½ç‰©è”ç½‘è®¾å¤‡ã€‚ SO é‡‡ç”¨èƒ½é‡æ„ŸçŸ¥æ— äººæœºé€‰æ‹© (EAUS)ã€å»¶è¿Ÿæ„ŸçŸ¥æ— äººæœºé€‰æ‹© (DAUS) å’Œå…¬å¹³æƒè¡¡æ— äººæœºé€‰æ‹© (FTUS)ã€‚ EAUS æ—¨åœ¨å‡å°‘æ— äººæœºçš„æ€»èƒ½é‡æ¶ˆè€—ï¼ŒDAUS æ—¨åœ¨å‡å°‘æ— äººæœºçš„è¿è¡Œæ—¶é—´ï¼ŒFTUS æ—¨åœ¨åœ¨èƒ½æºå’Œæ—¶é—´è¿™ä¸¤ä¸ªç›¸äº’å†²çªçš„ç›®æ ‡ä¹‹é—´æ‰¾åˆ°å…¬å¹³çš„è§£å†³æ–¹æ¡ˆã€‚è€ƒè™‘å¹¶ä¼˜åŒ–äº†è¡Œè¿›ã€ä¼ æ„Ÿã€å¤„ç†å’Œæ•°æ®ä¼ è¾“æ‰€éœ€çš„åŠŸç‡å’Œæ—¶é—´ã€‚ Advantages: Energy consumption, operational time, and fairness of the system are optimized jointly; environmental effects on flights and performance are considered. ä¼˜ç‚¹ï¼šç³»ç»Ÿçš„èƒ½è€—ã€è¿è¡Œæ—¶é—´ã€å…¬å¹³æ€§å…±åŒä¼˜åŒ–ï¼›è€ƒè™‘äº†ç¯å¢ƒå¯¹é£è¡Œå’Œæ€§èƒ½çš„å½±å“ã€‚ Limitations: GPS localization errors and signal losses exist; increase in execution time for FTUS, which impacts the performance of the model. å±€é™æ€§ï¼šå­˜åœ¨GPSå®šä½è¯¯å·®å’Œä¿¡å·ä¸¢å¤±ï¼› FTUS çš„æ‰§è¡Œæ—¶é—´å¢åŠ ï¼Œè¿™ä¼šå½±å“æ¨¡å‹çš„æ€§èƒ½ã€‚ Possible enhancements: Cases of accidents and UAV failures must be considered; the modeling part could be improved concerning the energy consumed by GPS in errors and signal losses. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¿…é¡»è€ƒè™‘äº‹æ•…å’Œæ— äººæœºæ•…éšœçš„æƒ…å†µï¼›å»ºæ¨¡éƒ¨åˆ†å¯ä»¥é’ˆå¯¹GPSè¯¯å·®å’Œä¿¡å·æŸå¤±æ‰€æ¶ˆè€—çš„èƒ½é‡è¿›è¡Œæ”¹è¿›ã€‚ 5.1.10. Dynamic Programming-based Cooperative Task Assignment (DP-CTA) 5.1.10.åŸºäºåŠ¨æ€è§„åˆ’çš„åä½œä»»åŠ¡åˆ†é…ï¼ˆDP-CTAï¼‰ DP-CTA, which accounts for cooperation among UAVs rather than just coordination in adversarial environments, was studied [119]. As discussed in [120], [121], [122], DP-CTA relies on weapon target assignment, where weapons are assigned to targets for optimizing the mission objectives. Two approximation methods of DP have been developed for large-scale networks. A one-step method is responsible for generating a cooperative solution quickly, and a two-step method generates an optimal solution with minimum possible computation time. Using a one-step look-ahead at stage and state, maximizes the expression as [119] ç ”ç©¶äº† DP-CTAï¼Œå®ƒè€ƒè™‘äº†æ— äººæœºä¹‹é—´çš„åˆä½œï¼Œè€Œä¸ä»…ä»…æ˜¯å¯¹æŠ—ç¯å¢ƒä¸­çš„åè°ƒ ã€‚æ­£å¦‚[120] ã€ [121] ã€ [122]ä¸­æ‰€è®¨è®ºçš„ï¼ŒDP-CTA ä¾èµ–äºæ­¦å™¨ç›®æ ‡åˆ†é…ï¼Œå…¶ä¸­æ­¦å™¨è¢«åˆ†é…åˆ°ç›®æ ‡ä»¥ä¼˜åŒ–ä»»åŠ¡ç›®æ ‡ã€‚å·²ç»é’ˆå¯¹å¤§è§„æ¨¡ç½‘ç»œå¼€å‘äº†ä¸¤ç§ DP è¿‘ä¼¼æ–¹æ³•ã€‚ ä¸€æ­¥æ³•è´Ÿè´£å¿«é€Ÿç”Ÿæˆåä½œè§£ï¼Œè€Œä¸¤æ­¥æ³•åˆ™ä»¥å°½å¯èƒ½æœ€å°çš„è®¡ç®—æ—¶é—´ç”Ÿæˆæœ€ä¼˜è§£ã€‚ ä½¿ç”¨é˜¶æ®µå’ŒçŠ¶æ€çš„ä¸€æ­¥å‰ç»ï¼Œæœ€å¤§åŒ–è¡¨è¾¾å¼ï¼š maxâ¡ut,âˆ£utâˆ£â‰¤mt{S(ut)+Î»JË‰t+1(rtâˆ’ut,mtâˆ’âˆ£utâˆ£)}tâˆˆ{0,â€¦,Nâˆ’1} \\max _{u_{t},\\left|u_{t}\\right| \\leq m_{t}}\\left\\{S\\left(u_{t}\\right)+\\lambda \\bar{J}_{t+1}\\left(r_{t}-u_{t}, m_{t}-\\left|u_{t}\\right|\\right)\\right\\} \\quad t \\in\\{0, \\ldots, N-1\\} utâ€‹,âˆ£utâ€‹âˆ£â‰¤mtâ€‹maxâ€‹{S(utâ€‹)+Î»JË‰t+1â€‹(rtâ€‹âˆ’utâ€‹,mtâ€‹âˆ’âˆ£utâ€‹âˆ£)}tâˆˆ{0,â€¦,Nâˆ’1} Advantages: Generates cooperative and optimal solution quickly; recovers planning of real-world air operations providing improvements. ä¼˜ç‚¹ï¼šå¿«é€Ÿç”ŸæˆååŒæœ€ä¼˜è§£ï¼›æ¢å¤ç°å®ä¸–ç•Œç©ºä¸­ä½œæˆ˜çš„è§„åˆ’å¹¶æä¾›æ”¹è¿›ã€‚ Limitations: Computation time grows with the number of targets, and the uncertainties of real complex environment are ignored. å±€é™æ€§ï¼šè®¡ç®—æ—¶é—´éšç€ç›®æ ‡æ•°é‡çš„å¢åŠ è€Œå¢é•¿ï¼Œå¹¶ä¸”å¿½ç•¥äº†çœŸå®å¤æ‚ç¯å¢ƒçš„ä¸ç¡®å®šæ€§ã€‚ Possible enhancements: Constraints of the real dynamic environment such as sudden threats, effects of wind, and temperature on UAV flights must be focused on. å¯èƒ½çš„æ”¹è¿›ï¼šå¿…é¡»å…³æ³¨çœŸå®åŠ¨æ€ç¯å¢ƒçš„çº¦æŸï¼Œä¾‹å¦‚çªå‘å¨èƒã€é£çš„å½±å“ã€æ¸©åº¦å¯¹æ— äººæœºé£è¡Œçš„å½±å“ã€‚ 5.1.11. Prognostics and Health Monitoring (PHM)-based Multi-UAV Task Assignment (PHM-based MTA) 5.1.11.åŸºäºé¢„æµ‹å’Œå¥åº·ç›‘æµ‹ (PHM) çš„å¤šæ— äººæœºä»»åŠ¡åˆ†é…ï¼ˆåŸºäº PHM çš„ MTAï¼‰ Applying integrated vehicle health management (IVHM), based on PHM for multiple UAVs, was considered in [123] to achieve objectives with negligible spontaneous disruptions. IVHM is the ability of the system to evaluate current as well as future system health state and incorporate that with the structure of existing resources and demands. PHM is the capability to measure different states of health, forecasting forthcoming failures and predicting the probable RUL of the system based on measurements. Information from PHM consists of residual useful life (RUL) approximations. System-level RUL is designed for decision support to assign a group of UAVs to weighted tasks. RUL is determined through fault tree analysis (FTA), which is then served by a distribution function from the probability distribution function concerning time and probability of failure in critical scenarios. FTA is a widely used failure analysis technique where graphs explore potential causes of undesired states. [123]è€ƒè™‘å¯¹å¤šæ¶æ— äººæœºåº”ç”¨åŸºäº PHM çš„é›†æˆè½¦è¾†å¥åº·ç®¡ç†(IVHM)ï¼Œä»¥å®ç°è‡ªå‘å¹²æ‰°å¯å¿½ç•¥ä¸è®¡çš„ç›®æ ‡ã€‚ IVHM æ˜¯ç³»ç»Ÿè¯„ä¼°å½“å‰å’Œæœªæ¥ç³»ç»Ÿå¥åº·çŠ¶æ€å¹¶å°†å…¶ä¸ç°æœ‰èµ„æºå’Œéœ€æ±‚ç»“æ„ç›¸ç»“åˆçš„èƒ½åŠ›ã€‚ PHM èƒ½å¤Ÿæµ‹é‡ä¸åŒçš„å¥åº·çŠ¶æ€ã€é¢„æµ‹å³å°†å‘ç”Ÿçš„æ•…éšœå¹¶æ ¹æ®æµ‹é‡ç»“æœé¢„æµ‹ç³»ç»Ÿå¯èƒ½çš„ RULã€‚æ¥è‡ª PHM çš„ä¿¡æ¯ç”±å‰©ä½™ä½¿ç”¨å¯¿å‘½ (RUL) è¿‘ä¼¼å€¼ç»„æˆã€‚ç³»ç»Ÿçº§ RUL æ—¨åœ¨æ”¯æŒå†³ç­–æ”¯æŒï¼Œå°†ä¸€ç»„æ— äººæœºåˆ†é…ç»™åŠ æƒä»»åŠ¡ã€‚ RUL é€šè¿‡æ•…éšœæ ‘åˆ†æ (FTA) ç¡®å®šï¼Œç„¶åç”±å…³äºå…³é”®åœºæ™¯ä¸­æ•…éšœæ—¶é—´å’Œæ¦‚ç‡çš„æ¦‚ç‡åˆ†å¸ƒå‡½æ•°çš„åˆ†å¸ƒå‡½æ•°æä¾›æœåŠ¡ã€‚ FTA æ˜¯ä¸€ç§å¹¿æ³›ä½¿ç”¨çš„æ•…éšœåˆ†ææŠ€æœ¯ï¼Œé€šè¿‡å›¾è¡¨æ¢ç´¢ä¸è‰¯çŠ¶æ€çš„æ½œåœ¨åŸå› ã€‚ Advantages: Applies system-level RUL methodology to accomplish task assignment including failure probability. ä¼˜ç‚¹ï¼šåº”ç”¨ç³»ç»Ÿçº§ RUL æ–¹æ³•æ¥å®ŒæˆåŒ…æ‹¬æ•…éšœæ¦‚ç‡åœ¨å†…çš„ä»»åŠ¡åˆ†é…ã€‚ Limitations: It may not be feasible to know the probability of failure in advance; threats and uncertainties of real stochastic environments are ignored. å±€é™æ€§ï¼šæå‰çŸ¥é“å¤±è´¥çš„æ¦‚ç‡å¯èƒ½ä¸å¯è¡Œï¼›çœŸå®éšæœºç¯å¢ƒçš„å¨èƒå’Œä¸ç¡®å®šæ€§è¢«å¿½ç•¥ã€‚ Possible enhancements: PHM-based TA for extensive haul task reaction of algorithm during failure requires further investigation; consideration of aspects of real environment such as wind, temperature, threats is a must. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šåŸºäº PHM çš„ TA åœ¨æ•…éšœæœŸé—´ç®—æ³•çš„å¹¿æ³›æ‹–è¿ä»»åŠ¡ååº”éœ€è¦è¿›ä¸€æ­¥ç ”ç©¶ï¼›å¿…é¡»è€ƒè™‘çœŸå®ç¯å¢ƒçš„å„ä¸ªæ–¹é¢ï¼Œä¾‹å¦‚é£ã€æ¸©åº¦ã€å¨èƒã€‚ 5.2. Distributed task assignment algorithms åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³• Centralized task assignments are sometimes not feasible for UAV swarms due to underlying communication restrictions, robustness concerns during inconsistencies, and scalability. Computation requirement gets impractical once the number of agents grows, which is also a limiting factor for centralized algorithms. Distributed methods can be helpful in such situations to minimize these complications. Distributed task assignment algorithms primarily focus on market-based procedures, i.e., contract network algorithms and auction algorithms [124], [125], [126], [127]. However, decentralized algorithms require proper coordination to improve overall performance [128], [129], [130], [131]. The fundamental problem is that accomplishing harmonization requires UAVs to interchange large amounts of environmental information, existing states, and forthcoming purposes. Communication on this scale is not always possible and increases UAVs' visibility to threats. Some recent decentralized approaches to overcome the issues of centralized task assignment on each UAV are discussed in the following subsections. Information sharing is a vital part of decentralized task assignment algorithms. ç”±äºæ½œåœ¨çš„é€šä¿¡é™åˆ¶ã€ä¸ä¸€è‡´æœŸé—´çš„é²æ£’æ€§é—®é¢˜ä»¥åŠå¯æ‰©å±•æ€§ï¼Œé›†ä¸­å¼ä»»åŠ¡åˆ†é…æœ‰æ—¶å¯¹äºæ— äººæœºç¾¤æ¥è¯´æ˜¯ä¸å¯è¡Œçš„ã€‚ä¸€æ—¦ä»£ç†æ•°é‡å¢åŠ ï¼Œè®¡ç®—éœ€æ±‚å°±å˜å¾—ä¸åˆ‡å®é™…ï¼Œè¿™ä¹Ÿæ˜¯ä¸­å¿ƒåŒ–ç®—æ³•çš„é™åˆ¶å› ç´ ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œåˆ†å¸ƒå¼æ–¹æ³•æœ‰åŠ©äºæœ€å¤§é™åº¦åœ°å‡å°‘è¿™äº›å¹¶å‘ç—‡ã€‚åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•ä¸»è¦å…³æ³¨åŸºäºå¸‚åœºçš„ç¨‹åºï¼Œå³åˆçº¦ç½‘ç»œç®—æ³•å’Œæ‹å–ç®—æ³•[124] ï¼Œ [125] ï¼Œ [126] ï¼Œ [127] ã€‚ç„¶è€Œï¼Œå»ä¸­å¿ƒåŒ–ç®—æ³•éœ€è¦é€‚å½“çš„åè°ƒæ¥æé«˜æ•´ä½“æ€§èƒ½[128] ï¼Œ [129] ï¼Œ [130] ï¼Œ [131] ã€‚æ ¹æœ¬é—®é¢˜æ˜¯ï¼Œå®ç°åè°ƒéœ€è¦æ— äººæœºäº¤æ¢å¤§é‡ç¯å¢ƒä¿¡æ¯ã€ç°æœ‰çŠ¶æ€å’Œå³å°†å®ç°çš„ç›®çš„ã€‚è¿™ç§è§„æ¨¡çš„é€šä¿¡å¹¶ä¸æ€»æ˜¯å¯è¡Œï¼Œå¹¶ä¸”å¢åŠ äº†æ— äººæœºå¯¹å¨èƒçš„å¯è§æ€§ã€‚ä»¥ä¸‹å°èŠ‚å°†è®¨è®ºæœ€è¿‘çš„ä¸€äº›åˆ†æ•£æ–¹æ³•æ¥å…‹æœæ¯ä¸ªæ— äººæœºä¸Šé›†ä¸­ä»»åŠ¡åˆ†é…çš„é—®é¢˜ã€‚ä¿¡æ¯å…±äº«æ˜¯å»ä¸­å¿ƒåŒ–ä»»åŠ¡åˆ†é…ç®—æ³•çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚ 5.2.1. Auction-based Multiple Constraints Task Assignment (ABMC-TA) 5.2.1.åŸºäºæ‹å–çš„å¤šé‡çº¦æŸä»»åŠ¡åˆ†é…ï¼ˆABMC-TAï¼‰ An auction-based task assignment algorithm for assigning dynamic tasks to UAVs using multi-layer cost calculation was studied in [132]. The cost computation method divides the computation cost into four layers concerning the four constraint types. UAVs cooperate in a surveillance task considering four features: sensor type (C), field of view (F), lowest distinct pixels (P), and resolution (R). UAVs that can meet these features are selected when a new task appears. In addition, the task has a specific time window that specifies the start time for the earliest, latest, and total time required to accomplish that particular task. An auction-based task assignment algorithm is studied in [133], where UAVs are deployed as traps. [132]ç ”ç©¶äº†ä¸€ç§åŸºäºæ‹å–çš„ä»»åŠ¡åˆ†é…ç®—æ³•ï¼Œè¯¥ç®—æ³•ä½¿ç”¨å¤šå±‚æˆæœ¬è®¡ç®—å°†åŠ¨æ€ä»»åŠ¡åˆ†é…ç»™æ— äººæœºã€‚æˆæœ¬è®¡ç®—æ–¹æ³•å°†è®¡ç®—æˆæœ¬åˆ†ä¸ºæ¶‰åŠå››ç§çº¦æŸç±»å‹çš„å››å±‚ã€‚æ— äººæœºåœ¨æ‰§è¡Œç›‘è§†ä»»åŠ¡æ—¶è¦è€ƒè™‘å››ä¸ªç‰¹å¾ï¼šä¼ æ„Ÿå™¨ç±»å‹ (C)ã€è§†åœº (F)ã€æœ€ä½æ˜æ˜¾åƒç´  (P) å’Œåˆ†è¾¨ç‡ (R)ã€‚å½“æ–°çš„ä»»åŠ¡å‡ºç°æ—¶ï¼Œå°±ä¼šé€‰æ‹©èƒ½å¤Ÿæ»¡è¶³è¿™äº›ç‰¹å¾çš„æ— äººæœºã€‚æ­¤å¤–ï¼Œä»»åŠ¡è¿˜æœ‰ä¸€ä¸ªç‰¹å®šçš„æ—¶é—´çª—å£ï¼ŒæŒ‡å®šå®Œæˆè¯¥ç‰¹å®šä»»åŠ¡æ‰€éœ€çš„æœ€æ—©ã€æœ€æ™šå¼€å§‹æ—¶é—´å’Œæ€»æ—¶é—´ã€‚ [133]ç ”ç©¶äº†åŸºäºæ‹å–çš„ä»»åŠ¡åˆ†é…ç®—æ³•ï¼Œå…¶ä¸­æ— äººæœºè¢«éƒ¨ç½²ä¸ºé™·é˜±ã€‚ Advantages: Solves multi-constraint task assignment issues efficiently considering the constraints of sensors, time, danger, and fuel. ä¼˜ç‚¹ï¼šè€ƒè™‘ä¼ æ„Ÿå™¨ã€æ—¶é—´ã€å±é™©å’Œç‡ƒæ–™çš„çº¦æŸï¼Œæœ‰æ•ˆè§£å†³å¤šçº¦æŸä»»åŠ¡åˆ†é…é—®é¢˜ã€‚ Limitations: 2D environment with static obstacles considered for implementation which cannot justify the constraints of real dynamic environment; kinematics of UAV such as motion and impacts of external forces on its flight path needs consideration. å±€é™æ€§ï¼šè€ƒè™‘å®æ–½æ—¶å…·æœ‰é™æ€éšœç¢ç‰©çš„äºŒç»´ç¯å¢ƒï¼Œæ— æ³•è¯æ˜çœŸå®åŠ¨æ€ç¯å¢ƒçš„çº¦æŸï¼›éœ€è¦è€ƒè™‘æ— äººæœºçš„è¿åŠ¨å­¦ï¼Œä¾‹å¦‚è¿åŠ¨å’Œå¤–åŠ›å¯¹å…¶é£è¡Œè·¯å¾„çš„å½±å“ã€‚ Possible enhancements: Complexities imposed by real 3D environment need to be considered to confirm its practical validity; more experimental study and investigation are required to verify the efficiency of the proposed method in real environment. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šéœ€è¦è€ƒè™‘çœŸå® 3D ç¯å¢ƒå¸¦æ¥çš„å¤æ‚æ€§ï¼Œä»¥ç¡®è®¤å…¶å®é™…æœ‰æ•ˆæ€§ï¼›éœ€è¦æ›´å¤šçš„å®éªŒç ”ç©¶å’Œè°ƒæŸ¥æ¥éªŒè¯æ‰€æå‡ºçš„æ–¹æ³•åœ¨å®é™…ç¯å¢ƒä¸­çš„æœ‰æ•ˆæ€§ã€‚ 5.2.2. Robust Decentralized Task Assignment (RDTA) 5.2.2.é²æ£’çš„å»ä¸­å¿ƒåŒ–ä»»åŠ¡åˆ†é…ï¼ˆRDTAï¼‰ Decentralized task assignment for a swarm of cooperative UAVs, which performs well for sparse networks, was studied [134]. A set of waypoints is identified for UAVs, and a matrix gives their locations. A vector provides the waypoint values. A matrix characterizes the capabilities of UAVs; signifies a UAV that can handle tasks with waypoint w. Two significant phases, information consensus, and planning, are used, as shown in Fig. 7. In the first phase, UAV communication improves the consistency of the data. However, due to limitations on communication resulting from noise and slow convergence, consensus cannot be reached. In this case, the second phase, i.e., planning, must be used. RDTA uses a modified planning phase to eliminate potential conflicts [135]. In stage 1, UAVs use updated information to generate a set of candidate plans. Then, the petal algorithm is used, as discussed in [136]. In stage 2, UAVs develop the ultimate non-conflicting goal based on the candidate plan. ç ”ç©¶äº†ä¸€ç¾¤åä½œæ— äººæœºçš„åˆ†æ•£ä»»åŠ¡åˆ†é…ï¼Œå®ƒåœ¨ç¨€ç–ç½‘ç»œä¸­è¡¨ç°è‰¯å¥½[134] ã€‚ ä¸ºæ— äººæœºè¯†åˆ«ä¸€ç»„èˆªè·¯ç‚¹ï¼Œå¹¶ç”¨ä¸€ä¸ªçŸ©é˜µç»™å‡ºå®ƒä»¬çš„ä½ç½®ã€‚ çŸ¢é‡æä¾›èˆªè·¯ç‚¹å€¼ã€‚çŸ©é˜µæè¿°äº†æ— äººæœºçš„èƒ½åŠ›ï¼›w è¡¨ç¤ºå¯ä»¥å¤„ç†èˆªè·¯ç‚¹çš„ä»»åŠ¡çš„æ— äººæœºã€‚ å¦‚å›¾ 7æ‰€ç¤ºï¼Œä½¿ç”¨äº†ä¸¤ä¸ªé‡è¦çš„é˜¶æ®µï¼šä¿¡æ¯å…±è¯†å’Œè§„åˆ’ã€‚ ç¬¬ä¸€é˜¶æ®µï¼Œæ— äººæœºé€šä¿¡æé«˜äº†æ•°æ®çš„ä¸€è‡´æ€§ã€‚ç„¶è€Œï¼Œç”±äºå™ªå£°å’Œæ”¶æ•›é€Ÿåº¦æ…¢é€ æˆçš„é€šä¿¡é™åˆ¶ï¼Œæ— æ³•è¾¾æˆå…±è¯†ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¿…é¡»ä½¿ç”¨ç¬¬äºŒé˜¶æ®µï¼Œå³è§„åˆ’ã€‚ RDTA ä½¿ç”¨ä¿®æ”¹åçš„è§„åˆ’é˜¶æ®µæ¥æ¶ˆé™¤æ½œåœ¨çš„å†²çª[135] ã€‚ åœ¨ç¬¬ä¸€é˜¶æ®µï¼Œæ— äººæœºä½¿ç”¨æ›´æ–°çš„ä¿¡æ¯æ¥ç”Ÿæˆä¸€ç»„å€™é€‰è®¡åˆ’ã€‚ ç„¶åï¼Œä½¿ç”¨èŠ±ç“£ç®—æ³•ï¼Œå¦‚[136]ä¸­è®¨è®ºçš„ã€‚ åœ¨ç¬¬äºŒé˜¶æ®µï¼Œæ— äººæœºæ ¹æ®å€™é€‰è®¡åˆ’åˆ¶å®šæœ€ç»ˆçš„ä¸å†²çªç›®æ ‡ã€‚ Advantages: â€œNo Fly Zonesâ€ are considered; a modified candidate plan selection algorithm is used to improve performance and increase the robustness to the inconsistencies. ä¼˜ç‚¹ï¼šè€ƒè™‘â€œç¦é£åŒºâ€ï¼›ä¿®æ”¹åçš„å€™é€‰è®¡åˆ’é€‰æ‹©ç®—æ³•ç”¨äºæé«˜æ€§èƒ½å¹¶å¢åŠ å¯¹ä¸ä¸€è‡´çš„é²æ£’æ€§ã€‚ Disadvantages: Does not consider the heterogeneity of UAVs and targets and the constraints of the dynamic environment such as threats and effects of external forces (wind, temperature, etc.) on UAVs performance. ç¼ºç‚¹ï¼šæ²¡æœ‰è€ƒè™‘æ— äººæœºå’Œç›®æ ‡çš„å¼‚è´¨æ€§ä»¥åŠå¤–åŠ›ï¼ˆé£ã€æ¸©åº¦ç­‰ï¼‰å¯¹æ— äººæœºæ€§èƒ½çš„å¨èƒå’Œå½±å“ç­‰åŠ¨æ€ç¯å¢ƒçš„çº¦æŸã€‚ Possible enhancements: Conflicts arising due to low convergence need to be eliminated; heterogeneity of UAVs and other environmental aspects such as threats and uncertainties must be considered. å¯èƒ½çš„æ”¹è¿›ï¼šéœ€è¦æ¶ˆé™¤ç”±äºä½æ”¶æ•›æ€§è€Œäº§ç”Ÿçš„å†²çªï¼›å¿…é¡»è€ƒè™‘æ— äººæœºçš„å¼‚è´¨æ€§ä»¥åŠå¨èƒå’Œä¸ç¡®å®šæ€§ç­‰å…¶ä»–ç¯å¢ƒå› ç´ ã€‚ 5.2.3. Consensus-based Bundle Algorithm (CBBA) 5.2.3.åŸºäºå…±è¯†çš„æ†ç»‘ç®—æ³•ï¼ˆCBBAï¼‰ A conflict-free task assignment to resolve two real UAV operating complications, i.e., collision-free paths and churning behavior of UAV flight path, was considered in [137], [138]. CBBA was extended to account for obstacles and mitigate churning to reduce the algorithm's sensitivity to noise with the minimum computational burden. For a given task and agent, CBBA task assignment can be derived as maxâ¡âˆ‘i=1Nu(âˆ‘j=1Ntcij(xi,pi)xij) \\max \\sum_{i=1}^{N_{u}}\\left(\\sum_{j=1}^{N_{t}} c_{i j}\\left(x_{i,} p_{i}\\right) x_{i j}\\right) maxi=1âˆ‘Nuâ€‹â€‹(j=1âˆ‘Ntâ€‹â€‹cijâ€‹(xi,â€‹piâ€‹)xijâ€‹) [137] ã€ [138]è€ƒè™‘äº†æ— å†²çªä»»åŠ¡åˆ†é…æ¥è§£å†³ä¸¤ä¸ªå®é™…çš„æ— äººæœºæ“ä½œå¤æ‚æ€§ï¼Œå³æ— ç¢°æ’è·¯å¾„å’Œæ— äººæœºé£è¡Œè·¯å¾„çš„æ…åŠ¨è¡Œä¸ºã€‚ CBBA è¢«æ‰©å±•ä»¥è€ƒè™‘éšœç¢å¹¶å‡è½»æ…åŠ¨ï¼Œä»è€Œä»¥æœ€å°çš„è®¡ç®—è´Ÿæ‹…é™ä½ç®—æ³•å¯¹å™ªå£°çš„æ•æ„Ÿæ€§ã€‚å¯¹äºç»™å®šçš„ä»»åŠ¡å’Œä»£ç†ï¼ŒCBBA ä»»åŠ¡åˆ†é…å¯ä»¥å¯¼å‡ºä¸º maxâ¡âˆ‘i=1Nu(âˆ‘j=1Ntcij(xi,pi)xij) \\max \\sum_{i=1}^{N_{u}}\\left(\\sum_{j=1}^{N_{t}} c_{i j}\\left(x_{i,} p_{i}\\right) x_{i j}\\right) maxi=1âˆ‘Nuâ€‹â€‹(j=1âˆ‘Ntâ€‹â€‹cijâ€‹(xi,â€‹piâ€‹)xijâ€‹) åœ¨å“ªé‡Œ $x{i j}=1$ å¦‚æœ $U A V{i}$ è¢«åˆ†é…ç»™ä»»åŠ¡ $j$ è€Œ $x{i} \\in{0,1}^{N{t}}$ æ˜¯ç¬¬ $j$ ä¸ªå…ƒç´ ä¸ºçš„å‘é‡ $x_{i j}$, å’Œ $c i j(x i, p i)$ æ˜¯ä½œä¸š $x i$ å’Œè·¯å¾„ $p i$ çš„å¾—åˆ†å‡½æ•°ã€‚ [139]è¿˜ç ”ç©¶äº†åŸºäº CBBA çš„æ— äººæœºç¾¤ä¸¤å±‚ä»»åŠ¡åˆ†é…ã€‚ Advantages: Handles operational complexities of multi-UAVs; provides reliable, conflict-free UAV task assignments. ä¼˜ç‚¹ï¼šå¤„ç†å¤šæ— äººæœºæ“ä½œå¤æ‚æ€§ï¼›æä¾›å¯é ã€æ— å†²çªçš„æ— äººæœºä»»åŠ¡åˆ†é…ã€‚ Limitations: All targets may not be discovered; dynamic threats and uncertainties are ignored. å±€é™æ€§ï¼šå¯èƒ½æ— æ³•å‘ç°æ‰€æœ‰ç›®æ ‡ï¼›åŠ¨æ€å¨èƒå’Œä¸ç¡®å®šæ€§è¢«å¿½ç•¥ã€‚ Possible enhancements: Kinematic and dynamic UAV constraints on air and ground can be incorporated; UAVs need to be penalized for massive heading changes. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¯ä»¥çº³å…¥ç©ºä¸­å’Œåœ°é¢æ— äººæœºçš„è¿åŠ¨å’ŒåŠ¨æ€çº¦æŸï¼›æ— äººæœºéœ€è¦å› å¤§å¹…èˆªå‘å˜åŒ–è€Œå—åˆ°æƒ©ç½šã€‚ 5.3. Bio-inspired task assignment algorithms ä»¿ç”Ÿä»»åŠ¡åˆ†é…ç®—æ³• Bio-inspired algorithms originate from mimicking biological behavior based on their analyzing ability to deal with problems. These algorithms leave out the process of building difficult environmental models, and recommend a strong searching algorithm to meet the objective firmly. In our study, we have further classified the bio-inspired algorithms into swarm intelligence-based algorithms, GA-based algorithms, and artificial neural network (ANN)-based algorithms. On the other hand, evolutionary algorithms are stochastic methods used to find optimal solutions, and they have been applied in a variety of optimization problems [140], [141], [142]. Motivated by the nature of biological organisms, individuals learn and adapt to environmental situations for survival. The fitness function evaluates and decides which individuals are suited for the next generation in each iteration. ä»¿ç”Ÿç®—æ³•æºäºåŸºäºå…¶å¤„ç†é—®é¢˜çš„åˆ†æèƒ½åŠ›æ¥æ¨¡ä»¿ç”Ÿç‰©è¡Œä¸ºã€‚è¿™äº›ç®—æ³•çœç•¥äº†æ„å»ºå›°éš¾çš„ç¯å¢ƒæ¨¡å‹çš„è¿‡ç¨‹ï¼Œå¹¶æ¨èå¼ºå¤§çš„æœç´¢ç®—æ³•æ¥åšå®šåœ°å®ç°ç›®æ ‡ã€‚åœ¨æˆ‘ä»¬çš„ç ”ç©¶ä¸­ï¼Œæˆ‘ä»¬å°†ä»¿ç”Ÿç®—æ³•è¿›ä¸€æ­¥åˆ†ç±»ä¸ºåŸºäºç¾¤ä½“æ™ºèƒ½çš„ç®—æ³•ã€åŸºäºé—ä¼ ç®—æ³•çš„ç®—æ³•å’ŒåŸºäºäººå·¥ç¥ç»ç½‘ç»œï¼ˆANNï¼‰çš„ç®—æ³•ã€‚å¦ä¸€æ–¹é¢ï¼Œè¿›åŒ–ç®—æ³•æ˜¯ç”¨äºå¯»æ‰¾æœ€ä¼˜è§£çš„éšæœºæ–¹æ³•ï¼Œå®ƒä»¬å·²åº”ç”¨äºå„ç§ä¼˜åŒ–é—®é¢˜[140] ã€ [141] ã€ [142] ã€‚åœ¨ç”Ÿç‰©æœ‰æœºä½“æœ¬è´¨çš„æ¿€åŠ±ä¸‹ï¼Œä¸ªä½“å­¦ä¹ å¹¶é€‚åº”ç¯å¢ƒçŠ¶å†µä»¥æ±‚ç”Ÿå­˜ã€‚é€‚åº”åº¦å‡½æ•°åœ¨æ¯æ¬¡è¿­ä»£ä¸­è¯„ä¼°å¹¶å†³å®šå“ªäº›ä¸ªä½“é€‚åˆä¸‹ä¸€ä»£ã€‚ Swarm intelligence-based task assignment åŸºäºç¾¤ä½“æ™ºèƒ½çš„ä»»åŠ¡åˆ†é… Swarm intelligence is the communal behavior of self-organized and distributed particles generally witnessed in nature. These algorithms deploy a search-focused approach, where every particle operates independently. Later on, they collaborate with surrounding neighbors to explore the environment. Two different phases are involved: exploration and search. While exploring, particles sense data and then broadcast the sensed data to their neighbors through different communication channels. The data are then received by other agents of the swarm. In the search phase, every agent uses its specific data and the data obtained from its neighbors to discover a favorable direction to travel. ACO [60] and PSO [62] are some commonly used swarm intelligence-based algorithms for task assignment in the literature. ç¾¤ä½“æ™ºèƒ½æ˜¯è‡ªç„¶ç•Œä¸­æ™®éå­˜åœ¨çš„è‡ªç»„ç»‡å’Œåˆ†å¸ƒå¼ç²’å­çš„é›†ä½“è¡Œä¸ºã€‚è¿™äº›ç®—æ³•é‡‡ç”¨ä»¥æœç´¢ä¸ºä¸­å¿ƒçš„æ–¹æ³•ï¼Œå…¶ä¸­æ¯ä¸ªç²’å­ç‹¬ç«‹è¿è¡Œã€‚éšåï¼Œä»–ä»¬ä¸å‘¨å›´çš„é‚»å±…åˆä½œæ¢ç´¢ç¯å¢ƒã€‚æ¶‰åŠä¸¤ä¸ªä¸åŒçš„é˜¶æ®µï¼šæ¢ç´¢å’Œæœç´¢ã€‚åœ¨æ¢ç´¢æ—¶ï¼Œç²’å­æ„ŸçŸ¥æ•°æ®ï¼Œç„¶åé€šè¿‡ä¸åŒçš„é€šä¿¡æ¸ é“å°†æ„ŸçŸ¥åˆ°çš„æ•°æ®å¹¿æ’­ç»™é‚»å±…ã€‚ç„¶åæ•°æ®è¢«ç¾¤ä½“çš„å…¶ä»–ä»£ç†æ¥æ”¶ã€‚åœ¨æœç´¢é˜¶æ®µï¼Œæ¯ä¸ªä»£ç†ä½¿ç”¨å…¶ç‰¹å®šæ•°æ®å’Œä»é‚»å±…è·å¾—çš„æ•°æ®æ¥å‘ç°æœ‰åˆ©çš„è¡Œè¿›æ–¹å‘ã€‚ ACO [60]å’Œ PSO [62]æ˜¯æ–‡çŒ®ä¸­ä¸€äº›å¸¸ç”¨çš„åŸºäºç¾¤ä½“æ™ºèƒ½çš„ä»»åŠ¡åˆ†é…ç®—æ³•ã€‚ 5.3.1. Earliest available time with PSO (EAT-PSO) 5.3.1. PSO çš„æœ€æ—©å¯ç”¨æ—¶é—´ (EAT-PSO) A task assignment algorithm for UAVs to operate in an indoor environment has been studied [143]. A mathematical problem model and a heuristic approach to solve the problems faced by indoor UAV operation are suggested. For real-time actions, rapid response to indeterminate actions requires a practicable schedule. EAT is incorporated with PSO to find the optimum plan with a concise calculation time. Indistinguishable UAVs with cameras and substance handling tools capable of handling the desired tasks in an indoor environment were studied. UAVs can take more than one task during flight. The framework in [144] was upgraded by fitting its solvability. The scheduler allocates tasks to UAVs, and the time to start a consigned task for every UAV, flight path, hover time, waiting time, and recharge schedule are all planned. PSO-based cooperative task assignment and path planning is presented in [145]. äººä»¬å·²ç»ç ”ç©¶äº†æ— äººæœºåœ¨å®¤å†…ç¯å¢ƒä¸­è¿è¡Œçš„ä»»åŠ¡åˆ†é…ç®—æ³•[143] ã€‚æå‡ºäº†è§£å†³å®¤å†…æ— äººæœºæ“ä½œæ‰€é¢ä¸´é—®é¢˜çš„æ•°å­¦é—®é¢˜æ¨¡å‹å’Œå¯å‘å¼æ–¹æ³•ã€‚å¯¹äºå®æ—¶è¡ŒåŠ¨ï¼Œå¯¹ä¸ç¡®å®šè¡ŒåŠ¨çš„å¿«é€Ÿå“åº”éœ€è¦ä¸€ä¸ªå¯è¡Œçš„æ—¶é—´è¡¨ã€‚ EAT ä¸ PSO ç›¸ç»“åˆï¼Œä»¥ç®€æ´çš„è®¡ç®—æ—¶é—´æ‰¾åˆ°æœ€ä½³è®¡åˆ’ã€‚ç ”ç©¶äº†å…·æœ‰æ‘„åƒå¤´å’Œç‰©è´¨å¤„ç†å·¥å…·çš„ã€æ— æ³•åŒºåˆ†çš„æ— äººæœºï¼Œè¿™äº›æ— äººæœºèƒ½å¤Ÿåœ¨å®¤å†…ç¯å¢ƒä¸­å¤„ç†æ‰€éœ€çš„ä»»åŠ¡ã€‚æ— äººæœºåœ¨é£è¡Œè¿‡ç¨‹ä¸­å¯ä»¥æ‰§è¡Œå¤šé¡¹ä»»åŠ¡ã€‚ [144]ä¸­çš„æ¡†æ¶é€šè¿‡æ‹Ÿåˆå…¶å¯è§£æ€§è¿›è¡Œäº†å‡çº§ã€‚è°ƒåº¦å™¨ç»™æ— äººæœºåˆ†é…ä»»åŠ¡ï¼Œæ¯æ¶æ— äººæœºå¯åŠ¨å§”æ‰˜ä»»åŠ¡çš„æ—¶é—´ã€é£è¡Œè·¯å¾„ã€æ‚¬åœæ—¶é—´ã€ç­‰å¾…æ—¶é—´ã€å……ç”µæ—¶é—´è¡¨ç­‰éƒ½å·²è§„åˆ’å¥½ã€‚ [145]ä¸­æå‡ºäº†åŸºäº PSO çš„åä½œä»»åŠ¡åˆ†é…å’Œè·¯å¾„è§„åˆ’ã€‚ Advantages: Achieves a minimum total make span, forms a seamless UAV operation schedule, and short computation time in finding a high-quality feasible solution. ä¼˜ç‚¹ï¼šå®ç°æœ€å°çš„æ€»åˆ¶é€ å‘¨æœŸï¼Œå½¢æˆæ— ç¼çš„æ— äººæœºæ“ä½œè®¡åˆ’ï¼Œå¹¶ç¼©çŸ­æ‰¾åˆ°é«˜è´¨é‡å¯è¡Œè§£å†³æ–¹æ¡ˆçš„è®¡ç®—æ—¶é—´ã€‚ Limitations: Allows a single UAV to occupy a position at a particular time, ignoring uncertain events and obstacles. å±€é™æ€§ï¼šå…è®¸å•æ¶æ— äººæœºåœ¨ç‰¹å®šæ—¶é—´å æ®æŸä¸ªä½ç½®ï¼Œå¿½ç•¥ä¸ç¡®å®šçš„äº‹ä»¶å’Œéšœç¢ç‰©ã€‚ Possible enhancements: An anti-collision refinement phase can be incorporated, a detailed study on the distributed control of UAVs can be conducted, and the robustness of the system can be assessed. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¯ä»¥çº³å…¥é˜²ç¢°æ’ç»†åŒ–é˜¶æ®µï¼Œå¯ä»¥å¯¹æ— äººæœºçš„åˆ†å¸ƒå¼æ§åˆ¶è¿›è¡Œè¯¦ç»†ç ”ç©¶ï¼Œå¹¶å¯ä»¥è¯„ä¼°ç³»ç»Ÿçš„é²æ£’æ€§ã€‚ 5.3.2. Orchard Picking Algorithms (OPA) 5.3.2.æœå›­é‡‡æ‘˜ç®—æ³• (OPA) Influenced by the garnering proficiency of farmers, a task assignment for multiple UAVs was presented in [146]. The nearest neighbor, which is deliberated with minimum possible neighboring distance as a pointer, rapidly resolves the optimum arrangement of numerous tasks for collective accomplishment. Every target that must be destroyed necessitates various ammunition, and a collaborative task assignment model for heterogeneous UAVs is established accordingly. Three different types of task sets, i.e., reconnaissance (D), attack (A), and evaluation (V), are considered. Specifies the load task set of UAVs, where subscripts T and U indicate belonging to the task and UAV, respectively. Depending on the geometric relation between two triples, i.e., the ammunition required to destroy the target entirely and the capacity of UAVs to load this ammunition, it is decided whether tasks are fully executed. If and denote the sets of targets and UAVs, respectively, and, where is the number of types of missiles, the total number of type missiles for targets to be destroyed is given as å—å†œæ°‘æ”¶å‰²èƒ½åŠ›çš„å½±å“ï¼Œ [146]æå‡ºäº†å¤šæ— äººæœºçš„ä»»åŠ¡åˆ†é…ã€‚æœ€è¿‘é‚»ä»¥æœ€å°å¯èƒ½çš„é‚»è¿‘è·ç¦»ä¸ºæŒ‡é’ˆï¼Œå¿«é€Ÿè§£å†³ä¼—å¤šä»»åŠ¡çš„æœ€ä½³å®‰æ’ï¼Œä»¥å®ç°é›†ä½“å®Œæˆã€‚æ¯ä¸€ä¸ªéœ€è¦æ‘§æ¯çš„ç›®æ ‡éƒ½éœ€è¦ä¸åŒçš„å¼¹è¯ï¼Œå¹¶æ®æ­¤å»ºç«‹äº†å¼‚æ„æ— äººæœºçš„ååŒä»»åŠ¡åˆ†é…æ¨¡å‹ã€‚è€ƒè™‘ä¸‰ç§ä¸åŒç±»å‹çš„ä»»åŠ¡é›†ï¼Œå³ä¾¦å¯Ÿï¼ˆ D ï¼‰ã€æ”»å‡»ï¼ˆ A ï¼‰å’Œè¯„ä¼°ï¼ˆ V ï¼‰ã€‚æŒ‡å®šæ— äººæœºçš„è´Ÿè½½ä»»åŠ¡é›†ï¼Œä¸‹æ ‡ T å’Œ U åˆ†åˆ«è¡¨ç¤ºå±äºä»»åŠ¡å’Œæ— äººæœºã€‚æ ¹æ®ä¸¤ä¸ªä¸‰å…ƒç»„ä¹‹é—´çš„å‡ ä½•å…³ç³»ï¼Œå³å®Œå…¨æ‘§æ¯ç›®æ ‡æ‰€éœ€çš„å¼¹è¯å’Œæ— äººæœºè£…è½½è¯¥å¼¹è¯çš„èƒ½åŠ›ï¼Œæ¥å†³å®šä»»åŠ¡æ˜¯å¦å®Œå…¨æ‰§è¡Œã€‚å¦‚æœ å’Œ åˆ†åˆ«è¡¨ç¤ºç›®æ ‡å’Œæ— äººæœºçš„é›†åˆï¼Œå…¶ä¸­ æ˜¯å¯¼å¼¹ç±»å‹çš„æ•°é‡ï¼Œåˆ™è¦æ‘§æ¯çš„ç›®æ ‡ç±»å‹å¯¼å¼¹çš„æ€»æ•°ä¸º Advantages: Works with short execution time, highly flexible, strongly robust, and scalable; quickly finds optimal solution; avoids difficult cost function based on the tasks, and has high calculation efficiency. ä¼˜ç‚¹ï¼šæ‰§è¡Œæ—¶é—´çŸ­ã€çµæ´»æ€§é«˜ã€é²æ£’æ€§å¼ºã€å¯æ‰©å±•ï¼›å¿«é€Ÿæ‰¾åˆ°æœ€ä¼˜è§£ï¼›é¿å…äº†åŸºäºä»»åŠ¡çš„å¤æ‚æˆæœ¬å‡½æ•°ï¼Œè®¡ç®—æ•ˆç‡é«˜ã€‚ Limitations: Does not consider the constraints of the actual battlefield; threats and uncertainties that may arise in the dynamic environment are ignored. å±€é™æ€§ï¼šæ²¡æœ‰è€ƒè™‘å®é™…æˆ˜åœºçš„é™åˆ¶ï¼›åŠ¨æ€ç¯å¢ƒä¸­å¯èƒ½å‡ºç°çš„å¨èƒå’Œä¸ç¡®å®šæ€§è¢«å¿½ç•¥ã€‚ Possible enhancements: Adaptive approach of cooperative task assignment can be introduced to balance the load of UAVs and adapt to real-time battlefield situations. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¯ä»¥å¼•å…¥åä½œä»»åŠ¡åˆ†é…çš„è‡ªé€‚åº”æ–¹æ³•æ¥å¹³è¡¡æ— äººæœºçš„è´Ÿè½½å¹¶é€‚åº”å®æ—¶æˆ˜åœºæƒ…å†µã€‚ 5.3.3. Cooperative Task Assignment (CTA) 5.3.3.åˆä½œä»»åŠ¡åˆ†é…ï¼ˆCTAï¼‰ Cooperative task assignment for UAVs in obstacle-based environments was presented in [147]. The upgraded ACO-based optimization and Hungarian algorithm are collectively used for multi-UAV formation. A battlefield environment is considered, where UAVs fly from different positions, search targets in that area, and destroy them. If xi,jâˆˆ[0,1] is the decision variable, xi,j=1 when the UAV is assigned a task, and xi,j=0 otherwise. Cooperative task assignment and path planning for multi-UAVs using K-means algorithm and hybrid optimization algorithms is also studied in [148]. [147]ä¸­æå‡ºäº†åŸºäºéšœç¢çš„ç¯å¢ƒä¸­æ— äººæœºçš„åä½œä»»åŠ¡åˆ†é…ã€‚å‡çº§åçš„åŸºäºACOçš„ä¼˜åŒ–å’ŒåŒˆç‰™åˆ©ç®—æ³•å…±åŒç”¨äºå¤šæ— äººæœºç¼–é˜Ÿã€‚è€ƒè™‘æˆ˜åœºç¯å¢ƒï¼Œæ— äººæœºä»ä¸åŒä½ç½®é£è¡Œï¼Œæœç´¢è¯¥åŒºåŸŸçš„ç›®æ ‡å¹¶æ‘§æ¯å®ƒä»¬ã€‚å¦‚æœ $xi,jâˆˆ[0,1]$ æ˜¯å†³ç­–å˜é‡ï¼Œ $xi,j=1$ å½“æ— äººæœºè¢«åˆ†é…ä»»åŠ¡æ—¶ï¼Œä»¥åŠ $xi,j=0$ å¦åˆ™ã€‚æ–‡çŒ®[148]è¿˜ç ”ç©¶äº†ä½¿ç”¨K-meansç®—æ³•å’Œæ··åˆä¼˜åŒ–ç®—æ³•çš„å¤šæ— äººæœºåä½œä»»åŠ¡åˆ†é…å’Œè·¯å¾„è§„åˆ’ã€‚ Advantages: Efficiently solves considerate task assignment problems of UAVs under multiple circumstances and constraints; fast convergence and a highly stable iterative curve are assured. ä¼˜ç‚¹ï¼šé«˜æ•ˆè§£å†³å¤šç¯å¢ƒã€å¤šçº¦æŸä¸‹çš„æ— äººæœºä»»åŠ¡åˆ†é…é—®é¢˜ï¼›ç¡®ä¿å¿«é€Ÿæ”¶æ•›å’Œé«˜åº¦ç¨³å®šçš„è¿­ä»£æ›²çº¿ã€‚ Limitations: Focuses on flight length only and ignores other constraints of task assignment; threats and uncertainties of the real environment are ignored, making the solution impractical. å±€é™æ€§ï¼šä»…å…³æ³¨é£è¡Œé•¿åº¦ï¼Œå¿½ç•¥ä»»åŠ¡åˆ†é…çš„å…¶ä»–çº¦æŸï¼›ç°å®ç¯å¢ƒçš„å¨èƒå’Œä¸ç¡®å®šæ€§è¢«å¿½è§†ï¼Œä½¿å¾—è§£å†³æ–¹æ¡ˆä¸åˆ‡å®é™…ã€‚ Possible enhancements: Estimation of cost function could be adjusted considering the flight mission; in an actual battlefield environment, target values vary, and distribution of UAV firepower must be considered. å¯èƒ½çš„æ”¹è¿›ï¼šå¯ä»¥è€ƒè™‘é£è¡Œä»»åŠ¡æ¥è°ƒæ•´æˆæœ¬å‡½æ•°çš„ä¼°è®¡ï¼›åœ¨å®é™…æˆ˜åœºç¯å¢ƒä¸­ï¼Œç›®æ ‡å€¼å„ä¸ç›¸åŒï¼Œå¿…é¡»è€ƒè™‘æ— äººæœºç«åŠ›åˆ†å¸ƒã€‚ GA-based task assignment åŸºäº GA çš„ä»»åŠ¡åˆ†é… Recently, GA has a wide range of applications and it is demonstrated to be appropriate for task assignment problems [149], [150], [151], [152]. The central idea of GA is the survival of the fittest using good genetic factor (i.e., efficient assignment) to the succeeding generation. It also produces new search space combining different genes. A GA-based approach for assigning processing tasks to engines spontaneously is studied in [153]. Some other task assignment algorithms using GA are studied as well [154], [155], [156], [157]. æœ€è¿‘ï¼Œé—ä¼ ç®—æ³•å…·æœ‰å¹¿æ³›çš„åº”ç”¨ï¼Œå¹¶ä¸”å®ƒè¢«è¯æ˜é€‚ç”¨äºä»»åŠ¡åˆ†é…é—®é¢˜[149] ï¼Œ [150] ï¼Œ [151] ï¼Œ [152] ã€‚é—ä¼ ç®—æ³•çš„ä¸­å¿ƒæ€æƒ³æ˜¯åˆ©ç”¨è‰¯å¥½çš„é—ä¼ å› ç´ ï¼ˆå³æœ‰æ•ˆåˆ†é…ï¼‰ç»™ä¸‹ä¸€ä»£ï¼Œé€‚è€…ç”Ÿå­˜ã€‚å®ƒè¿˜äº§ç”Ÿç»“åˆä¸åŒåŸºå› çš„æ–°æœç´¢ç©ºé—´ã€‚ [153]ç ”ç©¶äº†ä¸€ç§åŸºäº GA çš„æ–¹æ³•ï¼Œç”¨äºè‡ªå‘åœ°å°†å¤„ç†ä»»åŠ¡åˆ†é…ç»™å¼•æ“ã€‚è¿˜ç ”ç©¶äº†ä¸€äº›ä½¿ç”¨ GA çš„å…¶ä»–ä»»åŠ¡åˆ†é…ç®—æ³•[154] ã€ [155] ã€ [156] ã€ [157] ã€‚ 5.3.4. Cooperative Multiple Task Assignment Problem with GA (CMTAP-GA) 5.3.4.é—ä¼ ç®—æ³•çš„åä½œå¤šä»»åŠ¡åˆ†é…é—®é¢˜ï¼ˆCMTAP-GAï¼‰ The combined issue of task assignment and path planning in the form of a graph was presented in [158]. The CMTAP is suggested for circumstances concerning a group of different types of UAVs. A Dubins car model-based motion planning is used to consider each vehicle's specific constraint's minimum turn radius. Consuming a determinate set for defining the visit angle of a UAV over a target, the combined problem of task assignment and path optimization was posed as a graph. This novel method results in suboptimal route assignments. Refining the visitation angle discretization results in an upgraded solution. Owing to the computational complications of the subsequent combinatorial optimization problem, GA for stochastic exploration of the space of solutions was proposed. Two different cases of UAVs group configuration were illustrated: homogeneous, where all UAVs are indistinguishable and heterogeneous, with varying competencies of working and kinematic limitations. [158]ä¸­ä»¥å›¾è¡¨çš„å½¢å¼æå‡ºäº†ä»»åŠ¡åˆ†é…å’Œè·¯å¾„è§„åˆ’çš„ç»„åˆé—®é¢˜ã€‚ CMTAP å»ºè®®ç”¨äºæ¶‰åŠä¸€ç»„ä¸åŒç±»å‹æ— äººæœºçš„æƒ…å†µã€‚åŸºäºæœå®¾æ–¯æ±½è½¦æ¨¡å‹çš„è¿åŠ¨è§„åˆ’ç”¨äºè€ƒè™‘æ¯è¾†è½¦çš„ç‰¹å®šçº¦æŸçš„æœ€å°è½¬å¼¯åŠå¾„ã€‚ä½¿ç”¨ç¡®å®šé›†æ¥å®šä¹‰æ— äººæœºåœ¨ç›®æ ‡ä¸Šçš„è®¿é—®è§’åº¦ï¼Œå°†ä»»åŠ¡åˆ†é…å’Œè·¯å¾„ä¼˜åŒ–çš„ç»„åˆé—®é¢˜å‘ˆç°ä¸ºå›¾è¡¨ã€‚è¿™ç§æ–°é¢–çš„æ–¹æ³•ä¼šå¯¼è‡´è·¯çº¿åˆ†é…ä¸ç†æƒ³ã€‚æ”¹è¿›è®¿é—®è§’åº¦ç¦»æ•£åŒ–ä¼šäº§ç”Ÿå‡çº§çš„è§£å†³æ–¹æ¡ˆã€‚ç”±äºåç»­ç»„åˆä¼˜åŒ–é—®é¢˜çš„è®¡ç®—å¤æ‚æ€§ï¼Œæå‡ºäº†å¯¹è§£ç©ºé—´è¿›è¡Œéšæœºæ¢ç´¢çš„é—ä¼ ç®—æ³•ã€‚è¯´æ˜äº†æ— äººæœºç»„é…ç½®çš„ä¸¤ç§ä¸åŒæƒ…å†µï¼šåŒç±»ï¼Œå…¶ä¸­æ‰€æœ‰æ— äººæœºéƒ½æ— æ³•åŒºåˆ†å’Œå¼‚æ„ï¼Œå…·æœ‰ä¸åŒçš„å·¥ä½œèƒ½åŠ›å’Œè¿åŠ¨å­¦é™åˆ¶ã€‚ Advantages: Promptly offers feasible task assignment solutions and real-time implementation for high dimensions; considers task priority and coordination, time constraints, and trajectory. ä¼˜ç‚¹ï¼šé’ˆå¯¹é«˜ç»´åº¦ï¼ŒåŠæ—¶æä¾›å¯è¡Œçš„ä»»åŠ¡åˆ†é…æ–¹æ¡ˆå¹¶å®æ—¶æ‰§è¡Œï¼›è€ƒè™‘ä»»åŠ¡ä¼˜å…ˆçº§å’Œåè°ƒã€æ—¶é—´é™åˆ¶å’Œè½¨è¿¹ã€‚ Disadvantages: Performance degrades if the search space is harsh; it ignores the aspects of real dynamic environments, which makes the proposed method impractical in real-time implementation. ç¼ºç‚¹ï¼šå¦‚æœæœç´¢ç©ºé—´ä¸¥é…·ï¼Œæ€§èƒ½ä¼šä¸‹é™ï¼›å®ƒå¿½ç•¥äº†çœŸå®åŠ¨æ€ç¯å¢ƒçš„å„ä¸ªæ–¹é¢ï¼Œè¿™ä½¿å¾—æ‰€æå‡ºçš„æ–¹æ³•åœ¨å®æ—¶å®æ–½ä¸­ä¸åˆ‡å®é™…ã€‚ Possible enhancements: Proper synchronization must be considered to maintain coordination among UAVs; constraints of the dynamic environment such as threats, uncertainties, and external forces and their impacts on UAV's motion need to be investigated. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¿…é¡»è€ƒè™‘é€‚å½“çš„åŒæ­¥ä»¥ä¿æŒæ— äººæœºä¹‹é—´çš„åè°ƒï¼›éœ€è¦ç ”ç©¶å¨èƒã€ä¸ç¡®å®šæ€§å’Œå¤–åŠ›ç­‰åŠ¨æ€ç¯å¢ƒçš„çº¦æŸåŠå…¶å¯¹æ— äººæœºè¿åŠ¨çš„å½±å“ã€‚ 5.3.5. Cooperative Multiple Task Assignment Problem (CMTAP) 5.3.5ã€‚åä½œå¤šä»»åŠ¡åˆ†é…é—®é¢˜ï¼ˆCMTAPï¼‰ Assigning cooperative UAVs for multiple tasks on multiple targets was proposed as a combinatorial optimization problem [159]. The authors used GA to account for distinctive necessities, such as task preference and harmonization, timing constraints, and flight restrictions. A matrix exemplification of GA chromosomes simplifies the encoding procedure and the application of genetic operatives. The set of tasks is performed by the teams of the UAVs on each target, i.e., classify, attack, verify. Each task requires execution after a successful target classification from the given observation ability. It is assumed that the probability of achieving the assigned task if the physical requirements are met sums to one. If not, the assignment algorithm is conducted again. ä¸ºå¤šä¸ªç›®æ ‡ä¸Šçš„å¤šä¸ªä»»åŠ¡åˆ†é…åä½œæ— äººæœºè¢«æå‡ºä½œä¸ºç»„åˆä¼˜åŒ–é—®é¢˜[159] ã€‚ä½œè€…ä½¿ç”¨é—ä¼ ç®—æ³•æ¥è€ƒè™‘ç‹¬ç‰¹çš„å¿…è¦æ€§ï¼Œä¾‹å¦‚ä»»åŠ¡åå¥½å’Œåè°ƒã€æ—¶é—´é™åˆ¶å’Œé£è¡Œé™åˆ¶ã€‚ GA æŸ“è‰²ä½“çš„çŸ©é˜µç¤ºä¾‹ç®€åŒ–äº†ç¼–ç è¿‡ç¨‹å’Œé—ä¼ æ“ä½œçš„åº”ç”¨ã€‚è¿™ç»„ä»»åŠ¡ç”±æ— äººæœºå›¢é˜Ÿå¯¹æ¯ä¸ªç›®æ ‡æ‰§è¡Œï¼Œå³åˆ†ç±»ã€æ”»å‡»ã€éªŒè¯ã€‚æ¯ä¸ªä»»åŠ¡éƒ½éœ€è¦åœ¨æ ¹æ®ç»™å®šçš„è§‚å¯Ÿèƒ½åŠ›æˆåŠŸè¿›è¡Œç›®æ ‡åˆ†ç±»åæ‰§è¡Œã€‚å‡è®¾å¦‚æœæ»¡è¶³ç‰©ç†è¦æ±‚ï¼Œåˆ™å®ŒæˆæŒ‡å®šä»»åŠ¡çš„æ¦‚ç‡æ€»è®¡ä¸º 1ã€‚å¦‚æœæ²¡æœ‰ï¼Œåˆ™å†æ¬¡è¿›è¡Œåˆ†é…ç®—æ³•ã€‚ Fig. 8 presents a graph representation of the CMTAP solution with two UAVs, $U=\\left{U{1}, U{2}\\right}$ and two targets $T=\\left{T{1}, T{2}\\right}$ to perform three tasks $N{m}=3$. The green line indicates the path of the first UAV, $U{1}$, starting from the initial point, visiting the target, $T{1}$, moving $\\psi=120^{\\circ}$, and completing its assignment visiting $T{2}$. However, the purple path shows the routes of $U{2}$ visiting $T{2}$ with $\\psi=0^{\\circ}$ and proceeding towards $T{1}$, returning to $T{2}$ with $\\psi=240^{\\circ}$, and flying to $T_{1}$ with $\\psi=240^{\\circ}$. å›¾ 8 å±•ç¤ºäº†ä½¿ç”¨ä¸¤æ¶æ— äººæœºçš„ CMTAP è§£å†³æ–¹æ¡ˆçš„å›¾å½¢è¡¨ç¤º, $U=\\left{U{1}, U{2}\\right}$ å’Œä¸¤ä¸ªç›®æ ‡ $T=\\left{T{1}, T{2}\\right}$ æ‰§è¡Œä¸‰é¡¹ä»»åŠ¡ $N{m}=3$ ã€‚ç»¿çº¿è¡¨ç¤ºç¬¬ä¸€æ¶æ— äººæœºçš„è·¯å¾„, $U{1}$, ä»åˆå§‹ç‚¹å‡ºå‘, è®¿é—®ç›®æ ‡ç‚¹, $T{1}$, ç§»åŠ¨ $\\psi=120^{\\circ}$, å¹¶å®Œæˆå…¶ä»»åŠ¡è®¿é—® $T{2}$ ã€‚ç„¶è€Œ, ç´«è‰²è·¯å¾„æ˜¾ç¤ºäº† $U{2}$ æ¥è®¿ $T{2}$ å’Œ $\\psi=0^{\\circ}$ å¹¶æœç€ $T{1}$, è¿”å›åˆ° $T{2}$ å’Œ $\\psi=240^{\\circ}$, å¹¶é£å¾€ $T_{1}$ å’Œ $\\psi=240^{\\circ}$ ã€‚ Advantages: Solves computational complexity for classical combinatorial optimization methods with higher efficiency and considers task priority and timing constraints. ä¼˜ç‚¹ï¼šä»¥æ›´é«˜çš„æ•ˆç‡è§£å†³ç»å…¸ç»„åˆä¼˜åŒ–æ–¹æ³•çš„è®¡ç®—å¤æ‚æ€§ï¼Œå¹¶è€ƒè™‘ä»»åŠ¡ä¼˜å…ˆçº§å’Œæ—¶åºçº¦æŸã€‚ Disadvantages: Does not consider the dynamic aspects of the environment such as impacts of threats, uncertainties, and external forces on UAVs flight; heterogeneity of tasks, targets, and UAVs are ignored. ç¼ºç‚¹ï¼šæ²¡æœ‰è€ƒè™‘ç¯å¢ƒçš„åŠ¨æ€æ–¹é¢ï¼Œå¦‚å¨èƒã€ä¸ç¡®å®šæ€§ã€å¤–åŠ›å¯¹æ— äººæœºé£è¡Œçš„å½±å“ï¼›ä»»åŠ¡ã€ç›®æ ‡å’Œæ— äººæœºçš„å¼‚è´¨æ€§è¢«å¿½ç•¥ã€‚ Possible enhancements: Moving, sudden targets, and actual environmental scenarios must be considered; computational efficiency needs to be realized to achieve a real-time solution. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¿…é¡»è€ƒè™‘ç§»åŠ¨ã€çªå‘ç›®æ ‡å’Œå®é™…ç¯å¢ƒåœºæ™¯ï¼›éœ€è¦æé«˜è®¡ç®—æ•ˆç‡æ‰èƒ½å®ç°å®æ—¶è§£å†³æ–¹æ¡ˆã€‚ 5.3.6. Modified GA-based Cooperative Task Assignment (MGA-CTA) 5.3.6ã€‚æ”¹è¿›çš„åŸºäº GA çš„åä½œä»»åŠ¡åˆ†é… (MGA-CTA) Task assignment for heterogeneous multiple UAVs, concerned with cooperative decision-making and control, was studied in [160]. In comparison to previous GA-based algorithms, genetic factors of chromosomes were distinct with regard to the tasks to be accomplished on targets in this work. In addition, a mirror demonstration of UAVs for expressing inadequate resources of UAVs was used. Information on UAV resources is maintained and updated in a timely manner to process distinct types of genes. A task assignment that assigns multiple UAVs to several tasks on various targets is a possible solution. [160]ç ”ç©¶äº†å¼‚æ„å¤šæ— äººæœºçš„ä»»åŠ¡åˆ†é…ï¼Œæ¶‰åŠåä½œå†³ç­–å’Œæ§åˆ¶ã€‚ä¸ä¹‹å‰åŸºäºé—ä¼ ç®—æ³•çš„ç®—æ³•ç›¸æ¯”ï¼ŒæŸ“è‰²ä½“çš„é—ä¼ å› ç´ åœ¨è¿™é¡¹å·¥ä½œä¸­è¦åœ¨ç›®æ ‡ä¸Šå®Œæˆçš„ä»»åŠ¡æ–¹é¢æ˜¯ä¸åŒçš„ã€‚æ­¤å¤–ï¼Œè¿˜é€šè¿‡æ— äººæœºé•œåƒæ¼”ç¤ºæ¥è¡¨è¾¾æ— äººæœºèµ„æºä¸è¶³çš„æƒ…å†µã€‚åŠæ—¶ç»´æŠ¤å’Œæ›´æ–°æ— äººæœºèµ„æºä¿¡æ¯ï¼Œä»¥å¤„ç†ä¸åŒç±»å‹çš„åŸºå› ã€‚å°†å¤šæ¶æ— äººæœºåˆ†é…ç»™ä¸åŒç›®æ ‡ä¸Šçš„å¤šé¡¹ä»»åŠ¡çš„ä»»åŠ¡åˆ†é…æ˜¯ä¸€ç§å¯èƒ½çš„è§£å†³æ–¹æ¡ˆã€‚ Advantages: Considers and addresses the heterogeneity of UAVs, targets, and environments; mirror representation to deal with the limited resources. ä¼˜ç‚¹ï¼šè€ƒè™‘å¹¶è§£å†³æ— äººæœºã€ç›®æ ‡å’Œç¯å¢ƒçš„å¼‚æ„æ€§ï¼›é•œåƒè¡¨ç¤ºæ¥å¤„ç†æœ‰é™çš„èµ„æºã€‚ Limitations: Only one kind of resource, i.e., weapon, is considered; stationary targets considered in simulation, weapons are used in one way only. å±€é™æ€§ï¼šåªè€ƒè™‘ä¸€ç§èµ„æºï¼Œå³æ­¦å™¨ï¼›åœ¨æ¨¡æ‹Ÿä¸­è€ƒè™‘å›ºå®šç›®æ ‡æ—¶ï¼Œæ­¦å™¨ä»…ä»¥ä¸€ç§æ–¹å¼ä½¿ç”¨ã€‚ Possible enhancements: Different operational and kinematic constraints of UAV must be considered; aspects of real dynamic environments such as threats, uncertainties, and other external forces and their impacts need to be analyzed. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¿…é¡»è€ƒè™‘æ— äººæœºçš„ä¸åŒæ“ä½œå’Œè¿åŠ¨å­¦çº¦æŸï¼›éœ€è¦åˆ†æçœŸå®åŠ¨æ€ç¯å¢ƒçš„å„ä¸ªæ–¹é¢ï¼Œä¾‹å¦‚å¨èƒã€ä¸ç¡®å®šæ€§å’Œå…¶ä»–å¤–éƒ¨åŠ›é‡åŠå…¶å½±å“ã€‚ 5.3.7. Cooperative Multiple Task Assignment Problem with Stochastic Velocities and Time Windows (CMTAPSVTW) 5.3.7.å…·æœ‰éšæœºé€Ÿåº¦å’Œæ—¶é—´çª—çš„åä½œå¤šä»»åŠ¡åˆ†é…é—®é¢˜ (CMTAPSVTW) A unique improved GA is anticipated to acquire a competent solution for realistic mission environments [161]. UAVs with superior abilities and some limitations are considered for task consignment. The model of Dubins car is accepted to create UAV flight paths along with two extra flights to coordinate the paths and create actual paths. ç‹¬ç‰¹çš„æ”¹è¿›å‹é—ä¼ ç®—æ³•é¢„è®¡å°†ä¸ºç°å®ä»»åŠ¡ç¯å¢ƒæä¾›æœ‰æ•ˆçš„è§£å†³æ–¹æ¡ˆ[161] ã€‚ä»»åŠ¡å§”æ‰˜æ—¶ä¼šè€ƒè™‘ä½¿ç”¨èƒ½åŠ›ä¼˜è¶Šä½†æœ‰ä¸€å®šå±€é™æ€§çš„æ— äººæœºã€‚ Dubins æ±½è½¦æ¨¡å‹è¢«ç”¨æ¥åˆ›å»ºæ— äººæœºé£è¡Œè·¯å¾„ä»¥åŠä¸¤ä¸ªé¢å¤–çš„èˆªç­æ¥åè°ƒè·¯å¾„å¹¶åˆ›å»ºå®é™…è·¯å¾„ã€‚ Advantages: Considers kinematic constraints (motion, external forces, propulsion), resource constraints (fuel and onboard weapons), and time constraints (time windows and sequence of tasks). ä¼˜ç‚¹ï¼šè€ƒè™‘è¿åŠ¨å­¦çº¦æŸï¼ˆè¿åŠ¨ã€å¤–åŠ›ã€æ¨è¿›åŠ›ï¼‰ã€èµ„æºçº¦æŸï¼ˆç‡ƒæ–™å’Œæœºè½½æ­¦å™¨ï¼‰å’Œæ—¶é—´çº¦æŸï¼ˆæ—¶é—´çª—å£å’Œä»»åŠ¡é¡ºåºï¼‰ã€‚ Limitations: Does not cover practical mission scenarios such as weather constraints, radar, terrain barriers during simulation. å±€é™æ€§ï¼šä¸æ¶µç›–æ¨¡æ‹Ÿè¿‡ç¨‹ä¸­çš„å¤©æ°”é™åˆ¶ã€é›·è¾¾ã€åœ°å½¢éšœç¢ç­‰å®é™…ä»»åŠ¡åœºæ™¯ã€‚ Possible enhancements: Distributed model with more stochastic features can be considered to cover practical mission scenarios; a comparison of a centralized and distributed algorithm for stochastic task assignment needs to be made. å¯èƒ½çš„æ”¹è¿›ï¼šå¯ä»¥è€ƒè™‘ä½¿ç”¨å…·æœ‰æ›´å¤šéšæœºç‰¹å¾çš„åˆ†å¸ƒå¼æ¨¡å‹æ¥è¦†ç›–å®é™…çš„ä»»åŠ¡åœºæ™¯ï¼›éœ€è¦å¯¹éšæœºä»»åŠ¡åˆ†é…çš„é›†ä¸­å¼å’Œåˆ†å¸ƒå¼ç®—æ³•è¿›è¡Œæ¯”è¾ƒã€‚ 5.3.8. Battle Antennae Search with GA (BAS-GA) 5.3.8. GA æˆ˜æ–—å¤©çº¿æœç´¢ (BAS-GA) The BAS algorithm-based multi-UAV task assignment using an improved GA was discussed in [162]. First, the target sequence is searched using the BAS algorithm, and then double-crossing operatives are used to increase the multiplicity of the target arrangement to find the optimal solution. Finally, dynamic adjustment of mutation probability is considered to improve the local search ability to avoid local optima. Homogeneous UAVs are assigned to accomplish tasks within a target area. Three main types of tasks are considered, i.e., Task={Reconnaissance,Attack,Verify}. [162]è®¨è®ºäº†ä½¿ç”¨æ”¹è¿›çš„ GA çš„åŸºäº BAS ç®—æ³•çš„å¤šæ— äººæœºä»»åŠ¡åˆ†é…ã€‚é¦–å…ˆä½¿ç”¨ BAS ç®—æ³•æœç´¢ç›®æ ‡åºåˆ—ï¼Œç„¶åä½¿ç”¨åŒäº¤å‰ç®—å­å¢åŠ ç›®æ ‡æ’åˆ—çš„é‡æ•°æ¥å¯»æ‰¾æœ€ä¼˜è§£ã€‚æœ€åï¼Œè€ƒè™‘åŠ¨æ€è°ƒæ•´å˜å¼‚æ¦‚ç‡ï¼Œæé«˜å±€éƒ¨æœç´¢èƒ½åŠ›ï¼Œé¿å…å±€éƒ¨æœ€ä¼˜ã€‚åŒç±»æ— äººæœºè¢«åˆ†é…æ¥å®Œæˆç›®æ ‡åŒºåŸŸå†…çš„ä»»åŠ¡ã€‚è€ƒè™‘ä¸‰ç§ä¸»è¦ç±»å‹çš„ä»»åŠ¡ï¼Œå³ Task={Reconnaissance,Attack,Verify} ã€‚ Advantages: Diversity of searching capacity improves convergence time; local search ability is increased; has good convergence from small to large missions. ä¼˜ç‚¹ï¼šæœç´¢èƒ½åŠ›çš„å¤šæ ·æ€§æé«˜äº†æ”¶æ•›æ—¶é—´ï¼›æœ¬åœ°æœç´¢èƒ½åŠ›å¢å¼ºï¼›ä»å°åˆ°å¤§ä»»åŠ¡å…·æœ‰è‰¯å¥½çš„æ”¶æ•›æ€§ã€‚ Limitations: Does not consider the kinematics of UAV which impacts on performance and constraints of the realistic dynamic environment such as threats and uncertainties. å±€é™æ€§ï¼šæ²¡æœ‰è€ƒè™‘æ— äººæœºçš„è¿åŠ¨å­¦å¯¹æ€§èƒ½çš„å½±å“ä»¥åŠç°å®åŠ¨æ€ç¯å¢ƒçš„çº¦æŸï¼Œä¾‹å¦‚å¨èƒå’Œä¸ç¡®å®šæ€§ã€‚ Possible enhancements: Rapid task adjustment using centralized and distributed methods can be experimented on; integration of path plan into task assignment for broad task planning for multi-UAVs can be done. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¯ä»¥å°è¯•ä½¿ç”¨é›†ä¸­å¼å’Œåˆ†å¸ƒå¼æ–¹æ³•å¿«é€Ÿè°ƒæ•´ä»»åŠ¡ï¼›å¯ä»¥å°†è·¯å¾„è§„åˆ’é›†æˆåˆ°ä»»åŠ¡åˆ†é…ä¸­ï¼Œä»¥å®ç°å¤šæ— äººæœºçš„å¹¿æ³›ä»»åŠ¡è§„åˆ’ã€‚ 5.3.9. Opposition-based GA Using Double-Chromosomes Encoding and Multiple Mutation Operators (OGA-DEMMO) 5.3.9.ä½¿ç”¨åŒæŸ“è‰²ä½“ç¼–ç å’Œå¤šçªå˜ç®—å­çš„åŸºäºå¯¹ç«‹çš„é—ä¼ ç®—æ³• (OGA-DEMMO) Multi-UAV-based reconnaissance for heterogeneous targets using GA to optimize the task sequence of UAVs was considered in [163]. Targets are classified as line targets, point targets, and area targets, considering the features of the target geometry and view of the sensor's field. To solve the computational issues, OGA-DEMMO was developed to enhance the variety of the population to improve the global exploration ability. OGA-DEMMO aims to find the best task assignment to UAVs, maximizing overall performance effectiveness. [163]è€ƒè™‘äº†åŸºäºå¤šæ— äººæœºçš„å¼‚æ„ç›®æ ‡ä¾¦å¯Ÿï¼Œä½¿ç”¨é—ä¼ ç®—æ³•æ¥ä¼˜åŒ–æ— äººæœºçš„ä»»åŠ¡åºåˆ—ã€‚è€ƒè™‘åˆ°ç›®æ ‡å‡ ä½•å½¢çŠ¶å’Œä¼ æ„Ÿå™¨è§†åœºçš„ç‰¹å¾ï¼Œå°†ç›®æ ‡åˆ†ä¸ºçº¿ç›®æ ‡ã€ç‚¹ç›®æ ‡å’ŒåŒºåŸŸç›®æ ‡ã€‚ä¸ºäº†è§£å†³è®¡ç®—é—®é¢˜ï¼Œå¼€å‘äº†OGA-DEMMOæ¥å¢å¼ºç§ç¾¤çš„å¤šæ ·æ€§ï¼Œä»¥æé«˜å…¨å±€æ¢ç´¢èƒ½åŠ›ã€‚ OGA-DEMMO æ—¨åœ¨æ‰¾åˆ°æ— äººæœºçš„æœ€ä½³ä»»åŠ¡åˆ†é…ï¼Œæœ€å¤§é™åº¦åœ°æé«˜æ•´ä½“æ€§èƒ½æ•ˆç‡ã€‚ Advantages: Minimizes the execution time and total UAV consumption and improves the optimality of the algorithm and convergence energy. ä¼˜ç‚¹ï¼šæœ€å°åŒ–æ‰§è¡Œæ—¶é—´å’Œæ— äººæœºæ€»æ¶ˆè€—ï¼Œæé«˜ç®—æ³•çš„æœ€ä¼˜æ€§å’Œæ”¶æ•›èƒ½é‡ã€‚ Limitations: No constraints are considered for reconnaissance; if the sensor's field of view covers the ground target, the task on that target is ended; constant UAV velocity is considered. å±€é™æ€§ï¼šä¾¦å¯Ÿæ—¶ä¸è€ƒè™‘ä»»ä½•çº¦æŸï¼›å¦‚æœä¼ æ„Ÿå™¨çš„è§†é‡è¦†ç›–äº†åœ°é¢ç›®æ ‡ï¼Œåˆ™å¯¹è¯¥ç›®æ ‡çš„ä»»åŠ¡ç»“æŸï¼›è€ƒè™‘æ’å®šçš„æ— äººæœºé€Ÿåº¦ã€‚ Possible enhancements: Constraints of natural and dynamic environments such as threats, uncertainties, and other external forces can be considered. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¯ä»¥è€ƒè™‘è‡ªç„¶å’ŒåŠ¨æ€ç¯å¢ƒçš„çº¦æŸï¼Œä¾‹å¦‚å¨èƒã€ä¸ç¡®å®šæ€§å’Œå…¶ä»–å¤–åŠ›ã€‚ Artificial Neural Network (ANN)-based Task Assignment åŸºäºäººå·¥ç¥ç»ç½‘ç»œ (ANN) çš„ä»»åŠ¡åˆ†é… Coordination and cooperation always remain as a challenge in multi-robot and multi-agent systems. The ultimate goal of the agents is to find an optimal policy to maximize the cumulative reward instead of the local optimal solution in real time. In recent years, ANN has been developed as a promising approach to solve the issues of dynamic environment by continuously interacting with the environment. DRL [164], [165], DNN [166], SOM [167], and DQN [168] are some commonly used ANN algorithms. Existing ANN-based task assignment algorithms were studied in the literature [169], [170], [171], [172]. åè°ƒä¸åˆä½œå§‹ç»ˆæ˜¯å¤šæœºå™¨äººå’Œå¤šæ™ºèƒ½ä½“ç³»ç»Ÿä¸­çš„ä¸€ä¸ªæŒ‘æˆ˜ã€‚æ™ºèƒ½ä½“çš„æœ€ç»ˆç›®æ ‡æ˜¯å®æ—¶æ‰¾åˆ°æœ€å¤§åŒ–ç´¯ç§¯å¥–åŠ±çš„æœ€ä¼˜ç­–ç•¥ï¼Œè€Œä¸æ˜¯å±€éƒ¨æœ€ä¼˜è§£ã€‚è¿‘å¹´æ¥ï¼Œäººå·¥ç¥ç»ç½‘ç»œå·²æˆä¸ºä¸€ç§é€šè¿‡ä¸ç¯å¢ƒæŒç»­äº¤äº’æ¥è§£å†³åŠ¨æ€ç¯å¢ƒé—®é¢˜çš„æœ‰å‰é€”çš„æ–¹æ³•ã€‚ DRL [164] ã€ [165] ã€ DNN [166] ã€SOM [167]å’Œ DQN [168]æ˜¯ä¸€äº›å¸¸ç”¨çš„ ANN ç®—æ³•ã€‚ç°æœ‰çš„åŸºäº ANN çš„ä»»åŠ¡åˆ†é…ç®—æ³•åœ¨æ–‡çŒ®[169] ã€ [170] ã€ [171] ã€ [172]ä¸­è¿›è¡Œäº†ç ”ç©¶ã€‚ 5.3.10. Fast Task Assignment (FTA) 5.3.10.å¿«é€Ÿä»»åŠ¡åˆ†é… (FTA) A Q-learning-based task assignment for heterogeneous UAVs in uncertain environments through neural network (NN) estimation and experience replay with priority to solve R L problems was studied in [173]. $T={T 1, T 2, \\ldots, T N}$ represents tasks in order of priority, and ${a t t(T k), \\operatorname{def}(T k), e l e(T k)}$ is attack capability, defense capability, and electronic jamming capability, respectively, to complete task Tk. Environmental uncertainty is denoted as $envk ={w k, r k}$, where w k represents wind speed, and r k represents rainfall. In addition, UAVs are denoted as $U=\\left{U{1}^{j}, U{12}^{j}, \\ldots, U_{m}^{j}\\right}$, and $\\left{a t t\\left(U^{j}\\right), \\operatorname{def}(T k), \\operatorname{ele}(T k)\\right}$ is the attack capability, defense capability, and electronic jamming capability of a j-type UAV. Task assignment can be formulated by repetitively choosing UAV type in correspondence with the maximum Q-value using the greedy. strategy as depicted in Fig. 9. [173]ç ”ç©¶äº†ä¸€ç§åŸºäº Q å­¦ä¹ çš„å¼‚æ„æ— äººæœºåœ¨ä¸ç¡®å®šç¯å¢ƒä¸­çš„ä»»åŠ¡åˆ†é…ï¼Œé€šè¿‡ç¥ç»ç½‘ç»œï¼ˆNNï¼‰ä¼°è®¡å’Œç»éªŒå›æ”¾ä¼˜å…ˆè§£å†³ R L é—®é¢˜ã€‚ $T={T 1, T 2, \\ldots, T N}$ æŒ‰ä¼˜å…ˆçº§é¡ºåºè¡¨ç¤ºä»»åŠ¡, å¹¶ä¸” ${\\operatorname{att}(T k), \\operatorname{def}(T k), \\operatorname{ele}(T k)}$ åˆ†åˆ«ä¸ºå®Œæˆä»»åŠ¡ $T k$ çš„æ”»å‡»èƒ½åŠ›ã€é˜²å¾¡èƒ½åŠ›å’Œç”µå­å¹²æ‰°èƒ½åŠ›ã€‚ ç¯å¢ƒä¸ç¡®å®šæ€§è¡¨ç¤ºä¸º $e n v k={w k, r k}$ ï¼Œå…¶ä¸­ $w k$ ä»£è¡¨é£é€Ÿï¼Œ$rk$ ä»£è¡¨é™é›¨é‡ã€‚ æ­¤å¤–ï¼Œæ— äººæœºè¢«è¡¨ç¤ºä¸º $U=\\left{U{1}^{j}, U{12}^{j}, \\ldots, U_{m}^{j}\\right}$ ï¼Œå’Œ$\\left{\\operatorname{att}\\left(U^{j}\\right), \\operatorname{def}(T k), \\operatorname{ele}(T k)\\right}$ æ˜¯ $j$ å‹æ— äººæœºçš„æ”»å‡»èƒ½åŠ›ã€é˜²å¾¡èƒ½åŠ›å’Œç”µå­å¹²æ‰°èƒ½åŠ›ã€‚ å¯ä»¥é€šè¿‡ä½¿ç”¨è´ªå©ªç­–ç•¥é‡å¤é€‰æ‹©ä¸æœ€å¤§ Q å€¼ç›¸å¯¹åº”çš„æ— äººæœºç±»å‹æ¥åˆ¶å®šä»»åŠ¡åˆ†é…ï¼Œå¦‚å›¾ 9 æ‰€ç¤ºã€‚ Advantages: Computationally fast and efficient, highly adaptive, and handles uncertainty; deals with different types of tasks. ä¼˜ç‚¹ï¼šè®¡ç®—å¿«é€Ÿé«˜æ•ˆã€é€‚åº”æ€§å¼ºã€å¤„ç†ä¸ç¡®å®šæ€§ï¼›å¤„ç†ä¸åŒç±»å‹çš„ä»»åŠ¡ã€‚ Disadvantages: Considers only stationary targets; complexities and aspects of the real battlefield environment are ignored. ç¼ºç‚¹ï¼šä»…è€ƒè™‘é™æ­¢ç›®æ ‡ï¼›çœŸå®æˆ˜åœºç¯å¢ƒçš„å¤æ‚æ€§å’Œå„ä¸ªæ–¹é¢éƒ½è¢«å¿½ç•¥äº†ã€‚ Possible enhancements: Moving and sudden targets and complexities of real battlefield environmental scenarios must be considered. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¿…é¡»è€ƒè™‘ç§»åŠ¨å’Œçªç„¶çš„ç›®æ ‡ä»¥åŠçœŸå®æˆ˜åœºç¯å¢ƒåœºæ™¯çš„å¤æ‚æ€§ã€‚ 5.4. Multi-fusion-based task assignments åŸºäºå¤šé‡èåˆçš„ä»»åŠ¡åˆ†é… To meet the requirements of UAV applications, the fusion of two or more task assignment algorithms is practiced in the literature. GA, ACO, and PSO-based multi-UAV task assignments for team orienteering problems are studied [174]. In this manner, the limitations imposed by specific algorithms can be complemented by the advantages of other algorithms, and hence, the best solution can be achieved. A few studies that utilized a combination of two or more algorithms are presented below. ä¸ºäº†æ»¡è¶³æ— äººæœºåº”ç”¨çš„è¦æ±‚ï¼Œæ–‡çŒ®ä¸­å®è·µäº†ä¸¤ç§æˆ–å¤šç§ä»»åŠ¡åˆ†é…ç®—æ³•çš„èåˆã€‚ç ”ç©¶äº†é’ˆå¯¹å›¢é˜Ÿå®šå‘é—®é¢˜çš„åŸºäº GAã€ ACOå’Œ PSO çš„å¤šæ— äººæœºä»»åŠ¡åˆ†é…[174] ã€‚è¿™æ ·ï¼Œç‰¹å®šç®—æ³•çš„é™åˆ¶å¯ä»¥é€šè¿‡å…¶ä»–ç®—æ³•çš„ä¼˜ç‚¹æ¥è¡¥å……ï¼Œä»è€Œè·å¾—æœ€ä½³è§£å†³æ–¹æ¡ˆã€‚ä¸‹é¢ä»‹ç»äº†ä¸€äº›ç»“åˆä½¿ç”¨ä¸¤ç§æˆ–å¤šç§ç®—æ³•çš„ç ”ç©¶ã€‚ 5.4.1. Robust Filter Embedded Task Assignment (RFETA) 5.4.1.é²æ£’è¿‡æ»¤å™¨åµŒå…¥å¼ä»»åŠ¡åˆ†é… (RFETA) A combination of robust and FETA algorithms for uncertain and dynamic environments was presented in [175]. One of the approaches is used to design task plans robust to uncertainties, reduce sensitivity to errors in situational awareness, and work for long durations. After updating these results, the following approach plans again, resulting in the best plan with the current information. However, this may lead to churning if updates are frequent. RFETA uses proactive and reactive methods for handling uncertainties and enhances the worst-case scenario expressed as [175]ä¸­æå‡ºäº†é’ˆå¯¹ä¸ç¡®å®šå’ŒåŠ¨æ€ç¯å¢ƒçš„é²æ£’ç®—æ³•å’Œ FETA ç®—æ³•çš„ç»„åˆã€‚ å…¶ä¸­ä¸€ç§æ–¹æ³•ç”¨äºè®¾è®¡å¯¹ä¸ç¡®å®šæ€§å…·æœ‰é²æ£’æ€§çš„ä»»åŠ¡è®¡åˆ’ï¼Œé™ä½å¯¹æ€åŠ¿æ„ŸçŸ¥é”™è¯¯çš„æ•æ„Ÿæ€§ï¼Œå¹¶é•¿æ—¶é—´å·¥ä½œã€‚ æ›´æ–°è¿™äº›ç»“æœåï¼Œä»¥ä¸‹æ–¹æ³•å†æ¬¡è®¡åˆ’ï¼Œä»è€Œæ ¹æ®å½“å‰ä¿¡æ¯å¾—å‡ºæœ€ä½³è®¡åˆ’ã€‚ ä½†æ˜¯ï¼Œå¦‚æœæ›´æ–°é¢‘ç¹ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´æµå¤±ã€‚ RFETA ä½¿ç”¨ä¸»åŠ¨å’Œè¢«åŠ¨æ–¹æ³•æ¥å¤„ç†ä¸ç¡®å®šæ€§ï¼Œå¹¶å¢å¼ºæœ€åæƒ…å†µçš„æƒ…å†µï¼Œè¡¨ç¤ºä¸º maxâ¡xk1âˆˆXk(Ckâ€¾âˆ’Î»â€¾kâ‹…Ïƒk)Txk1âˆ’Î²kT(xk1âŠ•xkâˆ’1) \\max _{x_{k 1} \\in X_{k}}\\left(\\overline{C_{k}}-\\underline{\\lambda}_{k} \\cdot \\sigma_{k}\\right)^{T} x_{k 1}-\\beta_{k}^{T}\\left(x_{k 1} \\oplus x_{k-1}\\right) xk1â€‹âˆˆXkâ€‹maxâ€‹(Ckâ€‹â€‹âˆ’Î»â€‹kâ€‹â‹…Ïƒkâ€‹)Txk1â€‹âˆ’Î²kTâ€‹(xk1â€‹âŠ•xkâˆ’1â€‹) åœ¨å“ªé‡Œ $\\overline{C{k}}$ æ˜¯ $k$ æ—¶åˆ»çš„æœ€å°å€¼, $\\oplus$ æ˜¯å¼‚æˆ–, $x{k 1}$ æ˜¯æ—¶é—´ $k 1$ æ—¶çš„å†³ç­–å˜é‡, å¹¶ä¸” $\\underline{\\lambda}{k} \\circ \\sigma{k}$ è¡¨ç¤ºé€ä¸ªå…ƒç´ çš„ä¹˜æ³•ã€‚ Advantages: Presents robust results in uncertain environments; sensitive to errors; minimizes the effects of noise; yields fast convergence, and reduces churning. ä¼˜ç‚¹ï¼šåœ¨ä¸ç¡®å®šçš„ç¯å¢ƒä¸­å‘ˆç°ç¨³å¥çš„ç»“æœï¼›å¯¹é”™è¯¯æ•æ„Ÿï¼›æœ€å¤§é™åº¦åœ°å‡å°‘å™ªéŸ³çš„å½±å“ï¼›äº§ç”Ÿå¿«é€Ÿæ”¶æ•›ï¼Œå¹¶å‡å°‘æ…åŠ¨ã€‚ Limitations: It does not perform better if lots of information must be considered while planning. å±€é™æ€§ï¼šå¦‚æœåœ¨è§„åˆ’æ—¶å¿…é¡»è€ƒè™‘å¤§é‡ä¿¡æ¯ï¼Œå®ƒçš„æ€§èƒ½å¹¶ä¸ä¼šæ›´å¥½ã€‚ Possible enhancements: Effects of intermittent measurements on the performance of RFETA can be studied; adaptive formulations of tuning parameter Î» for optimization can be studied. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¯ä»¥ç ”ç©¶é—´æ­‡æµ‹é‡å¯¹ RFETA æ€§èƒ½çš„å½±å“ï¼›å¯ä»¥ç ”ç©¶ç”¨äºä¼˜åŒ–çš„è°ƒæ•´å‚æ•°Î»çš„è‡ªé€‚åº”å…¬å¼ã€‚ 5.4.2. Energy-Efficient Multi-UAV Assisted Multi- Access Edge Computing (EMU-MEC) 5.4.2.èŠ‚èƒ½å¤šæ— äººæœºè¾…åŠ©å¤šè·¯è®¿é—®è¾¹ç¼˜è®¡ç®— (EMU-MEC) Energy efficient multi-UAV task assignment using MEC that offers computing services to resource-constrained UAVs has been studied [176]. Task assignment, joint device association, and computing resource assignment problems were formulated for the minimization of energy depletion considering the power budget, existing resources for computing at UAVs, and deadline restraints. The problem is first decomposed into three sub-problems and solved using the iterative block coordinate descent (BCD) algorithm. A single UAV-aided MEC was studied in [177], [178] where UAV roams around the target area to aid as a server. Performance and stability of the single UAV based system is constrained. Thus, constraints of energy, computing power, task completion are improved by controlling association of devices and resource assignment variables in multi-UAV system in the proposed method. äººä»¬å·²ç»ç ”ç©¶äº†ä½¿ç”¨ MEC ä¸ºèµ„æºå—é™çš„æ— äººæœºæä¾›è®¡ç®—æœåŠ¡çš„èŠ‚èƒ½å¤šæ— äººæœºä»»åŠ¡åˆ†é…[176] ã€‚ è€ƒè™‘åˆ°åŠŸç‡é¢„ç®—ã€æ— äººæœºè®¡ç®—çš„ç°æœ‰èµ„æºå’ŒæœŸé™é™åˆ¶ï¼Œåˆ¶å®šäº†ä»»åŠ¡åˆ†é…ã€è”åˆè®¾å¤‡å…³è”å’Œè®¡ç®—èµ„æºåˆ†é…é—®é¢˜ï¼Œä»¥æœ€å¤§é™åº¦åœ°å‡å°‘èƒ½é‡æ¶ˆè€—ã€‚ è¯¥é—®é¢˜é¦–å…ˆåˆ†è§£ä¸ºä¸‰ä¸ªå­é—®é¢˜ï¼Œå¹¶ä½¿ç”¨è¿­ä»£å—åæ ‡ä¸‹é™ï¼ˆBCDï¼‰ç®—æ³•è¿›è¡Œæ±‚è§£ã€‚ [177] ã€ [178]ç ”ç©¶äº†å•ä¸ªæ— äººæœºè¾…åŠ©çš„ MEC ï¼Œå…¶ä¸­æ— äººæœºåœ¨ç›®æ ‡åŒºåŸŸå‘¨å›´æ¼«æ¸¸ï¼Œä½œä¸ºæœåŠ¡å™¨æä¾›å¸®åŠ©ã€‚å•ä¸€æ— äººæœºç³»ç»Ÿçš„æ€§èƒ½å’Œç¨³å®šæ€§å—åˆ°é™åˆ¶ã€‚å› æ­¤ï¼Œè¯¥æ–¹æ³•é€šè¿‡æ§åˆ¶å¤šæ— äººæœºç³»ç»Ÿä¸­è®¾å¤‡çš„å…³è”å’Œèµ„æºåˆ†é…å˜é‡æ¥æ”¹å–„èƒ½é‡ã€è®¡ç®—èƒ½åŠ›ã€ä»»åŠ¡å®Œæˆåº¦çš„çº¦æŸã€‚ Advantages: Total energy consumption of sensor devices and UAVs is minimized. ä¼˜ç‚¹ï¼šä¼ æ„Ÿå™¨è®¾å¤‡å’Œæ— äººæœºçš„æ€»èƒ½è€—æœ€å°åŒ–ã€‚ Limitations: Inter-cell inferences from mobile devices of other UAVs are experienced. å±€é™æ€§ï¼šæ¥è‡ªå…¶ä»–æ— äººæœºç§»åŠ¨è®¾å¤‡çš„å°åŒºé—´å¹²æ‰°æ˜¯å­˜åœ¨çš„ã€‚ Possible enhancements: UAV trajectory, communication, and computation resource assignment can be investigated. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¯ä»¥ç ”ç©¶æ— äººæœºè½¨è¿¹ã€é€šä¿¡å’Œè®¡ç®—èµ„æºåˆ†é…ã€‚ 5.4.3. Multiple Time-Window-based Dubins Traveling Salesmen Problem (MTWDTSP) 5.4.3.åŸºäºå¤šæ—¶é—´çª—çš„æœå®¾æ—…è¡Œå•†é—®é¢˜ (MTWDTSP) Task assignment for multiple UAVs with altered capacities using a multi-objective symbiotic organism search algorithm to enhance UAV task arrangement was studied in [179]. In addition, a task model based on the time window and task assignment based on MTWDTSP was developed for various targets. Double-chain and some criteria are recognized for task assignment in logical and environmental constraints. A group of targets requires an investigation using heterogeneous UAVs subjected to different restraints. The Dubins model [180], [181] is introduced for UAVs with the following suppositions: (i) constant UAV velocity, (ii) reconnaissance job at certain heights, (iii) UAV flies at different heights without collision, and (iv) limited flight time. The dimensions of the UAVs are abridged from 3D to 2D. [179]ç ”ç©¶äº†ä½¿ç”¨å¤šç›®æ ‡å…±ç”Ÿæœ‰æœºä½“æœç´¢ç®—æ³•æ¥å¢å¼ºæ— äººæœºä»»åŠ¡å®‰æ’çš„å…·æœ‰æ”¹å˜èƒ½åŠ›çš„å¤šä¸ªæ— äººæœºçš„ä»»åŠ¡åˆ†é…ã€‚æ­¤å¤–ï¼Œé’ˆå¯¹å„ç§ç›®æ ‡ï¼Œå¼€å‘äº†åŸºäºæ—¶é—´çª—å£å’ŒåŸºäºMTWDTSPçš„ä»»åŠ¡åˆ†é…çš„ä»»åŠ¡æ¨¡å‹ã€‚åœ¨é€»è¾‘å’Œç¯å¢ƒçº¦æŸä¸‹ï¼ŒåŒé“¾å’Œä¸€äº›æ ‡å‡†è¢«è®¤å¯ç”¨äºä»»åŠ¡åˆ†é…ã€‚ä¸€ç»„ç›®æ ‡éœ€è¦ä½¿ç”¨å—åˆ°ä¸åŒçº¦æŸçš„å¼‚æ„æ— äººæœºè¿›è¡Œè°ƒæŸ¥ã€‚ Dubins æ¨¡å‹[180] ã€ [181]æ˜¯é’ˆå¯¹æ— äººæœºå¼•å…¥çš„ï¼Œå‡è®¾å¦‚ä¸‹ï¼šï¼ˆiï¼‰æ— äººæœºé€Ÿåº¦æ’å®šï¼Œï¼ˆiiï¼‰åœ¨ä¸€å®šé«˜åº¦è¿›è¡Œä¾¦å¯Ÿå·¥ä½œï¼Œï¼ˆiiiï¼‰æ— äººæœºåœ¨ä¸åŒé«˜åº¦é£è¡Œè€Œä¸å‘ç”Ÿç¢°æ’ï¼Œï¼ˆivï¼‰é£è¡Œæ—¶é—´æœ‰é™ã€‚æ— äººæœºçš„å°ºå¯¸ä» 3D ç¼©å‡ä¸º 2Dã€‚ Advantages: Improved convergence speed and efficiency; provides optimized task sequence. ä¼˜ç‚¹ï¼šæé«˜æ”¶æ•›é€Ÿåº¦å’Œæ•ˆç‡ï¼›æä¾›ä¼˜åŒ–çš„ä»»åŠ¡åºåˆ—ã€‚ Limitations: Complexities increases with the number of UAVs and tasks; not all tasks are executed. å±€é™æ€§ï¼šå¤æ‚æ€§éšç€æ— äººæœºå’Œä»»åŠ¡æ•°é‡çš„å¢åŠ è€Œå¢åŠ ï¼›å¹¶éæ‰€æœ‰ä»»åŠ¡éƒ½è¢«æ‰§è¡Œã€‚ Possible enhancements: Constraints of complex dynamic environments such as the effect of speed of the wind, flight height, and temperature can be considered for better and realistic results. å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ï¼šå¯ä»¥è€ƒè™‘å¤æ‚åŠ¨æ€ç¯å¢ƒçš„çº¦æŸï¼Œä¾‹å¦‚é£é€Ÿã€é£è¡Œé«˜åº¦å’Œæ¸©åº¦çš„å½±å“ï¼Œä»¥è·å¾—æ›´å¥½ã€æ›´çœŸå®çš„ç»“æœã€‚ The advantages, limitations, and possible enhancements of each task assignment algorithms discussed in this section are listed in Table 4. This will help readers to understand better through comparison. è¡¨ 4åˆ—å‡ºäº†æœ¬èŠ‚ä¸­è®¨è®ºçš„æ¯ç§ä»»åŠ¡åˆ†é…ç®—æ³•çš„ä¼˜ç‚¹ã€å±€é™æ€§å’Œå¯èƒ½çš„å¢å¼ºåŠŸèƒ½ã€‚è¿™æ ·å¯ä»¥å¸®åŠ©è¯»è€…é€šè¿‡æ¯”è¾ƒæ›´å¥½åœ°ç†è§£ã€‚ Table 4. Comparison of task assignment algorithms in terms of their advantages, limitations, and possible enhancements. Protocol Advantages Limitations Possible enhancements HA-TA [90] Improves operational reliabilities and capabilities through adaptive task assignment systems and system awareness; demonstrated effective performance through simulation and experiments. Randomly occurring failures provide a level of uncertainty; uncertainty present at all planning stages due to incomplete knowledge at the flight plan level, health of sensors during task assignment, and enduring maintenance at the mission planning level. The amount and quality of feedback information can be improved, and a sophisticated stochastic model of health states like energy usage and sensors' performance can be embedded to deal with uncertainties. MILP-TA [91] Useful in offline task assignment calculations; provides optimal solution for UAV groups with combined tasks with timing and task order limitations. Makes a discrete representation of real-world problems, which makes solutions impractical; solution requires high computation time and makes unreliable for real-time use. Kinematic constraints of UAVs should be focused; aspects of complex and dynamic environment such as obstacles, uncertainties, and wind speed must be considered. MTWPS [94] Deals with online uncertainties such as communication issues, UAV malfunction, and time-sensitive target problem; easy computing used to lessen simulation time for large-scale UAV networks. A UAV's waiting time depends on the performance of other UAVs, which makes waiting time complicated for large-scale networks; the deadlock problem is ignored. Different types of deadlocks require better handling, which can be focused on in the future; threats and other risks present in the stochastic environment should also be focused on. DTA [96] Time efficiency, scalability, and robustness are achieved; achieves the mission goal with minimum cost. Does not consider the uncertainties and aspects of dynamic environments; preliminary information regarding the size and location of enemy UAVs is unknown. Minimizing the combination of all costs is desired, requiring a solver algorithm; threats and uncertainties of the complex dynamic environments need consideration. SMAA-2 [97] Uncertainties are analyzed; finds satisfactory solution even in severe situations. Sensor error or target movement leads to unclear localization; probability of UAVs being destroyed while handling attacks remains. Threats present in the defense system of targets can be made more apparent; a confidence factor is introduced to judge the accuracy of criteria values. FEUTA [112] Condenses the consequence of noise caused due to high-frequency on the planner; mitigates the effects of noise. Ignores the aspects such as threats and uncertainties, which makes it unreliable for the real environment; accepts noise entirely. The importance of robust methods proposed for FEUTA and their connection to noise rejection algorithms must be investigated. CTAI [113] Decomposition of motion planning issues helps obtain a near-real-time solution; risk is mitigated by increasing distance between UAV and threats. Tracking error increases due to disturbances; only static threats are considered, and thus the results obtained are suboptimal. Timing of target intersection can be considered; aspects of the dynamic, complex 3D environment such as wind speed, risks need consideration. EETA [117] Lessens energy depletion, and optimizes task offloading, resource sharing, and trajectory without increasing delay; minimizes UAV's propulsion and computation power. Single UAV is used, which increases the risk of mission failure. UAVs' kinematic constraints such as external forces, motions, and physical limitations of the dynamic environment such as threats and uncertainties must be considered during the assignment process. EDATA [118] Energy consumption, operational time, and fairness of the system are optimized jointly; environmental effects on flights and performance are considered. GPS localization errors and signal losses exist; increase in execution time for FTUS, which impacts the performance of the model. Cases of accidents and UAV failures must be considered; the modeling part could be improved concerning the energy consumed by GPS in errors and signal losses. DP-CTA [119] Generates cooperative and optimal solution quickly; recovers planning of real-world air operations providing improvements. Computation time grows with the number of targets, and the uncertainties of real complex environment are ignored. Constraints of the real dynamic environment such as sudden threats, effects of wind, and temperature on UAV flights must be focused on. PHM-based MTA [123] Applies system-level RUL methodology to accomplish task assignment including failure probability. It may not be feasible to know the probability of failure in advance; threats and uncertainties of real stochastic environments are ignored. PHM-based TA for extensive haul task reaction of algorithm during failure requires further investigation; consideration of aspects of real environment such as wind, temperature, threats is a must. ABMC-TA [132] Solves multi-constraint task assignment issues efficiently considering the constraints of sensors, time, danger, and fuel. 2D environment with static obstacles considered for implementation which cannot justify the constraints of real dynamic environment; kinematics of UAV such as motion and impacts of external forces on its flight path needs consideration. Complexities imposed by real 3D environment need to be considered to confirm its practical validity; more experimental study and investigation are required to verify the efficiency of the proposed method in real environment. RDTA [134] â€œNo Fly Zonesâ€ are considered; a modified candidate plan selection algorithm is used to improve performance and increase the robustness to the inconsistencies. Does not consider the heterogeneity of UAVs and targets and the constraints of the dynamic environment such as threats and effects of external forces (wind, temperature, etc.) on UAVs performance. Conflicts arising due to low convergence need to be eliminated; heterogeneity of UAVs and other environmental aspects such as threats and uncertainties must be considered. CBBA [137], [138] Handles operational complexities of multi-UAVs; provides reliable, conflict-free UAV task assignments. All targets may not be discovered; dynamic threats and uncertainties are ignored. Kinematic and dynamic UAV constraints on air and ground can be incorporated; UAVs need to be penalized for massive heading changes. EAT-PSO [143] Achieves a minimum total make span, forms a seamless UAV operation schedule, and short computation time in finding a high-quality feasible solution. Allows a single UAV to occupy a position at a particular time, ignoring uncertain events and obstacles. An anti-collision refinement phase can be incorporated, a detailed study on the distributed control of UAVs can be conducted, and the robustness of the system can be assessed. OPA [146] Works with short execution time, highly flexible, strongly robust, and scalable; quickly finds optimal solution; avoids difficult cost function based on the tasks, and has high calculation efficiency. Does not consider the constraints of the actual battlefield; threats and uncertainties that may arise in the dynamic environment are ignored. Adaptive approach of cooperative task assignment can be introduced to balance the load of UAVs and adapt to real-time battlefield situations. CTA [147] Efficiently solves considerate task assignment problems of UAVs under multiple circumstances and constraints; fast convergence and a highly stable iterative curve are assured. Focuses on flight length only and ignores other constraints of task assignment; threats and uncertainties of the real environment are ignored, making the solution impractical. Estimation of cost function could be adjusted considering the flight mission; in an actual battlefield environment, target values vary, and distribution of UAV firepower must be considered. CTMAP-GA [158] Promptly offers feasible task assignment solutions and real-time implementation for high dimensions; considers task priority and coordination, time constraints, and trajectory. Performance degrades if the search space is harsh; it ignores the aspects of real dynamic environments, which makes the proposed method impractical in real-time implementation. Proper synchronization must be considered to maintain coordination among UAVs; constraints of the dynamic environment such as threats, uncertainties, and external forces and their impacts on UAV's motion need to be investigated. CMTAP [159] Solves computational complexity for classical combinatorial optimization methods with higher efficiency and considers task priority and timing constraints. Does not consider the dynamic aspects of the environment such as impacts of threats, uncertainties, and external forces on UAVs flight; heterogeneity of tasks, targets, and UAVs are ignored. Moving, sudden targets, and actual environmental scenarios must be considered; computational efficiency needs to be realized to achieve a real-time solution. MGA-CTA [160] Considers and addresses the heterogeneity of UAVs, targets, and environments; mirror representation to deal with the limited resources. Only one kind of resource, i.e., weapon, is considered; stationary targets considered in simulation, weapons are used in one way only. Different operational and kinematic constraints of UAV must be considered; aspects of real dynamic environments such as threats, uncertainties, and other external forces and their impacts need to be analyzed. CMTAPSVTW[161] Considers kinematic constraints (motion, external forces, propulsion), resource constraints (fuel and onboard weapons), and time constraints (time windows and sequence of tasks). Does not cover practical mission scenarios such as weather constraints, radar, terrain barriers during simulation. Distributed model with more stochastic features can be considered to cover practical mission scenarios; a comparison of a centralized and distributed algorithm for stochastic task assignment needs to be made. BAS-GA [162] Diversity of searching capacity improves convergence time; local search ability is increased; has good convergence from small to large missions. Does not consider the kinematics of UAV which impacts on performance and constraints of the realistic dynamic environment such as threats and uncertainties. Rapid task adjustment using centralized and distributed methods can be experimented on; integration of path plan into task assignment for broad task planning for multi-UAVs can be done. OGA-DEMMO [163] Minimizes the execution time and total UAV consumption and improves the optimality of the algorithm and convergence energy. No constraints are considered for reconnaissance; if the sensor's field of view covers the ground target, the task on that target is ended; constant UAV velocity is considered. Constraints of natural and dynamic environments such as threats, uncertainties, and other external forces can be considered. FTA [173] Computationally fast and efficient, highly adaptive, and handles uncertainty; deals with different types of tasks. Considers only stationary targets; complexities and aspects of the real battlefield environment are ignored. Moving and sudden targets and complexities of real battlefield environmental scenarios must be considered. RFETA [175] Presents robust results in uncertain environments; sensitive to errors; minimizes the effects of noise; yields fast convergence, and reduces churning. It does not perform better if lots of information must be considered while planning. Effects of intermittent measurements on the performance of RFETA can be studied; adaptive formulations of tuning parameter Î» for optimization can be studied. EMU-MEC [176] Total energy consumption of sensor devices and UAVs is minimized. Inter-cell inferences from mobile devices of other UAVs are experienced UAV trajectory, communication, and computation resource assignment can be investigated. MTWDTSP [179] Improved convergence speed and efficiency; provides optimized task sequence. Complexities increases with the number of UAVs and tasks; not all tasks are executed. Constraints of complex dynamic environments such as the effect of speed of the wind, flight height, and temperature can be considered for better and realistic results. 5.4.4. Lesson learned 5.4.4.å¸å–çš„æ•™è®­ A good task assignment algorithm should be adaptive that can acquires the best performance in any circumstances. Thus, creating an adaptive system, which is capable of adapting not only to the objectives of the assignment but also to the limitations of the environment, is highly anticipated. Otherwise, massive degradation in the performance of the target system can be observed with the increasing amount of limitations imposed by the environment and UAVs. The task assignment algorithms, reviewed in this section, were evaluated through computer simulations by the original authors and many of them were also validated through theoretical analysis. In the future, one can consider implementing these algorithms in real systems and evaluate the performance accurateness of the algorithms in actual environment, which is necessary when handling the intricate environmental issues. Though computer based simulations gives preliminary results for the validation of the algorithms, many unforeseen issues may arise while implementing the algorithms in real systems. ä¸€ä¸ªå¥½çš„ä»»åŠ¡åˆ†é…ç®—æ³•åº”è¯¥å…·æœ‰é€‚åº”æ€§ï¼Œåœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½èƒ½è·å¾—æœ€ä½³æ€§èƒ½ã€‚å› æ­¤ï¼Œäººä»¬é«˜åº¦æœŸæœ›åˆ›å»ºä¸€ä¸ªä¸ä»…èƒ½å¤Ÿé€‚åº”ä»»åŠ¡ç›®æ ‡è€Œä¸”èƒ½å¤Ÿé€‚åº”ç¯å¢ƒé™åˆ¶çš„è‡ªé€‚åº”ç³»ç»Ÿã€‚å¦åˆ™ï¼Œéšç€ç¯å¢ƒå’Œæ— äººæœºæ–½åŠ çš„é™åˆ¶è¶Šæ¥è¶Šå¤šï¼Œå¯ä»¥è§‚å¯Ÿåˆ°ç›®æ ‡ç³»ç»Ÿæ€§èƒ½çš„å¤§å¹…ä¸‹é™ã€‚æœ¬èŠ‚å›é¡¾çš„ä»»åŠ¡åˆ†é…ç®—æ³•ç”±åŸä½œè€…é€šè¿‡è®¡ç®—æœºæ¨¡æ‹Ÿè¿›è¡Œäº†è¯„ä¼°ï¼Œå…¶ä¸­è®¸å¤šç®—æ³•è¿˜é€šè¿‡ç†è®ºåˆ†æè¿›è¡Œäº†éªŒè¯ã€‚æœªæ¥å¯ä»¥è€ƒè™‘åœ¨å®é™…ç³»ç»Ÿä¸­å®ç°è¿™äº›ç®—æ³•ï¼Œå¹¶è¯„ä¼°ç®—æ³•åœ¨å®é™…ç¯å¢ƒä¸­çš„æ€§èƒ½å‡†ç¡®æ€§ï¼Œè¿™åœ¨å¤„ç†å¤æ‚çš„ç¯å¢ƒé—®é¢˜æ—¶æ˜¯å¿…è¦çš„ã€‚å°½ç®¡åŸºäºè®¡ç®—æœºçš„æ¨¡æ‹Ÿç»™å‡ºäº†ç®—æ³•éªŒè¯çš„åˆæ­¥ç»“æœï¼Œä½†åœ¨å®é™…ç³»ç»Ÿä¸­å®ç°ç®—æ³•æ—¶å¯èƒ½ä¼šå‡ºç°è®¸å¤šä¸å¯é¢„è§çš„é—®é¢˜ã€‚ 6. Comparison of task assignment algorithms for UAVs æ— äººæœºä»»åŠ¡åˆ†é…ç®—æ³•æ¯”è¾ƒ In this section, existing task assignment algorithms studied for UAVs and UAV networks are qualitatively compared in terms of their main ideas, algorithms used for the task assignment process, performance metrics considered, and qualitative and operational features. Table 4 summarizes the main ideas of all 27 algorithms discussed in the previous section along with the metrics considered for their improvement. It can be observed that the most popular algorithms used for task assignment are GA, RHTA, MILP, and DP. The primary focus of the task assignment algorithms is to minimize the convergence time and complexities while maintaining cooperation between UAVs. åœ¨æœ¬èŠ‚ä¸­ï¼Œå¯¹ç°æœ‰çš„æ— äººæœºå’Œæ— äººæœºç½‘ç»œä»»åŠ¡åˆ†é…ç®—æ³•çš„ä¸»è¦æ€æƒ³ã€ç”¨äºä»»åŠ¡åˆ†é…è¿‡ç¨‹çš„ç®—æ³•ã€è€ƒè™‘çš„æ€§èƒ½æŒ‡æ ‡ä»¥åŠå®šæ€§å’Œæ“ä½œç‰¹å¾è¿›è¡Œäº†å®šæ€§æ¯”è¾ƒã€‚è¡¨ 4æ€»ç»“äº†ä¸Šä¸€èŠ‚è®¨è®ºçš„æ‰€æœ‰ 27 ç§ç®—æ³•çš„ä¸»è¦æ€æƒ³ä»¥åŠæ”¹è¿›è¿™äº›ç®—æ³•æ‰€è€ƒè™‘çš„æŒ‡æ ‡ã€‚å¯ä»¥çœ‹å‡ºï¼Œæœ€æµè¡Œçš„ä»»åŠ¡åˆ†é…ç®—æ³•æ˜¯GA ã€RHTAã€MILP å’Œ DPã€‚ä»»åŠ¡åˆ†é…ç®—æ³•çš„ä¸»è¦é‡ç‚¹æ˜¯æœ€å¤§é™åº¦åœ°å‡å°‘æ”¶æ•›æ—¶é—´å’Œå¤æ‚æ€§ï¼ŒåŒæ—¶ä¿æŒæ— äººæœºä¹‹é—´çš„åˆä½œã€‚ In Table 5, task assignment algorithms are compared in terms of qualitative features and key characteristics, such as task interdependence, types of target, task precedence, types of UAVs considered, types of task assignment algorithms, level of operational complexities of the algorithms, performance evaluation tools used, and environmental scenario considered. Only a few of the algorithms consider real environmental scenarios that are full of uncertainties and adversities. An ideal task assignment algorithm must consider the dynamics and complexities of real-world scenarios. In some missions, task priorities are significant, and hence, they must be considered during the task assignment process. In addition, from the tabular comparison, we can observe that heterogeneous UAVs have been used in recent studies. Most task assignment algorithms are centralized and evolutionary. However, a combination of centralized and distributed task assignment algorithms has not been considered in the literature. The fusion of multiple algorithms can be observed in some task assignment processes. Most algorithms are aimed at minimizing complexities. Moreover, popular simulation tools include Monte Carlo, MATLAB, and mathematical formulations. åœ¨è¡¨ 5ä¸­ï¼Œä»»åŠ¡åˆ†é…ç®—æ³•åœ¨å®šæ€§ç‰¹å¾å’Œå…³é”®ç‰¹å¾æ–¹é¢è¿›è¡Œäº†æ¯”è¾ƒï¼Œä¾‹å¦‚ä»»åŠ¡ç›¸äº’ä¾èµ–æ€§ã€ç›®æ ‡ç±»å‹ã€ä»»åŠ¡ä¼˜å…ˆçº§ã€è€ƒè™‘çš„æ— äººæœºç±»å‹ã€ä»»åŠ¡åˆ†é…ç®—æ³•ç±»å‹ã€ç®—æ³•çš„æ“ä½œå¤æ‚ç¨‹åº¦ã€æ€§èƒ½ä½¿ç”¨çš„è¯„ä¼°å·¥å…·å¹¶è€ƒè™‘ç¯å¢ƒæƒ…æ™¯ã€‚åªæœ‰å°‘æ•°ç®—æ³•è€ƒè™‘äº†å……æ»¡ä¸ç¡®å®šæ€§å’Œé€†å¢ƒçš„çœŸå®ç¯å¢ƒåœºæ™¯ã€‚ç†æƒ³çš„ä»»åŠ¡åˆ†é…ç®—æ³•å¿…é¡»è€ƒè™‘ç°å®åœºæ™¯çš„åŠ¨æ€æ€§å’Œå¤æ‚æ€§ã€‚åœ¨ä¸€äº›ç‰¹æ´¾å›¢ä¸­ï¼Œä»»åŠ¡ä¼˜å…ˆäº‹é¡¹å¾ˆé‡è¦ï¼Œå› æ­¤åœ¨ä»»åŠ¡åˆ†é…è¿‡ç¨‹ä¸­å¿…é¡»è€ƒè™‘è¿™äº›ä¼˜å…ˆäº‹é¡¹ã€‚æ­¤å¤–ï¼Œä»è¡¨æ ¼æ¯”è¾ƒä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°æœ€è¿‘çš„ç ”ç©¶ä¸­å·²ç»ä½¿ç”¨äº†å¼‚æ„æ— äººæœºã€‚å¤§å¤šæ•°ä»»åŠ¡åˆ†é…ç®—æ³•éƒ½æ˜¯é›†ä¸­å¼å’Œè¿›åŒ–å¼çš„ã€‚ç„¶è€Œï¼Œæ–‡çŒ®ä¸­å°šæœªè€ƒè™‘é›†ä¸­å¼å’Œåˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•çš„ç»“åˆã€‚åœ¨ä¸€äº›ä»»åŠ¡åˆ†é…è¿‡ç¨‹ä¸­å¯ä»¥è§‚å¯Ÿåˆ°å¤šç§ç®—æ³•çš„èåˆã€‚å¤§å¤šæ•°ç®—æ³•çš„ç›®çš„æ˜¯æœ€å°åŒ–å¤æ‚æ€§ã€‚æ­¤å¤–ï¼Œæµè¡Œçš„ä»¿çœŸå·¥å…·åŒ…æ‹¬è’™ç‰¹å¡æ´›ã€MATLAB å’Œæ•°å­¦å…¬å¼ã€‚ Table 5. Comparison of task assignment algorithms in terms of main ideas and design approaches. Protocol Main idea Design approach HA-TA [90] Step towards allowing robust decision making for disseminated autonomous UAVs. RHTA algorithm MILP-TA [91] Optimal formulation for solving the coupled multiple-assignment problem. MILP algorithm MTWPS [94] Task assignment with constraint and time-sensitive uncertainties. Meta-heuristic optimization called MTPS DTA [96] A dynamic task assignment using enemy information for combinatorial optimization. Hungarian algorithm SMAA-2 [97] Offers suitable task assignment under severely uncertain circumstances. Stochastic multi-criteria acceptability analysis method FEUTA [112] Performs reassignment at the rate that information is updated, which permits instantaneous response to any noteworthy fluctuations in the environment. Noise rejection algorithm and linear integer program CTAI [113] Provides end-to-end explanation to cooperative control problem in the occurrence of dynamic threats. Satisfying decisions theory EETA [117] Joint task assignment and resource assignment in UAV-aided MEC. Block successive upper-bound minimization algorithm EDATA [118] EAUS, DAUS, and FTUS are proposed. Linear integer problem DP-CTA [119] Two models of DP estimation methods are designed i.e. one-step look-ahead and two-step look-ahead Dynamic programming based PHM-based MTA [123] Information from a PHM method is applied so as to support decision making through IVHM structure. Receding horizon task assignment algorithm ABMC-TA [132] Auction-based technique that deals with assigning tasks of multi-UAV system under the constrictions of UAV capability, time window, cost of fuel and dangers during the travel. Auction algorithm and multi-layer cost computation RDTA [134] Confirms the resultant plans calculated by team are conflict-free and feasible RDTA CBBA [137], [138] Modified CBBA to handle obstacles and mitigate churning behavior Consensus-based bundle algorithm EAT-PSO [143] A mathematical model that solves the problem and heuristic-based methodology. Earliest available time (EAT) and PSO algorithm OPA [146] Resolves the ideal order of numerous tasks for cooperative accomplishment. Nearest neighbor method CTA [147] Cooperative multi-task assignment model. Hungarian algorithm CTMAP-GA [158] Allows unique requirements of the scenario to be considered, such as task precedence and coordination, timing constraints, and trajectory limitations GA CMTAP [159] Integrated task assignment and path optimization refining the visitation angle Dubins car and GA MGA-CTA [160] Concerned with cooperative decision making and control Modified GA with multi-type genes CMTAPSVTW[161] Cooperative multi-task assignment problem with stochastic velocities and time windows for heterogeneity Meta-heuristic based on a modified GA BAS-GA [162] Uses two cross-operator methods to preserve the globality of the algorithm and perform a deep search of the solution space Improved GA based on the beetle antenna search algorithm OGA-DEMMO [163] Presents a multi-UAV reconnaissance task assignment model for heterogeneous targets and an effective genetic algorithm to optimize UAV task sequence Opposition-based GA FTA [173] Neural network approximation and prioritized replay to offload online computation to offline learning procedure MDP and Q-learning-based RFETA [175] Provides substitute approach that associates robust scheduling with procedures established to eradicate churning Robust filter embedded task assignment EMU-MEC [176] A joint device association, task assignment, and computing resource assignment problem considering the energy budget, available computing power, and task completion deadline constraints Mixed-integer non-linear programming and block coordinate descent MTWDTSP [179] Problem of task consignment is articulated as a manifold time window-based Dubins traveling salesman problem Modified multi-objective symbiotic organism search algorithm Similarly, Table 6, Table 6 summarizes different performance metrics, such as energy consumption, latency, efficiency of algorithms, adaptability scalability, and load balancing. Most task assignment algorithms focus on increasing the lifetime of the network by reducing energy consumption. Delay is another major consideration in task assignment algorithms. We can observe that most task assignment algorithms have managed to achieve low latency and high efficiency. Balancing the load among UAVs has not been considered much in state-of-the-art algorithms. However, load balancing also plays a significant role in large-scale mission planning systems. Moreover, performance determinants, such as adaptability and scalability, have not been considered much in previous studies. ç±»ä¼¼åœ°ï¼Œè¡¨ 6 ï¼Œè¡¨ 6 æ€»ç»“äº†ä¸åŒçš„æ€§èƒ½æŒ‡æ ‡ï¼Œä¾‹å¦‚èƒ½è€—ã€å»¶è¿Ÿã€ç®—æ³•æ•ˆç‡ã€é€‚åº”æ€§å¯æ‰©å±•æ€§å’Œè´Ÿè½½å¹³è¡¡ã€‚å¤§å¤šæ•°ä»»åŠ¡åˆ†é…ç®—æ³•çš„é‡ç‚¹æ˜¯é€šè¿‡å‡å°‘èƒ½è€—æ¥å»¶é•¿ç½‘ç»œçš„å¯¿å‘½ã€‚å»¶è¿Ÿæ˜¯ä»»åŠ¡åˆ†é…ç®—æ³•ä¸­çš„å¦ä¸€ä¸ªä¸»è¦è€ƒè™‘å› ç´ ã€‚æˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°å¤§å¤šæ•°ä»»åŠ¡åˆ†é…ç®—æ³•éƒ½èƒ½å¤Ÿå®ç°ä½å»¶è¿Ÿå’Œé«˜æ•ˆç‡ã€‚æœ€å…ˆè¿›çš„ç®—æ³•å°šæœªå……åˆ†è€ƒè™‘å¹³è¡¡æ— äººæœºä¹‹é—´çš„è´Ÿè½½ã€‚ç„¶è€Œï¼Œè´Ÿè½½å¹³è¡¡åœ¨å¤§è§„æ¨¡ä»»åŠ¡è§„åˆ’ç³»ç»Ÿä¸­ä¹Ÿå‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚æ­¤å¤–ï¼Œåœ¨ä¹‹å‰çš„ç ”ç©¶ä¸­ï¼Œé€‚åº”æ€§å’Œå¯æ‰©å±•æ€§ç­‰æ€§èƒ½å†³å®šå› ç´ å¹¶æœªå¾—åˆ°å¤ªå¤šè€ƒè™‘ã€‚ Table 6. Comparison of task assignment algorithms in terms of key features and characteristics. è¡¨ 6 .ä»»åŠ¡åˆ†é…ç®—æ³•åœ¨å…³é”®ç‰¹å¾å’Œç‰¹æ€§æ–¹é¢çš„æ¯”è¾ƒã€‚ Protocol Task interdependency Target Priority Environment HA-TA [90] No Heterogeneous Yes Complex and uncertain MILP-TA [91] Yes Heterogeneous Yes - MTWPS [94] No Mobile No Complex and dynamic DTA [96] No â€“ No Battlefield SMAA-2 [97] No Mobile No Severely uncertain FEUTA [112] â€“ Uncertain No Dynamic CTAI [113] Yes Homogeneous Yes Dynamic and threat-based EETA [117] No Mobile No â€“ EDATA [118] No IoT devices Yes Unknown and uncertain DP-CTA [119] Yes Heterogeneous No Adversarial PHM-based MTA [123] No Stationary Yes Critical ABMC-TA [132] No Heterogeneous No Dynamic RDTA [134] No â€“ No Uncertain CBBA [137], [138] No Stationary and mobile No Obstacle- and noise-based EAT-PSO [143] No Heterogeneous No Indoor OPA [146] No Stationary No Complex CTA [147] No Mobile No Obstacle-based CTMAP-GA [158] Yes Heterogeneous Yes â€“ CMTAP [159] No Heterogeneous and stationary No â€“ MGA-CTA [160] Yes Heterogeneous No â€“ CMTAPSVTW[161] Yes Stationary Yes Uncertain and dynamic BAS-GA [162] Yes Stationary No â€“ OGA-DEMMO [163] No Heterogeneous No Real-world mission environments FTA [173] No Stationary Yes Complex and uncertain RFETA [175] No Heterogeneous No Uncertain and dynamic EMU-MEC [176] Yes IoT No Infrastructure-less MTWDTSP [179] No Heterogeneous Yes Obstacle- and threat-based Table 6. Comparison of task assignment algorithms in terms of key features and characteristics (continued). è¡¨ 6 .ä»»åŠ¡åˆ†é…ç®—æ³•åœ¨å…³é”®ç‰¹å¾å’Œç‰¹æ€§æ–¹é¢çš„æ¯”è¾ƒï¼ˆç»­ï¼‰ ã€‚ Protocol Year UAV type Task assignment type Operational complexity Performance evaluation tool HA-TA [90] 2008 Draganfly VTi Pro R/C helicopters Centralized Low MIT's Real-time Indoor Autonomous Vehicle Test Environment MILP-TA [91] 2003 WASM Centralized High Numerical formulations MTWPS [94] 2017 Heterogeneous Centralized Low MATLAB DTA [96] 2019 â€“ Centralized Low SITL and Gazebo SMAA-2 [97] 2015 Homogeneous Stochastic and centralized Low Monte Carlo FEUTA [112] 2004 Homogeneous Centralized and stochastic High Numerical formulations CTAI [113] 2002 Homogeneous Coordinated and stochastic High MATLAB and Simulink EETA [117] 2021 Single UAV Centralized and stochastic Low Numerical formulation EDATA [118] 2019 Rotary UAVs Centralized and stochastic â€“ Python and Gurobi optimization tools DP-CTA [119] 2005 Homogeneous Stochastic and centralized Lower Numerical formulations PHM-based MTA [123] 2014 Homogeneous Decentralized â€“ MATLAB and CPLEX ABMC-TA [132] 2016 Homogeneous Centralized and stochastic â€“ Experimented RDTA [134] 2006 Heterogeneous Decentralized Low Monte Carlo CBBA [137], [138] 2009 Heterogeneous Decentralized Low Monte Carlo EAT-PSO [143] 2019 Multi-copters Bio-inspired High Numerical formulations OPA [146] 2021 Heterogeneous Bio-inspired Low Numerical formulation CTA [147] 2017 Homogeneous Bio-inspired â€“ MATLAB CTMAP-GA [158] 2005 â€“ Bio-inspired Low Monte Carlo CMTAP [159] 2010 Heterogeneous Bio-inspired Low Monte Carlo MGA-CTA [160] 2012 Heterogeneous Bio-inspired Low Monte Carlo CMTAPSVTW[161] 2018 Heterogeneous Bio-inspired Low MATLAB BAS-GA [162] 2020 Homogeneous Bio-inspired Low - OGA-DEMMO [163] 2018 Heterogeneous Bio-inspired High MATLAB FTA [173] 2019 Heterogeneous Bio-inspired â€“ Python 3.7.0, Tensorflow RFETA [175] 2007 Homogeneous Multi-fusion â€“ Monte Carlo EMU-MEC [176] 2021 Edge server- equipped UAVs Multi-fusion Low Numerical formulations MTWDTSP [179] 2019 Heterogeneous Multi-fusion Low Visual C++ and MATLAB By comparison, for practical applications, stochastic evolutionary algorithms can perform better as they can learn from experience and adapt to the aspects of complex dynamic environments in real time. Moreover, decentralized algorithms assuring coordinated UAV operation can provide alternative solutions to enhance the performance of multi-UAV operations. In addition, robust and highly scalable algorithms are desirable for large missions. See Table 7. ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨å®é™…åº”ç”¨ä¸­ï¼Œéšæœºè¿›åŒ–ç®—æ³•å¯ä»¥è¡¨ç°å¾—æ›´å¥½ï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥ä»ç»éªŒä¸­å­¦ä¹ å¹¶å®æ—¶é€‚åº”å¤æ‚åŠ¨æ€ç¯å¢ƒçš„å„ä¸ªæ–¹é¢ã€‚æ­¤å¤–ï¼Œç¡®ä¿æ— äººæœºåè°ƒè¿è¡Œçš„å»ä¸­å¿ƒåŒ–ç®—æ³•å¯ä»¥æä¾›æ›¿ä»£è§£å†³æ–¹æ¡ˆï¼Œä»¥æé«˜å¤šæ— äººæœºè¿è¡Œçš„æ€§èƒ½ã€‚æ­¤å¤–ï¼Œå¤§å‹ä»»åŠ¡éœ€è¦ç¨³å¥ä¸”é«˜åº¦å¯æ‰©å±•çš„ç®—æ³•ã€‚å‚è§è¡¨ 7 ã€‚ Table 7. Qualitative comparison of task assignment algorithms in terms of performance. è¡¨ 7 .ä»»åŠ¡åˆ†é…ç®—æ³•åœ¨æ€§èƒ½æ–¹é¢çš„å®šæ€§æ¯”è¾ƒã€‚ Protocol Energy consumption Latency Efficiency Adaptability Scalability Load balancing HA-TA [90] Low Low High High â€“ No MILP-TA [91] â€“ High High No No No MTWPS [94] No Low High No No No DTA [96] Low Low High High High - SMAA-2 [97] No No Improved No No No FEUTA [112] â€“ Low Improved No No No CTAI [113] â€“ Low High No No No EETA [117] Low Satisfactory High No No No EDATA [118] Low Low High No No No DP-CTA [119] No Low Improved High â€“ No PHM-based MTA [123] Low Low High No No No ABMC-TA [132] Low Low High â€“ â€“ No RDTA [134] â€“ Low High High Low No CBBA [137], [138] No Low High â€“ â€“ No EAT-PSO [143] Recharging Low High No Yes No available OPA [146] No Low High High High Yes CTA [147] No Low Improved No No No CTMAP-GA [158] Low Low High High High No CMTAP [159] Low Low Improved High High No MGA-CTA [160] Low Low Improved No â€“ No CMTAPSVTW[161] Low Low High High High No BAS-GA [162] Low Low High No Yes No OGA-DEMMO [163] Low Low High No No No FTA [173] No Low High High No No RFETA [175] No Low High High High No EMU-MEC [176] Low Low High â€“ â€“ No MTWDTSP [179] Low Low High No No No 7. Open issues, research challenges, and future directions æœªå†³é—®é¢˜ã€ç ”ç©¶æŒ‘æˆ˜å’Œæœªæ¥æ–¹å‘ Researchers in both academic and industrial fields are striving to utilize the full potential of UAVs. Regardless of the promising roles of UAVs, there are also a number of design challenges to be addressed. In fact, every UAV application has its own challenges and opportunities. From the above detailed review of the literature, we present the following research gaps along with future efforts that could be pursued for the practical deployment of UAVs. In this section, the major characteristics and research gaps faced during the design of task assignment schemes for a set of UAVs are briefly addressed. Furthermore, future research directions for these issues are suggested. å­¦æœ¯å’Œå·¥ä¸šé¢†åŸŸçš„ç ”ç©¶äººå‘˜æ­£åœ¨åŠªåŠ›å……åˆ†åˆ©ç”¨æ— äººæœºçš„æ½œåŠ›ã€‚å°½ç®¡æ— äººæœºçš„ä½œç”¨å‰æ™¯å¹¿é˜”ï¼Œä½†ä»æœ‰è®¸å¤šè®¾è®¡æŒ‘æˆ˜éœ€è¦è§£å†³ã€‚äº‹å®ä¸Šï¼Œæ¯ç§æ— äººæœºåº”ç”¨éƒ½æœ‰å…¶è‡ªèº«çš„æŒ‘æˆ˜å’Œæœºé‡ã€‚é€šè¿‡ä¸Šè¿°å¯¹æ–‡çŒ®çš„è¯¦ç»†å›é¡¾ï¼Œæˆ‘ä»¬æå‡ºäº†ä»¥ä¸‹ç ”ç©¶ç©ºç™½ä»¥åŠæœªæ¥ä¸ºæ— äººæœºçš„å®é™…éƒ¨ç½²å¯ä»¥é‡‡å–çš„åŠªåŠ›ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œç®€è¦è®¨è®ºäº†ä¸€ç»„æ— äººæœºçš„ä»»åŠ¡åˆ†é…æ–¹æ¡ˆè®¾è®¡è¿‡ç¨‹ä¸­é¢ä¸´çš„ä¸»è¦ç‰¹å¾å’Œç ”ç©¶ç©ºç™½ã€‚æ­¤å¤–ï¼Œè¿˜æå‡ºäº†è¿™äº›é—®é¢˜çš„æœªæ¥ç ”ç©¶æ–¹å‘ã€‚ 7.1. UAV regulations 7.1.æ— äººæœºæ³•è§„ Regulatory concerns are a key limiting factor in the deployment of UAV operations. Regardless of the widespread UAVs applications, there are numerous issues concerning confidentiality, security, collision avoidance, safety, and protection of data. In this respect, UAV guidelines are uninterruptedly being established to govern the operation of UAVs while bearing in mind various factors, such as UAV type, range, height, and speed of UAVs [182], [183]. Generally, five different criteria are frequently considered when developing UAV regulations. Despite their usefulness in each area, UAVs are banned in different places; hence, appropriate airspace protocols and registration of drones are necessary for appropriate UAV operation. Specific areas of flying should be recognized for UAV practitioners, where they can operate UAVs without any obstacles following the regulations. Apps that indicate restricted zones must be developed to ensure safe UAV operation. Moreover, combative counter-drone measures should be established to circumvent the utilization of UAVs for malicious intent or in an unintentional security breach. ç›‘ç®¡é—®é¢˜æ˜¯æ— äººæœºè¡ŒåŠ¨éƒ¨ç½²çš„ä¸€ä¸ªå…³é”®é™åˆ¶å› ç´ ã€‚å°½ç®¡æ— äººæœºåº”ç”¨å¹¿æ³›ï¼Œä½†ä»å­˜åœ¨è®¸å¤šæ¶‰åŠæœºå¯†æ€§ã€å®‰å…¨æ€§ã€é˜²æ’ã€å®‰å…¨å’Œæ•°æ®ä¿æŠ¤çš„é—®é¢˜ã€‚åœ¨è¿™æ–¹é¢ï¼Œä¸æ–­åˆ¶å®šæ— äººæœºæŒ‡å—æ¥ç®¡ç†æ— äººæœºçš„æ“ä½œï¼ŒåŒæ—¶è€ƒè™‘å„ç§å› ç´ ï¼Œä¾‹å¦‚æ— äººæœºç±»å‹ã€èˆªç¨‹ã€é«˜åº¦å’Œæ— äººæœºé€Ÿåº¦[182] ã€ [183] ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œåˆ¶å®šæ— äººæœºæ³•è§„æ—¶ç»å¸¸è€ƒè™‘äº”ç§ä¸åŒçš„æ ‡å‡†ã€‚å°½ç®¡æ— äººæœºåœ¨å„ä¸ªé¢†åŸŸéƒ½å¾ˆæœ‰ç”¨ï¼Œä½†åœ¨ä¸åŒçš„åœ°æ–¹éƒ½è¢«ç¦æ­¢ä½¿ç”¨ï¼›å› æ­¤ï¼Œé€‚å½“çš„ç©ºåŸŸåè®®å’Œæ— äººæœºæ³¨å†Œå¯¹äºé€‚å½“çš„æ— äººæœºæ“ä½œæ˜¯å¿…è¦çš„ã€‚åº”ä¸ºæ— äººæœºä»ä¸šè€…æä¾›ç‰¹å®šçš„é£è¡ŒåŒºåŸŸï¼Œè®©ä»–ä»¬èƒ½å¤ŸæŒ‰ç…§è§„å®šæ— éšœç¢åœ°æ“ä½œæ— äººæœºã€‚å¿…é¡»å¼€å‘æŒ‡ç¤ºé™åˆ¶åŒºåŸŸçš„åº”ç”¨ç¨‹åºï¼Œä»¥ç¡®ä¿æ— äººæœºå®‰å…¨è¿è¡Œã€‚æ­¤å¤–ï¼Œåº”å»ºç«‹æˆ˜æ–—æ€§åæ— äººæœºæªæ–½ï¼Œä»¥é¿å…å‡ºäºæ¶æ„æˆ–æ— æ„çš„å®‰å…¨æ¼æ´è€Œåˆ©ç”¨æ— äººæœºã€‚ 7.2. Dynamic network topology åŠ¨æ€ç½‘ç»œæ‹“æ‰‘ The foundation of a peer-to-peer wireless network is a dynamic network topology that determines the relationships among neighboring nodes to be maintained within the network. Due to the high maneuverability of UAVs and constraints of the dynamic environment, the topology of UAV networks remains intermittent most of the time. High UAV mobility causes rapid changes in the network topology and fluctuations in radio communication channels. Communication between nodes is significantly affected when the topology of the network fluctuates due to failures and mobility. Delayed or incorrect information misleads the communication process. As a result, the network may experience delays, which are intolerable in many UAV applications. FANETs require exact and timely network information to determine the best and real-time communication. Moreover, adaptive and online communication protocols must be explored and designed for dynamic network topologies [184], [185]. å¯¹ç­‰æ— çº¿ç½‘ç»œçš„åŸºç¡€æ˜¯åŠ¨æ€ç½‘ç»œæ‹“æ‰‘ï¼Œå®ƒç¡®å®šç½‘ç»œå†…è¦ç»´æŠ¤çš„ç›¸é‚»èŠ‚ç‚¹ä¹‹é—´çš„å…³ç³»ã€‚ç”±äºæ— äººæœºçš„é«˜æœºåŠ¨æ€§å’ŒåŠ¨æ€ç¯å¢ƒçš„é™åˆ¶ï¼Œæ— äººæœºç½‘ç»œçš„æ‹“æ‰‘ç»“æ„åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ä¿æŒé—´æ­‡æ€§ã€‚æ— äººæœºçš„é«˜æœºåŠ¨æ€§å¯¼è‡´ç½‘ç»œæ‹“æ‰‘çš„å¿«é€Ÿå˜åŒ–å’Œæ— çº¿ç”µé€šä¿¡ä¿¡é“çš„æ³¢åŠ¨ã€‚å½“ç½‘ç»œæ‹“æ‰‘ç”±äºæ•…éšœå’Œç§»åŠ¨æ€§è€Œå‘ç”Ÿæ³¢åŠ¨æ—¶ï¼ŒèŠ‚ç‚¹ä¹‹é—´çš„é€šä¿¡ä¼šå—åˆ°æ˜¾ç€å½±å“ã€‚å»¶è¿Ÿæˆ–ä¸æ­£ç¡®çš„ä¿¡æ¯ä¼šè¯¯å¯¼æ²Ÿé€šè¿‡ç¨‹ã€‚å› æ­¤ï¼Œç½‘ç»œå¯èƒ½ä¼šå‡ºç°å»¶è¿Ÿï¼Œè¿™åœ¨è®¸å¤šæ— äººæœºåº”ç”¨ä¸­æ˜¯æ— æ³•å®¹å¿çš„ã€‚ FANET éœ€è¦å‡†ç¡®ã€åŠæ—¶çš„ç½‘ç»œä¿¡æ¯æ¥ç¡®å®šæœ€ä½³çš„å®æ—¶é€šä¿¡ã€‚æ­¤å¤–ï¼Œå¿…é¡»é’ˆå¯¹åŠ¨æ€ç½‘ç»œæ‹“æ‰‘æ¢ç´¢å’Œè®¾è®¡è‡ªé€‚åº”åœ¨çº¿é€šä¿¡åè®®[184] ï¼Œ [185] ã€‚ 7.3. Localization 7.3.æœ¬åœŸåŒ– Localization plays a crucial role in the safe operation of UAVs beyond LoS applications. Because of the high and unpredictable mobility of UAVs, accurate localization of UAVs within a short time is problematic. The position of UAVs in the network affects the formation of appropriate communication between UAVs. A widely adopted solution is to use GPS [186], [187] to obtain the position coordinates of any wireless node. However, the accuracy of UAV location is limited due to its 3D mobility and highly dynamic and obstacle-based environment. Furthermore, due to the probable large deployment of UAVs, the use of GPS may add unnecessary costs undermining its use prospective. Different localization methods have been studied for proficient UAV location. Network-based positioning, which is based on exchanging packets and height-based positioning, can be used to enhance position information. Recently, localization techniques based on fuzzy logic that relies on weighted centroid and vision-based localizations [188] have been greatly favored for precise localization. Moreover, wireless links through which location information is shared must be reliable and robust in the network design [189]. é™¤äº†è§†è·åº”ç”¨ä¹‹å¤–ï¼Œå®šä½å¯¹äºæ— äººæœºçš„å®‰å…¨è¿è¡Œä¹Ÿèµ·ç€è‡³å…³é‡è¦çš„ä½œç”¨ã€‚ç”±äºæ— äººæœºçš„æœºåŠ¨æ€§é«˜ä¸”éš¾ä»¥é¢„æµ‹ï¼ŒçŸ­æ—¶é—´å†…å‡†ç¡®å®šä½æ— äººæœºæ˜¯å­˜åœ¨é—®é¢˜çš„ã€‚æ— äººæœºåœ¨ç½‘ç»œä¸­çš„ä½ç½®å½±å“æ— äººæœºä¹‹é—´é€‚å½“é€šä¿¡çš„å½¢æˆã€‚ä¸€ç§å¹¿æ³›é‡‡ç”¨çš„è§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨GPS [186] ã€ [187]æ¥è·å–ä»»ä½•æ— çº¿èŠ‚ç‚¹çš„ä½ç½®åæ ‡ã€‚ç„¶è€Œï¼Œç”±äºæ— äººæœºçš„3Dç§»åŠ¨æ€§ä»¥åŠé«˜åº¦åŠ¨æ€å’ŒåŸºäºéšœç¢ç‰©çš„ç¯å¢ƒï¼Œæ— äººæœºå®šä½çš„å‡†ç¡®æ€§å—åˆ°é™åˆ¶ã€‚æ­¤å¤–ï¼Œç”±äºæ— äººæœºå¯èƒ½å¤§è§„æ¨¡éƒ¨ç½²ï¼ŒGPSçš„ä½¿ç”¨å¯èƒ½ä¼šå¢åŠ ä¸å¿…è¦çš„æˆæœ¬ï¼Œä»è€ŒæŸå®³å…¶ä½¿ç”¨å‰æ™¯ã€‚ä¸ºäº†ç†Ÿç»ƒçš„æ— äººæœºå®šä½ï¼Œå·²ç»ç ”ç©¶äº†ä¸åŒçš„å®šä½æ–¹æ³•ã€‚åŸºäºç½‘ç»œçš„å®šä½ä»¥äº¤æ¢æ•°æ®åŒ…å’ŒåŸºäºé«˜åº¦çš„å®šä½ä¸ºåŸºç¡€ï¼Œå¯ç”¨äºå¢å¼ºä½ç½®ä¿¡æ¯ã€‚æœ€è¿‘ï¼ŒåŸºäºæ¨¡ç³Šé€»è¾‘çš„å®šä½æŠ€æœ¯ä¾èµ–äºåŠ æƒè´¨å¿ƒå’ŒåŸºäºè§†è§‰çš„å®šä½[188]ï¼Œåœ¨ç²¾ç¡®å®šä½æ–¹é¢å—åˆ°äº†æå¤§çš„é’çã€‚æ­¤å¤–ï¼Œå…±äº«ä½ç½®ä¿¡æ¯çš„æ— çº¿é“¾è·¯åœ¨ç½‘ç»œè®¾è®¡ä¸­å¿…é¡»å¯é ä¸”ç¨³å¥[189] ã€‚ 7.4. UAV speed 7.4.æ— äººæœºé€Ÿåº¦ The mobility of UAVs is one of the major reasons for their rapid adoption in many different applications. Owing to the high mobility of UAVs, frequently changing and unpredictable topologies have been observed. The speed of UAVs varies with their size; small-sized UAVs usually move at 15 m/s approximately, and large UAVs can have a remarkable speed of 150 m/s. The types of UAVs must be carefully selected considering the desired speed for their targeted applications. The trade-off between the speed of the UAV and its turning agility must also be prioritized. Different emergent technologies, such as designing dynamic and optimized trajectories for UAVs in 3D for better accuracy and speed, have sustained the durability of small UAV nodes. Consequently, restrictions on speed must be considered via field experiments. The optimized and adaptive speed of UAVs benefits highly enhanced UAV communication [190]. æ— äººæœºçš„ç§»åŠ¨æ€§æ˜¯å…¶åœ¨è®¸å¤šä¸åŒåº”ç”¨ä¸­å¿«é€Ÿé‡‡ç”¨çš„ä¸»è¦åŸå› ä¹‹ä¸€ã€‚ç”±äºæ— äººæœºçš„é«˜æœºåŠ¨æ€§ï¼Œäººä»¬è§‚å¯Ÿåˆ°é¢‘ç¹å˜åŒ–ä¸”ä¸å¯é¢„æµ‹çš„æ‹“æ‰‘ç»“æ„ã€‚æ— äººæœºçš„é€Ÿåº¦å› å…¶å¤§å°è€Œå¼‚ï¼›å°å‹æ— äººæœºçš„ç§»åŠ¨é€Ÿåº¦é€šå¸¸çº¦ä¸º 15 m/sï¼Œå¤§å‹æ— äººæœºçš„ç§»åŠ¨é€Ÿåº¦å¯è¾¾ 150 m/sã€‚å¿…é¡»ä»”ç»†é€‰æ‹©æ— äººæœºçš„ç±»å‹ï¼Œè€ƒè™‘å…¶ç›®æ ‡åº”ç”¨æ‰€éœ€çš„é€Ÿåº¦ã€‚æ— äººæœºçš„é€Ÿåº¦å’Œè½¬å¼¯æ•æ·æ€§ä¹‹é—´çš„æƒè¡¡ä¹Ÿå¿…é¡»ä¼˜å…ˆè€ƒè™‘ã€‚ä¸åŒçš„æ–°å…´æŠ€æœ¯ï¼Œä¾‹å¦‚ä¸ºæ— äººæœºè®¾è®¡åŠ¨æ€å’Œä¼˜åŒ–çš„ 3D è½¨è¿¹ä»¥æé«˜ç²¾åº¦å’Œé€Ÿåº¦ï¼Œç»´æŒäº†å°å‹æ— äººæœºèŠ‚ç‚¹çš„è€ç”¨æ€§ã€‚å› æ­¤ï¼Œå¿…é¡»é€šè¿‡ç°åœºå®éªŒæ¥è€ƒè™‘å¯¹é€Ÿåº¦çš„é™åˆ¶ã€‚æ— äººæœºçš„ä¼˜åŒ–å’Œè‡ªé€‚åº”é€Ÿåº¦æœ‰åˆ©äºé«˜åº¦å¢å¼ºçš„æ— äººæœºé€šä¿¡[190] ã€‚ 7.5. UAV types 7.5ã€‚æ— äººæœºç±»å‹ Depending on the goals and application of UAV operation, one must select an appropriate UAV type and meet numerous requirements imposed by the anticipated QoS and environmental constraints. In fact, for the proper utilization of UAVs, numerous factors, such as UAV capabilities and onboard sensor devices, must be considered [191], [192]. UAVs are categorized based on their size, weight, speed, coverage range, and other operational capabilities. Inappropriate UAV selection may deteriorate complete network performance. æ ¹æ®æ— äººæœºæ“ä½œçš„ç›®æ ‡å’Œåº”ç”¨ï¼Œå¿…é¡»é€‰æ‹©åˆé€‚çš„æ— äººæœºç±»å‹å¹¶æ»¡è¶³é¢„æœŸæœåŠ¡è´¨é‡å’Œç¯å¢ƒé™åˆ¶æ‰€æå‡ºçš„ä¼—å¤šè¦æ±‚ã€‚äº‹å®ä¸Šï¼Œä¸ºäº†æ­£ç¡®åˆ©ç”¨æ— äººæœºï¼Œå¿…é¡»è€ƒè™‘è®¸å¤šå› ç´ ï¼Œä¾‹å¦‚æ— äººæœºèƒ½åŠ›å’Œæœºè½½ä¼ æ„Ÿå™¨è®¾å¤‡[191] ï¼Œ [192] ã€‚æ— äººæœºæ ¹æ®å…¶å°ºå¯¸ã€é‡é‡ã€é€Ÿåº¦ã€è¦†ç›–èŒƒå›´å’Œå…¶ä»–æ“ä½œèƒ½åŠ›è¿›è¡Œåˆ†ç±»ã€‚ä¸é€‚å½“çš„æ— äººæœºé€‰æ‹©å¯èƒ½ä¼šé™ä½æ•´ä½“ç½‘ç»œæ€§èƒ½ã€‚ 7.6. Channel modeling 7.6 ä¿¡é“å»ºæ¨¡ Wireless media amongst transmitters and receivers affect the signal propagation. The characteristics of A2G channels are considerably different from those of ground-to-ground (G2G) channels. A2G is highly susceptible to blockage, whereas A2A communication has dominant LoS communications. To design and implement optimal UAV applications, an accurate A2G channel model is a perquisite. In addition, A2G channels are highly dependent on altitude, type, angle of elevation, and type of propagation environment of UAV employment. Therefore, finding a standard channel model for UAV-to-UAV and UAV-to-ground communications requires ample simulations and measurements. In [193], [41], a summary of the prevailing A2G channel modeling works were presented. Ref. [193] provides both simulation and measurement-based results for path loss, delay spread, and fading in A2G communications. Thus, accurate channel characterization is crucial for performance optimization and the design of efficient UAV communication. Measurement operation while modeling the UAV-UAV and UAV-GBS channels with various velocities and moving directions of UAVs must be done in the presence of regularly and irregularly shaped infrastructures. å‘å°„å™¨å’Œæ¥æ”¶å™¨ä¹‹é—´çš„æ— çº¿ä»‹è´¨å½±å“ä¿¡å·ä¼ æ’­ã€‚ A2G ä¿¡é“çš„ç‰¹æ€§ä¸åœ°å¯¹åœ°ï¼ˆG2Gï¼‰ä¿¡é“æœ‰å¾ˆå¤§ä¸åŒã€‚ A2G éå¸¸å®¹æ˜“å—åˆ°é˜»å¡ï¼Œè€Œ A2A é€šä¿¡åˆ™ä»¥è§†è·é€šä¿¡ä¸ºä¸»ã€‚ä¸ºäº†è®¾è®¡å’Œå®ç°æœ€ä½³çš„æ— äººæœºåº”ç”¨ï¼Œå‡†ç¡®çš„ A2G ä¿¡é“æ¨¡å‹æ˜¯å¿…è¦æ¡ä»¶ã€‚æ­¤å¤–ï¼ŒA2G ä¿¡é“é«˜åº¦ä¾èµ–äºæ— äººæœºä½¿ç”¨çš„é«˜åº¦ã€ç±»å‹ã€ä»°è§’å’Œä¼ æ’­ç¯å¢ƒç±»å‹ã€‚å› æ­¤ï¼Œæ‰¾åˆ°æ— äººæœºå¯¹æ— äººæœºå’Œæ— äººæœºå¯¹åœ°é¢é€šä¿¡çš„æ ‡å‡†ä¿¡é“æ¨¡å‹éœ€è¦å¤§é‡çš„æ¨¡æ‹Ÿå’Œæµ‹é‡ã€‚åœ¨[193] ã€ [41]ä¸­ï¼Œæ€»ç»“äº†æµè¡Œçš„A2Gä¿¡é“å»ºæ¨¡å·¥ä½œã€‚å‚è€ƒå·[193]æä¾›äº† A2G é€šä¿¡ä¸­è·¯å¾„æŸè€—ã€å»¶è¿Ÿæ‰©å±•å’Œè¡°è½çš„ä»¿çœŸå’ŒåŸºäºæµ‹é‡çš„ç»“æœã€‚å› æ­¤ï¼Œå‡†ç¡®çš„ä¿¡é“è¡¨å¾å¯¹äºæ€§èƒ½ä¼˜åŒ–å’Œé«˜æ•ˆæ— äººæœºé€šä¿¡çš„è®¾è®¡è‡³å…³é‡è¦ã€‚åœ¨å¯¹å…·æœ‰ä¸åŒé€Ÿåº¦å’Œæ— äººæœºç§»åŠ¨æ–¹å‘çš„ UAV-UAV å’Œ UAV-GBS é€šé“è¿›è¡Œå»ºæ¨¡æ—¶ï¼Œå¿…é¡»åœ¨å­˜åœ¨è§„åˆ™å’Œä¸è§„åˆ™å½¢çŠ¶çš„åŸºç¡€è®¾æ–½çš„æƒ…å†µä¸‹è¿›è¡Œæµ‹é‡æ“ä½œã€‚ 7.7. Synchronization 7.7.åŒæ­¥ It is assumed that for every application sphere of UAV time synchronization, proper time-stamping is required not only to be updated but also for coordination among other UAVs and devices. Synchronization plays a crucial role in UAV applications in disaster or emergency environments, where if one of the UAVs misses information at a particular time, the network will be partitioned, which degrades the network performance [194]. å‡è®¾å¯¹äºæ— äººæœºæ—¶é—´åŒæ­¥çš„æ¯ä¸ªåº”ç”¨é¢†åŸŸï¼Œä¸ä»…éœ€è¦æ›´æ–°é€‚å½“çš„æ—¶é—´æˆ³ï¼Œè€Œä¸”è¿˜éœ€è¦ç”¨äºå…¶ä»–æ— äººæœºå’Œè®¾å¤‡ä¹‹é—´çš„åè°ƒã€‚åŒæ­¥åœ¨ç¾éš¾æˆ–ç´§æ€¥ç¯å¢ƒä¸­çš„æ— äººæœºåº”ç”¨ä¸­èµ·ç€è‡³å…³é‡è¦çš„ä½œç”¨ï¼Œå¦‚æœå…¶ä¸­ä¸€æ¶æ— äººæœºåœ¨ç‰¹å®šæ—¶é—´ä¸¢å¤±ä¿¡æ¯ï¼Œç½‘ç»œå°†è¢«åˆ†å‰²ï¼Œä»è€Œé™ä½ç½‘ç»œæ€§èƒ½[194] ã€‚ 7.8. UAV antennas 7.8 æ— äººæœºå¤©çº¿ Owing to the ability to move in any direction and at different speeds, a new antenna design for UAV networks is essential to achieve higher data rates. One of the alternatives for improving the data rate during UAV-to-UAV and UAV-to-BS transmission is to install a UAV tracking antenna. For UAVs cruising at high speeds, it is desirable to have small, aerodynamic antennas that limit drag but can still yield sufficient bandwidth and coverage. Moreover, directional antennas are widespread due the restricted energy and space limitations of particularly small sized UAVs. Moreover, tilted-beam circularly-polarized antenna can be used to save space. Performance is expected to be improved in terms of return losses, axial ratio, and radiation pattern, which can be achieved by means of such antennas. Additional propose for scheming and using smart antennas is to reduce the UAV communication energy by minimizing the transmission power [85], [86]. Backscatter antennas and wireless power transfer techniques could also be adopted for longer-term network life. The integration of several adaptive antennas also contributes in the communication of highly mobile UAVs. A compact, sabre-like antenna that is capable of switching between two radiation patterns can be considered for better coverage in UAV communications [195], [196]. ç”±äºèƒ½å¤Ÿä»¥ä¸åŒçš„é€Ÿåº¦å‘ä»»ä½•æ–¹å‘ç§»åŠ¨ï¼Œæ— äººæœºç½‘ç»œçš„æ–°å¤©çº¿è®¾è®¡å¯¹äºå®ç°æ›´é«˜çš„æ•°æ®é€Ÿç‡è‡³å…³é‡è¦ã€‚æé«˜æ— äººæœºåˆ°æ— äººæœºå’Œæ— äººæœºåˆ°åŸºç«™ä¼ è¾“æœŸé—´æ•°æ®é€Ÿç‡çš„æ›¿ä»£æ–¹æ¡ˆä¹‹ä¸€æ˜¯å®‰è£…æ— äººæœºè·Ÿè¸ªå¤©çº¿ã€‚å¯¹äºé«˜é€Ÿå·¡èˆªçš„æ— äººæœºï¼Œå¸Œæœ›æ‹¥æœ‰å°å‹ç©ºæ°”åŠ¨åŠ›å­¦å¤©çº¿ï¼Œæ—¢èƒ½é™åˆ¶é˜»åŠ›ï¼Œåˆèƒ½äº§ç”Ÿè¶³å¤Ÿçš„å¸¦å®½å’Œè¦†ç›–èŒƒå›´ã€‚æ­¤å¤–ï¼Œç”±äºç‰¹åˆ«å°å‹æ— äººæœºçš„èƒ½é‡å’Œç©ºé—´é™åˆ¶ï¼Œå®šå‘å¤©çº¿å¾—åˆ°äº†å¹¿æ³›åº”ç”¨ã€‚æ­¤å¤–ï¼Œå¯ä»¥ä½¿ç”¨æ–œæ³¢æŸåœ†æåŒ–å¤©çº¿æ¥èŠ‚çœç©ºé—´ã€‚é¢„æœŸåœ¨å›æ³¢æŸè€—ã€è½´æ¯”å’Œè¾å°„æ–¹å‘å›¾æ–¹é¢çš„æ€§èƒ½å°†å¾—åˆ°æ”¹å–„ï¼Œè¿™å¯ä»¥é€šè¿‡æ­¤ç±»å¤©çº¿æ¥å®ç°ã€‚è®¾è®¡å’Œä½¿ç”¨æ™ºèƒ½å¤©çº¿çš„é¢å¤–å»ºè®®æ˜¯é€šè¿‡æœ€å°åŒ–ä¼ è¾“åŠŸç‡æ¥å‡å°‘æ— äººæœºé€šä¿¡èƒ½é‡[85] ï¼Œ [86] ã€‚è¿˜å¯ä»¥é‡‡ç”¨åå‘æ•£å°„å¤©çº¿å’Œæ— çº¿åŠŸç‡ä¼ è¾“æŠ€æœ¯æ¥å»¶é•¿ç½‘ç»œå¯¿å‘½ã€‚å¤šä¸ªè‡ªé€‚åº”å¤©çº¿çš„é›†æˆä¹Ÿæœ‰åŠ©äºé«˜æœºåŠ¨æ€§æ— äººæœºçš„é€šä¿¡ã€‚å¯ä»¥è€ƒè™‘ä½¿ç”¨èƒ½å¤Ÿåœ¨ä¸¤ç§è¾å°„æ¨¡å¼ä¹‹é—´åˆ‡æ¢çš„ç´§å‡‘å‹å†›åˆ€å¼å¤©çº¿ï¼Œä»¥åœ¨æ— äººæœºé€šä¿¡ä¸­å®ç°æ›´å¥½çš„è¦†ç›–èŒƒå›´[195] ã€ [196] ã€‚ 7.9. Network lifetime 7.9 ç½‘ç»œå¯¿å‘½ Power consumption is always a primary concern in UAV communications. Most often, UAVs are battery-powered devices, and UAVs use their energy for thrust, data gathering, processing, and dissemination. The proficiency of UAV networks and network lifetime are greatly determined by the energy levels of the UAVs. Hence, ensuring energy-efficient UAV mission operations is of primary importance. Different energy harvesting techniques, such as wireless charging and solar energy can help increase the network lifetime of UAVs. An autonomous concept of battery swapping was introduced and enhanced in [197], [198], [199], [200]. In the swapping process, UAVs are connected to an external power supply for smooth functioning and to prevent data loss due to dead UAV nodes [201], [202]. Additionally, exhausted batteries are sometimes replaced by abundantly charged batteries to continue the current mission. The clustering of nodes also helps to minimize energy consumption by limiting the number of transmissions [203]. åŠŸè€—å§‹ç»ˆæ˜¯æ— äººæœºé€šä¿¡çš„é¦–è¦é—®é¢˜ã€‚å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæ— äººæœºæ˜¯ç”µæ± ä¾›ç”µçš„è®¾å¤‡ï¼Œæ— äººæœºåˆ©ç”¨å…¶èƒ½é‡è¿›è¡Œæ¨åŠ›ã€æ•°æ®æ”¶é›†ã€å¤„ç†å’Œä¼ æ’­ã€‚æ— äººæœºç½‘ç»œçš„ç†Ÿç»ƒç¨‹åº¦å’Œç½‘ç»œå¯¿å‘½åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå–å†³äºæ— äººæœºçš„èƒ½é‡æ°´å¹³ã€‚å› æ­¤ï¼Œç¡®ä¿æ— äººæœºä»»åŠ¡è¿è¡Œçš„èŠ‚èƒ½è‡³å…³é‡è¦ã€‚æ— çº¿å……ç”µå’Œå¤ªé˜³èƒ½ç­‰ä¸åŒçš„èƒ½é‡æ”¶é›†æŠ€æœ¯å¯ä»¥å¸®åŠ©å»¶é•¿æ— äººæœºçš„ç½‘ç»œå¯¿å‘½ã€‚ [197] ã€ [198] ã€ [199] ã€ [200]ä¸­å¼•å…¥å¹¶å¢å¼ºäº†ç”µæ± äº¤æ¢çš„è‡ªä¸»æ¦‚å¿µã€‚åœ¨äº¤æ¢è¿‡ç¨‹ä¸­ï¼Œæ— äººæœºè¿æ¥åˆ°å¤–éƒ¨ç”µæºä»¥å®ç°å¹³ç¨³è¿è¡Œå¹¶é˜²æ­¢ç”±äºæ— äººæœºèŠ‚ç‚¹å¤±æ•ˆè€Œå¯¼è‡´æ•°æ®ä¸¢å¤±[201] ï¼Œ [202] ã€‚æ­¤å¤–ï¼Œè€—å°½çš„ç”µæ± æœ‰æ—¶ä¼šè¢«å……æ»¡ç”µçš„ç”µæ± æ›¿æ¢ä»¥ç»§ç»­å½“å‰çš„ä»»åŠ¡ã€‚èŠ‚ç‚¹é›†ç¾¤è¿˜æœ‰åŠ©äºé€šè¿‡é™åˆ¶ä¼ è¾“æ•°é‡æ¥æœ€å°åŒ–èƒ½è€—[203] ã€‚ 7.10. Coordinated communication 7.10 åè°ƒæ²Ÿé€š The number of UAVs employed in any application may vary from one to numerous. Proper coordination and control among UAVs is necessary for better network performance. To this end, several efforts have been made to design error-free mechanisms to guarantee cooperation among UAVs. However, most of them are still immature and are subject to several challenges. The distributed approach divides the workload between all nodes, making peer-to-peer communication suitable. In the centralized approach, a central entity is responsible for designing and controlling all other nodes. Collision avoidance and proper sharing of tasks between the employed UAVs are significant for efficient cooperation and collaboration. A bandwidth-efficient multi-robot coordination algorithm tackling the problem of UAV swarm formation and maintenance was studied in [204]. Network time synchronization and proper time-stamping for UAV networks require intense investigation for proper coordination among UAVs. ä»»ä½•åº”ç”¨ä¸­ä½¿ç”¨çš„æ— äººæœºæ•°é‡å¯èƒ½ä»ä¸€æ¶åˆ°å¤šæ¶ä¸ç­‰ã€‚æ— äººæœºä¹‹é—´çš„é€‚å½“åè°ƒå’Œæ§åˆ¶å¯¹äºæ›´å¥½çš„ç½‘ç»œæ€§èƒ½æ˜¯å¿…è¦çš„ã€‚ä¸ºæ­¤ï¼Œäººä»¬åšå‡ºäº†ä¸€äº›åŠªåŠ›æ¥è®¾è®¡æ— å·®é”™æœºåˆ¶æ¥ä¿è¯æ— äººæœºä¹‹é—´çš„åˆä½œã€‚ç„¶è€Œï¼Œå®ƒä»¬ä¸­çš„å¤§å¤šæ•°ä»ç„¶ä¸æˆç†Ÿï¼Œå¹¶ä¸”é¢ä¸´ä¸€äº›æŒ‘æˆ˜ã€‚åˆ†å¸ƒå¼æ–¹æ³•åœ¨æ‰€æœ‰èŠ‚ç‚¹ä¹‹é—´åˆ’åˆ†å·¥ä½œè´Ÿè½½ï¼Œä»è€Œé€‚åˆç‚¹å¯¹ç‚¹é€šä¿¡ã€‚åœ¨é›†ä¸­å¼æ–¹æ³•ä¸­ï¼Œä¸­å¤®å®ä½“è´Ÿè´£è®¾è®¡å’Œæ§åˆ¶æ‰€æœ‰å…¶ä»–èŠ‚ç‚¹ã€‚æ‰€ä½¿ç”¨çš„æ— äººæœºä¹‹é—´çš„é¿å…ç¢°æ’å’Œæ­£ç¡®åˆ†æ‹…ä»»åŠ¡å¯¹äºé«˜æ•ˆåˆä½œå’Œåä½œå…·æœ‰é‡è¦æ„ä¹‰ã€‚ [204]ç ”ç©¶äº†ä¸€ç§è§£å†³æ— äººæœºç¾¤å½¢æˆå’Œç»´æŠ¤é—®é¢˜çš„å¸¦å®½é«˜æ•ˆçš„å¤šæœºå™¨äººåè°ƒç®—æ³•ã€‚æ— äººæœºç½‘ç»œçš„ç½‘ç»œæ—¶é—´åŒæ­¥å’Œæ­£ç¡®çš„æ—¶é—´æˆ³éœ€è¦è¿›è¡Œæ·±å…¥è°ƒæŸ¥ï¼Œä»¥ç¡®ä¿æ— äººæœºä¹‹é—´çš„æ­£ç¡®åè°ƒã€‚ 7.11. Network density 7.11 ç½‘ç»œå¯†åº¦ A UAV network consists of flying nodes that rely on battery power and limited onboard resources; therefore, communication protocols that consume the minimum possible energy with new inbuilt intelligent technologies must be focused on. Based on the types of UAV and objectives of the applications, the density of UAVs can vary from small to extremely dense. In dense UAV networks, suitable clustering methods must be considered to aid communication. Designing adaptive density-based communication protocols can be another credible solution [205], [27]. In addition, adaptive and energy-efficient clustering approaches improve the performance of dense UAV networks. The assessment of wind and weather conditions affects drone robustness against harsh environmental conditions to enhance network lifetime. æ— äººæœºç½‘ç»œç”±ä¾èµ–ç”µæ± ç”µæºå’Œæœ‰é™æœºè½½èµ„æºçš„é£è¡ŒèŠ‚ç‚¹ç»„æˆï¼›å› æ­¤ï¼Œå¿…é¡»å…³æ³¨é‡‡ç”¨æ–°çš„å†…ç½®æ™ºèƒ½æŠ€æœ¯æ¶ˆè€—å°½å¯èƒ½å°‘çš„èƒ½é‡çš„é€šä¿¡åè®®ã€‚æ ¹æ®æ— äººæœºçš„ç±»å‹å’Œåº”ç”¨ç›®æ ‡ï¼Œæ— äººæœºçš„å¯†åº¦å¯ä»¥ä»å°å‹åˆ°æå…¶å¯†é›†ä¸ç­‰ã€‚åœ¨å¯†é›†çš„æ— äººæœºç½‘ç»œä¸­ï¼Œå¿…é¡»è€ƒè™‘åˆé€‚çš„èšç±»æ–¹æ³•æ¥è¾…åŠ©é€šä¿¡ã€‚è®¾è®¡åŸºäºè‡ªé€‚åº”å¯†åº¦çš„é€šä¿¡åè®®å¯èƒ½æ˜¯å¦ä¸€ç§å¯é çš„è§£å†³æ–¹æ¡ˆ[205] ã€ [27] ã€‚æ­¤å¤–ï¼Œè‡ªé€‚åº”å’ŒèŠ‚èƒ½çš„é›†ç¾¤æ–¹æ³•å¯ä»¥æé«˜å¯†é›†æ— äººæœºç½‘ç»œçš„æ€§èƒ½ã€‚å¯¹é£å’Œå¤©æ°”æ¡ä»¶çš„è¯„ä¼°ä¼šå½±å“æ— äººæœºåœ¨æ¶åŠ£ç¯å¢ƒæ¡ä»¶ä¸‹çš„é²æ£’æ€§ï¼Œä»è€Œå»¶é•¿ç½‘ç»œå¯¿å‘½ã€‚ 7.12. Security and privacy 7.12. å®‰å…¨å’Œéšç§ UAVs are exposed to many possible security risks attributed to the susceptibility of protocols and resource-constrained UAV nodes. Security communication is necessary for many UAV applications. Security issues are a foremost concern in UAV communications because wireless media are used. Highly secure and safe communication is of utmost importance for military applications, where data secrecy is the principal focus. Any alterations in information by a fraudulent node may cause severe degradation of UAV applications. Furthermore, invaders may cause network partitioning and decrease network efficiency. Consequently, it is very important to develop robust and secure UAV communications that can meet the diverse needs of application reliability with minimum untrusted node involvement [206]. The security mechanisms of UAV communications are highly affected by the presence of faulty nodes and erroneous communication channels, which must be controlled with effective approaches. Different cryptographic measures, such as data encryption and hashing techniques, can be used to prevent network attacks [207]. Block chain technology can be utilized to ensure the safety and security of UAVs based on collected data. ç”±äºåè®®çš„æ•æ„Ÿæ€§å’Œèµ„æºå—é™çš„æ— äººæœºèŠ‚ç‚¹ï¼Œæ— äººæœºé¢ä¸´è®¸å¤šå¯èƒ½çš„å®‰å…¨é£é™©ã€‚å®‰å…¨é€šä¿¡å¯¹äºè®¸å¤šæ— äººæœºåº”ç”¨æ¥è¯´æ˜¯å¿…è¦çš„ã€‚ç”±äºä½¿ç”¨æ— çº¿åª’ä½“ï¼Œå®‰å…¨é—®é¢˜æ˜¯æ— äººæœºé€šä¿¡ä¸­æœ€é‡è¦çš„é—®é¢˜ã€‚é«˜åº¦å®‰å…¨çš„é€šä¿¡å¯¹äºå†›äº‹åº”ç”¨è‡³å…³é‡è¦ï¼Œå…¶ä¸­æ•°æ®ä¿å¯†æ˜¯ä¸»è¦å…³æ³¨ç‚¹ã€‚æ¬ºè¯ˆèŠ‚ç‚¹å¯¹ä¿¡æ¯çš„ä»»ä½•æ›´æ”¹éƒ½å¯èƒ½å¯¼è‡´æ— äººæœºåº”ç”¨çš„ä¸¥é‡é€€åŒ–ã€‚æ­¤å¤–ï¼Œå…¥ä¾µè€…å¯èƒ½ä¼šå¯¼è‡´ç½‘ç»œåˆ†åŒºå¹¶é™ä½ç½‘ç»œæ•ˆç‡ã€‚å› æ­¤ï¼Œå¼€å‘å¼ºå¤§ä¸”å®‰å…¨çš„æ— äººæœºé€šä¿¡éå¸¸é‡è¦ï¼Œè¯¥é€šä¿¡å¯ä»¥æ»¡è¶³åº”ç”¨ç¨‹åºå¯é æ€§çš„å¤šæ ·åŒ–éœ€æ±‚ï¼ŒåŒæ—¶æœ€å¤§é™åº¦åœ°å‡å°‘ä¸å¯ä¿¡èŠ‚ç‚¹çš„å‚ä¸[206] ã€‚æ— äººæœºé€šä¿¡çš„å®‰å…¨æœºåˆ¶å—åˆ°æ•…éšœèŠ‚ç‚¹å’Œé”™è¯¯é€šä¿¡é€šé“çš„å½±å“å¾ˆå¤§ï¼Œå¿…é¡»é‡‡å–æœ‰æ•ˆçš„æ–¹æ³•è¿›è¡Œæ§åˆ¶ã€‚å¯ä»¥ä½¿ç”¨ä¸åŒçš„åŠ å¯†æªæ–½ï¼Œä¾‹å¦‚æ•°æ®åŠ å¯†å’Œæ•£åˆ—æŠ€æœ¯ï¼Œæ¥é˜²æ­¢ç½‘ç»œæ”»å‡»[207] ã€‚åŸºäºæ”¶é›†çš„æ•°æ®ï¼Œå¯ä»¥åˆ©ç”¨åŒºå—é“¾æŠ€æœ¯æ¥ç¡®ä¿æ— äººæœºçš„å®‰å…¨ã€‚ 7.13. Fault-tolerant system 7.13 å®¹é”™ç³»ç»Ÿ In contrast to manned aerial networks, UAVs allow a wider range of flight operating points and are highly vulnerable to failures. To augment safe and reliable UAV communications, fault-tolerant methods must be considered when designing control systems for multiple UAVs. Different strategies of fault-tolerant control for UAV communications are receiving significant attention from researchers because of the growing awareness of hazards resulting from the failure of different components and the necessity of trustworthy and secure systems in emergent scenarios. A network of UAVs must share critical data, and faults in a particular UAV can break down the entire network. Keeping this in mind, robust fault-tolerant mechanisms should be adopted to overcome the different failures observed in UAV networks [208], [209]. Inter-UAV support must be restructured in case the network partitions due to the failure of one or more UAVs. ä¸æœ‰äººé©¾é©¶èˆªç©ºç½‘ç»œç›¸æ¯”ï¼Œæ— äººæœºå…è®¸æ›´å¹¿æ³›çš„é£è¡Œæ“ä½œç‚¹ï¼Œå¹¶ä¸”å¾ˆå®¹æ˜“å‡ºç°æ•…éšœã€‚ä¸ºäº†å¢å¼ºå®‰å…¨å¯é çš„æ— äººæœºé€šä¿¡ï¼Œåœ¨è®¾è®¡å¤šæ¶æ— äººæœºçš„æ§åˆ¶ç³»ç»Ÿæ—¶å¿…é¡»è€ƒè™‘å®¹é”™æ–¹æ³•ã€‚ç”±äºäººä»¬è¶Šæ¥è¶Šæ„è¯†åˆ°ä¸åŒç»„ä»¶æ•…éšœé€ æˆçš„å±é™©ä»¥åŠåœ¨ç´§æ€¥æƒ…å†µä¸‹éœ€è¦å¯é å’Œå®‰å…¨çš„ç³»ç»Ÿï¼Œæ— äººæœºé€šä¿¡çš„ä¸åŒå®¹é”™æ§åˆ¶ç­–ç•¥æ­£å—åˆ°ç ”ç©¶äººå‘˜çš„æå¤§å…³æ³¨ã€‚æ— äººæœºç½‘ç»œå¿…é¡»å…±äº«å…³é”®æ•°æ®ï¼Œç‰¹å®šæ— äººæœºçš„æ•…éšœå¯èƒ½ä¼šç ´åæ•´ä¸ªç½‘ç»œã€‚è®°ä½è¿™ä¸€ç‚¹ï¼Œåº”è¯¥é‡‡ç”¨å¼ºå¤§çš„å®¹é”™æœºåˆ¶æ¥å…‹æœæ— äººæœºç½‘ç»œä¸­è§‚å¯Ÿåˆ°çš„ä¸åŒæ•…éšœ[208] ï¼Œ [209] ã€‚å¿…é¡»é‡ç»„æ— äººæœºé—´æ”¯æŒï¼Œä»¥é˜²ç”±äºä¸€æ¶æˆ–å¤šæ¶æ— äººæœºæ•…éšœè€Œå¯¼è‡´ç½‘ç»œåˆ†åŒºã€‚ 7.14. Integration with cloud computing 7.14 ä¸äº‘è®¡ç®—é›†æˆ Cloud services have become the next frontier in advancing the workflows of UAVs. Cloud services have facilitated UAVs by allowing the use of resources at their leisure. The limitations of UAV networks can be incorporated and supported using cloud computing techniques, as discussed in [210]. To accomplish higher data throughput in UAV-based applications, aerial caching could be a promising solution. A cloud-assisted approach can also be useful for deriving optimal flight and data acquisition. Some research efforts have been made to provide techniques for linking UAVs to the cloud. äº‘æœåŠ¡å·²æˆä¸ºæ¨è¿›æ— äººæœºå·¥ä½œæµç¨‹çš„ä¸‹ä¸€ä¸ªå‰æ²¿ã€‚äº‘æœåŠ¡å…è®¸æ— äººæœºéšæ„ä½¿ç”¨èµ„æºï¼Œä»è€Œä¸ºæ— äººæœºæä¾›äº†ä¾¿åˆ©ã€‚æ­£å¦‚[210]ä¸­æ‰€è®¨è®ºçš„ï¼Œå¯ä»¥ä½¿ç”¨äº‘è®¡ç®—æŠ€æœ¯æ¥åˆå¹¶å’Œæ”¯æŒæ— äººæœºç½‘ç»œçš„å±€é™æ€§ã€‚ä¸ºäº†åœ¨åŸºäºæ— äººæœºçš„åº”ç”¨ä¸­å®ç°æ›´é«˜çš„æ•°æ®ååé‡ï¼Œç©ºä¸­ç¼“å­˜å¯èƒ½æ˜¯ä¸€ä¸ªæœ‰å‰é€”çš„è§£å†³æ–¹æ¡ˆã€‚äº‘è¾…åŠ©æ–¹æ³•ä¹Ÿå¯ç”¨äºè·å¾—æœ€ä½³é£è¡Œå’Œæ•°æ®é‡‡é›†ã€‚å·²ç»å¼€å±•äº†ä¸€äº›ç ”ç©¶å·¥ä½œæ¥æä¾›å°†æ— äººæœºè¿æ¥åˆ°äº‘çš„æŠ€æœ¯ã€‚ 7.15. Path planning 7.15 è·¯å¾„è§„åˆ’ Path/trajectory planning is an important and challenging issue in the design of UAV-based communication systems. In fact, task assignment and path planning are highly interrelated aspects of any UAV mission. The UAV path must be optimized with respect to key performance metrics, such as spectral efficiency, throughput, energy, and delay. Although many studies have focused on path planning algorithms for UAVs, UAV networks still experience issues of target location and identification due to high UAV mobility. Thus, it is desirable to rapidly develop dynamic trajectory planning approaches for UAVs to increase the likelihood of end-to-end connections while maintaining adequate intact target area coverage. Various path planning techniques proposed for UAV path planning were analyzed in [211]. There are still several issues in the path-planning process, in which path optimization considers the mobility patterns, obstacles, delay, and energy. Moreover, the algorithm can be equipped with deep learning approaches to help UAVs generate an environment map in real time. Genetic and chaotic operators can also be introduced to improve the convergence rate and hence the efficiency. 3D real-time path planning for different obstacle densities and moving obstacle environments in the presence of uncertainty was studied in [212], [213], [214]. è·¯å¾„/è½¨è¿¹è§„åˆ’æ˜¯åŸºäºæ— äººæœºçš„é€šä¿¡ç³»ç»Ÿè®¾è®¡ä¸­çš„ä¸€ä¸ªé‡è¦ä¸”å…·æœ‰æŒ‘æˆ˜æ€§çš„é—®é¢˜ã€‚äº‹å®ä¸Šï¼Œä»»åŠ¡åˆ†é…å’Œè·¯å¾„è§„åˆ’æ˜¯ä»»ä½•æ— äººæœºä»»åŠ¡ä¸­é«˜åº¦ç›¸å…³çš„æ–¹é¢ã€‚æ— äººæœºè·¯å¾„å¿…é¡»é’ˆå¯¹å…³é”®æ€§èƒ½æŒ‡æ ‡è¿›è¡Œä¼˜åŒ–ï¼Œä¾‹å¦‚é¢‘è°±æ•ˆç‡ã€ååé‡ã€èƒ½é‡å’Œå»¶è¿Ÿã€‚å°½ç®¡è®¸å¤šç ”ç©¶éƒ½é›†ä¸­åœ¨æ— äººæœºçš„è·¯å¾„è§„åˆ’ç®—æ³•ä¸Šï¼Œä½†ç”±äºæ— äººæœºçš„é«˜æœºåŠ¨æ€§ï¼Œæ— äººæœºç½‘ç»œä»ç„¶é¢ä¸´ç›®æ ‡å®šä½å’Œè¯†åˆ«çš„é—®é¢˜ã€‚å› æ­¤ï¼Œéœ€è¦å¿«é€Ÿå¼€å‘æ— äººæœºçš„åŠ¨æ€è½¨è¿¹è§„åˆ’æ–¹æ³•ï¼Œä»¥å¢åŠ ç«¯åˆ°ç«¯è¿æ¥çš„å¯èƒ½æ€§ï¼ŒåŒæ—¶ä¿æŒè¶³å¤Ÿçš„å®Œæ•´ç›®æ ‡åŒºåŸŸè¦†ç›–ã€‚ [211]ä¸­åˆ†æäº†é’ˆå¯¹æ— äººæœºè·¯å¾„è§„åˆ’æå‡ºçš„å„ç§è·¯å¾„è§„åˆ’æŠ€æœ¯ã€‚è·¯å¾„è§„åˆ’è¿‡ç¨‹ä¸­ä»ç„¶å­˜åœ¨å‡ ä¸ªé—®é¢˜ï¼Œå…¶ä¸­è·¯å¾„ä¼˜åŒ–è€ƒè™‘äº†ç§»åŠ¨æ¨¡å¼ã€éšœç¢ç‰©ã€å»¶è¿Ÿå’Œèƒ½é‡ã€‚æ­¤å¤–ï¼Œè¯¥ç®—æ³•å¯ä»¥é…å¤‡æ·±åº¦å­¦ä¹ æ–¹æ³•ï¼Œå¸®åŠ©æ— äººæœºå®æ—¶ç”Ÿæˆç¯å¢ƒåœ°å›¾ã€‚è¿˜å¯ä»¥å¼•å…¥é—ä¼ ç®—å­å’Œæ··æ²Œç®—å­æ¥æé«˜æ”¶æ•›é€Ÿåº¦ï¼Œä»è€Œæé«˜æ•ˆç‡ã€‚ [212] ã€ [213] ã€ [214]ç ”ç©¶äº†åœ¨å­˜åœ¨ä¸ç¡®å®šæ€§çš„æƒ…å†µä¸‹é’ˆå¯¹ä¸åŒéšœç¢ç‰©å¯†åº¦å’Œç§»åŠ¨éšœç¢ç‰©ç¯å¢ƒçš„ 3D å®æ—¶è·¯å¾„è§„åˆ’ã€‚ 7.16. Integration with IoT 7.16 ä¸ç‰©è”ç½‘é›†æˆ The efficient operation of UAVs requires addressing several key problems [215]. For instance, the number of UAVs that are necessary for full coverage of a given geographical area must be considered. UAVs are self-efficient for sensing and decision making, and this has made UAV networks more demanding. The integration of UAVs with IoT adds huge dimensions and remarkable results. However, there are many additional challenges [216]. Designing scalable UAV networks is in high demand as the application areas to be covered, as well as the number of tasks to be accomplished, are exponentially increasing. æ— äººæœºçš„é«˜æ•ˆè¿è¡Œéœ€è¦è§£å†³å‡ ä¸ªå…³é”®é—®é¢˜[215] ã€‚ä¾‹å¦‚ï¼Œå¿…é¡»è€ƒè™‘å®Œå…¨è¦†ç›–ç»™å®šåœ°ç†åŒºåŸŸæ‰€éœ€çš„æ— äººæœºæ•°é‡ã€‚æ— äººæœºåœ¨æ„ŸçŸ¥å’Œå†³ç­–æ–¹é¢å…·æœ‰è‡ªæˆ‘é«˜æ•ˆæ€§ï¼Œè¿™å¯¹æ— äººæœºç½‘ç»œæå‡ºäº†æ›´é«˜çš„è¦æ±‚ã€‚æ— äººæœºä¸ç‰©è”ç½‘çš„èåˆå¢åŠ äº†å·¨å¤§çš„è§„æ¨¡å’Œæ˜¾ç€çš„æˆæœã€‚ç„¶è€Œï¼Œè¿˜æœ‰è®¸å¤šé¢å¤–çš„æŒ‘æˆ˜[216] ã€‚éšç€è¦è¦†ç›–çš„åº”ç”¨é¢†åŸŸä»¥åŠè¦å®Œæˆçš„ä»»åŠ¡æ•°é‡å‘ˆæŒ‡æ•°çº§å¢é•¿ï¼Œè®¾è®¡å¯æ‰©å±•çš„æ— äººæœºç½‘ç»œçš„éœ€æ±‚é‡å¾ˆå¤§ã€‚ 7.17. Quality of service 7.17 æœåŠ¡è´¨é‡ QoS support over UAV communications remains as a challenging issue when previously built-up arrangements of the network are not accessible due to the changes in speed, location, architecture, or separation between UAV nodes. Different types of QoS provisions for UAV-aided IoT networks were recommended in [217]. New resource innovation and planning procedures are necessary to dynamically change the requirements of QoS of UAV networks. Therefore, well-organized approaches for the efficient handover mechanism, proficient methods for determining and solving UAV battery related issues, user-facilitation, and network assortment, capability, and spectral effectiveness needs an additional exploration. Furthermore, designing of the protocols supporting multiple classes of traffic and preemption allowance, identification of position and prioritization of the packets are some unexplored areas. Timely update of the control information guarantees prÃ©cised information but adds consumption of energy. Competent routing, flight self-sufficiency, and policy-making metrics can confirm the essential QoS of the targeted UAV applications. å½“ç”±äºé€Ÿåº¦ã€ä½ç½®ã€æ¶æ„æˆ–æ— äººæœºèŠ‚ç‚¹ä¹‹é—´çš„åˆ†ç¦»çš„å˜åŒ–è€Œæ— æ³•è®¿é—®å…ˆå‰æ„å»ºçš„ç½‘ç»œå®‰æ’æ—¶ï¼Œæ— äººæœºé€šä¿¡çš„ QoS æ”¯æŒä»ç„¶æ˜¯ä¸€ä¸ªå…·æœ‰æŒ‘æˆ˜æ€§çš„é—®é¢˜ã€‚ [217]ä¸­æ¨èäº†é’ˆå¯¹æ— äººæœºè¾…åŠ©ç‰©è”ç½‘ç½‘ç»œçš„ä¸åŒç±»å‹çš„ QoS è§„å®šã€‚æ–°çš„èµ„æºåˆ›æ–°å’Œè§„åˆ’ç¨‹åºå¯¹äºåŠ¨æ€æ”¹å˜æ— äººæœºç½‘ç»œçš„æœåŠ¡è´¨é‡è¦æ±‚æ˜¯å¿…è¦çš„ã€‚å› æ­¤ï¼Œé«˜æ•ˆåˆ‡æ¢æœºåˆ¶çš„ç»„ç»‡è‰¯å¥½çš„æ–¹æ³•ã€ç¡®å®šå’Œè§£å†³æ— äººæœºç”µæ± ç›¸å…³é—®é¢˜çš„ç†Ÿç»ƒæ–¹æ³•ã€ç”¨æˆ·ä¾¿åˆ©æ€§ä»¥åŠç½‘ç»œåˆ†ç±»ã€èƒ½åŠ›å’Œé¢‘è°±æœ‰æ•ˆæ€§éœ€è¦è¿›ä¸€æ­¥æ¢ç´¢ã€‚æ­¤å¤–ï¼Œæ”¯æŒå¤šç±»æµé‡å’ŒæŠ¢å å…è®¸çš„åè®®è®¾è®¡ã€æ•°æ®åŒ…çš„ä½ç½®è¯†åˆ«å’Œä¼˜å…ˆçº§åˆ’åˆ†ä¹Ÿæ˜¯ä¸€äº›å°šæœªæ¢ç´¢çš„é¢†åŸŸã€‚æ§åˆ¶ä¿¡æ¯çš„åŠæ—¶æ›´æ–°ä¿è¯äº†ä¿¡æ¯çš„ç²¾ç¡®æ€§ï¼Œä½†å¢åŠ äº†èƒ½æºçš„æ¶ˆè€—ã€‚æœ‰æ•ˆçš„èˆªçº¿ã€é£è¡Œè‡ªç»™è‡ªè¶³å’Œå†³ç­–æŒ‡æ ‡å¯ä»¥ç¡®è®¤ç›®æ ‡æ— äººæœºåº”ç”¨çš„åŸºæœ¬æœåŠ¡è´¨é‡ã€‚ 7.18. Scalability 7.18 å¯æ‰©å±•æ€§ The large-scale ever-growing use of UAVs in a wide range of applications is anticipated in the next few decades. Thus, UAV networks as well as task assignment algorithms designed for a swarm of UAVs must be highly scalable. Small-scaled UAV networks are the best choice for commercial applications because of their easy positioning, low maintenance, low acquisition costs, and high mobility. The number of UAVs employed, urgency of the UAV applications, and range to be covered are highly interrelated. Large-scaled UAVs are required when the mission area is large and delay is strictly undesirable. However, the complexity of task assignment algorithms increases with increasing number of UAVs and other IoT nodes. Designing scalable and adaptive communication protocols is a principal challenge for both light and dense UAV networks [218]. é¢„è®¡æœªæ¥å‡ åå¹´ï¼Œæ— äººæœºå°†åœ¨å„ç§åº”ç”¨ä¸­å¾—åˆ°å¤§è§„æ¨¡ã€ä¸æ–­å¢é•¿çš„ä½¿ç”¨ã€‚å› æ­¤ï¼Œæ— äººæœºç½‘ç»œä»¥åŠä¸ºæ— äººæœºç¾¤è®¾è®¡çš„ä»»åŠ¡åˆ†é…ç®—æ³•å¿…é¡»å…·æœ‰é«˜åº¦å¯æ‰©å±•æ€§ã€‚å°å‹æ— äººæœºç½‘ç»œå› å…¶æ˜“å®šä½ã€ä½ç»´æŠ¤ã€ä½é‡‡è´­æˆæœ¬å’Œé«˜æœºåŠ¨æ€§è€Œæˆä¸ºå•†ä¸šåº”ç”¨çš„æœ€ä½³é€‰æ‹©ã€‚ä½¿ç”¨çš„æ— äººæœºæ•°é‡ã€æ— äººæœºåº”ç”¨çš„ç´§è¿«æ€§ä»¥åŠè¦†ç›–èŒƒå›´æ˜¯é«˜åº¦ç›¸å…³çš„ã€‚å½“ä»»åŠ¡åŒºåŸŸå¾ˆå¤§å¹¶ä¸”å»¶è¿Ÿæ˜¯ç»å¯¹ä¸å¯å–çš„æ—¶å€™ï¼Œå°±éœ€è¦å¤§å‹æ— äººæœºã€‚ç„¶è€Œï¼Œä»»åŠ¡åˆ†é…ç®—æ³•çš„å¤æ‚æ€§éšç€æ— äººæœºå’Œå…¶ä»–ç‰©è”ç½‘èŠ‚ç‚¹æ•°é‡çš„å¢åŠ è€Œå¢åŠ ã€‚è®¾è®¡å¯æ‰©å±•å’Œè‡ªé€‚åº”çš„é€šä¿¡åè®®æ˜¯è½»å‹å’Œå¯†é›†å‹æ— äººæœºç½‘ç»œçš„ä¸»è¦æŒ‘æˆ˜[218] ã€‚ 7.19. Mobility management 7.19 ç§»åŠ¨ç®¡ç† Networks of UAVs face many design problems related to network mobility. Frequent topology changes affect the communication and cooperation among UAVs. Different mobility models have been studied to manage the movement of UAVs, but they are insufficient to completely solve the issues faced in UAV communication. Mobility models must be selected based on network requirements. UAV mobility at low speed reduces the coverage significantly, which results in network delays. Regarding the emergency application of UAVs, mobility models with minimal latency are highly desired. However, continuous connectivity with the network is very challenging, which may result in degraded network performance in such scenarios. Thus, new mobility models for a specific environment and applications that can cope with the challenges of mobility must be focused on. Recently, different mobility models have been designed for UAVs [219], and they can use variable speeds during different communication phases. Dynamic UAV speed control using machine learning techniques to adapt the UAV speed according to network requirements is another possible solution. Based on recent advances in deep reinforcement learning algorithms, green mobility management has been proposed for UAV-assisted IoT. æ— äººæœºç½‘ç»œé¢ä¸´è®¸å¤šä¸ç½‘ç»œç§»åŠ¨æ€§ç›¸å…³çš„è®¾è®¡é—®é¢˜ã€‚é¢‘ç¹çš„æ‹“æ‰‘å˜åŒ–ä¼šå½±å“æ— äººæœºä¹‹é—´çš„é€šä¿¡å’Œåä½œã€‚äººä»¬å·²ç»ç ”ç©¶äº†ä¸åŒçš„ç§»åŠ¨æ¨¡å‹æ¥ç®¡ç†æ— äººæœºçš„è¿åŠ¨ï¼Œä½†ä¸è¶³ä»¥å®Œå…¨è§£å†³æ— äººæœºé€šä¿¡ä¸­é¢ä¸´çš„é—®é¢˜ã€‚å¿…é¡»æ ¹æ®ç½‘ç»œè¦æ±‚é€‰æ‹©ç§»åŠ¨æ¨¡å‹ã€‚æ— äººæœºä½é€Ÿç§»åŠ¨ä¼šæ˜¾ç€é™ä½è¦†ç›–èŒƒå›´ï¼Œä»è€Œå¯¼è‡´ç½‘ç»œå»¶è¿Ÿã€‚å¯¹äºæ— äººæœºçš„ç´§æ€¥åº”ç”¨ï¼Œéå¸¸éœ€è¦å…·æœ‰æœ€å°å»¶è¿Ÿçš„ç§»åŠ¨æ¨¡å‹ã€‚ç„¶è€Œï¼Œä¸ç½‘ç»œçš„æŒç»­è¿æ¥éå¸¸å…·æœ‰æŒ‘æˆ˜æ€§ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹å¯èƒ½ä¼šå¯¼è‡´ç½‘ç»œæ€§èƒ½ä¸‹é™ã€‚å› æ­¤ï¼Œå¿…é¡»å…³æ³¨èƒ½å¤Ÿåº”å¯¹ç§»åŠ¨æŒ‘æˆ˜çš„ç‰¹å®šç¯å¢ƒå’Œåº”ç”¨çš„æ–°ç§»åŠ¨æ¨¡å‹ã€‚æœ€è¿‘ï¼Œå·²ç»ä¸ºæ— äººæœºè®¾è®¡äº†ä¸åŒçš„ç§»åŠ¨æ¨¡å‹[219] ï¼Œå®ƒä»¬å¯ä»¥åœ¨ä¸åŒçš„é€šä¿¡é˜¶æ®µä½¿ç”¨å¯å˜çš„é€Ÿåº¦ã€‚ä½¿ç”¨æœºå™¨å­¦ä¹ æŠ€æœ¯åŠ¨æ€æ§åˆ¶æ— äººæœºé€Ÿåº¦ï¼Œæ ¹æ®ç½‘ç»œè¦æ±‚è°ƒæ•´æ— äººæœºé€Ÿåº¦æ˜¯å¦ä¸€ç§å¯èƒ½çš„è§£å†³æ–¹æ¡ˆã€‚åŸºäºæ·±åº¦å¼ºåŒ–å­¦ä¹ ç®—æ³•çš„æœ€æ–°è¿›å±•ï¼Œé’ˆå¯¹æ— äººæœºè¾…åŠ©ç‰©è”ç½‘æå‡ºäº†ç»¿è‰²ç§»åŠ¨ç®¡ç†ã€‚ 7.20. Task offloading 7.20 ä»»åŠ¡å¸è½½ In many mission planning systems, numerous tasks must be conducted simultaneously. Multi-UAV systems are in high demand for such applications. Tasks must be divided among the employed UAVs such that all tasks receive proper attention in a timely manner. Owing to time-sensitive and computation-intensive UAV applications and high mobility scenarios, cost-efficient task offloading remains a challenging issue. Many intelligent task offloading algorithms have been presented in the literature for the proper utilization of UAV networks [220], [221] that aim to minimize the overall energy consumption for the accomplishment of predefined tasks. åœ¨è®¸å¤šä»»åŠ¡è§„åˆ’ç³»ç»Ÿä¸­ï¼Œå¿…é¡»åŒæ—¶æ‰§è¡Œè®¸å¤šä»»åŠ¡ã€‚æ­¤ç±»åº”ç”¨å¯¹å¤šæ— äººæœºç³»ç»Ÿçš„éœ€æ±‚å¾ˆé«˜ã€‚å¿…é¡»åœ¨æ‰€ä½¿ç”¨çš„æ— äººæœºä¹‹é—´åˆ†é…ä»»åŠ¡ï¼Œä»¥ä¾¿æ‰€æœ‰ä»»åŠ¡éƒ½èƒ½åŠæ—¶å¾—åˆ°é€‚å½“çš„å…³æ³¨ã€‚ç”±äºæ—¶é—´æ•æ„Ÿå’Œè®¡ç®—å¯†é›†å‹æ— äººæœºåº”ç”¨å’Œé«˜ç§»åŠ¨æ€§åœºæ™¯ï¼Œå…·æœ‰æˆæœ¬æ•ˆç›Šçš„ä»»åŠ¡å¸è½½ä»ç„¶æ˜¯ä¸€ä¸ªå…·æœ‰æŒ‘æˆ˜æ€§çš„é—®é¢˜ã€‚æ–‡çŒ®ä¸­å·²ç»æå‡ºäº†è®¸å¤šæ™ºèƒ½ä»»åŠ¡å¸è½½ç®—æ³•ï¼Œç”¨äºæ­£ç¡®åˆ©ç”¨æ— äººæœºç½‘ç»œ[220] ã€ [221] ï¼Œå…¶ç›®çš„æ˜¯æœ€å¤§é™åº¦åœ°å‡å°‘å®Œæˆé¢„å®šä¹‰ä»»åŠ¡çš„æ€»ä½“èƒ½è€—ã€‚ 7.21. Impact of 5G, B5G, and mm-wave communication 7.21 5Gã€B5G å’Œæ¯«ç±³æ³¢é€šä¿¡çš„å½±å“ Providing universal connectivity to miscellaneous IoT devices is a prime challenge for 5G and B5G. 5G communications were deployed globally from 2020, and many more competences are in the progression for standardization, such as mass connectivity, guaranteed low latency, and ultra-reliability. Concerning future requirements and demands, researchers are now interested in beyond 5G/6G communication, which is expected to provide worldwide coverage, improved energy/spectral/cost efficiency, better intelligent security, and more benefits. The challenges, issues, and concerns for these networks are immense, and integrating them with highly mobile aerial nodes adds more complications and technical problems. Mm-wave communication with multi-gigahertz/terahertz bandwidth availability enhances the proficiency and data transmission rate in comparison to microwave communications. Recently, UAVs have been expected to serve ample applications, and the use of mm-wave bands can be very promising for handling the higher demands for data rate to achieve greater throughput. However, mm-wave suffers from propagation-related inadequacies, which can be compensated by the flexibility of UAVs. Many other deficiencies present in mm-wave signals must be resolved while preserving its benefits. 5G, B5G, and mm-wave-based UAV communications were discussed in [222]. Further investigation of mm-wave and 6G communications is extremely desired for reliable, flexible, robust, and spectrally efficient UAV communications [223], [224]. ä¸ºå„ç§ç‰©è”ç½‘è®¾å¤‡æä¾›é€šç”¨è¿æ¥æ˜¯ 5G å’Œ B5G é¢ä¸´çš„ä¸»è¦æŒ‘æˆ˜ã€‚ 5G é€šä¿¡ä» 2020 å¹´å¼€å§‹åœ¨å…¨çƒèŒƒå›´å†…éƒ¨ç½²ï¼Œæ›´å¤šèƒ½åŠ›æ­£åœ¨æ ‡å‡†åŒ–è¿‡ç¨‹ä¸­ï¼Œä¾‹å¦‚å¤§è§„æ¨¡è¿æ¥ã€ä¿è¯ä½å»¶è¿Ÿå’Œè¶…å¯é æ€§ã€‚è€ƒè™‘åˆ°æœªæ¥çš„è¦æ±‚å’Œéœ€æ±‚ï¼Œç ”ç©¶äººå‘˜ç°åœ¨å¯¹è¶…è¶Š 5G/6G çš„é€šä¿¡æ„Ÿå…´è¶£ï¼Œè¿™ç§é€šä¿¡æœ‰æœ›æä¾›å…¨çƒè¦†ç›–ã€æ›´é«˜çš„èƒ½æº/é¢‘è°±/æˆæœ¬æ•ˆç‡ã€æ›´å¥½çš„æ™ºèƒ½å®‰å…¨æ€§å’Œæ›´å¤šæ•ˆç›Šã€‚è¿™äº›ç½‘ç»œé¢ä¸´ç€å·¨å¤§çš„æŒ‘æˆ˜ã€é—®é¢˜å’Œæ‹…å¿§ï¼Œå°†å®ƒä»¬ä¸é«˜åº¦ç§»åŠ¨çš„ç©ºä¸­èŠ‚ç‚¹é›†æˆä¼šå¢åŠ æ›´å¤šçš„å¤æ‚æ€§å’ŒæŠ€æœ¯é—®é¢˜ã€‚ä¸å¾®æ³¢é€šä¿¡ç›¸æ¯”ï¼Œå…·æœ‰å¤šåƒå…†èµ«/å¤ªèµ«å…¹å¸¦å®½å¯ç”¨æ€§çš„æ¯«ç±³æ³¢é€šä¿¡æé«˜äº†ç†Ÿç»ƒç¨‹åº¦å’Œæ•°æ®ä¼ è¾“é€Ÿç‡ã€‚æœ€è¿‘ï¼Œæ— äººæœºæœ‰æœ›æä¾›å¹¿æ³›çš„åº”ç”¨ï¼Œè€Œæ¯«ç±³æ³¢æ®µçš„ä½¿ç”¨éå¸¸æœ‰å¸Œæœ›æ»¡è¶³å¯¹æ•°æ®é€Ÿç‡çš„æ›´é«˜è¦æ±‚ï¼Œä»è€Œå®ç°æ›´å¤§çš„ååé‡ã€‚ç„¶è€Œï¼Œæ¯«ç±³æ³¢å­˜åœ¨ä¼ æ’­ç›¸å…³çš„ä¸è¶³ï¼Œè¿™å¯ä»¥é€šè¿‡æ— äººæœºçš„çµæ´»æ€§æ¥å¼¥è¡¥ã€‚æ¯«ç±³æ³¢ä¿¡å·ä¸­å­˜åœ¨çš„è®¸å¤šå…¶ä»–ç¼ºé™·å¿…é¡»å¾—åˆ°è§£å†³ï¼ŒåŒæ—¶ä¿ç•™å…¶ä¼˜ç‚¹ã€‚ [222]ä¸­è®¨è®ºäº† 5Gã€B5G å’ŒåŸºäºæ¯«ç±³æ³¢çš„æ— äººæœºé€šä¿¡ã€‚å¯¹äºå¯é ã€çµæ´»ã€ç¨³å¥å’Œé¢‘è°±é«˜æ•ˆçš„æ— äººæœºé€šä¿¡è€Œè¨€ï¼Œè¿«åˆ‡éœ€è¦å¯¹æ¯«ç±³æ³¢å’Œ 6G é€šä¿¡è¿›è¡Œè¿›ä¸€æ­¥ç ”ç©¶[223] ã€ [224] ã€‚ 7.22. Intelligence-based algorithms 7.22 åŸºäºæ™ºèƒ½çš„ç®—æ³• Machine learning techniques play a promising role in UAV-based applications as they can deal with uncertain environmental constraints and can be implemented in real time. Machine learning improves UAV network performance by learning from the surrounding environment and past experience. Machine learning can possibly be leveraged to design and optimize UAV-based wireless communication systems [225], [226], [227], [228]. Using RL methods, UAVs can automatically modify their locations, directions, and motion to serve ground nodes. UAVs can adapt to the constraints of dynamic environments by independently optimizing their paths. Furthermore, neural networks and data analysis models can be leveraged to envisage the behavior of ground nodes and efficiently arrange and control UAVs. The mobility of users and load sharing can be achieved for the best distribution and route planning of UAVs. æœºå™¨å­¦ä¹ æŠ€æœ¯åœ¨åŸºäºæ— äººæœºçš„åº”ç”¨ä¸­å‘æŒ¥ç€æœ‰å‰é€”çš„ä½œç”¨ï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥å¤„ç†ä¸ç¡®å®šçš„ç¯å¢ƒçº¦æŸå¹¶ä¸”å¯ä»¥å®æ—¶å®æ–½ã€‚æœºå™¨å­¦ä¹ é€šè¿‡å­¦ä¹ å‘¨å›´ç¯å¢ƒå’Œè¿‡å»çš„ç»éªŒæ¥æé«˜æ— äººæœºç½‘ç»œæ€§èƒ½ã€‚æœºå™¨å­¦ä¹ å¯ä»¥ç”¨æ¥è®¾è®¡å’Œä¼˜åŒ–åŸºäºæ— äººæœºçš„æ— çº¿é€šä¿¡ç³»ç»Ÿ[225] ï¼Œ [226] ï¼Œ [227] ï¼Œ [228] ã€‚ä½¿ç”¨å¼ºåŒ–å­¦ä¹ æ–¹æ³•ï¼Œæ— äººæœºå¯ä»¥è‡ªåŠ¨ä¿®æ”¹å…¶ä½ç½®ã€æ–¹å‘å’Œè¿åŠ¨ä»¥æœåŠ¡åœ°é¢èŠ‚ç‚¹ã€‚æ— äººæœºå¯ä»¥é€šè¿‡ç‹¬ç«‹ä¼˜åŒ–å…¶è·¯å¾„æ¥é€‚åº”åŠ¨æ€ç¯å¢ƒçš„çº¦æŸã€‚æ­¤å¤–ï¼Œå¯ä»¥åˆ©ç”¨ç¥ç»ç½‘ç»œå’Œæ•°æ®åˆ†ææ¨¡å‹æ¥è®¾æƒ³åœ°é¢èŠ‚ç‚¹çš„è¡Œä¸ºå¹¶æœ‰æ•ˆåœ°å®‰æ’å’Œæ§åˆ¶æ— äººæœºã€‚å¯ä»¥å®ç°ç”¨æˆ·çš„ç§»åŠ¨æ€§å’Œè´Ÿè½½åˆ†æ‹…ï¼Œä»¥å®ç°æ— äººæœºçš„æœ€ä½³åˆ†å¸ƒå’Œèˆªçº¿è§„åˆ’ã€‚ 7.23. Lesson learned 7.23 å¸å–çš„æ•™è®­ In this subsection, key lessons learned while surveying on the task assignment algorithms are provided. Multiple UAVs can be used in many applications to enhance the area of coverage, to minimize the cost of operation and maintenance, to do real-time operation, and to meet the network requirements. The task assignment is the significant aspect of multi-UAV based applications. Task allocation in UAVs needs several considerations such as UAV capability, time for task execution, cost of fuel, and risks imposed by the dynamic environment. An efficient task assignment algorithm can assure cooperative and coordinated UAV operation to meet the application requirements. The task assignment is mutually participated, discussed, and contended using multiple UAVs, or each UAV selects task independently in accordance to the observation of environmental constraints. Distributed algorithms emphasizes on achieving efficiency whereas they do not take global considerations into account, which may not result in accurate task assignment. Coordinated algorithms, on the other hand, have a central controller with global information and assign tasks that benefit the overall system. Proper connectivity between UAVs is always required while designing the multi-UAV systems. åœ¨æœ¬å°èŠ‚ä¸­ï¼Œæä¾›äº†åœ¨è°ƒæŸ¥ä»»åŠ¡åˆ†é…ç®—æ³•æ—¶å­¦åˆ°çš„é‡è¦ç»éªŒæ•™è®­ã€‚å¤šæ¶æ— äººæœºå¯ä»¥åœ¨å¤šç§åº”ç”¨ä¸­ä½¿ç”¨ï¼Œä»¥å¢å¼ºè¦†ç›–èŒƒå›´ï¼Œæœ€å¤§é™åº¦åœ°é™ä½è¿ç»´æˆæœ¬ï¼Œåšåˆ°å®æ—¶æ“ä½œï¼Œæ»¡è¶³ç½‘ç»œè¦æ±‚ã€‚ä»»åŠ¡åˆ†é…æ˜¯åŸºäºå¤šæ— äººæœºçš„åº”ç”¨çš„é‡è¦æ–¹é¢ã€‚æ— äººæœºçš„ä»»åŠ¡åˆ†é…éœ€è¦è€ƒè™‘å¤šç§å› ç´ ï¼Œä¾‹å¦‚æ— äººæœºèƒ½åŠ›ã€ä»»åŠ¡æ‰§è¡Œæ—¶é—´ã€ç‡ƒæ–™æˆæœ¬ä»¥åŠåŠ¨æ€ç¯å¢ƒå¸¦æ¥çš„é£é™©ã€‚é«˜æ•ˆçš„ä»»åŠ¡åˆ†é…ç®—æ³•å¯ä»¥ä¿è¯æ— äººæœºååŒä½œä¸šï¼Œæ»¡è¶³åº”ç”¨éœ€æ±‚ã€‚ä»»åŠ¡åˆ†é…é‡‡ç”¨å¤šæ¶æ— äººæœºç›¸äº’å‚ä¸ã€è®¨è®ºã€ç«äº‰ï¼Œæˆ–è€…æ¯æ¶æ— äººæœºæ ¹æ®å¯¹ç¯å¢ƒçº¦æŸçš„è§‚å¯Ÿç‹¬ç«‹é€‰æ‹©ä»»åŠ¡ã€‚åˆ†å¸ƒå¼ç®—æ³•å¼ºè°ƒå®ç°æ•ˆç‡ï¼Œè€Œæ²¡æœ‰è€ƒè™‘å…¨å±€å› ç´ ï¼Œè¿™å¯èƒ½å¯¼è‡´ä»»åŠ¡åˆ†é…ä¸å‡†ç¡®ã€‚å¦ä¸€æ–¹é¢ï¼Œåè°ƒç®—æ³•æœ‰ä¸€ä¸ªå…·æœ‰å…¨å±€ä¿¡æ¯çš„ä¸­å¤®æ§åˆ¶å™¨ï¼Œå¹¶åˆ†é…æœ‰åˆ©äºæ•´ä¸ªç³»ç»Ÿçš„ä»»åŠ¡ã€‚åœ¨è®¾è®¡å¤šæ— äººæœºç³»ç»Ÿæ—¶ï¼Œå§‹ç»ˆéœ€è¦æ— äººæœºä¹‹é—´ä¿æŒé€‚å½“çš„è¿æ¥ã€‚ 8. Conclusion In this article, we have presented a detailed review and discussion of the recent research and development of UAVs in industry as well as academia. UAV fleets are the primary choice for many mission planning systems because of their effectiveness. We have reviewed the prevailing studies on UAV networks and different aspects of UAV communications. Task assignment algorithms play a crucial role in multi-UAV operations for proper cooperation and coordination and need further research. We have extensively surveyed the state-of-the-art task assignment and optimization algorithms for multi-UAV based mission planning systems. We have also reviewed existing algorithms with their advantages, disadvantages, and possible enhancements in the near future. Then, all the task assignment algorithms for UAV networks were classified and compared in terms of their main principles, operational characteristics, and performance metrics. åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å¯¹å·¥ä¸šç•Œå’Œå­¦æœ¯ç•Œæœ€è¿‘çš„æ— äººæœºç ”ç©¶å’Œå‘å±•è¿›è¡Œäº†è¯¦ç»†çš„å›é¡¾å’Œè®¨è®ºã€‚æ— äººæœºæœºé˜Ÿå› å…¶æœ‰æ•ˆæ€§è€Œæˆä¸ºè®¸å¤šä»»åŠ¡è§„åˆ’ç³»ç»Ÿçš„é¦–é€‰ã€‚æˆ‘ä»¬å›é¡¾äº†æœ‰å…³æ— äººæœºç½‘ç»œå’Œæ— äººæœºé€šä¿¡ä¸åŒæ–¹é¢çš„æµè¡Œç ”ç©¶ã€‚ä»»åŠ¡åˆ†é…ç®—æ³•åœ¨å¤šæ— äººæœºæ“ä½œä¸­çš„é€‚å½“åˆä½œå’Œåè°ƒä¸­å‘æŒ¥ç€è‡³å…³é‡è¦çš„ä½œç”¨ï¼Œéœ€è¦è¿›ä¸€æ­¥ç ”ç©¶ã€‚æˆ‘ä»¬å¹¿æ³›ç ”ç©¶äº†åŸºäºå¤šæ— äººæœºçš„ä»»åŠ¡è§„åˆ’ç³»ç»Ÿçš„æœ€å…ˆè¿›çš„ä»»åŠ¡åˆ†é…å’Œä¼˜åŒ–ç®—æ³•ã€‚æˆ‘ä»¬è¿˜å›é¡¾äº†ç°æœ‰ç®—æ³•çš„ä¼˜ç‚¹ã€ç¼ºç‚¹ä»¥åŠåœ¨ä¸ä¹…çš„å°†æ¥å¯èƒ½çš„å¢å¼ºåŠŸèƒ½ã€‚ç„¶åï¼Œå¯¹æ— äººæœºç½‘ç»œçš„æ‰€æœ‰ä»»åŠ¡åˆ†é…ç®—æ³•çš„ä¸»è¦åŸç†ã€è¿è¡Œç‰¹ç‚¹å’Œæ€§èƒ½æŒ‡æ ‡è¿›è¡Œäº†åˆ†ç±»å’Œæ¯”è¾ƒã€‚ This review has exposed the blossoming attention of researchers and engineers towards the harnessing and utilization of the full potential of UAVs. A number of deep RL algorithms have been suggested in the literature for the mitigation of collision, trajectory optimization, etc. Nevertheless, there is significant scope for designing task assignment algorithms for multi-UAV communications. We believe that this review will assist researchers and engineers in conducting further research on task assignment and optimization algorithms. è¿™æ¬¡å®¡æŸ¥æš´éœ²äº†ç ”ç©¶äººå‘˜å’Œå·¥ç¨‹å¸ˆå¯¹å……åˆ†åˆ©ç”¨æ— äººæœºæ½œåŠ›çš„æ—¥ç›Šå…³æ³¨ã€‚æ–‡çŒ®ä¸­å·²ç»æå‡ºäº†è®¸å¤šç”¨äºå‡è½»ç¢°æ’ã€è½¨è¿¹ä¼˜åŒ–ç­‰çš„æ·±åº¦å¼ºåŒ–å­¦ä¹ ç®—æ³•ã€‚å°½ç®¡å¦‚æ­¤ï¼Œä¸ºå¤šæ— äººæœºé€šä¿¡è®¾è®¡ä»»åŠ¡åˆ†é…ç®—æ³•ä»æœ‰å¾ˆå¤§çš„ç©ºé—´ã€‚æˆ‘ä»¬ç›¸ä¿¡è¿™ç¯‡ç»¼è¿°å°†æœ‰åŠ©äºç ”ç©¶äººå‘˜å’Œå·¥ç¨‹å¸ˆå¯¹ä»»åŠ¡åˆ†é…å’Œä¼˜åŒ–ç®—æ³•è¿›è¡Œè¿›ä¸€æ­¥çš„ç ”ç©¶ã€‚ "},"Learn/LearnDrones/TaskAssignment/2022.10-A_Survey_of_UAV_Swarm_Task_Allocation_Based_on_the_Perspective_of_Coalition_Formation.html":{"url":"Learn/LearnDrones/TaskAssignment/2022.10-A_Survey_of_UAV_Swarm_Task_Allocation_Based_on_the_Perspective_of_Coalition_Formation.html","title":"2022.10 A Survey of UAV Swarm Task Allocation Based on the Perspective of Coalition Formation","keywords":"","body":"A Survey of UAV Swarm Task Allocation Based on the Perspective of Coalition Formation åŸºäºè”ç›Ÿç»„å»ºè§†è§’çš„æ— äººæœºé›†ç¾¤ä»»åŠ¡åˆ†é…ç ”ç©¶ç»¼è¿° Husheng Wu, Qiang Peng, Meimei Shi, Lining Xing Source Title: International Journal of Swarm Intelligence Research (IJSIR) 13(1) å›½é™…ç¾¤ä½“æ™ºèƒ½ç ”ç©¶æ‚å¿— IF(1.1) Engineering University of PAP, China Abstract Coalition formation of unmanned aerial vehicle (UAV) swarms, an effective solution for UAV swarm task allocation, is an important technology for UAV swarms to perform real-time and efficient collaborative task allocation in a dynamic and unknown environment. This paper summarizes the task allocation methods of UAV swarm coalition comprehensively and systematically. First, starting with the related work of UAV swarm coalition task allocation, this paper introduces the basic concept, general model, and constraint index of UAV swarm coalition task allocation. Then, the specific content, research status, advantages, and disadvantages of the coalition formation methods are analyzed, respectively. Third, the commonly used solution algorithms and research status of coalition task allocation are introduced, and the advantages and disadvantages of the existing coalition formation solution algorithms are compared and analyzed. Finally, it provides significant guidance for future related research. æ— äººæœºé›†ç¾¤è”ç›Ÿç»„å»ºæ˜¯æ— äººæœºé›†ç¾¤ä»»åŠ¡åˆ†é…çš„æœ‰æ•ˆè§£å†³æ–¹æ¡ˆï¼Œæ˜¯æ— äººæœºé›†ç¾¤åœ¨åŠ¨æ€æœªçŸ¥ç¯å¢ƒä¸­è¿›è¡Œå®æ—¶é«˜æ•ˆååŒä»»åŠ¡åˆ†é…çš„é‡è¦æŠ€æœ¯ã€‚æœ¬æ–‡å…¨é¢ã€ç³»ç»Ÿåœ°æ€»ç»“äº†æ— äººæœºé›†ç¾¤è”ç›Ÿçš„ä»»åŠ¡åˆ†é…æ–¹æ³•ã€‚é¦–å…ˆï¼Œä»æ— äººæœºé›†ç¾¤è”åˆä»»åŠ¡åˆ†é…çš„ç›¸å…³å·¥ä½œå…¥æ‰‹ï¼Œä»‹ç»äº†æ— äººæœºé›†ç¾¤è”åˆä»»åŠ¡åˆ†é…çš„åŸºæœ¬æ¦‚å¿µã€é€šç”¨æ¨¡å‹å’Œçº¦æŸæŒ‡æ ‡ã€‚ç„¶åï¼Œåˆ†åˆ«åˆ†æäº†è”ç›Ÿç»„å»ºæ–¹æ³•çš„å…·ä½“å†…å®¹ã€ç ”ç©¶ç°çŠ¶ã€ä¼˜ç¼ºç‚¹ã€‚å†æ¬¡ï¼Œä»‹ç»äº†å¸¸ç”¨çš„è”ç›Ÿä»»åŠ¡åˆ†é…æ±‚è§£ç®—æ³•å’Œç ”ç©¶ç°çŠ¶ï¼Œå¯¹æ¯”åˆ†æäº†ç°æœ‰è”ç›Ÿç»„å»ºç®—æ³•çš„ä¼˜ç¼ºç‚¹ã€‚æœ€åï¼Œå®ƒä¸ºæœªæ¥çš„ç›¸å…³ç ”ç©¶æä¾›äº†é‡è¦çš„æŒ‡å¯¼ã€‚ Intro Task allocation description of uav swarm coalition (modeling) task description constraint conditions mathematical model Coalition Formation method of uav swarm single task coalition multi-~ comparision Solution method of task allocation for uav swarm coaltion centralized distributed comparision Future Conclusion Introduction With the development of modern information and communication technology and artificial intelligence technology, UAV swarm warfare with autonomous capability has attracted much attention (Qi et al., 2020). UAV swarm task allocation is the premise and guarantee to determine whether the swarm can effectively complete combat tasks. Traditional task allocation methods often abstract task allocation problems into classical combinatorial optimization problems, such as the traveling salesman problem (TSP), the vehicle routing problem (VRP), and the multi-dimensional multi-choice knapsack problem (MMKP). In addition, it is under the assumption that a single UAV in the swarm has the ability to complete tasks independently, and the UAV swarm has the ability to communicate fully. The main problems of traditional task allocation methods are: (a) the heterogeneity of UAVs and the consumption of resources are not taken into account; (b) the algorithms are highly complex, so it is difficult to give real-time allocation results; (c) most of the research is only based on a single UAV performing a single task; and (d) in previous research, the overall battlefield information had to be obtained in advance, making it difficult to realize collaborative task allocation in an unknown environment. When the task is simple, the traditional task allocation method can solve the problem well. However, in the face of the increasingly complex modern battlefield environment, and due to the limited functions played by single UAVs, many combat tasks need to be completed by multiple UAVs in the swarm (Yao et al., 2014). It is difficult to meet the needs of actual tasks by applying the traditional task allocation methods because the actual combat environment continues to change dynamically (Wei et al., 2013). In reality, it is difficult for a single UAV in the UAV swarm to complete dynamic tasks with complex resource requirements independently. They often need multiple UAVs to form a coalition for a collaborative operation to complete tasks more efficiently and quickly. In recent years, coalition formation has become a key issue of UAV swarm task allocation, which has gained extensive attention from researchers. As shown in Figure 1, a coalition is a way to describe the form of cooperation, which means that some UAVs form a coalition to jointly complete tasks in a cooperative manner. Compared with taking a single UAV as the task execution unit in the swarm, the UAV coalition, as a UAV collection, has stronger task execution capability. At the same time, UAVs can be combined flexibly, and appropriate allies can be selected according to the task, to form the most effective coalition to complete the task and obtain the maximum benefits at the least cost. Coalition formation belongs to a special task allocation problem, which is consistent with the requirements of the dynamic and unknown battlefield environment. That is, it can ensure that UAVs can carry out real-time and efficient collaborative task allocation in the dynamic and unknown battlefield environment. The coalition method was proposed by Shehory and Kraus (1996) and has successfully solved the task allocation problem in a multi-agent system (MAS; Rahwan et al., 2009; Zhang et al., 2010; Diao et al., 2014; Shehory and Kraus, 1998; Sarkar et al., 2022) and multi-robot system (MRS; Vig & Adams, 2006; Ahmadoun et al., 2021; Mazdin & Rinner, 2021). Since Sujit et al. (2008) first introduced the concept of the coalition into the multi-UAV system, the coalition formation method has become one of the hot methods to solve the UAV swarm task allocation problem (Wu et al., 2018; Luan et al., 2020; Ruan et al., 2021; Fei et al., 2022). Coalition formation (Sandholm et al., 1999; Shen et al., 2006; Xing et al., 2019) could effectively and quickly organize UAVs in the swarm to form a task coalition so that the swarm can flexibly and efficiently complete tasks, avoid task deadlock and resource waste, give full play to the advantages of the system, reduce task costs, and improve work efficiency. Therefore, the formation of UAVs as an operational coalition to execute combat tasks is essentially a mixed problem of sequence determination and task allocation for task execution. However, as the number of UAVs increases, the number of eligible UAV coalition will increase exponentially, so solving the coalition with maximum interests is a dynamic NP-hard (Sandhlom & Lesser, 1997). To solve this problem, researchers have achieved a series of research results around coalition structure (Voice et al., 2012; Zick et al., 2014), coalition clustering (Kashef & Kamel, 2010), solving algorithm (Macarthur et al., 2011), and formed a certain theoretical and technical foundation. éšç€ç°ä»£ä¿¡æ¯é€šä¿¡æŠ€æœ¯å’Œäººå·¥æ™ºèƒ½æŠ€æœ¯çš„å‘å±•ï¼Œå…·å¤‡è‡ªä¸»èƒ½åŠ›çš„æ— äººæœºé›†ç¾¤ä½œæˆ˜å¤‡å—å…³æ³¨ï¼ˆQi ç­‰ï¼Œ2020ï¼‰ã€‚æ— äººæœºé›†ç¾¤ä»»åŠ¡åˆ†é…æ˜¯å†³å®šé›†ç¾¤èƒ½å¦æœ‰æ•ˆå®Œæˆä½œæˆ˜ä»»åŠ¡çš„å‰æå’Œä¿éšœã€‚ä¼ ç»Ÿçš„ä»»åŠ¡åˆ†é…æ–¹æ³•é€šå¸¸å°†ä»»åŠ¡åˆ†é…é—®é¢˜æŠ½è±¡ä¸ºç»å…¸çš„ç»„åˆä¼˜åŒ–é—®é¢˜ï¼Œä¾‹å¦‚æ—…è¡Œå•†é—®é¢˜ï¼ˆTSPï¼‰ã€è½¦è¾†è·¯å¾„é—®é¢˜ï¼ˆVRPï¼‰ä»¥åŠå¤šç»´å¤šé€‰æ‹©èƒŒåŒ…é—®é¢˜ï¼ˆMMKPï¼‰ã€‚æ­¤å¤–ï¼Œè¿™äº›æ–¹æ³•åŸºäºä»¥ä¸‹å‡è®¾ï¼šé›†ç¾¤ä¸­çš„å•ä¸ªæ— äººæœºå…·å¤‡ç‹¬ç«‹å®Œæˆä»»åŠ¡çš„èƒ½åŠ›ï¼Œä¸”æ— äººæœºé›†ç¾¤å…·å¤‡å®Œå…¨é€šä¿¡èƒ½åŠ›ã€‚ ä¼ ç»Ÿä»»åŠ¡åˆ†é…æ–¹æ³•çš„ä¸»è¦é—®é¢˜åœ¨äºï¼š ï¼ˆaï¼‰æœªè€ƒè™‘æ— äººæœºçš„å¼‚æ„æ€§åŠèµ„æºæ¶ˆè€—ï¼› ï¼ˆbï¼‰ç®—æ³•å¤æ‚åº¦é«˜ï¼Œéš¾ä»¥å®æ—¶ç”Ÿæˆåˆ†é…ç»“æœï¼› ï¼ˆcï¼‰å¤§å¤šæ•°ç ”ç©¶ä»…åŸºäºå•ä¸ªæ— äººæœºæ‰§è¡Œå•ä¸€ä»»åŠ¡ï¼› ï¼ˆdï¼‰ä»¥å¾€ç ”ç©¶éœ€è¦é¢„å…ˆè·å–æ•´ä½“æˆ˜åœºä¿¡æ¯ï¼Œéš¾ä»¥åœ¨æœªçŸ¥ç¯å¢ƒä¸­å®ç°ååŒä»»åŠ¡åˆ†é…ã€‚ å½“ä»»åŠ¡è¾ƒä¸ºç®€å•æ—¶ï¼Œä¼ ç»Ÿä»»åŠ¡åˆ†é…æ–¹æ³•èƒ½å¤Ÿè¾ƒå¥½åœ°è§£å†³é—®é¢˜ã€‚ç„¶è€Œï¼Œé¢å¯¹æ—¥ç›Šå¤æ‚çš„ç°ä»£æˆ˜åœºç¯å¢ƒï¼Œç”±äºå•ä¸ªæ— äººæœºçš„åŠŸèƒ½æœ‰é™ï¼Œè®¸å¤šä½œæˆ˜ä»»åŠ¡éœ€è¦é›†ç¾¤ä¸­çš„å¤šä¸ªæ— äººæœºååŒå®Œæˆï¼ˆYao ç­‰ï¼Œ2014ï¼‰ã€‚ç”±äºå®é™…ä½œæˆ˜ç¯å¢ƒåŠ¨æ€å˜åŒ–ï¼Œä¼ ç»Ÿä»»åŠ¡åˆ†é…æ–¹æ³•éš¾ä»¥æ»¡è¶³å®é™…ä»»åŠ¡éœ€æ±‚ï¼ˆWei ç­‰ï¼Œ2013ï¼‰ã€‚ åœ¨ç°å®ä¸­ï¼Œæ— äººæœºé›†ç¾¤ä¸­çš„å•ä¸ªæ— äººæœºéš¾ä»¥ç‹¬ç«‹å®Œæˆèµ„æºéœ€æ±‚å¤æ‚çš„åŠ¨æ€ä»»åŠ¡ã€‚é€šå¸¸éœ€è¦å¤šä¸ªæ— äººæœºç»„æˆè”ç›Ÿï¼Œé€šè¿‡ååŒæ“ä½œæ¥æ›´é«˜æ•ˆã€æ›´å¿«é€Ÿåœ°å®Œæˆä»»åŠ¡ã€‚è¿‘å¹´æ¥ï¼Œè”ç›Ÿå½¢æˆå·²æˆä¸ºæ— äººæœºé›†ç¾¤ä»»åŠ¡åˆ†é…çš„å…³é”®é—®é¢˜ï¼Œå—åˆ°ç ”ç©¶è€…çš„å¹¿æ³›å…³æ³¨ã€‚å¦‚å›¾ 1 æ‰€ç¤ºï¼Œè”ç›Ÿæ˜¯æè¿°åˆä½œå½¢å¼çš„ä¸€ç§æ–¹å¼ï¼Œå³éƒ¨åˆ†æ— äººæœºç»„æˆè”ç›Ÿï¼Œä»¥åä½œæ–¹å¼å…±åŒå®Œæˆä»»åŠ¡ã€‚ä¸å°†å•ä¸ªæ— äººæœºä½œä¸ºé›†ç¾¤ä¸­çš„ä»»åŠ¡æ‰§è¡Œå•å…ƒç›¸æ¯”ï¼Œæ— äººæœºè”ç›Ÿä½œä¸ºä¸€ä¸ªæ— äººæœºé›†åˆä½“ï¼Œå…·å¤‡æ›´å¼ºçš„ä»»åŠ¡æ‰§è¡Œèƒ½åŠ›ã€‚åŒæ—¶ï¼Œæ— äººæœºå¯ä»¥çµæ´»ç»„åˆï¼Œæ ¹æ®ä»»åŠ¡éœ€æ±‚é€‰æ‹©åˆé€‚çš„ç›Ÿå‹ï¼Œå½¢æˆæœ€æœ‰æ•ˆçš„è”ç›Ÿä»¥å®Œæˆä»»åŠ¡ï¼Œå¹¶ä»¥æœ€å°æˆæœ¬è·å¾—æœ€å¤§æ”¶ç›Šã€‚è”ç›Ÿå½¢æˆå±äºä¸€ç§ç‰¹æ®Šçš„ä»»åŠ¡åˆ†é…é—®é¢˜ï¼Œç¬¦åˆåŠ¨æ€å’ŒæœªçŸ¥æˆ˜åœºç¯å¢ƒçš„éœ€æ±‚ï¼Œå³èƒ½å¤Ÿç¡®ä¿æ— äººæœºåœ¨åŠ¨æ€å’ŒæœªçŸ¥çš„æˆ˜åœºç¯å¢ƒä¸­è¿›è¡Œå®æ—¶é«˜æ•ˆçš„ååŒä»»åŠ¡åˆ†é…ã€‚ è”ç›Ÿæ–¹æ³•ç”± Shehory å’Œ Krausï¼ˆ1996ï¼‰æå‡ºï¼Œå¹¶æˆåŠŸè§£å†³äº†å¤šæ™ºèƒ½ä½“ç³»ç»Ÿï¼ˆMASï¼›Rahwan ç­‰ï¼Œ2009ï¼›Zhang ç­‰ï¼Œ2010ï¼›Diao ç­‰ï¼Œ2014ï¼›Shehory å’Œ Krausï¼Œ1998ï¼›Sarkar ç­‰ï¼Œ2022ï¼‰å’Œå¤šæœºå™¨äººç³»ç»Ÿï¼ˆMRSï¼›Vig & Adamsï¼Œ2006ï¼›Ahmadoun ç­‰ï¼Œ2021ï¼›Mazdin & Rinnerï¼Œ2021ï¼‰ä¸­çš„ä»»åŠ¡åˆ†é…é—®é¢˜ã€‚ è‡ª Sujit ç­‰ï¼ˆ2008ï¼‰é¦–æ¬¡å°†è”ç›Ÿæ¦‚å¿µå¼•å…¥å¤šæ— äººæœºç³»ç»Ÿä»¥æ¥ï¼Œè”ç›Ÿå½¢æˆæ–¹æ³•å·²æˆä¸ºè§£å†³æ— äººæœºé›†ç¾¤ä»»åŠ¡åˆ†é…é—®é¢˜çš„çƒ­é—¨æ–¹æ³•ä¹‹ä¸€ï¼ˆWu ç­‰ï¼Œ2018ï¼›Luan ç­‰ï¼Œ2020ï¼›Ruan ç­‰ï¼Œ2021ï¼›Fei ç­‰ï¼Œ2022ï¼‰ã€‚ è”ç›Ÿå½¢æˆï¼ˆSandholm ç­‰ï¼Œ1999ï¼›Shen ç­‰ï¼Œ2006ï¼›Xing ç­‰ï¼Œ2019ï¼‰èƒ½å¤Ÿæœ‰æ•ˆä¸”å¿«é€Ÿåœ°ç»„ç»‡é›†ç¾¤ä¸­çš„æ— äººæœºå½¢æˆä»»åŠ¡è”ç›Ÿï¼Œä½¿é›†ç¾¤èƒ½å¤Ÿçµæ´»é«˜æ•ˆåœ°å®Œæˆä»»åŠ¡ï¼Œé¿å…ä»»åŠ¡æ­»é”å’Œèµ„æºæµªè´¹ï¼Œå……åˆ†å‘æŒ¥ç³»ç»Ÿä¼˜åŠ¿ï¼Œé™ä½ä»»åŠ¡æˆæœ¬ï¼Œæé«˜å·¥ä½œæ•ˆç‡ã€‚å› æ­¤ï¼Œå°†æ— äººæœºç»„æˆä½œæˆ˜è”ç›Ÿä»¥æ‰§è¡Œæˆ˜æ–—ä»»åŠ¡ï¼Œæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªä»»åŠ¡æ‰§è¡Œçš„åºåˆ—ç¡®å®šä¸ä»»åŠ¡åˆ†é…çš„æ··åˆé—®é¢˜ã€‚ç„¶è€Œï¼Œéšç€æ— äººæœºæ•°é‡çš„å¢åŠ ï¼Œç¬¦åˆæ¡ä»¶çš„æ— äººæœºè”ç›Ÿæ•°é‡å°†å‘ˆæŒ‡æ•°çº§å¢é•¿ï¼Œå› æ­¤æ±‚è§£å…·æœ‰æœ€å¤§åˆ©ç›Šçš„è”ç›Ÿæ˜¯ä¸€ä¸ªåŠ¨æ€çš„ NP éš¾é—®é¢˜ï¼ˆSandhlom & Lesserï¼Œ1997ï¼‰ã€‚ä¸ºè§£å†³è¿™ä¸€é—®é¢˜ï¼Œç ”ç©¶è€…å›´ç»•è”ç›Ÿç»“æ„ï¼ˆVoice ç­‰ï¼Œ2012ï¼›Zick ç­‰ï¼Œ2014ï¼‰ã€è”ç›Ÿèšç±»ï¼ˆKashef & Kamelï¼Œ2010ï¼‰å’Œæ±‚è§£ç®—æ³•ï¼ˆMacarthur ç­‰ï¼Œ2011ï¼‰å–å¾—äº†ä¸€ç³»åˆ—ç ”ç©¶æˆæœï¼Œå¹¶å½¢æˆäº†ä¸€å®šçš„ç†è®ºå’ŒæŠ€æœ¯åŸºç¡€ã€‚ Task allocation description of uav swarm coalition 2.1 Task description Heterogeneous UAV swarms mainly perform tasks on a large number of known and unknown targets in the task environment. Considering that performing tasks on the target needs to meet the resource constraints of the target, the resources carried by a single UAV are limited and may not be able to meet the requirements. For known targets, heterogeneous UAV swarms can directly select tasks and form UAV coalitions to execute them; for unknown targets, the UAV swarm continuously discovers new targets and triggers task allocation for the new targets until the UAV swarm completes all tasks within the task area. As shown in Figure 2, the basic process of task allocation of a UAV swarm coalition mainly includes five basic steps: task selection, coalition formation, task execution, task completion, and coalition dissolution. The task allocation problem of a heterogeneous UAV swarm coalition can be represented by the six-tuple âŸ¨ U , M , T , E , C , O âŸ©, where U is the set of UAVs in the swarm; M refers to the collection of targets in the mission area, including enemy positions, vehicles, and equipment; T is the task type set contained by each target, including reconnaissance task, and attack task; E refers to the mission environment, such as environmental threat, and no-fly zone; C is the set of constraints related to the task execution of heterogeneous swarm; and O is the overall goal of UAV swarm to complete tasks, such as the shortest time and the lowest track cost. å¼‚æ„æ— äººæœºé›†ç¾¤ä¸»è¦åœ¨ä»»åŠ¡ç¯å¢ƒä¸­å¯¹å¤§é‡å·²çŸ¥å’ŒæœªçŸ¥ç›®æ ‡æ‰§è¡Œä»»åŠ¡ã€‚è€ƒè™‘åˆ°å¯¹ç›®æ ‡æ‰§è¡Œä»»åŠ¡éœ€è¦æ»¡è¶³ç›®æ ‡çš„èµ„æºçº¦æŸï¼Œè€Œå•ä¸ªæ— äººæœºæºå¸¦çš„èµ„æºæœ‰é™ï¼Œå¯èƒ½æ— æ³•æ»¡è¶³éœ€æ±‚ã€‚å¯¹äºå·²çŸ¥ç›®æ ‡ï¼Œå¼‚æ„æ— äººæœºé›†ç¾¤å¯ä»¥ç›´æ¥é€‰æ‹©ä»»åŠ¡å¹¶å½¢æˆæ— äººæœºè”ç›Ÿæ¥æ‰§è¡Œï¼›å¯¹äºæœªçŸ¥ç›®æ ‡ï¼Œæ— äººæœºé›†ç¾¤ä¼šä¸æ–­å‘ç°æ–°ç›®æ ‡å¹¶è§¦å‘å¯¹æ–°ç›®æ ‡çš„ä»»åŠ¡åˆ†é…ï¼Œç›´åˆ°æ— äººæœºé›†ç¾¤å®Œæˆä»»åŠ¡åŒºåŸŸå†…çš„æ‰€æœ‰ä»»åŠ¡ã€‚ å¦‚å›¾ 2 æ‰€ç¤ºï¼Œæ— äººæœºé›†ç¾¤è”ç›Ÿä»»åŠ¡åˆ†é…çš„åŸºæœ¬æµç¨‹ä¸»è¦åŒ…æ‹¬äº”ä¸ªåŸºæœ¬æ­¥éª¤ï¼šä»»åŠ¡é€‰æ‹©ã€è”ç›Ÿå½¢æˆã€ä»»åŠ¡æ‰§è¡Œã€ä»»åŠ¡å®Œæˆå’Œè”ç›Ÿè§£æ•£ã€‚ å¼‚æ„æ— äººæœºé›†ç¾¤è”ç›Ÿçš„ä»»åŠ¡åˆ†é…é—®é¢˜å¯ä»¥ç”¨å…­å…ƒç»„ $âŸ¨ U , M , T , E , C , O âŸ©$ è¡¨ç¤ºï¼Œå…¶ä¸­ U æ˜¯é›†ç¾¤ä¸­æ— äººæœºçš„é›†åˆï¼› M æŒ‡ä»»åŠ¡åŒºåŸŸå†…ç›®æ ‡çš„é›†åˆï¼ŒåŒ…æ‹¬æ•Œæ–¹ä½ç½®ã€è½¦è¾†å’Œè£…å¤‡ï¼› T æ˜¯æ¯ä¸ªç›®æ ‡åŒ…å«çš„ä»»åŠ¡ç±»å‹é›†åˆï¼ŒåŒ…æ‹¬ä¾¦å¯Ÿä»»åŠ¡å’Œæ”»å‡»ä»»åŠ¡ï¼› E æŒ‡ä»»åŠ¡ç¯å¢ƒï¼Œä¾‹å¦‚ç¯å¢ƒå¨èƒå’Œç¦é£åŒºï¼› C æ˜¯ä¸å¼‚æ„é›†ç¾¤ä»»åŠ¡æ‰§è¡Œç›¸å…³çš„çº¦æŸé›†åˆï¼› O æ˜¯æ— äººæœºé›†ç¾¤å®Œæˆä»»åŠ¡çš„æ€»ä½“ç›®æ ‡ï¼Œä¾‹å¦‚æœ€çŸ­æ—¶é—´å’Œæœ€ä½è½¨è¿¹æˆæœ¬ã€‚ Figure 2. Basic process of UAV swarm coalition task allocation 2.2 Constraint Conditions When forming a coalition for UAV swarms, one should not only consider constraint conditions such as resource allocation balance, task dynamics, UAV communication range, and communication delay within the swarm but also pay attention to various types of constraints such as UAV kinematics constraints, target resource constraints, UAV arrival time constraints, and UAV collision avoidance constraints. Generally, the formed coalition needs to meet the following constraints and conditions: In order to improve the efficiency of task completion, it is required to complete tasks in the shortest time. In order to ensure the rapid completion of tasks and the success rate of completion, all coalition members are required to perform tasks at the same time. In order to improve the utilization of UAV resources and the number of tasks completed within unit time, the size of the coalition is required to be the smallest. If the size of the coalition is minimized each time, more UAV coalitions can be formed. In order to ensure that the task can be completed, the total resources owned by all coalition members in the coalition are required to meet the resource requirements of the task. 2.3 Mathematical Model It is assumed that there are $N{M}$ targets, and each target has $N{T}$ tasks and a UAV swarm composed of $N_{U}$ UAVs. The task allocation problem of heterogeneous UAV swarm coalition can be generally described as: In the task environment, under the requirements of meeting all constraints, seek a scheme for the formation of a UAV swarm coalition, to complete the current task to the greatest extent and optimize the overall objectives of task allocation, such as cost and benefit. Then the general mathematical model (Whitten, 2010; Butler & Hays, 2015) of the task allocation problem of heterogeneous UAV swarm coalition can be expressed as follows: maxâ¡âˆ‘i=1NUâˆ‘j=1NMâˆ‘k=1NTxijkâ‹…rijk \\max \\sum_{i=1}^{N_{U}} \\sum_{j=1}^{N_{M}} \\sum_{k=1}^{N_{T}} x_{i j}^{k} \\cdot r_{i j}^{k} maxi=1âˆ‘NUâ€‹â€‹j=1âˆ‘NMâ€‹â€‹k=1âˆ‘NTâ€‹â€‹xijkâ€‹â‹…rijkâ€‹ s.t.{xijkâˆˆ{0,1}C(xijk)â‰¥0 s.t. \\left\\{\\begin{array}{l}x_{i j}^{k} \\in\\{0,1\\} \\\\ C\\left(x_{i j}^{k}\\right) \\geq 0\\end{array}\\right. s.t.{xijkâ€‹âˆˆ{0,1}C(xijkâ€‹)â‰¥0â€‹ where $r{ij}$ k is the benefit of $UAV{i}$ ( $i = 1, 2, . . ., N{U}$ ) performing the k th ( $k = 1, 2, . . ., N{T}$ ) task of target j ( $j = 1, 2, . . ., N{M}$ ); $x{ij}$ k is the task allocation decision variable $x{ij}^k âˆˆ { 1 0 }$ , ; $x{ij}^k = 1$ indicates that $UAV{i}$ executes the $k$ th task of target j-otherwise, $x{ij}^ k = 0$ - and $C Â· ( )$ is the relevant constraint. It should be noted that this formula represents a general model of task allocation for UAV swarm coalitions. In the specific task allocation process, the model needs to be modified and refined according to the specific task background and actual task environment so as to meet the actual requirements of the tasks. Coalition Formation method of uav swarm UAV swarms form coalitions to perform tasks that cannot be accomplished by a single UAV, effectively improving the success rate and efficiency of task execution. The difference way of forming the coalition directly affects the efficiency of the UAV swarm in completing the task. Therefore, since coalition formation was used for UAV swarm task allocation, domestic and foreign scholars have carried out a lot of research and achieved fruitful results. Coalitions can be divided into different types based on different perspectives. From the perspective of coalition generation, it can be divided into serial coalition and parallel coalition. From the perspective of coalition structure, it can be divided into simple coalitions and complex coalitions. From the perspective of the number of tasks performed by the same coalition, it can be divided into single-task coalitions and multi-task coalitions. This section reviews the coalition formation methods regarding two aspects: the single-task coalition and multi-task coalition. æ— äººæœºé›†ç¾¤é€šè¿‡å½¢æˆè”ç›Ÿæ¥æ‰§è¡Œå•ä¸ªæ— äººæœºæ— æ³•å®Œæˆçš„ä»»åŠ¡ï¼Œä»è€Œæœ‰æ•ˆæé«˜ä»»åŠ¡æ‰§è¡Œçš„æˆåŠŸç‡å’Œæ•ˆç‡ã€‚è”ç›Ÿå½¢æˆçš„æ–¹å¼ç›´æ¥å½±å“æ— äººæœºé›†ç¾¤å®Œæˆä»»åŠ¡çš„æ•ˆç‡ã€‚å› æ­¤ï¼Œè‡ªè”ç›Ÿå½¢æˆæ–¹æ³•è¢«ç”¨äºæ— äººæœºé›†ç¾¤ä»»åŠ¡åˆ†é…ä»¥æ¥ï¼Œå›½å†…å¤–å­¦è€…å¼€å±•äº†å¤§é‡ç ”ç©¶å¹¶å–å¾—äº†ä¸°ç¡•æˆæœã€‚æ ¹æ®ä¸åŒçš„è§†è§’ï¼Œè”ç›Ÿå¯ä»¥åˆ†ä¸ºå¤šç§ç±»å‹ã€‚ä»è”ç›Ÿç”Ÿæˆçš„è§’åº¦ï¼Œå¯ä»¥åˆ†ä¸ºä¸²è¡Œè”ç›Ÿå’Œå¹¶è¡Œè”ç›Ÿï¼›ä»è”ç›Ÿç»“æ„çš„è§’åº¦ï¼Œå¯ä»¥åˆ†ä¸ºç®€å•è”ç›Ÿå’Œå¤æ‚è”ç›Ÿï¼›ä»åŒä¸€è”ç›Ÿæ‰§è¡Œä»»åŠ¡æ•°é‡çš„è§’åº¦ï¼Œå¯ä»¥åˆ†ä¸ºå•ä»»åŠ¡è”ç›Ÿå’Œå¤šä»»åŠ¡è”ç›Ÿã€‚æœ¬èŠ‚å°†ä»å•ä»»åŠ¡è”ç›Ÿå’Œå¤šä»»åŠ¡è”ç›Ÿä¸¤ä¸ªæ–¹é¢å¯¹è”ç›Ÿå½¢æˆæ–¹æ³•è¿›è¡Œç»¼è¿°ã€‚ Figure 3. Schematic diagram of UAV swarm coalition 3.1 Single-Task Coalition As shown in Figure 3(a), in a task environment, a coalition that only undertakes one task is called a single-task coalition. \"Specific task - Specific coalition\" is the main form of single-task coalition. The formation of a single-task coalition is to find a UAV coalition that can complete a certain task and has the best coalition result in a UAV swarm. The formation methods of single-task coalition mainly include serial coalition formation method and parallel coalition formation method. å¦‚å›¾ 3(a)æ‰€ç¤ºï¼Œåœ¨ä»»åŠ¡ç¯å¢ƒä¸­ï¼Œä»…æ‰¿æ‹…ä¸€ä¸ªä»»åŠ¡çš„è”ç›Ÿç§°ä¸ºå•ä»»åŠ¡è”ç›Ÿã€‚â€œç‰¹å®šä»»åŠ¡-ç‰¹å®šè”ç›Ÿâ€æ˜¯å•ä»»åŠ¡è”ç›Ÿçš„ä¸»è¦å½¢å¼ã€‚å•ä»»åŠ¡è”ç›Ÿçš„å½¢æˆæ˜¯åœ¨æ— äººæœºé›†ç¾¤ä¸­å¯»æ‰¾èƒ½å¤Ÿå®ŒæˆæŸä¸€ä»»åŠ¡ä¸”å…·æœ‰æœ€ä½³è”ç›Ÿç»“æœçš„æ— äººæœºè”ç›Ÿã€‚å•ä»»åŠ¡è”ç›Ÿçš„å½¢æˆæ–¹æ³•ä¸»è¦åŒ…æ‹¬ä¸²è¡Œè”ç›Ÿå½¢æˆæ–¹æ³•å’Œå¹¶è¡Œè”ç›Ÿå½¢æˆæ–¹æ³•ã€‚ 3.1.1 Serial Coalition Formation Method The serial coalition formation method refers to finding the UAV coalition with the largest global benefit for each current task in turn in the task environment. The main process of the method is as follows: The UAV swarm first determines the task priority according to the relevant requirements of the task execution and then selects the global optimal UAV for the task with the highest current priority in the task priority sequence in turn. As shown in Figure 4, when the UAV carries insufficient resources to complete the strike task of the target alone, the UAV becomes the initiator of coalition formation and broadcasts the specific information of the discovered target to other UAVs in the swarm (Wang et al., 2005). Then, other UAVs respond to the coalition initiator according to their own resources. The initiator of the coalition integrates all the feedback information, weighs the overall interests, and forms the current global optimal coalition to respond to the task. After the current task is completed, the UAV coalition will be dissolved, and coalition members can continue to participate in other tasks. This method is simple and widely used, but it has the following problems: First, the determination of task priority is greatly influenced by subjective factors, and the distribution results are random. Second, each task is solved in turn, which requires high computing power in the system. Third, the evolution of the coalition is not considered. Whenever new tasks are added to the task set, they need to be re-aligned according to the formation method, which will inevitably have a lot of computing and communication overhead, resulting in a great waste of computing resources. ä¸²è¡Œè”ç›Ÿå½¢æˆæ–¹æ³•æ˜¯æŒ‡åœ¨ä»»åŠ¡ç¯å¢ƒä¸­ä¾æ¬¡ä¸ºæ¯ä¸ªå½“å‰ä»»åŠ¡å¯»æ‰¾å…·æœ‰æœ€å¤§å…¨å±€æ”¶ç›Šçš„æ— äººæœºè”ç›Ÿã€‚è¯¥æ–¹æ³•çš„ä¸»è¦æµç¨‹å¦‚ä¸‹ï¼š æ— äººæœºé›†ç¾¤é¦–å…ˆæ ¹æ®ä»»åŠ¡æ‰§è¡Œçš„ç›¸å…³è¦æ±‚ç¡®å®šä»»åŠ¡ä¼˜å…ˆçº§ï¼Œç„¶åä¾æ¬¡åœ¨ä»»åŠ¡ä¼˜å…ˆçº§åºåˆ—ä¸­ä¸ºå½“å‰ä¼˜å…ˆçº§æœ€é«˜çš„ä»»åŠ¡é€‰æ‹©å…¨å±€æœ€ä¼˜çš„æ— äººæœºã€‚ å¦‚å›¾ 4 æ‰€ç¤ºï¼Œå½“æ— äººæœºæºå¸¦çš„èµ„æºä¸è¶³ä»¥å•ç‹¬å®Œæˆç›®æ ‡çš„æ‰“å‡»ä»»åŠ¡æ—¶ï¼Œè¯¥æ— äººæœºæˆä¸ºè”ç›Ÿå½¢æˆçš„å‘èµ·è€…ï¼Œå¹¶å‘é›†ç¾¤ä¸­çš„å…¶ä»–æ— äººæœºå¹¿æ’­æ‰€å‘ç°ç›®æ ‡çš„å…·ä½“ä¿¡æ¯ï¼ˆWang ç­‰ï¼Œ2005ï¼‰ã€‚ éšåï¼Œå…¶ä»–æ— äººæœºæ ¹æ®è‡ªèº«èµ„æºå¯¹è”ç›Ÿå‘èµ·è€…ä½œå‡ºå“åº”ã€‚è”ç›Ÿå‘èµ·è€…æ•´åˆæ‰€æœ‰åé¦ˆä¿¡æ¯ï¼Œæƒè¡¡æ•´ä½“åˆ©ç›Šï¼Œå½¢æˆå½“å‰å…¨å±€æœ€ä¼˜è”ç›Ÿä»¥å“åº”ä»»åŠ¡ã€‚ å½“å‰ä»»åŠ¡å®Œæˆåï¼Œæ— äººæœºè”ç›Ÿå°†è§£æ•£ï¼Œè”ç›Ÿæˆå‘˜å¯ä»¥ç»§ç»­å‚ä¸å…¶ä»–ä»»åŠ¡ã€‚ è¯¥æ–¹æ³•ç®€å•ä¸”åº”ç”¨å¹¿æ³›ï¼Œä½†å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š é¦–å…ˆï¼Œä»»åŠ¡ä¼˜å…ˆçº§çš„ç¡®å®šå—ä¸»è§‚å› ç´ å½±å“è¾ƒå¤§ï¼Œåˆ†é…ç»“æœå…·æœ‰éšæœºæ€§ï¼› å…¶æ¬¡ï¼Œæ¯ä¸ªä»»åŠ¡ä¾æ¬¡æ±‚è§£ï¼Œå¯¹ç³»ç»Ÿè®¡ç®—èƒ½åŠ›è¦æ±‚è¾ƒé«˜ï¼› ç¬¬ä¸‰ï¼Œæœªè€ƒè™‘è”ç›Ÿçš„æ¼”åŒ–ã€‚æ¯å½“ä»»åŠ¡é›†ä¸­æ–°å¢ä»»åŠ¡æ—¶ï¼Œéƒ½éœ€è¦æŒ‰ç…§å½¢æˆæ–¹æ³•é‡æ–°æ’åˆ—ï¼Œè¿™å¿…ç„¶ä¼šäº§ç”Ÿå¤§é‡çš„è®¡ç®—å’Œé€šä¿¡å¼€é”€ï¼Œå¯¼è‡´è®¡ç®—èµ„æºçš„æå¤§æµªè´¹ã€‚ Figure 4. Schematic diagram of the serial formation method of single-task coalition In order to avoid coalition deadlock and resource waste, Wang et al. (2005) proposed a coalition formation strategy based on an improved task matching calculation method. When dealing with the current task, this method can selectively learn from the historical experience of the system and give full play to its learning ability. It can effectively reduce the search time and computation of the coalition generation and has good realizability. Han and Yao (2018) decomposed all tasks into different types of sub-tasks and built a manned-UAV swarm holon coalition (SHC) formation model according to UAV combat capabilities and sub-task resource requirements. The model can effectively solve the problem of SHC formation, but it does not consider the execution time and execution situation of the task, and the execution of the task is difficult to continue in case of emergencies. Lin et al. (2013) put forward an online task allocation problem model based on an idle time window, which considered the time constraints and efficiency requirements of multi-UAV task allocation problem, and effectively solved the real-time and effectiveness of solving the multi-UAV task allocation problem. Liu et al. (2015) designed a coalition formation method for heterogeneous multi-UAV cooperative search and strike in an unknown environment, minimizing target strike time, minimizing coalition size as optimization indicators, and satisfying simultaneous strike and resource requirements as constraints. This method has high real-time performance and can be well adopted in unknown environments. ä¸ºäº†é¿å…è”ç›Ÿæ­»é”å’Œèµ„æºæµªè´¹ï¼ŒWang ç­‰äººï¼ˆ2005ï¼‰æå‡ºäº†ä¸€ç§åŸºäºæ”¹è¿›ä»»åŠ¡åŒ¹é…è®¡ç®—æ–¹æ³•çš„è”ç›Ÿå½¢æˆç­–ç•¥ã€‚è¯¥æ–¹æ³•åœ¨å¤„ç†å½“å‰ä»»åŠ¡æ—¶ï¼Œèƒ½å¤Ÿæœ‰é€‰æ‹©åœ°å€Ÿé‰´ç³»ç»Ÿçš„å†å²ç»éªŒï¼Œå……åˆ†å‘æŒ¥å…¶å­¦ä¹ èƒ½åŠ›ï¼Œä»è€Œæœ‰æ•ˆå‡å°‘è”ç›Ÿç”Ÿæˆçš„æœç´¢æ—¶é—´å’Œè®¡ç®—é‡ï¼Œå¹¶å…·æœ‰è‰¯å¥½çš„å¯å®ç°æ€§ã€‚ Han å’Œ Yaoï¼ˆ2018ï¼‰å°†æ‰€æœ‰ä»»åŠ¡åˆ†è§£ä¸ºä¸åŒç±»å‹çš„å­ä»»åŠ¡ï¼Œå¹¶æ ¹æ®æ— äººæœºçš„ä½œæˆ˜èƒ½åŠ›å’Œå­ä»»åŠ¡çš„èµ„æºéœ€æ±‚ï¼Œæ„å»ºäº†æœ‰äºº-æ— äººæœºé›†ç¾¤å…¨æ¯è”ç›Ÿï¼ˆSHCï¼‰å½¢æˆæ¨¡å‹ã€‚è¯¥æ¨¡å‹èƒ½å¤Ÿæœ‰æ•ˆè§£å†³ SHC å½¢æˆé—®é¢˜ï¼Œä½†æœªè€ƒè™‘ä»»åŠ¡çš„æ‰§è¡Œæ—¶é—´å’Œæ‰§è¡Œæƒ…å†µï¼Œåœ¨çªå‘æƒ…å†µä¸‹ä»»åŠ¡çš„æ‰§è¡Œéš¾ä»¥æŒç»­ã€‚ Lin ç­‰äººï¼ˆ2013ï¼‰æå‡ºäº†ä¸€ç§åŸºäºç©ºé—²æ—¶é—´çª—å£çš„åœ¨çº¿ä»»åŠ¡åˆ†é…é—®é¢˜æ¨¡å‹ï¼Œè¯¥æ¨¡å‹è€ƒè™‘äº†å¤šæ— äººæœºä»»åŠ¡åˆ†é…é—®é¢˜çš„æ—¶é—´çº¦æŸå’Œæ•ˆç‡è¦æ±‚ï¼Œæœ‰æ•ˆè§£å†³äº†å¤šæ— äººæœºä»»åŠ¡åˆ†é…é—®é¢˜çš„å®æ—¶æ€§å’Œæœ‰æ•ˆæ€§ã€‚ Liu ç­‰äººï¼ˆ2015ï¼‰è®¾è®¡äº†ä¸€ç§é€‚ç”¨äºæœªçŸ¥ç¯å¢ƒä¸­å¼‚æ„å¤šæ— äººæœºååŒæœç´¢ä¸æ‰“å‡»çš„è”ç›Ÿå½¢æˆæ–¹æ³•ï¼Œä»¥æœ€å°åŒ–ç›®æ ‡æ‰“å‡»æ—¶é—´ã€æœ€å°åŒ–è”ç›Ÿè§„æ¨¡ä¸ºä¼˜åŒ–æŒ‡æ ‡ï¼Œå¹¶æ»¡è¶³åŒæ—¶æ‰“å‡»å’Œèµ„æºéœ€æ±‚ä¸ºçº¦æŸæ¡ä»¶ã€‚è¯¥æ–¹æ³•å…·æœ‰è¾ƒé«˜çš„å®æ—¶æ€§ï¼Œèƒ½å¤Ÿåœ¨æœªçŸ¥ç¯å¢ƒä¸­å¾—åˆ°è‰¯å¥½åº”ç”¨ã€‚ 3.1.2 Parallel Coalition Formation Method Compared with the serial coalition formation method, the parallel coalition formation method has its uniqueness: in the task environment, the coalitions are searched for multiple tasks at the same time to maximize the overall benefit. Due to the existence of multiple coalitions generated at the same time and the arbitrary splitting and combination of individual abilities, there will be countless possible solutions to the problem, which requires a large amount of calculation and high system performance. Usually, parallel coalition formation methods include two processes: UAV task set construction and coalition formation conflict resolution. During the task set construction process, each UAV selects tasks to add to its own task set for the purpose of maximizing its own benefits. After the task set is constructed, the UAV needs to exchange information with other UAVs in the swarm, mediate task conflicts according to certain action rules, and form a UAV coalition suitable for each task to obtain conflict-free task allocation results. ä¸ä¸²è¡Œè”ç›Ÿå½¢æˆæ–¹æ³•ç›¸æ¯”ï¼Œå¹¶è¡Œè”ç›Ÿå½¢æˆæ–¹æ³•å…·æœ‰å…¶ç‹¬ç‰¹æ€§ï¼šåœ¨ä»»åŠ¡ç¯å¢ƒä¸­ï¼ŒåŒæ—¶ä¸ºå¤šä¸ªä»»åŠ¡æœç´¢è”ç›Ÿï¼Œä»¥å®ç°æ•´ä½“æ•ˆç›Šçš„æœ€å¤§åŒ–ã€‚ç”±äºåŒæ—¶ç”Ÿæˆçš„å¤šä¸ªè”ç›Ÿä»¥åŠä¸ªä½“èƒ½åŠ›çš„ä»»æ„æ‹†åˆ†ä¸ç»„åˆï¼Œé—®é¢˜çš„å¯èƒ½è§£å°†ä¸è®¡å…¶æ•°ï¼Œè¿™éœ€è¦å¤§é‡çš„è®¡ç®—å’Œé«˜ç³»ç»Ÿæ€§èƒ½ã€‚ é€šå¸¸ï¼Œå¹¶è¡Œè”ç›Ÿå½¢æˆæ–¹æ³•åŒ…æ‹¬ä¸¤ä¸ªè¿‡ç¨‹ï¼šæ— äººæœºä»»åŠ¡é›†æ„å»ºå’Œè”ç›Ÿå½¢æˆå†²çªè§£å†³ã€‚ åœ¨ä»»åŠ¡é›†æ„å»ºè¿‡ç¨‹ä¸­ï¼Œæ¯ä¸ªæ— äººæœºé€‰æ‹©ä»»åŠ¡åŠ å…¥è‡ªå·±çš„ä»»åŠ¡é›†ï¼Œä»¥å®ç°è‡ªèº«æ•ˆç›Šçš„æœ€å¤§åŒ–ã€‚ ä»»åŠ¡é›†æ„å»ºå®Œæˆåï¼Œæ— äººæœºéœ€è¦ä¸é›†ç¾¤ä¸­çš„å…¶ä»–æ— äººæœºäº¤æ¢ä¿¡æ¯ï¼Œæ ¹æ®ä¸€å®šçš„è¡ŒåŠ¨è§„åˆ™è°ƒè§£ä»»åŠ¡å†²çªï¼Œå¹¶å½¢æˆé€‚åˆæ¯ä¸ªä»»åŠ¡çš„æ— äººæœºè”ç›Ÿï¼Œä»¥è·å¾—æ— å†²çªçš„ä»»åŠ¡åˆ†é…ç»“æœã€‚ Figure 5. Schematic diagram of a parallel formation method of a single-task coalition Tang et al. (2020) extended the distributed consistency package theory to solve the task allocation problem of the heterogeneous multi-UAV coalition under the conditions of task load resource constraints, task-coupling relationship constraints, and execution window constraints. First, each UAV selects tasks to construct its own task set according to the principle of maximum benefit. Second, after UAVs share the winning agent matrix, winning bid matrix, timestamp list, and other information with adjacent UAVs, the conflict mediation of task allocation decision of heterogeneous multi-UAV coalition is realized based on the improved coordination principle. Li et al. (2020) aimed at the task allocation problem of the heterogeneous multi-UAV dynamic coalition under complex constraints. Based on the method proposed by Tang et al. (2020), this approach obtained efficient and reasonable allocation results, providing three dynamic allocation strategies: a no-re-planning dynamic allocation strategy, a fully re-planning dynamic allocation strategy, and a partially re-planning dynamic allocation strategy. At present, insufficient consideration has been given to task timing constraints and execution time windows in related research, and there is a lack of research on dynamic task allocation of multiUAV coalition under timing coupling relationship and time window constraints. Tang ç­‰äººï¼ˆ2020ï¼‰æ‰©å±•äº†åˆ†å¸ƒå¼ä¸€è‡´æ€§åŒ…ç†è®ºï¼Œè§£å†³äº†åœ¨ä»»åŠ¡è´Ÿè½½èµ„æºçº¦æŸã€ä»»åŠ¡è€¦åˆå…³ç³»çº¦æŸå’Œæ‰§è¡Œçª—å£çº¦æŸæ¡ä»¶ä¸‹çš„å¼‚æ„å¤šæ— äººæœºè”ç›Ÿä»»åŠ¡åˆ†é…é—®é¢˜ã€‚é¦–å…ˆï¼Œæ¯ä¸ªæ— äººæœºæ ¹æ®æœ€å¤§æ•ˆç›ŠåŸåˆ™é€‰æ‹©ä»»åŠ¡æ„å»ºè‡ªå·±çš„ä»»åŠ¡é›†ã€‚å…¶æ¬¡ï¼Œåœ¨æ— äººæœºä¸ç›¸é‚»æ— äººæœºå…±äº«è·èƒœä»£ç†çŸ©é˜µã€è·èƒœæŠ•æ ‡çŸ©é˜µã€æ—¶é—´æˆ³åˆ—è¡¨ç­‰ä¿¡æ¯åï¼ŒåŸºäºæ”¹è¿›çš„åè°ƒåŸåˆ™å®ç°å¼‚æ„å¤šæ— äººæœºè”ç›Ÿä»»åŠ¡åˆ†é…å†³ç­–çš„å†²çªè°ƒè§£ã€‚ Li ç­‰äººï¼ˆ2020ï¼‰é’ˆå¯¹å¤æ‚çº¦æŸä¸‹çš„å¼‚æ„å¤šæ— äººæœºåŠ¨æ€è”ç›Ÿä»»åŠ¡åˆ†é…é—®é¢˜ï¼ŒåŸºäº Tang ç­‰äººï¼ˆ2020ï¼‰æå‡ºçš„æ–¹æ³•ï¼Œè·å¾—äº†é«˜æ•ˆåˆç†çš„åˆ†é…ç»“æœï¼Œæä¾›äº†ä¸‰ç§åŠ¨æ€åˆ†é…ç­–ç•¥ï¼šæ— é‡æ–°è§„åˆ’åŠ¨æ€åˆ†é…ç­–ç•¥ã€å®Œå…¨é‡æ–°è§„åˆ’åŠ¨æ€åˆ†é…ç­–ç•¥å’Œéƒ¨åˆ†é‡æ–°è§„åˆ’åŠ¨æ€åˆ†é…ç­–ç•¥ã€‚ ç›®å‰ï¼Œç›¸å…³ç ”ç©¶å¯¹ä»»åŠ¡æ—¶åºçº¦æŸå’Œæ‰§è¡Œæ—¶é—´çª—å£çš„è€ƒè™‘ä¸è¶³ï¼Œç¼ºä¹åœ¨æ—¶åºè€¦åˆå…³ç³»å’Œæ—¶é—´çª—å£çº¦æŸä¸‹çš„å¤šæ— äººæœºè”ç›ŸåŠ¨æ€ä»»åŠ¡åˆ†é…ç ”ç©¶ã€‚ 3.2 Multi-Task Coalition å¤šä»»åŠ¡è”ç›Ÿ As shown in Figure 3(b), a UAV coalition that undertakes multiple tasks at the same time during the execution of a UAV swarm is called a multi-task coalition . The task-cluster coalition is the main form of multi-task coalition. The formation of multi-task coalition mainly includes two processes: task clustering and UAV matching task clusters. That is, during task execution, all tasks to be executed are clustered into several task clusters according to certain principles, and then the task clusters are assigned to the UAV coalition for execution. The formation of a multi-task coalition needs to solve the following two problems: (a) ensuring that tasks with similar characteristics in all tasks are clustered into one cluster, so as to effectively reduce the range cost of UAV swarm tasks, and (b) determining UAVs are responsible for the corresponding task clusters, so as to effectively reduce the cost of capabilities including communication and resources. Therefore, in the process of coalition formation and evolution, it is necessary to consider the characteristics of task distribution, dynamic uncertainty of battlefield environment, UAV swarm capability, and other factors, and use simple rules and protocols to realize the matching quickly and efficiently between task clustering and UAV optimal coalition. å¦‚å›¾ 3(b)æ‰€ç¤ºï¼Œåœ¨æ— äººæœºé›†ç¾¤æ‰§è¡Œä»»åŠ¡è¿‡ç¨‹ä¸­ï¼ŒåŒæ—¶æ‰¿æ‹…å¤šä¸ªä»»åŠ¡çš„æ— äººæœºè”ç›Ÿè¢«ç§°ä¸ºå¤šä»»åŠ¡è”ç›Ÿã€‚ä»»åŠ¡-é›†ç¾¤è”ç›Ÿæ˜¯å¤šä»»åŠ¡è”ç›Ÿçš„ä¸»è¦å½¢å¼ã€‚å¤šä»»åŠ¡è”ç›Ÿçš„å½¢æˆä¸»è¦åŒ…æ‹¬ä¸¤ä¸ªè¿‡ç¨‹ï¼šä»»åŠ¡èšç±»å’Œæ— äººæœºåŒ¹é…ä»»åŠ¡é›†ç¾¤ã€‚å³åœ¨ä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œå°†æ‰€æœ‰å¾…æ‰§è¡Œä»»åŠ¡æŒ‰ç…§ä¸€å®šåŸåˆ™èšç±»ä¸ºè‹¥å¹²ä»»åŠ¡é›†ç¾¤ï¼Œç„¶åå°†ä»»åŠ¡é›†ç¾¤åˆ†é…ç»™æ— äººæœºè”ç›Ÿæ‰§è¡Œã€‚ å¤šä»»åŠ¡è”ç›Ÿçš„å½¢æˆéœ€è¦è§£å†³ä»¥ä¸‹ä¸¤ä¸ªé—®é¢˜ï¼š ï¼ˆaï¼‰ç¡®ä¿æ‰€æœ‰ä»»åŠ¡ä¸­å…·æœ‰ç›¸ä¼¼ç‰¹å¾çš„ä»»åŠ¡è¢«èšç±»åˆ°ä¸€ä¸ªé›†ç¾¤ä¸­ï¼Œä»è€Œæœ‰æ•ˆé™ä½æ— äººæœºé›†ç¾¤ä»»åŠ¡çš„èŒƒå›´æˆæœ¬ï¼› ï¼ˆbï¼‰ç¡®å®šæ— äººæœºè´Ÿè´£ç›¸åº”çš„ä»»åŠ¡é›†ç¾¤ï¼Œä»è€Œæœ‰æ•ˆé™ä½é€šä¿¡å’Œèµ„æºç­‰èƒ½åŠ›çš„æˆæœ¬ã€‚ å› æ­¤ï¼Œåœ¨è”ç›Ÿå½¢æˆå’Œæ¼”åŒ–è¿‡ç¨‹ä¸­ï¼Œéœ€è¦è€ƒè™‘ä»»åŠ¡åˆ†å¸ƒç‰¹å¾ã€æˆ˜åœºç¯å¢ƒçš„åŠ¨æ€ä¸ç¡®å®šæ€§ã€æ— äººæœºé›†ç¾¤èƒ½åŠ›ç­‰å› ç´ ï¼Œå¹¶åˆ©ç”¨ç®€å•çš„è§„åˆ™å’Œåè®®å¿«é€Ÿé«˜æ•ˆåœ°å®ç°ä»»åŠ¡èšç±»ä¸æ— äººæœºæœ€ä¼˜è”ç›Ÿä¹‹é—´çš„åŒ¹é…ã€‚ Figure 6. Schematic diagram of the formation method of multi-task coalition Scholars have done a lot of research on the formation of multi-task coalitions. Hu et al. (2015) divided the multi-UAV task allocation problem into three sub-problems: task clustering, task cluster allocation, and task allocation within a cluster. Each UAV formed an actual coalition to execute tasks within each cluster. This method reduces the scale of problem-solving and has great advantages in real-time allocation. Wan et al. (2013) used the coalition formation strategy, \"first task grouping, then platformed matching to task group,\" which effectively solved the problem of forming a coalition when manned or unmanned aerial vehicles perform tasks. Zhong et al. (2017) adopted the phased formation strategy of task clustering - platform matching and successfully solved the problem of the manned-unmanned aerial mission coalition formation. In general, the existing research on the formation method of UAV swarm multi-task coalition has made great progress, but there are still several aspects that need to be improved. First, the quality of task clustering results will directly affect the subsequent coalition formation process, and the clustering method needs to be improved. Second, in the process of platform matching, since there may be multiple optimization objectives, the solution quality still needs to be improved. å­¦è€…ä»¬å¯¹å¤šä»»åŠ¡è”ç›Ÿçš„å½¢æˆè¿›è¡Œäº†å¤§é‡ç ”ç©¶ã€‚ Hu ç­‰äººï¼ˆ2015ï¼‰å°†å¤šæ— äººæœºä»»åŠ¡åˆ†é…é—®é¢˜åˆ†ä¸ºä¸‰ä¸ªå­é—®é¢˜ï¼šä»»åŠ¡èšç±»ã€ä»»åŠ¡é›†ç¾¤åˆ†é…å’Œé›†ç¾¤å†…ä»»åŠ¡åˆ†é…ã€‚æ¯ä¸ªæ— äººæœºå½¢æˆä¸€ä¸ªå®é™…è”ç›Ÿæ¥æ‰§è¡Œæ¯ä¸ªé›†ç¾¤å†…çš„ä»»åŠ¡ã€‚è¯¥æ–¹æ³•å‡å°‘äº†é—®é¢˜æ±‚è§£çš„è§„æ¨¡ï¼Œåœ¨å®æ—¶åˆ†é…æ–¹é¢å…·æœ‰å¾ˆå¤§ä¼˜åŠ¿ã€‚ Wan ç­‰äººï¼ˆ2013ï¼‰é‡‡ç”¨â€œå…ˆä»»åŠ¡åˆ†ç»„ï¼Œåå¹³å°åŒ¹é…ä»»åŠ¡ç»„â€çš„è”ç›Ÿå½¢æˆç­–ç•¥ï¼Œæœ‰æ•ˆè§£å†³äº†æœ‰äººæˆ–æ— äººæœºæ‰§è¡Œä»»åŠ¡æ—¶çš„è”ç›Ÿå½¢æˆé—®é¢˜ã€‚ Zhong ç­‰äººï¼ˆ2017ï¼‰é‡‡ç”¨ä»»åŠ¡èšç±»-å¹³å°åŒ¹é…çš„åˆ†é˜¶æ®µå½¢æˆç­–ç•¥ï¼ŒæˆåŠŸè§£å†³äº†æœ‰äºº-æ— äººæœºä»»åŠ¡è”ç›Ÿçš„å½¢æˆé—®é¢˜ã€‚ æ€»ä½“è€Œè¨€ï¼Œç°æœ‰å…³äºæ— äººæœºé›†ç¾¤å¤šä»»åŠ¡è”ç›Ÿå½¢æˆæ–¹æ³•çš„ç ”ç©¶å–å¾—äº†å¾ˆå¤§è¿›å±•ï¼Œä½†ä»æœ‰ä¸€äº›æ–¹é¢éœ€è¦æ”¹è¿›ã€‚é¦–å…ˆï¼Œä»»åŠ¡èšç±»ç»“æœçš„è´¨é‡å°†ç›´æ¥å½±å“åç»­è”ç›Ÿå½¢æˆè¿‡ç¨‹ï¼Œèšç±»æ–¹æ³•éœ€è¦æ”¹è¿›ã€‚å…¶æ¬¡ï¼Œåœ¨å¹³å°åŒ¹é…è¿‡ç¨‹ä¸­ï¼Œç”±äºå¯èƒ½å­˜åœ¨å¤šä¸ªä¼˜åŒ–ç›®æ ‡ï¼Œè§£å†³æ–¹æ¡ˆçš„è´¨é‡ä»éœ€æé«˜ã€‚ 3.3 Comparison of Coalition Formation Methods Based on the relevant research at home and abroad, Table 1 specifically compares and analyzes the basic situation of the formation method of the UAV swarm coalition. Table 1. Comparison of UAV swarm coalition formation methods Method Method Typical References Implementation Approach Advantage Key Points and Difficulties Research Status Single- task coalition Serial coalition formation method Wang et al., 2005; Han and Yao, 2018 Determine task priority; Form coalitions according to task priorities. It is simple and easy to implement, and both are the current optimal solutions. (1) Determining the priority of tasks is greatly affected by subjective factors. (2) High computing power is required. (1) Alliance evolution is not considered; (2) The mission scenario is simple and small in scale. Parallel coalition formation method Li et al., 2020; Tang et al., 2020 At the same time, find coalitions for multiple tasks respectively. Simple and easy, with a certain dynamic. Large solution space and a large amount of calculation require high system Inadequate consideration of task timing constraints and execution time windows. Multi-task coalition Multi-task coalition Hu et al., 2015; Wan et al., 2013; Zhong et al., 2017 The tasks are clustered into several task clusters, and then the task clusters are formed into coalitions, respectively. Reduce the scale of problem- solving and have a great advantage in allocating real-time performance. performance. (1) Task clustering has a great impact on coalition formation. (2) The task is complex, and the solution quality is difficult to guarantee. (1) The clustering method needs to be improved. (2) The solution quality needs to be improved. Solution method of task allocation for uav swarm coalition The main purpose of the task allocation problem for a UAV swarm coalition is to select an appropriate coalition for tasks, which is essentially a combinatorial optimization problem. Therefore, choosing an efficient solution method is a necessary condition to successfully solve the coalition task allocation problem. At present, there are two main methods for solving the task allocation problem of the UAV swarm coalition: the centralized solution method (Guruacharya et al., 2013; Klusch & Gerber, 2002; Das, Misra, & Roy, 2015; Anderson et al., 2004; Lerman et al., 2006; Wang & Liu, 2021) and the distributed solution method (Michalak et al., 2010; Tanzil et al., 2016; Kong et al., 2017; Johnson et al., 2011; Das, McGinnity, et al., 2015; Stranders et al., 2012). 4.1 Centralized Solution Method The main research ideas of the centralized solution method can be summarized as follows: Based on the global environment information, the task allocation is modeled into the corresponding resource allocation model, and then the centralized algorithm is used for the solution. As shown in Figure 7, the commonly used centralized solving methods are divided into two categories: optimization methods and intelligent optimization algorithms. Figure 7. Commonly used centralized solving methods 4.1.1 Optimization Method The optimization method solves the optimal solution of the problem under the condition of satisfying the multiple current constraints. The commonly used optimization methods mainly include integer linear programming method (ILP), constraint programming method, and dynamic programming method. ä¼˜åŒ–æ–¹æ³•æ˜¯åœ¨æ»¡è¶³å¤šç§å½“å‰çº¦æŸæ¡ä»¶ä¸‹æ±‚è§£é—®é¢˜çš„æœ€ä¼˜è§£ã€‚å¸¸ç”¨çš„ä¼˜åŒ–æ–¹æ³•ä¸»è¦åŒ…æ‹¬æ•´æ•°çº¿æ€§è§„åˆ’æ³•ï¼ˆILPï¼‰ã€çº¦æŸè§„åˆ’æ³•å’ŒåŠ¨æ€è§„åˆ’æ³•ã€‚ 4.1.1.1 Integer Linear Programming Method The integer linear programming (ILP) method establishes the objective function and related constraints and seeks a solution for its extreme value. Although the ILP method is flexible, easy to operate, with relatively fast solution speed, the model built by this method is relatively simple, which cannot represent the complex task environment with poor fault tolerance and is not ideal for solving multimachine and multi-objective allocation problems with different models. The commonly used integer programming methods are the matrix homework method, the branch and bound method, and the mixed integer linear programming algorithm (MILP). Shetty et al. (2008) abstracted the cooperative allocation and path planning problem of multiple UAVs attacking fixed targets into a MILP problem, used a centralized algorithm to solve it, and achieved good results, but the real-time performance of the solution was poor. æ•´æ•°çº¿æ€§è§„åˆ’æ³•ï¼ˆILPï¼‰é€šè¿‡å»ºç«‹ç›®æ ‡å‡½æ•°å’Œç›¸å…³çº¦æŸæ¡ä»¶ï¼Œå¹¶å¯»æ±‚å…¶æå€¼è§£ã€‚å°½ç®¡ ILP æ–¹æ³•çµæ´»ã€æ˜“äºæ“ä½œä¸”æ±‚è§£é€Ÿåº¦ç›¸å¯¹è¾ƒå¿«ï¼Œä½†è¯¥æ–¹æ³•å»ºç«‹çš„æ¨¡å‹è¾ƒä¸ºç®€å•ï¼Œæ— æ³•è¡¨ç¤ºå¤æ‚çš„ä»»åŠ¡ç¯å¢ƒï¼Œå®¹é”™æ€§è¾ƒå·®ï¼Œåœ¨è§£å†³ä¸åŒæ¨¡å‹çš„å¤šæœºå¤šç›®æ ‡åˆ†é…é—®é¢˜æ—¶æ•ˆæœä¸ç†æƒ³ã€‚å¸¸ç”¨çš„æ•´æ•°è§„åˆ’æ–¹æ³•åŒ…æ‹¬çŸ©é˜µä½œä¸šæ³•ã€åˆ†æ”¯å®šç•Œæ³•å’Œæ··åˆæ•´æ•°çº¿æ€§è§„åˆ’ç®—æ³•ï¼ˆMILPï¼‰ã€‚Shetty ç­‰äººï¼ˆ2008ï¼‰å°†å¤šæ— äººæœºååŒåˆ†é…å’Œè·¯å¾„è§„åˆ’é—®é¢˜æŠ½è±¡ä¸º MILP é—®é¢˜ï¼Œé‡‡ç”¨é›†ä¸­å¼ç®—æ³•æ±‚è§£å¹¶å–å¾—äº†è‰¯å¥½æ•ˆæœï¼Œä½†æ±‚è§£çš„å®æ—¶æ€§è¾ƒå·®ã€‚ 4.1.1.2 Dynamic Programming Method Dynamic programming refers to a method of transforming multi-stage decision-making problems into single-stage optimization problems in order to reduce the difficulty of decision-making problems. Dynamic refers to the changes and transitions of states caused by changes in the decision sequence and steps in the multi-stage decision-making of a problem. The algorithm has no definite steps, and the corresponding optimization algorithm needs to be designed in combination with the idea of dynamic programming. This method has high implementation efficiency but is prone to the curse of dimensionality. Xu and Liu (2015) designed a coalition constraint dynamic programming algorithm for the coalition structure generation of multi-agent systems, proving that the time complexity of the algorithm was $O(3^n)$, and further discussed the impact of the number of agents and the number of coalition constraints on the algorithm. åŠ¨æ€è§„åˆ’æ³•æ˜¯æŒ‡å°†å¤šé˜¶æ®µå†³ç­–é—®é¢˜è½¬åŒ–ä¸ºå•é˜¶æ®µä¼˜åŒ–é—®é¢˜ï¼Œä»¥é™ä½å†³ç­–é—®é¢˜çš„éš¾åº¦ã€‚åŠ¨æ€æŒ‡çš„æ˜¯åœ¨å¤šé˜¶æ®µå†³ç­–ä¸­ï¼Œç”±äºå†³ç­–åºåˆ—å’Œæ­¥éª¤çš„å˜åŒ–å¼•èµ·çš„çŠ¶æ€å˜åŒ–å’Œè½¬ç§»ã€‚è¯¥ç®—æ³•æ²¡æœ‰å›ºå®šçš„æ­¥éª¤ï¼Œéœ€è¦ç»“åˆåŠ¨æ€è§„åˆ’çš„æ€æƒ³è®¾è®¡ç›¸åº”çš„ä¼˜åŒ–ç®—æ³•ã€‚è¿™ç§æ–¹æ³•å®ç°æ•ˆç‡è¾ƒé«˜ï¼Œä½†å®¹æ˜“å‡ºç°ç»´åº¦ç¾éš¾é—®é¢˜ã€‚Xu å’Œ Liuï¼ˆ2015ï¼‰é’ˆå¯¹å¤šæ™ºèƒ½ä½“ç³»ç»Ÿçš„è”ç›Ÿç»“æ„ç”Ÿæˆé—®é¢˜ï¼Œè®¾è®¡äº†ä¸€ç§è”ç›Ÿçº¦æŸåŠ¨æ€è§„åˆ’ç®—æ³•ï¼Œè¯æ˜äº†è¯¥ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(3^n)ï¼Œå¹¶è¿›ä¸€æ­¥è®¨è®ºäº†æ™ºèƒ½ä½“æ•°é‡å’Œè”ç›Ÿçº¦æŸæ•°é‡å¯¹ç®—æ³•çš„å½±å“ã€‚ 4.1.1.3 Other Optimization Methods Manathara et al. (2011) took the minimum strike time and minimum coalition size as the goal and proposed a polynomial-time formation strategy for UAV cooperative coalitions to perform inspection and strike tasks on fixed targets. On the method proposed by Manathara et al. (2011), Sujit et al. (2014) considered the limited communication range and target movement of UAVs, avoided the network congestion caused by broadcasting, and adopted the resource distribution strategy one by one, but did not consider the impact of the resource distribution strategy on the execution of subsequent tasks in the current task execution. Zhong et al. (2017) established a mathematical model with minimizing task completion time as the objective function for heterogeneous multi-UAV muli-task execution and designed a phased greedy planning algorithm (PGPA) to solve the model, which improved the collaborative ability of multi-UAV multi-task execution. Bayram and Bozma (2016) came up with a coalition formation algorithm based on merge and split (CF-MS). The algorithm can be well applied to the formation of robot coalitions in dynamic scenarios, but it is difficult to deal with the formation of large-scale coalitions. Manathara ç­‰äººï¼ˆ2011ï¼‰ä»¥æœ€å°æ‰“å‡»æ—¶é—´å’Œæœ€å°è”ç›Ÿè§„æ¨¡ä¸ºç›®æ ‡ï¼Œæå‡ºäº†ä¸€ç§å¤šé¡¹å¼æ—¶é—´çš„æ— äººæœºååŒè”ç›Ÿå½¢æˆç­–ç•¥ï¼Œç”¨äºå¯¹å›ºå®šç›®æ ‡æ‰§è¡Œä¾¦å¯Ÿå’Œæ‰“å‡»ä»»åŠ¡ã€‚ åœ¨ Manathara ç­‰äººï¼ˆ2011ï¼‰æå‡ºçš„æ–¹æ³•åŸºç¡€ä¸Šï¼ŒSujit ç­‰äººï¼ˆ2014ï¼‰è€ƒè™‘äº†æ— äººæœºçš„æœ‰é™é€šä¿¡èŒƒå›´å’Œç›®æ ‡ç§»åŠ¨æ€§ï¼Œé¿å…äº†å¹¿æ’­å¼•èµ·çš„ç½‘ç»œæ‹¥å¡ï¼Œå¹¶é‡‡ç”¨é€ä¸€èµ„æºåˆ†é…ç­–ç•¥ï¼Œä½†æœªè€ƒè™‘å½“å‰ä»»åŠ¡æ‰§è¡Œä¸­èµ„æºåˆ†é…ç­–ç•¥å¯¹åç»­ä»»åŠ¡æ‰§è¡Œçš„å½±å“ã€‚ Zhong ç­‰äººï¼ˆ2017ï¼‰å»ºç«‹äº†ä»¥æœ€å°åŒ–ä»»åŠ¡å®Œæˆæ—¶é—´ä¸ºç›®æ ‡å‡½æ•°çš„å¼‚æ„å¤šæ— äººæœºå¤šä»»åŠ¡æ‰§è¡Œæ•°å­¦æ¨¡å‹ï¼Œå¹¶è®¾è®¡äº†ä¸€ç§åˆ†é˜¶æ®µè´ªå©ªè§„åˆ’ç®—æ³•ï¼ˆPGPAï¼‰æ¥æ±‚è§£è¯¥æ¨¡å‹ï¼Œæé«˜äº†å¤šæ— äººæœºå¤šä»»åŠ¡æ‰§è¡Œçš„ååŒèƒ½åŠ›ã€‚ Bayram å’Œ Bozmaï¼ˆ2016ï¼‰æå‡ºäº†ä¸€ç§åŸºäºåˆå¹¶ä¸æ‹†åˆ†ï¼ˆCF-MSï¼‰çš„è”ç›Ÿå½¢æˆç®—æ³•ã€‚è¯¥ç®—æ³•èƒ½å¤Ÿå¾ˆå¥½åœ°åº”ç”¨äºåŠ¨æ€åœºæ™¯ä¸­çš„æœºå™¨äººè”ç›Ÿå½¢æˆï¼Œä½†éš¾ä»¥å¤„ç†å¤§è§„æ¨¡è”ç›Ÿçš„å½¢æˆã€‚ According to the current research results, the optimization method is simple, flexible, and easy to implement, and it can flexibly deal with constraints to seek a solution for practical problems. In the case of small-scale tasks, the optimization method can quickly find the optimal solution for task allocation. However, when the task allocation scale is large, the time consumed by the algorithm increases sharply, and the optimization method is difficult to meet the real-time requirements in a dynamic environment. Therefore, the optimization method is only suitable for task allocation of an off-line coalition for UAV swarms which has low requirements on time and a small number of tasks. æ ¹æ®ç›®å‰çš„ç ”ç©¶æˆæœï¼Œä¼˜åŒ–æ–¹æ³•ç®€å•ã€çµæ´»ä¸”æ˜“äºå®ç°ï¼Œèƒ½å¤Ÿçµæ´»å¤„ç†çº¦æŸæ¡ä»¶ä»¥å¯»æ±‚å®é™…é—®é¢˜çš„è§£å†³æ–¹æ¡ˆã€‚åœ¨å°è§„æ¨¡ä»»åŠ¡æƒ…å†µä¸‹ï¼Œä¼˜åŒ–æ–¹æ³•èƒ½å¤Ÿå¿«é€Ÿæ‰¾åˆ°ä»»åŠ¡åˆ†é…çš„æœ€ä¼˜è§£ã€‚ç„¶è€Œï¼Œå½“ä»»åŠ¡åˆ†é…è§„æ¨¡è¾ƒå¤§æ—¶ï¼Œç®—æ³•æ¶ˆè€—çš„æ—¶é—´æ€¥å‰§å¢åŠ ï¼Œä¼˜åŒ–æ–¹æ³•éš¾ä»¥æ»¡è¶³åŠ¨æ€ç¯å¢ƒä¸­çš„å®æ—¶æ€§è¦æ±‚ã€‚å› æ­¤ï¼Œä¼˜åŒ–æ–¹æ³•ä»…é€‚ç”¨äºå¯¹æ—¶é—´è¦æ±‚è¾ƒä½ä¸”ä»»åŠ¡æ•°é‡è¾ƒå°‘çš„æ— äººæœºé›†ç¾¤ç¦»çº¿è”ç›Ÿä»»åŠ¡åˆ†é…ã€‚ 4.1.2 Intelligent Optimization Algorithm æ™ºèƒ½ä¼˜åŒ–ç®—æ³• An intelligent optimization algorithm (Yang et al., 2018; Wang, 2001) is a random search method developed under the inspiration of natural phenomena or social behaviors. This kind of algorithm is widely used and can be applied to large-scale and nonlinear problems with strong universality. The algorithms commonly used in UAV swarm coalition task allocation are the evolutionary algorithm and the swarm intelligence algorithm. æ™ºèƒ½ä¼˜åŒ–ç®—æ³•ï¼ˆYang ç­‰ï¼Œ2018ï¼›Wangï¼Œ2001ï¼‰æ˜¯ä¸€ç§åœ¨è‡ªç„¶ç°è±¡æˆ–ç¤¾ä¼šè¡Œä¸ºå¯å‘ä¸‹å‘å±•èµ·æ¥çš„éšæœºæœç´¢æ–¹æ³•ã€‚è¿™ç±»ç®—æ³•åº”ç”¨å¹¿æ³›ï¼Œèƒ½å¤Ÿé€‚ç”¨äºå¤§è§„æ¨¡å’Œéçº¿æ€§é—®é¢˜ï¼Œå…·æœ‰è¾ƒå¼ºçš„æ™®é€‚æ€§ã€‚åœ¨æ— äººæœºé›†ç¾¤è”ç›Ÿä»»åŠ¡åˆ†é…ä¸­å¸¸ç”¨çš„ç®—æ³•åŒ…æ‹¬è¿›åŒ–ç®—æ³•å’Œç¾¤ä½“æ™ºèƒ½ç®—æ³•ã€‚ 4.1.2.1 Evolutionary Algorithm An evolutionary algorithm (Zheng, 2007) achieves the purpose of searching for the optimal solution by simulating the biological evolution process proposed by Darwin. Based on this algorithm, in the task allocation stage, different actions are taken to perform task allocation for different goals and tasks, so that the overall allocation can be optimized. Representative algorithms in evolutionary algorithms include genetic algorithms (GA; Zhang et al., 2012) and differential evolution algorithms, which are widely used in UAV swarm coalition task allocation. Wu et al. (2017) took the heterogeneous multi-UAV cooperative air defense suppression task as the background and applied an improved genetic algorithm to solve the multi-UAV agent cooperative task allocation problem considering constraints such as aircraft load type and end entry target angle. Xiao et al. (2018) aimed at the target search and strike task of multiple heterogeneous UAVs in an unknown environment, focused on the UAV resource constraints, and designed a rapid coalition establishment method based on a parallel non-dominated genetic algorithm with elite strategy (NSGA-II). This method has high real-time performance but does not consider the impact of communication constraints such as communication distance and communication delay on coalition formation. Rauniyar and Muhuri (2016) presented a genetic algorithm based on random immigration and elite mechanism, which can only quickly seek the optimal solution to the problem of coalition formation in relatively simple application scenarios. It can be seen that the evolutionary algorithm has the advantages of strong global search ability, high search efficiency, and strong robustness, and can find the optimal solution in a short time, but the algorithm is easy to fall into local optimum when solving large-scale combinatorial optimization problems. è¿›åŒ–ç®—æ³•ï¼ˆZhengï¼Œ2007ï¼‰é€šè¿‡æ¨¡æ‹Ÿè¾¾å°”æ–‡æå‡ºçš„ç”Ÿç‰©è¿›åŒ–è¿‡ç¨‹ï¼Œå®ç°æœç´¢æœ€ä¼˜è§£çš„ç›®çš„ã€‚åŸºäºè¯¥ç®—æ³•ï¼Œåœ¨ä»»åŠ¡åˆ†é…é˜¶æ®µï¼Œé’ˆå¯¹ä¸åŒçš„ç›®æ ‡å’Œä»»åŠ¡é‡‡å–ä¸åŒçš„è¡ŒåŠ¨è¿›è¡Œä»»åŠ¡åˆ†é…ï¼Œä»è€Œå®ç°æ•´ä½“åˆ†é…çš„ä¼˜åŒ–ã€‚è¿›åŒ–ç®—æ³•ä¸­çš„ä»£è¡¨æ€§ç®—æ³•åŒ…æ‹¬é—ä¼ ç®—æ³•ï¼ˆGAï¼›Zhang ç­‰ï¼Œ2012ï¼‰å’Œå·®åˆ†è¿›åŒ–ç®—æ³•ï¼Œè¿™äº›ç®—æ³•åœ¨æ— äººæœºé›†ç¾¤è”ç›Ÿä»»åŠ¡åˆ†é…ä¸­å¾—åˆ°äº†å¹¿æ³›åº”ç”¨ã€‚Wu ç­‰ï¼ˆ2017ï¼‰ä»¥å¼‚æ„å¤šæ— äººæœºååŒé˜²ç©ºå‹åˆ¶ä»»åŠ¡ä¸ºèƒŒæ™¯ï¼Œåº”ç”¨æ”¹è¿›çš„é—ä¼ ç®—æ³•è§£å†³äº†è€ƒè™‘é£æœºè½½è·ç±»å‹å’Œæœ«ç«¯è¿›å…¥ç›®æ ‡è§’åº¦ç­‰çº¦æŸçš„å¤šæ— äººæœºä»£ç†ååŒä»»åŠ¡åˆ†é…é—®é¢˜ã€‚Xiao ç­‰ï¼ˆ2018ï¼‰é’ˆå¯¹æœªçŸ¥ç¯å¢ƒä¸­å¤šå¼‚æ„æ— äººæœºçš„ç›®æ ‡æœç´¢ä¸æ‰“å‡»ä»»åŠ¡ï¼Œé‡ç‚¹è€ƒè™‘äº†æ— äººæœºèµ„æºçº¦æŸï¼Œè®¾è®¡äº†ä¸€ç§åŸºäºç²¾è‹±ç­–ç•¥çš„å¹¶è¡Œéæ”¯é…é—ä¼ ç®—æ³•ï¼ˆNSGA-IIï¼‰çš„å¿«é€Ÿè”ç›Ÿå»ºç«‹æ–¹æ³•ã€‚è¯¥æ–¹æ³•å…·æœ‰è¾ƒé«˜çš„å®æ—¶æ€§ï¼Œä½†æœªè€ƒè™‘é€šä¿¡è·ç¦»å’Œé€šä¿¡å»¶è¿Ÿç­‰é€šä¿¡çº¦æŸå¯¹è”ç›Ÿå½¢æˆçš„å½±å“ã€‚Rauniyar å’Œ Muhuriï¼ˆ2016ï¼‰æå‡ºäº†ä¸€ç§åŸºäºéšæœºç§»æ°‘å’Œç²¾è‹±æœºåˆ¶çš„é—ä¼ ç®—æ³•ï¼Œè¯¥ç®—æ³•åªèƒ½åœ¨ç›¸å¯¹ç®€å•çš„åº”ç”¨åœºæ™¯ä¸­å¿«é€Ÿå¯»æ±‚è”ç›Ÿå½¢æˆé—®é¢˜çš„æœ€ä¼˜è§£ã€‚å¯ä»¥çœ‹å‡ºï¼Œè¿›åŒ–ç®—æ³•å…·æœ‰å…¨å±€æœç´¢èƒ½åŠ›å¼ºã€æœç´¢æ•ˆç‡é«˜å’Œé²æ£’æ€§å¼ºç­‰ä¼˜ç‚¹ï¼Œèƒ½å¤Ÿåœ¨è¾ƒçŸ­æ—¶é—´å†…æ‰¾åˆ°æœ€ä¼˜è§£ï¼Œä½†åœ¨è§£å†³å¤§è§„æ¨¡ç»„åˆä¼˜åŒ–é—®é¢˜æ—¶ï¼Œç®—æ³•å®¹æ˜“é™·å…¥å±€éƒ¨æœ€ä¼˜ã€‚ 4.1.2.2 Swarm Intelligence Optimization Algorithm The inspiration for the swarm intelligence optimization algorithm comes from the behavior of biological groups in nature, which means that multiple individuals representing candidate solutions are formed into a group, and the purpose of optimization is achieved through the information interaction between some or all of them. Commonly used swarm intelligence algorithms include the ant colony algorithm (Dorigo & StÃ¼tzle, 2003), particle swarm optimization (PSO; Kennedy & Eberhart, 1995), artificial bee colony algorithm (ABC), and wolf pack algorithm (WPA). Sujit et al. (2008) introduced the concept of coalition from a multi-agent system into a multi-UAV system for the first time, established a mathematical model for forming an optimal coalition, and used a PSO algorithm to seek a solution. However, for this method, all the information about the task environment needs to be obtained in advance, and the real-time performance is low. Jiang et al. (2009) introduced a discrete particle swarm algorithm to solve the problem of coalition formation. The random disturbance of particles was used to avoid the premature of the algorithm. A binary coding was designed to realize the parallel generation of a complex coalition. Through the coding feasibility check, conflict resolution, and compensation strategy, the resource conflict and coalition deadlock in the solution process were avoided. ç¾¤ä½“æ™ºèƒ½ä¼˜åŒ–ç®—æ³•çš„çµæ„Ÿæ¥æºäºè‡ªç„¶ç•Œä¸­ç”Ÿç‰©ç¾¤ä½“çš„è¡Œä¸ºï¼Œå³é€šè¿‡å°†ä»£è¡¨å€™é€‰è§£çš„å¤šä¸ªä¸ªä½“ç»„æˆä¸€ä¸ªç¾¤ä½“ï¼Œå¹¶é€šè¿‡éƒ¨åˆ†æˆ–å…¨éƒ¨ä¸ªä½“ä¹‹é—´çš„ä¿¡æ¯äº¤äº’å®ç°ä¼˜åŒ–ç›®çš„ã€‚å¸¸ç”¨çš„ç¾¤ä½“æ™ºèƒ½ç®—æ³•åŒ…æ‹¬èšç¾¤ç®—æ³•ï¼ˆDorigo & StÃ¼tzleï¼Œ2003ï¼‰ã€ç²’å­ç¾¤ä¼˜åŒ–ç®—æ³•ï¼ˆPSOï¼›Kennedy & Eberhartï¼Œ1995ï¼‰ã€äººå·¥èœ‚ç¾¤ç®—æ³•ï¼ˆABCï¼‰å’Œç‹¼ç¾¤ç®—æ³•ï¼ˆWPAï¼‰ã€‚Sujit ç­‰ï¼ˆ2008ï¼‰é¦–æ¬¡å°†å¤šæ™ºèƒ½ä½“ç³»ç»Ÿä¸­çš„è”ç›Ÿæ¦‚å¿µå¼•å…¥å¤šæ— äººæœºç³»ç»Ÿï¼Œå»ºç«‹äº†å½¢æˆæœ€ä¼˜è”ç›Ÿçš„æ•°å­¦æ¨¡å‹ï¼Œå¹¶ä½¿ç”¨ç²’å­ç¾¤ä¼˜åŒ–ç®—æ³•è¿›è¡Œæ±‚è§£ã€‚ç„¶è€Œï¼Œè¯¥æ–¹æ³•éœ€è¦é¢„å…ˆè·å–ä»»åŠ¡ç¯å¢ƒçš„æ‰€æœ‰ä¿¡æ¯ï¼Œå®æ—¶æ€§è¾ƒä½ã€‚Jiang ç­‰ï¼ˆ2009ï¼‰å¼•å…¥ç¦»æ•£ç²’å­ç¾¤ç®—æ³•è§£å†³è”ç›Ÿå½¢æˆé—®é¢˜ï¼Œé€šè¿‡ç²’å­çš„éšæœºæ‰°åŠ¨é¿å…ç®—æ³•æ—©ç†Ÿï¼Œè®¾è®¡äº†äºŒè¿›åˆ¶ç¼–ç ä»¥å®ç°å¤æ‚è”ç›Ÿçš„å¹¶è¡Œç”Ÿæˆï¼Œå¹¶é€šè¿‡ç¼–ç å¯è¡Œæ€§æ£€æŸ¥ã€å†²çªè§£å†³å’Œè¡¥å¿ç­–ç•¥ï¼Œé¿å…äº†æ±‚è§£è¿‡ç¨‹ä¸­çš„èµ„æºå†²çªå’Œè”ç›Ÿæ­»é”ã€‚ Wang et al. (2018) studied the task allocation of swarm networking, designed a hierarchical iterative task allocation model, and proposed a task allocation algorithm for UAV swarm networking based on PSO-ICWPA with the swarm intelligence optimization algorithm of low complexity and superior performance as the basis. This method has good convergence and rapidity and is useful for solving task allocation problems of different scales. The research shows that the swarm intelligence optimization algorithm has strong search ability, strong robustness, and strong scalability. It has prominent advantages in large-scale parallel computing and can also be combined with many other algorithms. However, when a large number of coalitions need to be formed in a complex task environment, the swarm intelligence optimization algorithm also shows the shortcomings of slow convergence speed, low operation efficiency, easily falling into local optimization, and low real-time solution. Wang ç­‰ï¼ˆ2018ï¼‰ç ”ç©¶äº†ç¾¤ä½“ç½‘ç»œåŒ–ä»»åŠ¡åˆ†é…é—®é¢˜ï¼Œè®¾è®¡äº†åˆ†å±‚è¿­ä»£ä»»åŠ¡åˆ†é…æ¨¡å‹ï¼Œå¹¶æå‡ºäº†ä¸€ç§åŸºäº PSO-ICWPA çš„æ— äººæœºç¾¤ä½“ç½‘ç»œåŒ–ä»»åŠ¡åˆ†é…ç®—æ³•ï¼Œä»¥ä½å¤æ‚åº¦å’Œé«˜æ€§èƒ½çš„ç¾¤ä½“æ™ºèƒ½ä¼˜åŒ–ç®—æ³•ä¸ºåŸºç¡€ã€‚è¯¥æ–¹æ³•å…·æœ‰è‰¯å¥½çš„æ”¶æ•›æ€§å’Œå¿«é€Ÿæ€§ï¼Œé€‚ç”¨äºè§£å†³ä¸åŒè§„æ¨¡çš„ä»»åŠ¡åˆ†é…é—®é¢˜ã€‚ç ”ç©¶è¡¨æ˜ï¼Œç¾¤ä½“æ™ºèƒ½ä¼˜åŒ–ç®—æ³•å…·æœ‰è¾ƒå¼ºçš„æœç´¢èƒ½åŠ›ã€é²æ£’æ€§å’Œå¯æ‰©å±•æ€§ï¼Œåœ¨å¤§è§„æ¨¡å¹¶è¡Œè®¡ç®—ä¸­å…·æœ‰çªå‡ºä¼˜åŠ¿ï¼Œå¹¶ä¸”å¯ä»¥ä¸å…¶ä»–å¤šç§ç®—æ³•ç»“åˆä½¿ç”¨ã€‚ç„¶è€Œï¼Œåœ¨å¤æ‚ä»»åŠ¡ç¯å¢ƒä¸­éœ€è¦å½¢æˆå¤§é‡è”ç›Ÿæ—¶ï¼Œç¾¤ä½“æ™ºèƒ½ä¼˜åŒ–ç®—æ³•ä¹Ÿè¡¨ç°å‡ºæ”¶æ•›é€Ÿåº¦æ…¢ã€è¿è¡Œæ•ˆç‡ä½ã€å®¹æ˜“é™·å…¥å±€éƒ¨ä¼˜åŒ–å’Œå®æ—¶æ±‚è§£èƒ½åŠ›ä¸è¶³ç­‰ç¼ºç‚¹ã€‚ Dong and Zou (2018) used an improved adaptive variable weight particle swarm optimization algorithm, which can quickly and effectively seek multi-objective optimal task allocation solutions for multi-UAVs formed by the coalition and obtain the optimal task allocation scheme. Diao et al. (2014) used the coalition formation theory to analyze the air combat task allocation under the condition of cooperative guidance, constructed the coalition characteristic function according to the characteristics of air combat tasks, and introduced the discrete particle swarm optimization algorithm to form the coalition, adopted the binary matrix coding form, designed the particle feasibility inspection strategy, and effectively improved and perfected the existing task allocation problem of cooperative air combat. Based on the Holon organization construction theory, Han and Yao (2018) analyzed the task allocation problem of manned and unmanned aerial vehicles swarm for a cooperative swarm operation, divided the total task of the target swarm into different types of subtasks, constructed a multi-objective optimization model, and designed a multi-objective hybrid bee colony algorithm to solve it, which achieved good results. Dong å’Œ Zouï¼ˆ2018ï¼‰é‡‡ç”¨äº†ä¸€ç§æ”¹è¿›çš„è‡ªé€‚åº”å˜æƒé‡ç²’å­ç¾¤ä¼˜åŒ–ç®—æ³•ï¼Œèƒ½å¤Ÿå¿«é€Ÿæœ‰æ•ˆåœ°å¯»æ±‚å¤šæ— äººæœºè”ç›Ÿå½¢æˆçš„å¤šç›®æ ‡æœ€ä¼˜ä»»åŠ¡åˆ†é…è§£ï¼Œå¹¶è·å¾—æœ€ä¼˜ä»»åŠ¡åˆ†é…æ–¹æ¡ˆã€‚Diao ç­‰ï¼ˆ2014ï¼‰åˆ©ç”¨è”ç›Ÿå½¢æˆç†è®ºåˆ†æäº†ååŒåˆ¶å¯¼æ¡ä»¶ä¸‹çš„ç©ºæˆ˜ä»»åŠ¡åˆ†é…é—®é¢˜ï¼Œæ ¹æ®ç©ºæˆ˜ä»»åŠ¡çš„ç‰¹ç‚¹æ„å»ºäº†è”ç›Ÿç‰¹å¾å‡½æ•°ï¼Œå¹¶å¼•å…¥ç¦»æ•£ç²’å­ç¾¤ä¼˜åŒ–ç®—æ³•è¿›è¡Œè”ç›Ÿå½¢æˆï¼Œé‡‡ç”¨äºŒè¿›åˆ¶çŸ©é˜µç¼–ç å½¢å¼ï¼Œè®¾è®¡äº†ç²’å­å¯è¡Œæ€§æ£€æŸ¥ç­–ç•¥ï¼Œæœ‰æ•ˆæ”¹è¿›å’Œå®Œå–„äº†ç°æœ‰ååŒç©ºæˆ˜ä»»åŠ¡åˆ†é…é—®é¢˜ã€‚Han å’Œ Yaoï¼ˆ2018ï¼‰åŸºäº Holon ç»„ç»‡æ„å»ºç†è®ºï¼Œåˆ†æäº†æœ‰äººä¸æ— äººæœºç¾¤ä½“ååŒä½œæˆ˜çš„ä»»åŠ¡åˆ†é…é—®é¢˜ï¼Œå°†ç›®æ ‡ç¾¤ä½“çš„æ€»ä»»åŠ¡åˆ’åˆ†ä¸ºä¸åŒç±»å‹çš„å­ä»»åŠ¡ï¼Œæ„å»ºäº†å¤šç›®æ ‡ä¼˜åŒ–æ¨¡å‹ï¼Œå¹¶è®¾è®¡äº†ä¸€ç§å¤šç›®æ ‡æ··åˆèœ‚ç¾¤ç®—æ³•è¿›è¡Œæ±‚è§£ï¼Œå–å¾—äº†è‰¯å¥½çš„æ•ˆæœã€‚ To sum up, the intelligent optimization algorithm has high computational efficiency. For largescale task allocation problems, it can also obtain a relatively satisfactory solution, but the feasible solution is not necessarily the optimal solution. That is, the solution is uncertain. In addition, the convergence speed of the algorithm cannot be guaranteed. ç»¼ä¸Šæ‰€è¿°ï¼Œæ™ºèƒ½ä¼˜åŒ–ç®—æ³•å…·æœ‰è¾ƒé«˜çš„è®¡ç®—æ•ˆç‡ï¼Œå¯¹äºå¤§è§„æ¨¡ä»»åŠ¡åˆ†é…é—®é¢˜ï¼Œä¹Ÿèƒ½å¤Ÿè·å¾—ç›¸å¯¹æ»¡æ„çš„è§£ï¼Œä½†å¯è¡Œè§£ä¸ä¸€å®šæ˜¯æœ€ä¼˜è§£ï¼Œå³è§£å…·æœ‰ä¸ç¡®å®šæ€§ã€‚æ­¤å¤–ï¼Œç®—æ³•çš„æ”¶æ•›é€Ÿåº¦æ— æ³•ä¿è¯ã€‚ 4.2 distributed Solving Method In recent years, the distributed solving method has received more and more attention and development, and it has become one of the mainstream methods of task allocation and solution in the current UAV swarm coalition (Yang et al., 2022). The main research idea of the distributed solving method can be summarized as follows: complete the computing and decision-making of the coalition in single UAVs based on the autonomous ability of those UAVs and seek a solution for conflict coordination of task allocation through the cooperation between UAVs, so as to improve the calculation speed and efficiency. Compared with the centralized method with a large computing load in the central node, the distributed method can overcome that shortcoming, and the real-time performance is relatively good. However, due to the need for multiple rounds of information collaboration, with the increase of the task scale and the number of UAVs, the communication overhead is large, and the requirements for the communication transmission capacity of the platform are high. At present, the more popular distributed solving methods are mainly two market-mechanism-based methods, namely, the contract net protocol (Smith, 1980; Zhai et al., 2021) and the auction algorithm (Chen, Wei, & Xu, 2014; Di et al., 2013; Ng et al., 2020). è¿‘å¹´æ¥ï¼Œåˆ†å¸ƒå¼æ±‚è§£æ–¹æ³•å—åˆ°è¶Šæ¥è¶Šå¤šçš„å…³æ³¨å’Œå‘å±•ï¼Œå·²æˆä¸ºå½“å‰æ— äººæœºé›†ç¾¤è”ç›Ÿä»»åŠ¡åˆ†é…ä¸æ±‚è§£çš„ä¸»æµæ–¹æ³•ä¹‹ä¸€ï¼ˆYang ç­‰ï¼Œ2022ï¼‰ã€‚åˆ†å¸ƒå¼æ±‚è§£æ–¹æ³•çš„ä¸»è¦ç ”ç©¶æ€è·¯å¯ä»¥æ¦‚æ‹¬ä¸ºï¼šåŸºäºå•æ¶æ— äººæœºçš„è‡ªä¸»èƒ½åŠ›ï¼Œåœ¨å•æœºå†…å®Œæˆè”ç›Ÿçš„è®¡ç®—ä¸å†³ç­–ï¼Œå¹¶é€šè¿‡æ— äººæœºä¹‹é—´çš„åä½œå®ç°ä»»åŠ¡åˆ†é…å†²çªåè°ƒçš„æ±‚è§£ï¼Œä»è€Œæé«˜è®¡ç®—é€Ÿåº¦å’Œæ•ˆç‡ã€‚ä¸é›†ä¸­å¼æ–¹æ³•åœ¨ä¸­å¿ƒèŠ‚ç‚¹è®¡ç®—è´Ÿè½½å¤§çš„ç¼ºç‚¹ç›¸æ¯”ï¼Œåˆ†å¸ƒå¼æ–¹æ³•èƒ½å¤Ÿå…‹æœè¿™ä¸€ä¸è¶³ï¼Œä¸”å®æ—¶æ€§è¾ƒå¥½ã€‚ç„¶è€Œï¼Œç”±äºéœ€è¦è¿›è¡Œå¤šè½®ä¿¡æ¯åä½œï¼Œéšç€ä»»åŠ¡è§„æ¨¡å’Œæ— äººæœºæ•°é‡çš„å¢åŠ ï¼Œé€šä¿¡å¼€é”€è¾ƒå¤§ï¼Œå¯¹å¹³å°çš„é€šä¿¡ä¼ è¾“èƒ½åŠ›è¦æ±‚è¾ƒé«˜ã€‚ç›®å‰è¾ƒä¸ºæµè¡Œçš„åˆ†å¸ƒå¼æ±‚è§£æ–¹æ³•ä¸»è¦æ˜¯ä¸¤ç§åŸºäºå¸‚åœºæœºåˆ¶çš„ç®—æ³•ï¼Œå³åˆåŒç½‘åè®®ï¼ˆSmithï¼Œ1980ï¼›Zhai ç­‰ï¼Œ2021ï¼‰å’Œæ‹å–ç®—æ³•ï¼ˆChenã€Wei å’Œ Xuï¼Œ2014ï¼›Di ç­‰ï¼Œ2013ï¼›Ng ç­‰ï¼Œ2020ï¼‰ã€‚ 4.2.1 Contract Network Protocol The contract network protocol (CNP), as a negotiation-oriented task allocation and cooperation mechanism, realizes task allocation, dynamic adjustment, and transfer by imitating the \"inviting a bid - submitting a bid - winning a bid - signing a contract\" mechanism in an economic act. When an agent does not have enough ability to process the current task or when it generates a new task through task decomposition, the bidding information is released, and other agents bid according to their own ability. CNP adopts the method of task bidding, takes the bid value as the control variable of task allocation among the agents, and realizes the dynamic allocation and adjustment of tasks through mutual negotiation and competition. The concept of CNP was first proposed by Smith in 1980 and has been widely used for research in the military field (Qian et al., 2011; Wu, 2017; Atkinson, 2003; Oh et al., 2017; Liu et al., 2010; Liu et al., 2016). åˆåŒç½‘åè®®ï¼ˆCNPï¼‰ä½œä¸ºä¸€ç§é¢å‘åå•†çš„ä»»åŠ¡åˆ†é…ä¸åä½œæœºåˆ¶ï¼Œé€šè¿‡æ¨¡ä»¿ç»æµè¡Œä¸ºä¸­çš„â€œæ‹›æ ‡-æŠ•æ ‡-ä¸­æ ‡-ç­¾è®¢åˆåŒâ€æœºåˆ¶ï¼Œå®ç°ä»»åŠ¡åˆ†é…ã€åŠ¨æ€è°ƒæ•´å’Œè½¬ç§»ã€‚å½“æŸä¸ªä»£ç†æ²¡æœ‰è¶³å¤Ÿèƒ½åŠ›å¤„ç†å½“å‰ä»»åŠ¡æˆ–é€šè¿‡ä»»åŠ¡åˆ†è§£ç”Ÿæˆæ–°ä»»åŠ¡æ—¶ï¼Œä¼šå‘å¸ƒæ‹›æ ‡ä¿¡æ¯ï¼Œå…¶ä»–ä»£ç†æ ¹æ®è‡ªèº«èƒ½åŠ›è¿›è¡ŒæŠ•æ ‡ã€‚CNP é‡‡ç”¨ä»»åŠ¡æ‹›æ ‡çš„æ–¹å¼ï¼Œä»¥æŠ•æ ‡å€¼ä½œä¸ºä»£ç†é—´ä»»åŠ¡åˆ†é…çš„æ§åˆ¶å˜é‡ï¼Œé€šè¿‡ç›¸äº’åå•†ä¸ç«äº‰å®ç°ä»»åŠ¡çš„åŠ¨æ€åˆ†é…ä¸è°ƒæ•´ã€‚CNP çš„æ¦‚å¿µæœ€æ—©ç”± Smith äº 1980 å¹´æå‡ºï¼Œå¹¶å·²åœ¨å†›äº‹é¢†åŸŸå¾—åˆ°å¹¿æ³›åº”ç”¨ï¼ˆQian ç­‰ï¼Œ2011ï¼›Wuï¼Œ2017ï¼›Atkinsonï¼Œ2003ï¼›Oh ç­‰ï¼Œ2017ï¼›Liu ç­‰ï¼Œ2010ï¼›Liu ç­‰ï¼Œ2016ï¼‰ã€‚ Alighanbari and How (2005) aimed at heterogeneous UAVs' collaborative search and strike tasks. The idea of a contract network was adopted to improve the coalition formation mechanism, so as to dynamically form coalitions. This method has high allocation efficiency and good real-time performance and is suitable for the rapid allocation of dynamic tasks in a large-scale, uncertain environment. However, due to the strong dependence of a large number of negotiation requirements on the communication status, the communication system load is large. The solution results have a great relationship with the internal negotiation mechanism, so it is difficult to evaluate the quality of the solution. Zhang (2016) solved the problem of dynamic formation coalition generation by using the contract net protocol and proposed an improved contract net protocol based on trust and restricted the minimum structural adjustment to adapt to changes in the battlefield environment. In order to meet the operational requirements of an aviation cluster to be flexible, highly coupled, multi-task, and multi-target, Zhu et al. (2019) presented a method of coalition formation with low traffic requirements to solve the problem of too much global negotiation information in the classical contract network protocol. This method effectively improves the quality of the solution by designing a hybrid multi-layer interactive network structure suitable for the aviation cluster and improving the bidding process of the classical contract network. Chen et al. (2021) put forward a distributed multiUAV task allocation method based on a contract network. This method can make each UAV in the coalition consume resources in a more balanced way under the constraints of communication distance and time delay, but it can only provide a solution for task allocation in the local sense. Alighanbari å’Œ Howï¼ˆ2005ï¼‰é’ˆå¯¹å¼‚æ„æ— äººæœºçš„ååŒæœç´¢ä¸æ‰“å‡»ä»»åŠ¡ï¼Œé‡‡ç”¨äº†åˆåŒç½‘çš„æ€æƒ³æ¥æ”¹è¿›è”ç›Ÿå½¢æˆæœºåˆ¶ï¼Œä»¥å®ç°åŠ¨æ€è”ç›Ÿçš„å½¢æˆã€‚è¯¥æ–¹æ³•å…·æœ‰è¾ƒé«˜çš„åˆ†é…æ•ˆç‡å’Œè‰¯å¥½çš„å®æ—¶æ€§èƒ½ï¼Œé€‚ç”¨äºå¤§è§„æ¨¡ä¸ç¡®å®šç¯å¢ƒä¸­åŠ¨æ€ä»»åŠ¡çš„å¿«é€Ÿåˆ†é…ã€‚ç„¶è€Œï¼Œç”±äºå¤§é‡åå•†éœ€æ±‚å¯¹é€šä¿¡çŠ¶æ€çš„å¼ºä¾èµ–æ€§ï¼Œé€šä¿¡ç³»ç»Ÿè´Ÿè½½è¾ƒå¤§ï¼Œä¸”æ±‚è§£ç»“æœä¸å†…éƒ¨åå•†æœºåˆ¶å¯†åˆ‡ç›¸å…³ï¼Œå› æ­¤éš¾ä»¥è¯„ä¼°æ±‚è§£è´¨é‡ã€‚Zhangï¼ˆ2016ï¼‰åˆ©ç”¨åˆåŒç½‘åè®®è§£å†³äº†åŠ¨æ€è”ç›Ÿç”Ÿæˆé—®é¢˜ï¼Œå¹¶æå‡ºäº†ä¸€ç§åŸºäºä¿¡ä»»çš„æ”¹è¿›åˆåŒç½‘åè®®ï¼Œé€šè¿‡é™åˆ¶æœ€å°ç»“æ„è°ƒæ•´ä»¥é€‚åº”æˆ˜åœºç¯å¢ƒçš„å˜åŒ–ã€‚ ä¸ºäº†æ»¡è¶³èˆªç©ºé›†ç¾¤çµæ´»ã€é«˜è€¦åˆã€å¤šä»»åŠ¡ã€å¤šç›®æ ‡çš„ä½œæˆ˜éœ€æ±‚ï¼ŒZhu ç­‰ï¼ˆ2019ï¼‰æå‡ºäº†ä¸€ç§ä½é€šä¿¡æµé‡éœ€æ±‚çš„è”ç›Ÿå½¢æˆæ–¹æ³•ï¼Œä»¥è§£å†³ç»å…¸åˆåŒç½‘åè®®ä¸­å…¨å±€åå•†ä¿¡æ¯è¿‡å¤šçš„é—®é¢˜ã€‚è¯¥æ–¹æ³•é€šè¿‡è®¾è®¡é€‚åˆèˆªç©ºé›†ç¾¤çš„æ··åˆå¤šå±‚äº¤äº’ç½‘ç»œç»“æ„å¹¶æ”¹è¿›ç»å…¸åˆåŒç½‘çš„æŠ•æ ‡æµç¨‹ï¼Œæœ‰æ•ˆæé«˜äº†æ±‚è§£è´¨é‡ã€‚Chen ç­‰ï¼ˆ2021ï¼‰æå‡ºäº†ä¸€ç§åŸºäºåˆåŒç½‘çš„åˆ†å¸ƒå¼å¤šæ— äººæœºä»»åŠ¡åˆ†é…æ–¹æ³•ã€‚è¯¥æ–¹æ³•èƒ½å¤Ÿåœ¨é€šä¿¡è·ç¦»å’Œæ—¶é—´å»¶è¿Ÿçš„çº¦æŸä¸‹ï¼Œä½¿è”ç›Ÿä¸­çš„æ¯æ¶æ— äººæœºæ›´å‡è¡¡åœ°æ¶ˆè€—èµ„æºï¼Œä½†åªèƒ½æä¾›å±€éƒ¨æ„ä¹‰ä¸Šçš„ä»»åŠ¡åˆ†é…è§£å†³æ–¹æ¡ˆã€‚ 4.2.2 Auction Algorithm The auction algorithm (Tang et al., 2010) is important for solving task allocation problems in dynamic environments. An auction mainly consists of elements such as UAV, task, revenue function, and cost. UAV assigns tasks by way of bidding, and the highest bidder gets the task. The auction algorithm has the advantages of clear rules and easy operation. However, in order to prevent the information delay when bidders bid to the auctioneer and obtain the optimal task allocation results, the auction process must be transmitted in the same network environment. Scholars have made a lot of improvements on the shortcomings of the auction algorithm and have successfully applied it to the task allocation of UAVs, robots, and other agents (Fu et al., 2019; Buckman, 2018; Kim et al., 2014). In order to solve the problem of coalition formation of manned-unmanned combat agents in cooperative task execution, Wan et al. (2013) designed a coalition formation strategy of \"task grouping first and then agent matching task group\" based on an auction mechanism. This method efficiently forms the coalition and reasonably assigns the formed coalition to tasks. æ‹å–ç®—æ³•ï¼ˆTang ç­‰ï¼Œ2010ï¼‰åœ¨åŠ¨æ€ç¯å¢ƒä¸­çš„ä»»åŠ¡åˆ†é…é—®é¢˜ä¸­å…·æœ‰é‡è¦æ„ä¹‰ã€‚æ‹å–ä¸»è¦ç”±æ— äººæœºã€ä»»åŠ¡ã€æ”¶ç›Šå‡½æ•°å’Œæˆæœ¬ç­‰è¦ç´ ç»„æˆã€‚æ— äººæœºé€šè¿‡æŠ•æ ‡æ–¹å¼åˆ†é…ä»»åŠ¡ï¼Œå‡ºä»·æœ€é«˜è€…è·å¾—ä»»åŠ¡ã€‚æ‹å–ç®—æ³•å…·æœ‰è§„åˆ™æ¸…æ™°ã€æ“ä½œç®€ä¾¿çš„ä¼˜ç‚¹ã€‚ç„¶è€Œï¼Œä¸ºé˜²æ­¢æŠ•æ ‡è€…å‘æ‹å–è€…æŠ•æ ‡æ—¶çš„ä¿¡æ¯å»¶è¿Ÿå¹¶è·å¾—æœ€ä¼˜ä»»åŠ¡åˆ†é…ç»“æœï¼Œæ‹å–è¿‡ç¨‹å¿…é¡»åœ¨åŒä¸€ç½‘ç»œç¯å¢ƒä¸­ä¼ è¾“ã€‚å­¦è€…ä»¬å¯¹æ‹å–ç®—æ³•çš„ä¸è¶³è¿›è¡Œäº†å¤§é‡æ”¹è¿›ï¼Œå¹¶æˆåŠŸåº”ç”¨äºæ— äººæœºã€æœºå™¨äººç­‰ä»£ç†çš„ä»»åŠ¡åˆ†é…ä¸­ï¼ˆFu ç­‰ï¼Œ2019ï¼›Buckmanï¼Œ2018ï¼›Kim ç­‰ï¼Œ2014ï¼‰ã€‚ä¸ºè§£å†³æœ‰äºº-æ— äººä½œæˆ˜ä»£ç†åœ¨ååŒä»»åŠ¡æ‰§è¡Œä¸­çš„è”ç›Ÿå½¢æˆé—®é¢˜ï¼ŒWan ç­‰ï¼ˆ2013ï¼‰è®¾è®¡äº†ä¸€ç§åŸºäºæ‹å–æœºåˆ¶çš„â€œä»»åŠ¡åˆ†ç»„ä¼˜å…ˆï¼Œä»£ç†åŒ¹é…ä»»åŠ¡ç»„â€çš„è”ç›Ÿå½¢æˆç­–ç•¥ã€‚è¯¥æ–¹æ³•é«˜æ•ˆåœ°å½¢æˆäº†è”ç›Ÿï¼Œå¹¶å°†å½¢æˆçš„è”ç›Ÿåˆç†åˆ†é…ç»™ä»»åŠ¡ã€‚ Aiming at the problem of dynamic task assignment of multi-UAV agent alliances, Chen, Yao, et al. (2014) proposed a dynamic target allocation method for multi-UAV cooperative operations based on a distributed auction mechanism. Wan et al. (2015) used the auction algorithm to solve the alliance problem of manned and unmanned combat agents, but the model lacked time constraints such as task completion time limit. Wu (2018) put forward a task re-allocation method based on the supervised sequential auction mechanism. For new tasks in the battlefield environment, the auction sequence is randomly generated by the auctioneer, and each UAV sequentially bids to select tasks until all bursts are selected. é’ˆå¯¹å¤šæ— äººæœºä»£ç†è”ç›Ÿçš„åŠ¨æ€ä»»åŠ¡åˆ†é…é—®é¢˜ï¼ŒChenã€Yao ç­‰ï¼ˆ2014ï¼‰æå‡ºäº†ä¸€ç§åŸºäºåˆ†å¸ƒå¼æ‹å–æœºåˆ¶çš„å¤šæ— äººæœºååŒä½œæˆ˜åŠ¨æ€ç›®æ ‡åˆ†é…æ–¹æ³•ã€‚Wan ç­‰ï¼ˆ2015ï¼‰åˆ©ç”¨æ‹å–ç®—æ³•è§£å†³äº†æœ‰äººä¸æ— äººä½œæˆ˜ä»£ç†çš„è”ç›Ÿé—®é¢˜ï¼Œä½†æ¨¡å‹ç¼ºä¹ä»»åŠ¡å®Œæˆæ—¶é™ç­‰æ—¶é—´çº¦æŸã€‚Wuï¼ˆ2018ï¼‰æå‡ºäº†ä¸€ç§åŸºäºç›‘ç£é¡ºåºæ‹å–æœºåˆ¶çš„ä»»åŠ¡é‡æ–°åˆ†é…æ–¹æ³•ã€‚å¯¹äºæˆ˜åœºç¯å¢ƒä¸­çš„æ–° 4.2.3 Other Distributed Algorithms In addition to the auction algorithm, the contract network algorithm, and their improvement methods, other distributed algorithms have been applied to solve the formation of UAV swarm coalitions. Zheng et al. (2022) proposed a distributed coalition formation method based on a Monte Carlo tree search for the distributed coalition formation problem of heterogeneous UAV swarms in unknown dynamic environments. This method designed a coalition task automaton and optimized the coalition structure through a two-stage Monte Carlo tree search, which can effectively seek a solution for large-scale distributed coalition formation problems. To sum up, the distributed solution method forms an optimal coalition by communication negotiation to address all the problems, which can better meet the needs of fast task allocation in a dynamic uncertainty environment. However, the UAV swarm adopts an explicit communication method, which has a strong dependence on communication. When the UAV swarm is large in size, the system communication load is heavy correspondingly. é™¤äº†æ‹å–ç®—æ³•ã€åˆåŒç½‘ç®—æ³•åŠå…¶æ”¹è¿›æ–¹æ³•å¤–ï¼Œå…¶ä»–åˆ†å¸ƒå¼ç®—æ³•ä¹Ÿè¢«åº”ç”¨äºè§£å†³æ— äººæœºé›†ç¾¤è”ç›Ÿçš„å½¢æˆé—®é¢˜ã€‚Zheng ç­‰ï¼ˆ2022ï¼‰é’ˆå¯¹æœªçŸ¥åŠ¨æ€ç¯å¢ƒä¸­å¼‚æ„æ— äººæœºé›†ç¾¤çš„åˆ†å¸ƒå¼è”ç›Ÿå½¢æˆé—®é¢˜ï¼Œæå‡ºäº†ä¸€ç§åŸºäºè’™ç‰¹å¡æ´›æ ‘æœç´¢çš„åˆ†å¸ƒå¼è”ç›Ÿå½¢æˆæ–¹æ³•ã€‚è¯¥æ–¹æ³•è®¾è®¡äº†è”ç›Ÿä»»åŠ¡è‡ªåŠ¨æœºï¼Œå¹¶é€šè¿‡ä¸¤é˜¶æ®µè’™ç‰¹å¡æ´›æ ‘æœç´¢ä¼˜åŒ–è”ç›Ÿç»“æ„ï¼Œèƒ½å¤Ÿæœ‰æ•ˆæ±‚è§£å¤§è§„æ¨¡åˆ†å¸ƒå¼è”ç›Ÿå½¢æˆé—®é¢˜ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼Œåˆ†å¸ƒå¼æ±‚è§£æ–¹æ³•é€šè¿‡é€šä¿¡åå•†å½¢æˆæœ€ä¼˜è”ç›Ÿä»¥è§£å†³é—®é¢˜ï¼Œèƒ½å¤Ÿæ›´å¥½åœ°æ»¡è¶³åŠ¨æ€ä¸ç¡®å®šç¯å¢ƒä¸­å¿«é€Ÿä»»åŠ¡åˆ†é…çš„éœ€æ±‚ã€‚ç„¶è€Œï¼Œæ— äººæœºé›†ç¾¤é‡‡ç”¨æ˜¾å¼é€šä¿¡æ–¹å¼ï¼Œå¯¹é€šä¿¡çš„ä¾èµ–æ€§è¾ƒå¼ºï¼Œå½“æ— äººæœºé›†ç¾¤è§„æ¨¡è¾ƒå¤§æ—¶ï¼Œç³»ç»Ÿé€šä¿¡è´Ÿè½½ç›¸åº”è¾ƒé‡ã€‚ 4.3 Comparison of Solution Methods for Coalition Task Allocation Based on the relevant research at home and abroad, it is found that for the task allocation problem of the UAV swarm coalition, two methods are mainly used: the centralized solution method and the distributed solution method. The centralized solution method has fast convergence speed and high solution accuracy with low requirements on objective function features. Compared with the centralized method with a large computing load in the central node, the distributed method can overcome that shortcoming and has fast speed, high efficiency, and relatively good real-time performance. Table 2 specifically compares and analyzes the advantages and disadvantages of the commonly used task allocation solution methods for UAV swarm coalition. åŸºäºå›½å†…å¤–çš„ç›¸å…³ç ”ç©¶ï¼Œå‘ç°é’ˆå¯¹æ— äººæœºé›†ç¾¤è”ç›Ÿçš„ä»»åŠ¡åˆ†é…é—®é¢˜ï¼Œä¸»è¦é‡‡ç”¨ä¸¤ç§æ–¹æ³•ï¼šé›†ä¸­å¼æ±‚è§£æ–¹æ³•å’Œåˆ†å¸ƒå¼æ±‚è§£æ–¹æ³•ã€‚é›†ä¸­å¼æ±‚è§£æ–¹æ³•å…·æœ‰æ”¶æ•›é€Ÿåº¦å¿«ã€æ±‚è§£ç²¾åº¦é«˜çš„ç‰¹ç‚¹ï¼Œä¸”å¯¹ç›®æ ‡å‡½æ•°ç‰¹å¾çš„è¦æ±‚è¾ƒä½ã€‚ä¸é›†ä¸­å¼æ–¹æ³•åœ¨ä¸­å¿ƒèŠ‚ç‚¹è®¡ç®—è´Ÿè½½å¤§çš„ç¼ºç‚¹ç›¸æ¯”ï¼Œåˆ†å¸ƒå¼æ–¹æ³•èƒ½å¤Ÿå…‹æœè¿™ä¸€ä¸è¶³ï¼Œå…·æœ‰é€Ÿåº¦å¿«ã€æ•ˆç‡é«˜å’Œå®æ—¶æ€§è¾ƒå¥½çš„ä¼˜åŠ¿ã€‚è¡¨ 2 å…·ä½“å¯¹æ¯”åˆ†æäº†æ— äººæœºé›†ç¾¤è”ç›Ÿå¸¸ç”¨ä»»åŠ¡åˆ†é…æ±‚è§£æ–¹æ³•çš„ä¼˜ç¼ºç‚¹ã€‚ Table 2. Comparison of commonly used solution methods for UAV swarm coalition task allocation æ–¹æ³• ä¼˜ç‚¹ ç¼ºç‚¹ é›†ä¸­å¼æ±‚è§£æ–¹æ³• 1. æ”¶æ•›é€Ÿåº¦å¿«ï¼Œæ±‚è§£ç²¾åº¦é«˜ã€‚2. å¯¹ç›®æ ‡å‡½æ•°ç‰¹å¾è¦æ±‚ä½ã€‚ 1. ä¸­å¿ƒèŠ‚ç‚¹è®¡ç®—è´Ÿè½½å¤§ã€‚2. å¯¹é€šä¿¡ä¾èµ–æ€§å¼ºï¼Œå¤§è§„æ¨¡ä»»åŠ¡æ—¶å®æ—¶æ€§è¾ƒå·®ã€‚ åˆ†å¸ƒå¼æ±‚è§£æ–¹æ³• 1. è®¡ç®—è´Ÿè½½åˆ†æ•£ï¼Œé€Ÿåº¦å¿«ã€æ•ˆç‡é«˜ã€‚2. å®æ—¶æ€§è¾ƒå¥½ï¼Œé€‚åˆåŠ¨æ€ç¯å¢ƒã€‚ 1. éœ€è¦å¤šè½®ä¿¡æ¯åä½œï¼Œé€šä¿¡å¼€é”€å¤§ã€‚2. å¯¹é€šä¿¡ä¼ è¾“èƒ½åŠ›è¦æ±‚è¾ƒé«˜ã€‚ é€šè¿‡å¯¹æ¯”å¯ä»¥çœ‹å‡ºï¼Œé›†ä¸­å¼æ–¹æ³•é€‚åˆå°è§„æ¨¡ä»»åŠ¡æˆ–å¯¹å®æ—¶æ€§è¦æ±‚ä¸é«˜çš„åœºæ™¯ï¼Œè€Œåˆ†å¸ƒå¼æ–¹æ³•æ›´é€‚åˆå¤§è§„æ¨¡ä»»åŠ¡å’ŒåŠ¨æ€ç¯å¢ƒä¸‹çš„å®æ—¶ä»»åŠ¡åˆ†é…ã€‚ä¸¤ç§æ–¹æ³•å„æœ‰ä¼˜åŠ£ï¼Œå®é™…åº”ç”¨ä¸­éœ€æ ¹æ®å…·ä½“ä»»åŠ¡éœ€æ±‚å’Œç¯å¢ƒç‰¹ç‚¹é€‰æ‹©åˆé€‚çš„æ–¹æ³•ã€‚ Future Research Directions æœªæ¥ç ”ç©¶æ–¹å‘ At present, there are many solutions to task allocation for a UAV swarm coalition, and a large number of research results have been achieved. However, the following problems still need to be solved: The research on temporal constraints is not deep enough. With the continuous development of ground air defense weapons, the cooperative execution time of combat tasks by multi-UAVs is more restricted, and the \"finishing tasks within a limited amount of time\" feature is continuously enhanced. At the same time, for complex combat tasks, it is usually necessary to conduct reconnaissance of the surrounding areas of the target in advance and complete the ground attack after the target characteristics are confirmed. Therefore, there are time constraints between tasks, and certain execution times should be allocated for each task. However, the current related research does not fully consider the task timing constraints and execution time window (\"finishing tasks within a limited amount of time\" feature) and lacks research on the dynamic task allocation of the multi-UAV coalition under the timing coupling relationship and time window constraints. The communication mechanism needs to be further optimized. When heterogeneous UAV swarms form a coalition, UAVs need to carry out information interaction, which happens through the wireless communication network built by the multiple UAVs themselves. Therefore, the highspeed movement of UAVs, the limited communication capability of single UAVs, and the dynamic change of the topology of the UAV network will cause the network connectivity of local areas to be unable to meet the requirements of dynamic tasks, that is, the communication constraints such as communication distance and communication delay between UAVs will affect the formation of coalitions among heterogeneous UAV swarm. Under the constraints of communication distance and communication delay, how to establish optimal coalitions by using a coalition mechanism for UAV swarm task allocation demands further research. Insufficient consideration of swarm heterogeneity. At present, the research focus on coalition formation in the field of artificial intelligence is mainly on the formation of homogeneous agent coalitions. The research on the dynamic coalition formation of heterogeneous UAV swarms has started, but it is still in its infancy. The existing coalition methods are mostly simple task cooperation of homogeneous UAVs, distributed coalition formation of heterogeneous UAV swarms in the form of fixed teams, and centralized coalition formation of heterogeneous UAV swarms aiming at complex tasks. However, the problem of dynamic coalition formation of distributed heterogeneous UAV swarm in complex networks has received less attention and research, and there is no flexible and effective solution yet. The coalition formation methods are not practical enough. Firstly, most of the existing coalition formation methods adopt the \"single-target coalition\" model, which is high in coalition formation cost but low in task efficiency. Secondly, in order to adapt to the needs of the dynamic environment, the formation of coalitions usually adopts the step-by-step solution, which increases the intermediate links, and the results are often far from the optimal solution set. Thirdly, most of the existing coalition formation methods are deployed centrally, which makes it difficult to real-time process complex coalition formation problems. Less consideration is given to task allocation with inadequate resources. Currently, the main purpose of task allocation is to minimize the total cost, mostly assuming that UAV swarms have the autonomy to finish tasks and possess sufficient capacity to complete all tasks. However, in reality, UAV swarms may not always have adequate resources and capabilities to complete every task, not to mention tasks are constantly changing. In the task execution process, if the number of UAVs is insufficient, the existing methods may not be able to form a coalition under the condition that the resources do not fully meet the task conditions, resulting in the inability to carry out the current task. ç›®å‰ï¼Œé’ˆå¯¹æ— äººæœºé›†ç¾¤è”ç›Ÿä»»åŠ¡åˆ†é…çš„è§£å†³æ–¹æ¡ˆå·²æœ‰è®¸å¤šï¼Œå¹¶å–å¾—äº†å¤§é‡çš„ç ”ç©¶æˆæœã€‚ç„¶è€Œï¼Œä»¥ä¸‹é—®é¢˜ä»éœ€è§£å†³ï¼š æ—¶é—´çº¦æŸç ”ç©¶ä¸å¤Ÿæ·±å…¥ã€‚éšç€åœ°é¢é˜²ç©ºæ­¦å™¨çš„ä¸æ–­å‘å±•ï¼Œå¤šæ— äººæœºååŒæ‰§è¡Œä½œæˆ˜ä»»åŠ¡çš„æ—¶é—´é™åˆ¶æ›´åŠ ä¸¥æ ¼ï¼Œâ€œæœ‰é™æ—¶é—´å†…å®Œæˆä»»åŠ¡â€çš„ç‰¹æ€§ä¸æ–­å¢å¼ºã€‚åŒæ—¶ï¼Œå¯¹äºå¤æ‚çš„ä½œæˆ˜ä»»åŠ¡ï¼Œé€šå¸¸éœ€è¦æå‰å¯¹ç›®æ ‡å‘¨è¾¹åŒºåŸŸè¿›è¡Œä¾¦å¯Ÿï¼Œå¹¶åœ¨ç¡®è®¤ç›®æ ‡ç‰¹å¾åå®Œæˆåœ°é¢æ”»å‡»ã€‚å› æ­¤ï¼Œä»»åŠ¡ä¹‹é—´å­˜åœ¨æ—¶é—´çº¦æŸï¼Œä¸”éœ€è¦ä¸ºæ¯ä¸ªä»»åŠ¡åˆ†é…ä¸€å®šçš„æ‰§è¡Œæ—¶é—´ã€‚ç„¶è€Œï¼Œå½“å‰çš„ç›¸å…³ç ”ç©¶å¹¶æœªå……åˆ†è€ƒè™‘ä»»åŠ¡æ—¶åºçº¦æŸå’Œæ‰§è¡Œæ—¶é—´çª—å£ï¼ˆâ€œæœ‰é™æ—¶é—´å†…å®Œæˆä»»åŠ¡â€çš„ç‰¹æ€§ï¼‰ï¼Œç¼ºä¹åœ¨æ—¶åºè€¦åˆå…³ç³»å’Œæ—¶é—´çª—å£çº¦æŸä¸‹å¤šæ— äººæœºè”ç›ŸåŠ¨æ€ä»»åŠ¡åˆ†é…çš„ç ”ç©¶ã€‚ é€šä¿¡æœºåˆ¶éœ€è¿›ä¸€æ­¥ä¼˜åŒ–ã€‚å½“å¼‚æ„æ— äººæœºé›†ç¾¤å½¢æˆè”ç›Ÿæ—¶ï¼Œæ— äººæœºéœ€è¦é€šè¿‡è‡ªèº«æ„å»ºçš„æ— çº¿é€šä¿¡ç½‘ç»œè¿›è¡Œä¿¡æ¯äº¤äº’ã€‚ç„¶è€Œï¼Œæ— äººæœºçš„é«˜é€Ÿç§»åŠ¨ã€å•æœºé€šä¿¡èƒ½åŠ›æœ‰é™ä»¥åŠæ— äººæœºç½‘ç»œæ‹“æ‰‘çš„åŠ¨æ€å˜åŒ–ï¼Œå¯èƒ½å¯¼è‡´å±€éƒ¨åŒºåŸŸçš„ç½‘ç»œè¿æ¥æ— æ³•æ»¡è¶³åŠ¨æ€ä»»åŠ¡çš„éœ€æ±‚ï¼Œå³æ— äººæœºä¹‹é—´çš„é€šä¿¡è·ç¦»å’Œé€šä¿¡å»¶è¿Ÿç­‰é€šä¿¡çº¦æŸä¼šå½±å“å¼‚æ„æ— äººæœºé›†ç¾¤è”ç›Ÿçš„å½¢æˆã€‚åœ¨é€šä¿¡è·ç¦»å’Œé€šä¿¡å»¶è¿Ÿçš„çº¦æŸä¸‹ï¼Œå¦‚ä½•åˆ©ç”¨è”ç›Ÿæœºåˆ¶ä¸ºæ— äººæœºé›†ç¾¤ä»»åŠ¡åˆ†é…å»ºç«‹æœ€ä¼˜è”ç›Ÿï¼Œä»éœ€è¿›ä¸€æ­¥ç ”ç©¶ã€‚ é›†ç¾¤å¼‚æ„æ€§è€ƒè™‘ä¸è¶³ã€‚ç›®å‰ï¼Œäººå·¥æ™ºèƒ½é¢†åŸŸå…³äºè”ç›Ÿå½¢æˆçš„ç ”ç©¶ä¸»è¦é›†ä¸­åœ¨åŒè´¨ä»£ç†è”ç›Ÿçš„å½¢æˆä¸Šã€‚å¼‚æ„æ— äººæœºé›†ç¾¤çš„åŠ¨æ€è”ç›Ÿå½¢æˆç ”ç©¶è™½å·²èµ·æ­¥ï¼Œä½†ä»å¤„äºåˆæœŸé˜¶æ®µã€‚ç°æœ‰çš„è”ç›Ÿæ–¹æ³•å¤šä¸ºåŒè´¨æ— äººæœºçš„ç®€å•ä»»åŠ¡åä½œã€å›ºå®šç¼–é˜Ÿå½¢å¼çš„å¼‚æ„æ— äººæœºé›†ç¾¤åˆ†å¸ƒå¼è”ç›Ÿå½¢æˆï¼Œä»¥åŠé’ˆå¯¹å¤æ‚ä»»åŠ¡çš„å¼‚æ„æ— äººæœºé›†ç¾¤é›†ä¸­å¼è”ç›Ÿå½¢æˆã€‚ç„¶è€Œï¼Œå¤æ‚ç½‘ç»œä¸­åˆ†å¸ƒå¼å¼‚æ„æ— äººæœºé›†ç¾¤çš„åŠ¨æ€è”ç›Ÿå½¢æˆé—®é¢˜å—åˆ°çš„å…³æ³¨å’Œç ”ç©¶è¾ƒå°‘ï¼Œç›®å‰å°šæ— çµæ´»æœ‰æ•ˆçš„è§£å†³æ–¹æ¡ˆã€‚ è”ç›Ÿå½¢æˆæ–¹æ³•å®ç”¨æ€§ä¸è¶³ã€‚é¦–å…ˆï¼Œç°æœ‰çš„å¤§å¤šæ•°è”ç›Ÿå½¢æˆæ–¹æ³•é‡‡ç”¨â€œå•ç›®æ ‡è”ç›Ÿâ€æ¨¡å‹ï¼Œè”ç›Ÿå½¢æˆæˆæœ¬é«˜ä½†ä»»åŠ¡æ•ˆç‡ä½ã€‚å…¶æ¬¡ï¼Œä¸ºäº†é€‚åº”åŠ¨æ€ç¯å¢ƒçš„éœ€æ±‚ï¼Œè”ç›Ÿå½¢æˆé€šå¸¸é‡‡ç”¨é€æ­¥æ±‚è§£çš„æ–¹å¼ï¼Œå¢åŠ äº†ä¸­é—´ç¯èŠ‚ï¼Œç»“æœå¾€å¾€è¿œç¦»æœ€ä¼˜è§£é›†ã€‚ç¬¬ä¸‰ï¼Œç°æœ‰çš„å¤§å¤šæ•°è”ç›Ÿå½¢æˆæ–¹æ³•é‡‡ç”¨é›†ä¸­å¼éƒ¨ç½²ï¼Œéš¾ä»¥å®æ—¶å¤„ç†å¤æ‚çš„è”ç›Ÿå½¢æˆé—®é¢˜ã€‚ èµ„æºä¸è¶³çš„ä»»åŠ¡åˆ†é…è€ƒè™‘è¾ƒå°‘ã€‚ç›®å‰ï¼Œä»»åŠ¡åˆ†é…çš„ä¸»è¦ç›®çš„æ˜¯æœ€å°åŒ–æ€»æˆæœ¬ï¼Œå¤§å¤šå‡è®¾æ— äººæœºé›†ç¾¤å…·æœ‰å®Œæˆä»»åŠ¡æ‰€éœ€çš„è‡ªä¸»æ€§å’Œè¶³å¤Ÿçš„èƒ½åŠ›ã€‚ç„¶è€Œï¼Œç°å®ä¸­æ— äººæœºé›†ç¾¤å¯èƒ½å¹¶ä¸æ€»æ˜¯æ‹¥æœ‰è¶³å¤Ÿçš„èµ„æºå’Œèƒ½åŠ›æ¥å®Œæˆæ¯é¡¹ä»»åŠ¡ï¼Œæ›´ä½•å†µä»»åŠ¡è¿˜åœ¨ä¸æ–­å˜åŒ–ã€‚åœ¨ä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œå¦‚æœæ— äººæœºæ•°é‡ä¸è¶³ï¼Œç°æœ‰æ–¹æ³•å¯èƒ½æ— æ³•åœ¨èµ„æºä¸å®Œå…¨æ»¡è¶³ä»»åŠ¡æ¡ä»¶çš„æƒ…å†µä¸‹å½¢æˆè”ç›Ÿï¼Œå¯¼è‡´æ— æ³•æ‰§è¡Œå½“å‰ä»»åŠ¡ã€‚ In view of the deficiencies of current research, the methods to solve such problems can be researched in the following aspects: Comprehensively consider relevant constraints and enhance the feasibility of allocation results. First, comprehensively consider the complex practical constraints such as task timing, communication within the swarm, swarm resources, and execution time window, based on the reality of the tasks. Second, it is necessary to carefully analyze the result standard constraints in the process of task execution, for example, the balance of task execution, the efficiency of task completion, and the cost of task execution. Fully consider the heterogeneity of swarms and design a suitable coalition formation method. Increase the research on the task cooperation of heterogeneous UAVs and distributed coalition formation of heterogeneous UAV swarms in the form of flexible teams; focus on designing parallel and multi-task complex coalition formation methods around the requirements of high dynamic complex tasks, to ensure the efficient completion of diversified tasks. Improve the optimization performance of the algorithm and enhance the fast and accurate decision-making ability of the swarms. First, improve the optimization speed of centralized algorithms to ensure the speed of solutions and meet the needs of dynamic tasks. Second, improve the optimization accuracy of distributed algorithms in order to guarantee the accuracy of the results and avoid the waste of resources. Third, make clear the mapping relationship between the algorithm and the problem, give full play to the performance of the algorithm, and enhance the ability of independent decision-making of the system. é’ˆå¯¹å½“å‰ç ”ç©¶çš„ä¸è¶³ï¼Œå¯ä»¥ä»ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ç ”ç©¶è§£å†³æ­¤ç±»é—®é¢˜çš„æ–¹æ³•ï¼š ç»¼åˆè€ƒè™‘ç›¸å…³çº¦æŸï¼Œå¢å¼ºåˆ†é…ç»“æœçš„å¯è¡Œæ€§ã€‚é¦–å…ˆï¼ŒåŸºäºä»»åŠ¡ç°å®ï¼Œç»¼åˆè€ƒè™‘ä»»åŠ¡æ—¶åºã€é›†ç¾¤å†…éƒ¨é€šä¿¡ã€é›†ç¾¤èµ„æºå’Œæ‰§è¡Œæ—¶é—´çª—å£ç­‰å¤æ‚çš„å®é™…çº¦æŸã€‚å…¶æ¬¡ï¼Œéœ€è¦ä»”ç»†åˆ†æä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹ä¸­çš„ç»“æœæ ‡å‡†çº¦æŸï¼Œä¾‹å¦‚ä»»åŠ¡æ‰§è¡Œçš„å¹³è¡¡æ€§ã€ä»»åŠ¡å®Œæˆçš„æ•ˆç‡ä»¥åŠä»»åŠ¡æ‰§è¡Œçš„æˆæœ¬ã€‚ å……åˆ†è€ƒè™‘é›†ç¾¤çš„å¼‚æ„æ€§ï¼Œè®¾è®¡åˆé€‚çš„è”ç›Ÿå½¢æˆæ–¹æ³•ã€‚å¢åŠ å¯¹å¼‚æ„æ— äººæœºä»»åŠ¡åä½œå’Œçµæ´»ç¼–é˜Ÿå½¢å¼çš„å¼‚æ„æ— äººæœºé›†ç¾¤åˆ†å¸ƒå¼è”ç›Ÿå½¢æˆçš„ç ”ç©¶ï¼›å›´ç»•é«˜åŠ¨æ€å¤æ‚ä»»åŠ¡çš„éœ€æ±‚ï¼Œé‡ç‚¹è®¾è®¡å¹¶è¡Œå’Œå¤šä»»åŠ¡çš„å¤æ‚è”ç›Ÿå½¢æˆæ–¹æ³•ï¼Œä»¥ç¡®ä¿å¤šæ ·åŒ–ä»»åŠ¡çš„é«˜æ•ˆå®Œæˆã€‚ æé«˜ç®—æ³•çš„ä¼˜åŒ–æ€§èƒ½ï¼Œå¢å¼ºé›†ç¾¤çš„å¿«é€Ÿå‡†ç¡®å†³ç­–èƒ½åŠ›ã€‚é¦–å…ˆï¼Œæé«˜é›†ä¸­å¼ç®—æ³•çš„ä¼˜åŒ–é€Ÿåº¦ï¼Œç¡®ä¿æ±‚è§£é€Ÿåº¦ä»¥æ»¡è¶³åŠ¨æ€ä»»åŠ¡çš„éœ€æ±‚ã€‚å…¶æ¬¡ï¼Œæé«˜åˆ†å¸ƒå¼ç®—æ³•çš„ä¼˜åŒ–ç²¾åº¦ï¼Œä»¥ä¿è¯ç»“æœçš„å‡†ç¡®æ€§å¹¶é¿å…èµ„æºæµªè´¹ã€‚ç¬¬ä¸‰ï¼Œæ˜ç¡®ç®—æ³•ä¸é—®é¢˜ä¹‹é—´çš„æ˜ å°„å…³ç³»ï¼Œå……åˆ†å‘æŒ¥ç®—æ³•æ€§èƒ½ï¼Œå¢å¼ºç³»ç»Ÿçš„è‡ªä¸»å†³ç­–èƒ½åŠ›ã€‚ Conclusion This paper starts with the related work of UAV swarm coalition task allocation and introduces the basic concept, general model, and constraint index of task allocation for UAV swarm coalition. Then, from the perspective of the number of tasks performed by the same coalition, the coalition formation methods are divided into single-task coalition formation method and multi-task coalition formation method, and their specific content, research status, advantages, and disadvantages of these two methods are analyzed, respectively. Thirdly, from the two aspects of the centralized solution method and distributed solution method, the commonly used solution algorithms and current research on coalition task allocation are introduced, and the advantages and disadvantages of existing coalition formation solution algorithms are compared and analyzed. Finally, the specific problems existing in the current task allocation method of UAV swarm coalitions are summarized and analyzed, and future directions for research are suggested. This paper is of great significance for reference to fully understand the research of coalition task allocation of UAV swarm. æœ¬æ–‡ä»æ— äººæœºé›†ç¾¤è”ç›Ÿä»»åŠ¡åˆ†é…çš„ç›¸å…³å·¥ä½œå…¥æ‰‹ï¼Œä»‹ç»äº†æ— äººæœºé›†ç¾¤è”ç›Ÿä»»åŠ¡åˆ†é…çš„åŸºæœ¬æ¦‚å¿µã€é€šç”¨æ¨¡å‹å’Œçº¦æŸæŒ‡æ ‡ã€‚ éšåï¼Œä»åŒä¸€è”ç›Ÿæ‰§è¡Œä»»åŠ¡æ•°é‡çš„è§’åº¦ï¼Œå°†è”ç›Ÿå½¢æˆæ–¹æ³•åˆ†ä¸ºå•ä»»åŠ¡è”ç›Ÿå½¢æˆæ–¹æ³•å’Œå¤šä»»åŠ¡è”ç›Ÿå½¢æˆæ–¹æ³•ï¼Œå¹¶åˆ†åˆ«åˆ†æäº†è¿™ä¸¤ç§æ–¹æ³•çš„å…·ä½“å†…å®¹ã€ç ”ç©¶ç°çŠ¶ã€ä¼˜ç¼ºç‚¹ã€‚ æ¥ç€ï¼Œä»é›†ä¸­å¼æ±‚è§£æ–¹æ³•å’Œåˆ†å¸ƒå¼æ±‚è§£æ–¹æ³•ä¸¤ä¸ªæ–¹é¢ï¼Œä»‹ç»äº†å¸¸ç”¨çš„æ±‚è§£ç®—æ³•åŠå½“å‰è”ç›Ÿä»»åŠ¡åˆ†é…çš„ç ”ç©¶è¿›å±•ï¼Œå¹¶å¯¹ç°æœ‰è”ç›Ÿå½¢æˆæ±‚è§£ç®—æ³•çš„ä¼˜ç¼ºç‚¹è¿›è¡Œäº†å¯¹æ¯”åˆ†æã€‚ æœ€åï¼Œæ€»ç»“å¹¶åˆ†æäº†å½“å‰æ— äººæœºé›†ç¾¤è”ç›Ÿä»»åŠ¡åˆ†é…æ–¹æ³•ä¸­å­˜åœ¨çš„å…·ä½“é—®é¢˜ï¼Œå¹¶æå‡ºäº†æœªæ¥çš„ç ”ç©¶æ–¹å‘ã€‚ æœ¬æ–‡å¯¹å…¨é¢äº†è§£æ— äººæœºé›†ç¾¤è”ç›Ÿä»»åŠ¡åˆ†é…çš„ç ”ç©¶å…·æœ‰é‡è¦çš„å‚è€ƒæ„ä¹‰ã€‚ References Ahmadoun, D., Bonzon, E., Buron, C., Moraitis, P., SavÃ©ant, P., & Shehory, O. (2021, November). Decentralized coalition structure formation for interdependent tasks allocation. 33rd International Conference on Tools with Artificial Intelligence , 73-80. doi:10.1109/ICTAI52525.2021.00018 Alighanbari, M., & How, J. P. (2005, December). Decentralized task assignment for unmanned aerial vehicles. Proceedings of the 44th IEEE Conference on Decision and Control , 5668-5673. doi:10.1109/CDC.2005.1583066 Anderson, J., Tanner, B., & Baltes, J. (2004, December). Dynamic coalition formation in robotic soccer. Proceedings of the AAAI-04 Workshop on Forming and Maintaining Coalitions and Teams in Adaptive Multiagent Systems , 1-10. Atkinson, M. (2003). Contract nets for control of distributed agents in unmanned air vehicles. 2nd AIAA \"Unmanned Unlimited\" Conference and Workshop and Exhibit , 6532. Bayram, H., & Bozma, H. I. (2016). Coalition formation games for dynamic multirobot tasks. The International Journal of Robotics Research , 35 (5), 514-527. doi:10.1177/0278364915595707 Buckman, N. (2018). Decentralized task allocation for dynamic, time-sensitive tasks [Doctoral dissertation]. Massachusetts Institute of Technology. Butler, Z., & Hays, J. (2015). Task allocation for reconfigurable teams. Robotics and Autonomous Systems , 68 , 59-71. doi:10.1016/j.robot.2015.02.001 Chen, J., Yao, P., Tang, J., & Jia, F. (2014). Multi-UAV decentralized cooperative dynamic target assignment method. Journal of Air Force Engineering University , 15 (6), 11-16. Chen, P., Yan, F., Liu, Z., & Cheng, G. (2021). Heterogeneous unmanned aerial vehicles task allocation with communication constraints. Hangkong Xuebao , 42 (8), 313-326. Chen, X., Wei, X., & Xu, G. (2014). Multi-aircraft collaborative air combat decision based on distributed invitation auction algorithm. Xitong Fangzhen Xuebao , 6 , 1257-1261. Das, B., Misra, S., & Roy, U. (2015). Coalition formation for cooperative service-based message sharing in vehicular ad hoc networks. IEEE Transactions on Parallel and Distributed Systems , 27 (1), 144-156. doi:10.1109/ TPDS.2014.2387282 Das, G. P., McGinnity, T. M., Coleman, S. A., & Behera, L. (2015). A distributed task allocation algorithm for a multi-robot system in healthcare facilities. Journal of Intelligent & Robotic Systems , 80 (1), 33-58. doi:10.1007/ s10846-014-0154-2 Di, B., Zhou, R., & Ding, Q. (2013). Multi-UAV distributed collaborative heterogeneous task assignment. Control and Decision , 28 (2), 274-278. Diao, X., Fang, Y., Xiao, B., & Mao, D. (2014). Multi-aircraft cooperative air combat task assignment based on multi-agent alliance. Journal of Beijing University of Aeronautics and Astronautics , 40 (9), 1268-1275. Dong, H., & Zou, J. (2018). Research on UAV task assignment based on AMPSO algorithm. Electro-Optics and Control , 25 (2), 28-32. Dorigo, M., & StÃ¼tzle, T. (2003). The ant colony optimization metaheuristic: Algorithms, applications, and advances. In Handbook of metaheuristics . Springer. Fei, L., Dong, X., Yu, J., Hua, Y., Li, Q., & Ren, Z. (2022). Distributed Nash equilibrium seeking of N -coalition non-cooperative games with application to UAV swarms. IEEE Transactions on Network Science and Engineering , 9 (4), 2392-2405. doi:10.1109/TNSE.2022.3163447 Fu, X., Feng, P., & Gao, X. (2019). Swarm UAVs task and resource dynamic assignment algorithm based on task sequence mechanism. IEEE Access: Practical Innovations, Open Solutions , 7 , 41090-41100. doi:10.1109/ ACCESS.2019.2907544 Guruacharya, S., Niyato, D., Bennis, M., & Kim, D. I. (2013). Dynamic coalition formation for network MIMO in small cell networks. IEEE Transactions on Wireless Communications , 12 (10), 5360-5372. doi:10.1109/ TWC.2013.090513.130516 Han, B., & Yao, P. (2018). Coalition formation of manned/unmanned aerial vehicle cluster based on holon organization. Journal of Systems Engineering and Electronics , 40 (1), 91-97. Hu, X., Ma, H., Ye, Q., & Luo, H. (2015). Hierarchical method of task assignment for multiple cooperating UAV teams. Journal of Systems Engineering and Electronics , 26 (5), 1000-1009. doi:10.1109/JSEE.2015.00109 Jiang, J., Zhang, G., Qi, M., & Su, Z. (2009). Parallel generation of complex coalition based on discrete particle swarm. Chinese Journal of Electronics and Information , 31 (3), 519-522. Johnson, L., Ponda, S., Choi, H. L., & How, J. (2011). Asynchronous decentralized task allocation for dynamic environments. Infotech@Aerospace 2011 , 1441. Kashef, R., & Kamel, M. S. (2010). Cooperative clustering. Pattern Recognition , 43 (6), 2315-2329. doi:10.1016/j. patcog.2009.12.018 Kennedy, J., & Eberhart, R. (1995, November). Particle swarm optimization. Proceedings of ICNN'95International Conference on Neural Networks, 4 , 1942-1948. doi:10.1109/ICNN.1995.488968 Kim, M. G., Shin, S. H., Lee, E. B., & Chi, S. D. (2014). Modified consensus based auction algorithm for task allocation of multiple unmanned aerial vehicle. Journal of the Korea Society for Simulation , 23 (4), 197-202. doi:10.9709/JKSS.2014.23.4.197 Klusch, M., & Gerber, A. (2002). Dynamic coalition formation among rational agents. IEEE Intelligent Systems , 17 (3), 42-47. doi:10.1109/MIS.2002.1005630 Kong, Y., Zhang, M., & Ye, D. (2017). A belief propagation-based method for task allocation in open and dynamic cloud environments. Knowledge-Based Systems , 115 , 123-132. doi:10.1016/j.knosys.2016.10.016 Lerman, K., Jones, C., Galstyan, A., & MatariÄ‡, M. J. (2006). Analysis of dynamic task allocation in multi-robot systems. The International Journal of Robotics Research , 25 (3), 225-241. doi:10.1177/0278364906063426 Li, X., Tang, J., Dai, J., & Bo, N. (2020). Dynamic coalition task allocation of heterogeneous multiple agents. Journal of Northwestern Polytechnical University , 38 (5), 1094-1104. doi:10.1051/jnwpu/20203851094 Lin, L., Sun, Q., Wang, S., & Yang, F. (2013). Research on time window based coalition formation for multiUAVs task assignment. Dianzi Yu Xinxi Xuebao , 35 (8), 1983-1988. doi:10.3724/SP.J.1146.2012.01425 Liu, Y., & Zhang, A. (2010). Manned/UAV formation collaborative task assignment method. Journal of Systems Engineering and Electronics , 32 (3), 584-588. Liu, Y., Zou, J., & Sun, H. (2016, August). Task allocation method of manned/unmanned aerial vehicle formation based on extended CNP. 2016 IEEE Chinese Guidance , Navigation and Control Conference , 1975-1979. Liu, Z., Gao, X., Fu, X., & Mou, Z. (2015). Coalition formation of multiple heterogeneous unmanned aerial vehicles in cooperative search and attack in unknown environment. Acta Armamentarii , 36 (12), 2284-2297. Luan, H., Xu, Y., Liu, D., Du, Z., Qian, H., Liu, X., & Tong, X. (2020). Energy efficient task cooperation for multi-UAV networks: A coalition formation game approach. IEEE Access: Practical Innovations, Open Solutions , 8 , 149372-149384. doi:10.1109/ACCESS.2020.3016009 Macarthur, K., Stranders, R., Ramchurn, S., & Jennings, N. (2011, August). A distributed anytime algorithm for dynamic task allocation in multi-agent systems. Proceedings of the AAAI Conference on Artificial Intelligence , 25 (1), 701-706. doi:10.1609/aaai.v25i1.7866 Manathara, J. G., Sujit, P. B., & Beard, R. W. (2011). Multiple UAV coalitions for a search and prosecute mission. Journal of Intelligent & Robotic Systems , 62 (1), 125-158. doi:10.1007/s10846-010-9439-2 Mazdin, P., & Rinner, B. (2021). Distributed and communication-aware coalition formation and task assignment in multi-robot systems. IEEE Access: Practical Innovations, Open Solutions , 9 , 35088-35100. doi:10.1109/ ACCESS.2021.3061149 Michalak, T., Sroka, J., Rahwan, T., Wooldridge, M., McBurney, P., & Jennings, N. (2010). A distributed algorithm for anytime coalition structure generation. Academic Press. Ng, J. S., Lim, W. Y. B., Dai, H. N., Xiong, Z., Huang, J., Niyato, D., & Miao, C. (2020). Joint auction-coalition formation framework for communication-efficient federated learning in UAV-enabled internet of vehicles. IEEE Transactions on Intelligent Transportation Systems , 22 (4), 2326-2344. doi:10.1109/TITS.2020.3041345 Oh, G., Kim, Y., Ahn, J., & Choi, H. L. (2017). Market-based task assignment for cooperative timing missions in dynamic environments. Journal of Intelligent & Robotic Systems , 87 (1), 97-123. doi:10.1007/s10846-017-0493-x Qi, X., Li, B., Fan, Y., & Liu, L. (2020). A survey of mission planning on UAV system based on multi-constraints. Zhineng Xitong Xuebao , 15 (2), 204-217. Qian, Y., Xia, J., & Liu, T. (2011). A method of unmanned aerial vehicle cooperative target assignment based on contract network. System Simulation , 23 (8), 1672-1676. Rahwan, T., Ramchurn, S. D., Jennings, N. R., & Giovannucci, A. (2009). An anytime algorithm for optimal coalition structure generation. Journal of Artificial Intelligence Research , 34 , 521-567. doi:10.1613/jair.2695 Rauniyar, A., & Muhuri, P. K. (2016, October). Multi-robot coalition formation problem: Task allocation with adaptive immigrants based genetic algorithms. 2016 IEEE International Conference on Systems, Man, and Cybernetics , 137-142. doi:10.1109/SMC.2016.7844232 Ruan, L., Li, G., Dai, W., Tian, S., Fan, G., Wang, J., & Dai, X. (2021). Cooperative relative localization for UAV swarm in GNSS-denied environment: a coalition formation game approach. IEEE Internet of Things Journa, 9 (13), 11560-11577. Sandhlom, T. W., & Lesser, V. R. (1997). Coalitions among computationally bounded agents. Artificial Intelligence , 94 (1-2), 99-137. doi:10.1016/S0004-3702(97)00030-1 Sandholm, T., Larson, K., Andersson, M., Shehory, O., & TohmÃ©, F. (1999). Coalition structure generation with worst case guarantees. Artificial Intelligence , 111 (1-2), 209-238. doi:10.1016/S0004-3702(99)00036-3 Sarkar, S., Curado Malta, M., & Dutta, A. (2022). A survey on applications of coalition formation in multi-agent systems. Concurrency and Computation , 34 (11), e6876. doi:10.1002/cpe.6876 Shehory, O., & Kraus, S. (1996, December). Formation of overlapping coalitions for precedence-ordered task-execution among autonomous agents. Proceedings of the Second International Conference on Multiagent Systems , 330-337. Shehory, O., & Kraus, S. (1998). Methods for task allocation via agent coalition formation. Artificial Intelligence , 101 (1-2), 165-200. doi:10.1016/S0004-3702(98)00045-9 Shen, Y., Guo, B., & Wang, D. (2006, June). Optimal coalition structure based on particle swarm optimization algorithm in multi-agent system. Proceedings of the 6th World Congress on Intelligent Control and Automation , 1 , 2494-2497. doi:10.1109/WCICA.2006.1712810 Shetty, V. K., Sudit, M., & Nagi, R. (2008). Priority-based assignment and routing of a fleet of unmanned combat aerial vehicles. Computers & Operations Research , 35 (6), 1813-1828. doi:10.1016/j.cor.2006.09.013 Smith, R. G. (1980). The contract net protocol: High-level communication and control in a distributed problem solver. IEEE Transactions on Computers , 29 (12), 1104-1113. doi:10.1109/TC.1980.1675516 Stranders, R., Tran-Thanh, L., Delle Fave, F. M., Rogers, A., & Jennings, N. (2012). DCOPs and bandits: Exploration and exploitation in decentralised coordination, Proc. 11th Int. Conference on Autonomous Agents and Multi-Agent Systems (AAMAS) (pp. 289-297). University of Southampton. Sujit, P., George, J., & Beard, R. (2008, August). Multiple UAV task allocation using particle swarm optimization. AIAA Guidance, Navigation and Control Conference and Exhibit , 6837. Sujit, P. B., Manathara, J. G., Ghose, D., & de Sousa, J. (2014). Decentralized multi-UAV coalition formation with limited communication ranges. In Handbook of unmanned aerial vehicles . Springer. Tang, J., Li, X., Dai, J., & Bo, N. (2020). Coalition task allocation of heterogeneous multiple agents with complex constraints. Control Theory and Applications , 37 (11), 2413-2422. Tang, S., Zhu, Y., Li, Q., & Lei, Y. (2010). A survey of task assignment methods in multi-agent systems. Journal of Systems Engineering and Electronics , 32 (10), 2155-2161. Tanzil, S. S., Gharehshiran, O. N., & Krishnamurthy, V. (2016). A distributed coalition game approach to femtocloud formation. IEEE Transactions on Cloud Computing , 7 (1), 129-140. doi:10.1109/TCC.2016.2594175 Vig, L., & Adams, J. A. (2006). Multi-robot coalition formation. IEEE Transactions on Robotics , 22 (4), 637-649. doi:10.1109/TRO.2006.878948 Voice, T., Polukarov, M., & Jennings, N. R. (2012). Coalition structure generation over graphs. Journal of Artificial Intelligence Research , 45 , 165-196. doi:10.1613/jair.3715 Wan, L., Yao, P., & Sun, P. (2013). Manned/unmanned combat agent distributed task assignment method. Journal of Systems Engineering and Electronics , 35 (2), 310-316. Wan, L., Yao, P., Sun, P., Deng, C., & Shui, D. (2013). Strategy of manned-unmanned combat agents task coalition formation. Journal of Air Force Engineering University , 14 (3), 10-14. Wang, H., & Liu, S. (2021). Task allocation of multi-UAV coalition based on resource constraints. Journal of East China University of Science and Technology , 47 (4), 504-509. Wang, L. (2001). Intelligent optimization algorithm and its application . Tsinghua University Press. Wang, L., Tang, H., & Sun, Z. (2005). Gift value algorithm in multi-robot systems to promote cooperative coalitions. Qinghua Daxue Xuebao. Ziran Kexue Ban , 45 (4), 505-508. Wang, R., Li, W., Liu, Y., & Liu, J. (2018). Research on task allocation method of UAV swarm networking. Xitong Fangzhen Xuebao , 30 (12), 4794-4801. Wei, Y., Blake, M. B., & Madey, G. R. (2013). An operation-time simulation framework for UAV swarm configuration and mission planning. Procedia Computer Science , 18 , 1949-1958. doi:10.1016/j.procs.2013.05.364 Wen, C. (2009). Study on coalition formation in multi-agent system . Lanzhou University. Whitten, A. A. K. (2010). Decentralized planning for autonomous agents cooperating in complex missions [Master's thesis]. Massachusetts Institute of Technology. Wu, R. (2017). Research on task assignment method of multi-UAV formation in uncertain environment . Hefei University of Technology. Wu, W., Cui, N., & Guo, J. (2018). Distributed task assignment method based on local information consensus and target estimation. Control Theory and Applications , 35 (4), 566-576. Wu, W., Guan, Y., Guo, J., & Cui, N. (2017). Research on cooperative task assignment method used to the mission SEAD with real constraints. Control and Design , 32 (9), 1574-1582. Wu, X. (2018). Coordination tasks pre-auocation and redistribution studies in UAVs . Nanchang Hangkong University. Xiao, D., Jiang, J., Yu, C., & Zhou, J. (2018). Multiple heterogeneous UAVs cooperative searching and attacking based on parallel NSGA-II algorithm. Electronics Optics and Control , 25 (7), 24-28. Xing, N., Zong, Q., Dou, L., Tian, B., & Wang, Q. (2019). A game theoretic approach for mobility prediction clustering in unmanned aerial vehicle networks. IEEE Transactions on Vehicular Technology , 68 (10), 9963-9973. doi:10.1109/TVT.2019.2936894 Xu, G., & Liu, J. (2015). Optimal coalition structure generation with constraint on the number of coalitions. Journal of Nanjing University . Nature and Science , 51 (4), 749-761. Yang, J., Xi, J., Wang, C., & Xie, X. (2018). A review of multi-UAV cooperative patrol mission planning methods. Flight Mechanics , 36 (5), 1-6. Yang, M., Zhang, A., Bi, W., & Wang, Y. (2022). A resource-constrained distributed task allocation method based on a two-stage coalition formation methodology for multi-UAVs. The Journal of Supercomputing , 78 (7), 10025-10062. doi:10.1007/s11227-021-04223-3 Yao, P., Wan, L., Sun, P., & Zhou, X. (2014). Dynamic task allocation in multiple agent groups based on RHPIVFSA. Journal of Systems Engineering and Electronics , 36 (7), 1309-1319. Zhai, X. B., Li, L., Zhao, X., Zhao, Y., & Liu, K. (2021). Real-time task allocation of heterogeneous unmanned aerial vehicles for search and prosecute mission. Wireless Communications and Mobile Computing , 2021 , 2021. doi:10.1155/2021/5516086 Zhang, G., Jiang, J., Su, Z., Qi, M., & Fang, H. (2010). Searching for overlapping coalitions in multiple virtual organizations. Information Sciences , 180 (17), 3140-3156. doi:10.1016/j.ins.2010.04.028 Zhang, J., Yao, P., Zhou, X., & Wang, X. (2012). A combat mission-platform resource matching method based on DLS and GA. Journal of Systems Engineering and Electronics , 5 , 947-954. Zhang, Y. (2016). Research on C~2S of manned-machine/UAV formation cooperative sea battle based on holonagent . Northwestern Polytechnical University. Zheng, H., Guo, J., Xie, X., & Yan, P. (2022). A distributed coalition formation method of heterogeneous UAV swarm in unknown dynamic environment. Journal of Astronautics , 43 (2), 189-197. Zheng, J. (2007). Multi-objective evolutionary algorithm and its application . Science Press. Zhong, Y., Yao, P., Sun, Y., & Yang, J. (2017). UAV action coalition formation model and algorithm in multitask execution. Journal of Systems Engineering and Electronics , 39 (10), 2248-2254. Zhu, M., Lu, N., & Chen, K. (2019). The method of forming a hybrid multi-level alliance of aviation clusters. [Natural Science Edition]. Journal of Lanzhou University , 55 (3), 402-409. Zick, Y., Markakis, E., & Elkind, E. (2014). Arbitration and stability in cooperative games with overlapping coalitions. Journal of Artificial Intelligence Research , 50 , 847-884. doi:10.1613/jair.4237 Authors Husheng Wu received a BS degree in automobile command and an ME degree in military equipment science from Armed Police Force Engineering University in 2008 and 2011, respectively, and a PhD in systems engineering from the Air Force Engineering University, Xi'an, China, in 2014. He is currently an associate professor in the College of Equipment Support and Management at the Engineering University of PAP. His research interests include swarm intelligence, unmanned systems in combat operations, and intelligent military equipment. Peng Qiang is currently working toward an MS degree at the Engineering University of PAP, Xi'an, China, College of Equipment Support and Management. His research interests include swarm intelligence, UAV swarm mission planning in combat operations, and intelligent military equipment. Meimei Shi is currently a professor at Engineering University of PAP, China. She is skilled in English teaching methods and English translation in topics such as swarm intelligence and unmanned systems. Her research interests include applied linguistics schools, military literature translation, and teaching methods. Lining Xing, born in February 1980, is a researcher and doctoral supervisor at the National University of Defense Technology. His main research directions are in intelligent optimization, resource scheduling, and task planning. He is an expert in the Artificial Intelligence Equipment Application Professional Group of the Military Aerospace Forces of the Equipment Development Department of the Central Military Commission and chairman of the Intelligent Simulation Optimization and Scheduling Committee of the Chinese Simulation Society. He has published more than 100 academic papers, seven of which became the top 1% or 10% of papers cited by ESI. Relevant achievements won the first prize for innovative technology in the China Simulation Society Science and Technology Award, the second prize of the Hunan Province Natural Science Award, and the second prize of the Wu Wenjun Artificial Intelligence Science and Technology Award. An author of 100 outstanding doctoral dissertations in China, he was selected for the Ministry of Education's New Century Excellent Talents Support Program and was awarded the Hunan Provincial Natural Science Outstanding Youth Fund Project. He has published four monographs, obtained more than 20 national invention patents, and presided over and participated in more than 20 projects of the National Natural Science Foundation of China. å´è™ç”Ÿäº2008å¹´å’Œ2011å¹´åˆ†åˆ«è·å¾—æ­¦è­¦å·¥ç¨‹å¤§å­¦æ±½è½¦æŒ‡æŒ¥å­¦å£«å­¦ä½å’Œå†›äº‹è£…å¤‡å­¦ç¡•å£«å­¦ä½ï¼Œ2014å¹´è·å¾—ç©ºå†›å·¥ç¨‹å¤§å­¦ç³»ç»Ÿå·¥ç¨‹åšå£«å­¦ä½ã€‚ä»–ç°ä¸ºæ­¦è­¦å·¥ç¨‹å¤§å­¦è£…å¤‡ç®¡ç†ä¸ä¿éšœå­¦é™¢å‰¯æ•™æˆï¼Œç ”ç©¶æ–¹å‘åŒ…æ‹¬ç¾¤ä½“æ™ºèƒ½ã€ä½œæˆ˜ä¸­çš„æ— äººç³»ç»Ÿä»¥åŠæ™ºèƒ½å†›äº‹è£…å¤‡ã€‚ å½­å¼ºç›®å‰æ­£åœ¨æ­¦è­¦å·¥ç¨‹å¤§å­¦è£…å¤‡ç®¡ç†ä¸ä¿éšœå­¦é™¢æ”»è¯»ç¡•å£«å­¦ä½ï¼Œç ”ç©¶æ–¹å‘åŒ…æ‹¬ç¾¤ä½“æ™ºèƒ½ã€ä½œæˆ˜ä¸­çš„æ— äººæœºé›†ç¾¤ä»»åŠ¡è§„åˆ’ä»¥åŠæ™ºèƒ½å†›äº‹è£…å¤‡ã€‚ çŸ³ç¾æ¢…ç°ä¸ºæ­¦è­¦å·¥ç¨‹å¤§å­¦æ•™æˆï¼Œæ“…é•¿è‹±è¯­æ•™å­¦æ–¹æ³•å’Œç¾¤ä½“æ™ºèƒ½ã€æ— äººç³»ç»Ÿç­‰é¢†åŸŸçš„è‹±è¯­ç¿»è¯‘ã€‚å¥¹çš„ç ”ç©¶æ–¹å‘åŒ…æ‹¬åº”ç”¨è¯­è¨€å­¦æµæ´¾ã€å†›äº‹æ–‡çŒ®ç¿»è¯‘ä»¥åŠæ•™å­¦æ–¹æ³•ã€‚ é‚¢ç«‹å®ï¼Œ1980å¹´2æœˆå‡ºç”Ÿï¼Œå›½é˜²ç§‘æŠ€å¤§å­¦ç ”ç©¶å‘˜ã€åšå£«ç”Ÿå¯¼å¸ˆï¼Œä¸»è¦ç ”ç©¶æ–¹å‘ä¸ºæ™ºèƒ½ä¼˜åŒ–ã€èµ„æºè°ƒåº¦å’Œä»»åŠ¡è§„åˆ’ã€‚ä»–æ˜¯ä¸­å¤®å†›å§”è£…å¤‡å‘å±•éƒ¨å†›äº‹èˆªå¤©åŠ›é‡äººå·¥æ™ºèƒ½è£…å¤‡åº”ç”¨ä¸“ä¸šç»„ä¸“å®¶ã€ä¸­å›½ä»¿çœŸå­¦ä¼šæ™ºèƒ½ä»¿çœŸä¼˜åŒ–ä¸è°ƒåº¦ä¸“ä¸šå§”å‘˜ä¼šä¸»ä»»å§”å‘˜ã€‚ä»–å‘è¡¨äº†100ä½™ç¯‡å­¦æœ¯è®ºæ–‡ï¼Œå…¶ä¸­7ç¯‡è¿›å…¥ESIé«˜è¢«å¼•è®ºæ–‡å‰1%æˆ–10%ã€‚ç›¸å…³æˆæœè£è·ä¸­å›½ä»¿çœŸå­¦ä¼šç§‘æŠ€åˆ›æ–°å¥–ä¸€ç­‰å¥–ã€æ¹–å—çœè‡ªç„¶ç§‘å­¦å¥–äºŒç­‰å¥–å’Œå´æ–‡ä¿Šäººå·¥æ™ºèƒ½ç§‘å­¦æŠ€æœ¯å¥–äºŒç­‰å¥–ã€‚ä»–æ˜¯å…¨å›½ç™¾ç¯‡ä¼˜ç§€åšå£«å­¦ä½è®ºæ–‡ä½œè€…ï¼Œå…¥é€‰æ•™è‚²éƒ¨æ–°ä¸–çºªä¼˜ç§€äººæ‰æ”¯æŒè®¡åˆ’ï¼Œå¹¶è·æ¹–å—çœè‡ªç„¶ç§‘å­¦æ°å‡ºé’å¹´åŸºé‡‘é¡¹ç›®èµ„åŠ©ã€‚ä»–å·²å‡ºç‰ˆ4éƒ¨ä¸“è‘—ï¼Œè·å¾—20ä½™é¡¹å›½å®¶å‘æ˜ä¸“åˆ©ï¼Œä¸»æŒå’Œå‚ä¸äº†20ä½™é¡¹å›½å®¶è‡ªç„¶ç§‘å­¦åŸºé‡‘é¡¹ç›®ã€‚ "},"Learn/LearnDrones/TaskAssignment/2024-Distributed_task_allocation_algorithm_for_heterogeneous_unmanned_aerial_vehic_swarm_based_on_coalition_formation_game.html":{"url":"Learn/LearnDrones/TaskAssignment/2024-Distributed_task_allocation_algorithm_for_heterogeneous_unmanned_aerial_vehic_swarm_based_on_coalition_formation_game.html","title":"2024 Distributed_task_allocation_algorithm_for_heterogeneous_unmanned_aerial_vehic_swarm_based_on_coalition_formation_game","keywords":"","body":"åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„å¼‚æ„æ— äººæœºé›†ç¾¤åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³• ä¸­å›½ç§‘å­¦:ä¿¡æ¯ç§‘å­¦ å—äº¬èˆªç©ºèˆªå¤©å¤§å­¦è‡ªåŠ¨åŒ–å­¦é™¢ 2024 Distributed task allocation algorithm for heterogeneous unmanned aerial vehicle swarm based on coalition formation game. è–›èˆ’å¿ƒ 1,3, é©¬äºšæ° 1,3*, å§œæ–Œ 1,3, ææ–‡åš 1,2, åˆ˜æˆç‘ 1,2 å—äº¬èˆªç©ºèˆªå¤©å¤§å­¦è‡ªåŠ¨åŒ–å­¦é™¢, å—äº¬ 210016 åŒ—äº¬æ§åˆ¶å·¥ç¨‹ç ”ç©¶æ‰€ç©ºé—´æ™ºèƒ½æ§åˆ¶æŠ€æœ¯å…¨å›½é‡ç‚¹å®éªŒå®¤, åŒ—äº¬ 100094 é£è¡Œå™¨è‡ªä¸»æ§åˆ¶æŠ€æœ¯æ•™è‚²éƒ¨å·¥ç¨‹ç ”ç©¶ä¸­å¿ƒ, å—äº¬ 210016 * é€šä¿¡ä½œè€…. E-mail: yajiema@nuaa.edu.cn å…³é”®è¯ï¼š ä»»åŠ¡åˆ†é…; å¼‚æ„æ— äººæœºé›†ç¾¤; å¼‚æ„èµ„æº; èšç±»ç®—æ³•; è”ç›Ÿå½¢æˆåšå¼ˆ; Keywords: task allocation, heterogeneous UAV swarms, heterogeneous resources, clustering algorithm, coalition formation game æ‘˜è¦ï¼š é’ˆå¯¹æ— äººæœºé›†ç¾¤æºå¸¦å¼‚æ„èµ„æºä»¥åŠä»»åŠ¡çš„å¼‚æ„éœ€æ±‚ä¸‹çš„å¤æ‚ä»»åŠ¡åˆ†é…ä¼˜åŒ–æ±‚è§£é—®é¢˜,æå‡ºä¸€ç§åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•. é¦–å…ˆé’ˆå¯¹ä»»åŠ¡åˆ†é…é—®é¢˜è§„æ¨¡è¾ƒå¤§çš„ç‰¹ç‚¹ä»¥åŠèµ„æºçš„å¼‚æ„æ€§,æå‡ºä¸€ç§åŸºäºå¼‚æ„èµ„æºçš„æ”¹è¿› K-medoids èšç±»ç®—æ³•,é€šè¿‡å¯¹æ— äººæœºé›†ç¾¤å’Œä»»åŠ¡è¿›è¡Œèšç±»çš„é¢„å¤„ç†,é™ä½äº†ä»»åŠ¡åˆ†é…çš„è§„æ¨¡å’Œéš¾åº¦. è€ƒè™‘ä»»åŠ¡éœ€æ±‚ã€æœºè½½èµ„æºä»¥åŠè·¯å¾„æˆæœ¬ç­‰æ¡ä»¶å»ºç«‹ä»»åŠ¡åˆ†é…æ¨¡å‹,å°†åŸæœ‰ä»»åŠ¡åˆ†é…é—®é¢˜è½¬åŒ–ä¸ºè”ç›Ÿåˆ’åˆ†é—®é¢˜,è®¾è®¡äº†ä¸€ç§åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•è¿›è¡Œæ±‚è§£. æœ€å,å°† 30 ä¸ªå…·æœ‰å¼‚æ„éœ€æ±‚çš„ä»»åŠ¡åˆ†é…ç»™ 100 æ¶æºå¸¦ 3 ç§å¼‚æ„èµ„æºçš„æ— äººæœºçš„ä»¿çœŸç»“æœè¡¨æ˜,æ‰€æç®—æ³•èƒ½å¤Ÿå®ç°è¾ƒå¥½çš„ä»»åŠ¡åˆ†é…æ•ˆæœ,åŒæ—¶æå¤§æé«˜ä»»åŠ¡åˆ†é…çš„å®æ—¶æ€§,å……åˆ†å‘æŒ¥é›†ç¾¤æ•ˆèƒ½. åŸºé‡‘èµ„åŠ©ï¼š å›½å®¶è‡ªç„¶ç§‘å­¦åŸºé‡‘(æ‰¹å‡†å·:62273177,62020106003,62233009)ï¼› æ±Ÿè‹çœè‡ªç„¶ç§‘å­¦åŸºé‡‘(æ‰¹å‡†å·:BK20211566,BK20222012)ï¼› é«˜æ ¡å­¦ç§‘åˆ›æ–°å¼•æ™ºåŸºåœ°(æ‰¹å‡†å·:B20007)ï¼› ç©ºé—´æ™ºèƒ½æ§åˆ¶æŠ€æœ¯å…¨å›½é‡ç‚¹å®éªŒå®¤å¼€æ”¾åŸºé‡‘(æ‰¹å‡†å·:HTKJ2023KL502006)ï¼› ä¸­å¤®é«˜æ ¡åŸºæœ¬ç§‘ç ”ä¸šåŠ¡è´¹(æ‰¹å‡†å·:NI2024001)èµ„åŠ©é¡¹ç›®ï¼› doi-link å¼•è¨€ é—®é¢˜æè¿° æ•°å­¦å»ºæ¨¡ æ— äººæœºå»ºæ¨¡ ä»»åŠ¡å»ºæ¨¡ è”ç›Ÿå½¢æˆåšå¼ˆæ•°å­¦æ¨¡å‹ ç›®æ ‡å‡½æ•°ä¸çº¦æŸæ¡ä»¶ è”ç›Ÿå½¢æˆåšå¼ˆç®—æ³•è®¾è®¡ åŸºäºå¼‚æ„èµ„æºçš„æ”¹è¿› K-medoids èšç±»ç®—æ³• æ— äººæœºé›†ç¾¤èšç±» ä»»åŠ¡èšç±» åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„ä»»åŠ¡åˆ†é…ç®—æ³• ç®—æ³•å¤æ‚åº¦åˆ†æ ä»¿çœŸéªŒè¯ åŸºäºå¼‚æ„èµ„æºçš„æ”¹è¿› K-medoids èšç±»ç®—æ³•ç»“æœåˆ†æ åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„ä»»åŠ¡åˆ†é…ç®—æ³•ç»“æœåˆ†æ ç»“è®º others ä»åŒˆç‰™åˆ©ç®—æ³•åˆ° KM ç®—æ³• å¼•è¨€ å¸¸è§çš„åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•ä¸»è¦æœ‰åšå¼ˆè®ºæ–¹æ³•ã€åŸºäºå¸‚åœºæœºåˆ¶çš„æ–¹æ³• [7] å’Œåˆ†å¸ƒå¼é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹æ–¹æ³•. åŸºäºå¸‚åœºæœºåˆ¶çš„æ–¹æ³•ï¼š åˆåŒç½‘ç®—æ³•å’Œæ‹å–ç®—æ³•æ˜¯åº”ç”¨è¾ƒä¸ºå¹¿æ³›çš„åŸºäºå¸‚åœºæœºåˆ¶çš„æ–¹æ³•. æ–‡çŒ® [8] é’ˆå¯¹å¼‚æ„æ— äººæœºå’ŒæœªçŸ¥ç›®æ ‡èƒŒæ™¯æå‡ºäº†ä¸€ç§åŸºäºåˆä½œç½‘åè®®çš„ä»»åŠ¡åˆ†é…ç®—æ³•, èƒ½å¤Ÿè·å¾—è¾ƒå¤§çš„ç³»ç»Ÿæ•ˆèƒ½, ä½†ç®—æ³•ç¼ºå°‘å¯¹æŸæ— äººæœºå¯èƒ½åŒå±å¤šä¸ªä»»åŠ¡æœ€ä¼˜è”ç›Ÿè§£çš„å†²çªæ¶ˆé™¤è€ƒè™‘. æ–‡çŒ® [9] é’ˆå¯¹ä¸åŒä½œæˆ˜ä»»åŠ¡, å»ºç«‹äº†ä¸€ç§é¢å‘å¼‚æ„ä¸”å…·æœ‰æ—¶åºçº¦æŸä»»åŠ¡çš„å¤šè½®æ¬¡åˆ†å¸ƒå¼æ‹å–ç®—æ³•, æœ¬æ–‡æ¨¡å‹ä¸­æ— äººæœºå¯æ‰§è¡Œä¸åŒç±»å‹çš„ä»»åŠ¡,ä½†ç¼ºå°‘å¯¹æ‰§è¡Œç›¸åŒç±»å‹ä»»åŠ¡çš„æ— äººæœºèƒ½åŠ›çš„åŒºåˆ†. åŸºäºåˆ†å¸ƒå¼é©¬å°”å¯å¤«æ³•é€šå¸¸è®­ç»ƒéš¾åº¦å¤§, æ”¶æ•›è¾ƒæ…¢. åˆ†å¸ƒå¼é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹æ–¹æ³•ï¼š æ–‡çŒ® [10] é’ˆå¯¹è¾¹ç¼˜æœåŠ¡å™¨çš„åˆ†å¸ƒå¼ä»»åŠ¡å’Œèµ„æºåˆ†é…é—®é¢˜, å°†å…¶å»ºæ¨¡ä¸ºéƒ¨åˆ†è§‚æµ‹çš„é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹,æå‡ºä¸€ç§ä¾èµ–äºå¤šæ™ºèƒ½ä½“çš„æ·±åº¦å¼ºåŒ–ä¸¤æ­¥ç­–ç•¥, æ‰€æå‡ºçš„è§£å†³æ–¹æ¡ˆåœ¨è®­ç»ƒå’Œæ”¶æ•›æ–¹é¢ä¼˜äºåŸºå‡†. åšå¼ˆè®ºæ–¹æ³•ï¼š ç›®å‰, å¾—ç›Šäºåšå¼ˆè®ºèƒ½å¤Ÿä¸ºæ— äººæœºä¹‹é—´çš„åˆä½œåå•†æä¾›è‰¯å¥½æ€§èƒ½, åšå¼ˆæ–¹æ³•å·²æˆä¸ºçƒ­é—¨ç ”ç©¶æ–¹å‘,åº”ç”¨äºå„ç§ä¼˜åŒ–é—®é¢˜ [11]. æ–‡çŒ® [5] è®¾è®¡äº†æ™ºèƒ½ä½“ä¹‹é—´çš„ç»„åˆç­–ç•¥, å°†å…¨å±€æ•ˆç”¨æ˜ å°„ä¸ºåŠ¿å‡½æ•°è·å¾—æœ€ä¼˜åˆ†é…æ–¹æ¡ˆ. æ–‡çŒ® [12] é‡‡ç”¨äº†åŸºäºåŠ¿åšå¼ˆçš„åˆ†å¸ƒå¼å¤šæ™ºèƒ½ä½“åŠ¨æ€ä»»åŠ¡åˆ†é…æ–¹æ³•, è¯¥ç®—æ³•åœ¨å…¨å±€æœç´¢èƒ½åŠ›æ–¹é¢è¡¨ç°è‰¯å¥½. æ–‡çŒ® [13] è®¾è®¡äº†åŸºäºåå¥½è”ç›Ÿå½¢æˆåšå¼ˆçš„ä»»åŠ¡åˆ†é…ç®—æ³•, åˆ©ç”¨åå¥½ç¨‹åº¦å®šä¹‰æœºå™¨äººåŠ å…¥è”ç›Ÿåçš„æ•ˆç”¨, ç®—æ³•ä¿è¯äº†å¤šé¡¹å¼æ—¶é—´å¤æ‚æ€§å’Œè§£çš„çº³ä»€ç¨³å®šæ€§. å…¶ä¸­, è”ç›Ÿå½¢æˆåšå¼ˆ (coalition formation game, CFG) æ¨¡å‹æ˜¯å¸¸ç”¨çš„åšå¼ˆæ¨¡å‹ä¹‹ä¸€, ç›®çš„åœ¨äºåˆ©ç”¨æ— äººæœºä¹‹é—´çš„ç›¸äº’åˆä½œæœ€å¤§åŒ–ç³»ç»Ÿæ€§èƒ½, ä¸ºå‚ä¸è€…ä¹‹é—´çš„å†³ç­–æä¾›äº†ä¸€ä¸ªé«˜æ•ˆçš„æ¨¡å‹ä¸å·¥å…·. åœ¨æ•´ä¸ªåšå¼ˆè¿‡ç¨‹ä¸­, å‚ä¸è€…ä¼šè‡ªè¡Œç»„æˆè‹¥å¹²ä¸ªè”ç›Ÿ, ä»å…¨å±€æ¥çœ‹å½¢æˆè‹¥å¹²åˆ†ç»„. æ–‡çŒ® [14] è®¾è®¡äº†ä¸€ç§åŸºäºè”ç›Ÿåšå¼ˆçš„é¢å‘ç»„çš„åˆ†å¸ƒå¼èšç±»ç®—æ³•, ç®—æ³•ç»éªŒè¯åœ¨é€šä¿¡é“¾è·¯ç¨³å®šæ€§ã€èšç±»æ•°é‡å’Œè´Ÿè½½å¹³è¡¡ç­‰æ–¹é¢ä¼˜äºç°æœ‰ç®—æ³•. æ–‡çŒ® [15] é’ˆå¯¹æ— äººæœºå‰ç½®ç¾¤å¹²æ‰°æå‡ºä¸€ç§åŸºäºåˆ†å¸ƒå¼è”ç›Ÿå½¢æˆåšå¼ˆçš„åŠ¨æ€ä»»åŠ¡åˆ†é…ç®—æ³•,å°†ä»»åŠ¡åˆ†é…é—®é¢˜è½¬åŒ–ä¸ºå¤šæ™ºèƒ½ä½“ååŒé—®é¢˜, ç®—æ³•å¯ä»¥å®ç°ä¸é›†ä¸­å¼ä¼˜åŒ–ç›¸ä¼¼çš„æ€§èƒ½. æ–‡çŒ® [16] è€ƒè™‘èµ„æºå±æ€§å’Œä»»åŠ¡æ‰§è¡Œé¡ºåºçš„é‡å å’Œäº’è¡¥å…³ç³», åœ¨åŸºäºé¡ºåºé‡å è”ç›Ÿå½¢æˆåšå¼ˆæ¨¡å‹åŸºç¡€ä¸Šå¼€å‘äº†ä¸€ç§åå¥½é‡åŠ›å¼•å¯¼ç¦å¿Œæœç´¢ç®—æ³•, å¯è·å¾—ç¨³å®šçš„è”ç›Ÿç»“æ„. ç»¼ä¸Šæ‰€è¿°, åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•å·²å–å¾—è¾ƒå¤šç ”ç©¶æˆæœ, å°¤å…¶åœ¨åšå¼ˆæ–¹é¢. ç„¶è€Œ, ç›®å‰å·¥ä½œä»å­˜åœ¨ä»¥ä¸‹é—®é¢˜: ä¸€æ˜¯å¯¹äºæœºè½½èµ„æºå’Œä»»åŠ¡éœ€æ±‚èµ„æºçš„å¼‚æ„æ€§ç ”ç©¶è¾ƒä¸ºè–„å¼±; äºŒæ˜¯å¤§è§„æ¨¡æ— äººæœºé›†ç¾¤åœ¨è¿›è¡Œä»»åŠ¡åˆ†é…æ—¶æ±‚è§£éš¾åº¦å‰§å¢, å¯¼è‡´ç®—æ³•å®æ—¶æ€§è¾ƒå·®; ä¸‰æ˜¯å•ä¸ªæ— äººæœºè¿è½½èƒ½åŠ›å¾ˆéš¾æ»¡è¶³ä»»åŠ¡éœ€æ±‚, éœ€è¦è€ƒè™‘æ— äººæœºä¹‹é—´çš„åä½œ. åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆè§£å†³ä»»åŠ¡åˆ†é…é—®é¢˜èƒ½å¤Ÿï¼š æ ¹æ®æ— äººæœºåœ¨æ€§èƒ½ã€èƒ½åŠ›å’Œèµ„æºæ–¹é¢çš„å·®å¼‚çµæ´»è¿›è¡Œä»»åŠ¡åˆ†é…, æé«˜ç³»ç»Ÿæ•´ä½“æ•ˆç‡; å…¶æ¬¡å…·æœ‰è¾ƒé«˜çš„å¯æ‹“å±•æ€§, èƒ½å¤Ÿé€‚åº”ä¸åŒè§„æ¨¡çš„æ— äººæœºé›†ç¾¤. åŒæ—¶è”ç›Ÿå½¢æˆåšå¼ˆæ”¯æŒåˆ†å¸ƒå¼å†³ç­–, æ— äººæœºèƒ½å¤Ÿè‡ªä¸»è¿›è¡Œä»»åŠ¡åˆ†é…, æå‡ç³»ç»Ÿçš„é²æ£’æ€§å’Œå¯é æ€§; é€šè¿‡åˆç†çš„æ”¶ç›Šåˆ†é…æœºåˆ¶, æ¿€åŠ±æ— äººæœºç§¯æå‚ä¸ä»»åŠ¡æ‰§è¡Œ, å¢å¼ºåä½œæ•ˆæœ. å› æ­¤, æœ¬æ–‡æå‡ºä¸€ç§åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•, ä¸»è¦è´¡çŒ®æ€»ç»“å¦‚ä¸‹: é’ˆå¯¹åŸä»»åŠ¡åˆ†é…é—®é¢˜è§„æ¨¡å¤§ä»¥åŠèµ„æºçš„å¼‚æ„æ€§, åœ¨ K-medoids èšç±»ç®—æ³•çš„åŸºç¡€ä¸ŠåŠ å…¥å…³äºå¼‚æ„èµ„æºæ•°ç›®å‡è¡¡åº¦çš„æ”¶æ•›æ¡ä»¶ä»¥è¿›è¡Œæ”¹è¿›, å¯¹æ— äººæœºé›†ç¾¤å’Œä»»åŠ¡è¿›è¡Œåˆç†çš„é¢„å¤„ç†, é™ä½åŸé—®é¢˜çš„è§„æ¨¡, æé«˜ä»»åŠ¡åˆ†é…çš„å®æ—¶æ€§; å»ºç«‹äº†è”ç›Ÿå½¢æˆåšå¼ˆæ•°å­¦æ¨¡å‹, å°†ä»»åŠ¡åˆ†é…é—®é¢˜è½¬åŒ–ä¸ºè”ç›Ÿåˆ’åˆ†é—®é¢˜; é€šè¿‡è¯æ˜æœ¬æ–‡è”ç›Ÿå½¢æˆåšå¼ˆæ¨¡å‹ä¸ºåŠ¿åšå¼ˆ, è¯æ˜äº†çº³ä»€å‡è¡¡è§£çš„å­˜åœ¨æ€§å¹¶ä¸ºç®—æ³•çš„è®¾è®¡æä¾›äº†ç†è®ºåŸºç¡€; è®¾è®¡äº†åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•, ä¸»è¦åŒ…å«äº†æœ€å¤§åŠ æƒåŒ¹é…é˜¶æ®µå’Œæ— äººæœºè½¬ç§»è”ç›Ÿåˆ¤æ–­é˜¶æ®µ, ä½¿å¾—ç®—æ³•ç›¸æ¯”éšæœºå¯»ä¼˜æ›´å…·æœ‰å¯¼å‘æ€§, èƒ½å¤Ÿè·å¾—è¾ƒå¥½çš„åˆ†é…æ•ˆæœå¹¶ä¸”æé«˜ä»»åŠ¡åˆ†é…çš„å®æ—¶æ€§. Overall_flowchart_of_the_coalition_formation_game_model --> Overall_flowchart_of_the_task_allocation_algorithm_based_on_coalition_formation_game åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„ä»»åŠ¡åˆ†é…ç®—æ³•æ•´ä½“æµç¨‹å›¾ Initial task allocation result. Calculate or update the benefit matric. Matching based on maximum weighed principle. Update the required resources of task, design rules for profit checking. Obtain the final stable result of this layer. Update the carried resources and requirements of tasks. Requirements of a certain task are an empty set. if true, jump to 2. else go to 8. Exit.When all tasks exit, obtain the final coalition structure. 2 é—®é¢˜æè¿° æ•°å­¦å»ºæ¨¡ æ— äººæœºå»ºæ¨¡ ä»»åŠ¡å»ºæ¨¡ è”ç›Ÿå½¢æˆåšå¼ˆæ•°å­¦æ¨¡å‹ ç›®æ ‡å‡½æ•°ä¸çº¦æŸæ¡ä»¶ m é¡¹ä»»åŠ¡åˆ†é…ç»™ n ä¸ªå¼‚æ„æ— äººæœº æ—‹ç¿¼æ— äººæœº: å¼‚æ„æ— äººæœº - é‡åŒ–ä¸ºæºå¸¦èµ„æºçš„ç±»å‹ä¸æ•°ç›®çš„å·®åˆ«, å³èµ„æºå‘é‡ ä»»åŠ¡: æ¯ä¸ªä»»åŠ¡åŒ…å«å¤šç§å­ä»»åŠ¡, ä¸”æ¯ä¸ªå­ä»»åŠ¡å¯¹èµ„æºéœ€æ±‚ä¸åŒ, é‡åŒ–ä¸ºèµ„æºéœ€æ±‚å‘é‡ ä¸€ä¸ªä»»åŠ¡éœ€è¦å¤šä¸ªå¤šç§æ— äººæœºååŒå®Œæˆ, åä½œå®ŒæˆåŒä¸€ä¸ªä»»åŠ¡çš„æ— äººæœºç§°ä½œä¸€ä¸ªè”ç›Ÿ coalition å‡è®¾: æ— äººæœº ä»»åŠ¡ çŠ¶æ€ä¿¡æ¯å·²çŸ¥ä¸”ä¸å˜ æ— äººæœºå¯ä¸¤ä¸¤é€šè®¯ 2.1 æ•°å­¦å»ºæ¨¡ 2.1.1 æ— äººæœºå»ºæ¨¡ $n$ ä¸ªæ— äººæœºé›†åˆ: $\\boldsymbol{U}=\\left{u{1}, u{2}, \\ldots, u_{n}\\right}$ åˆ©ç”¨å››å…ƒç»„æ¥æç»˜æ— äººæœºçŠ¶æ€ä¿¡æ¯ UIN: $U I N\\langle\\text { Res, position, value, } \\mathrm{v}\\rangle$ $U I N=\\left{U I N{u{i}} \\mid i=1,2, \\ldots, n\\right}$ $l$ ç§èµ„æºç±»å‹, $R e{u{i}}^{k}$ ä¸ºæ— äººæœºæºå¸¦ç¬¬ k ç§èµ„æºçš„æ•°ç›® æ— äººæœº $ui$ çš„æ€§èƒ½æè¿°ä¸º: $\\operatorname{Res}{u{i}}=\\left{R e{u{i}}^{1}, ~ R e{u{i}}^{2}, \\ldots, R e{u_{i}}^{l}\\right}$ æ— äººæœºä»·å€¼ä¿¡æ¯ $value {u{\\mathrm{i}}}$ æ— äººæœºé€Ÿåº¦çº¦æŸ: $v{u{i}} \\leqslant v{u{i}}^{\\max }, \\forall u_{i} \\in U$ $v{u{i}}^{\\max}$ ä¸ºå¸¸æ•°ï¼Œè¡¨ç¤ºå„æ— äººæœºæœ€å¤§é€Ÿåº¦çº¦æŸ åˆ™æ— äººæœº $u_i$ çš„çŠ¶æ€ä¿¡æ¯å¦‚ä¸‹: UINui=âŸ¨Resâ¡ui,Â positionÂ ui,Â valueÂ ui,vuiâŸ©=âŸ¨{Reâ¡ui1,â€¦,Reâ¡uil},(xui,yui,zui),Â valueÂ ui,vuiâŸ© \\begin{aligned} U I N_{u_{i}} & =\\left\\langle\\operatorname{Res}_{u_{i}}, \\text { position }_{\\mathrm{u}_{\\mathrm{i}}}, \\text { value }_{\\mathrm{u}_{\\mathrm{i}}}, \\mathrm{v}_{\\mathrm{u}_{\\mathrm{i}}}\\right\\rangle \\\\& =\\left\\langle\\left\\{\\operatorname{Re}_{u_{i}}^{1}, \\ldots, \\operatorname{Re}_{u_{i}}^{l}\\right\\},\\left(x_{u_{i}}, y_{u_{i}}, z_{u_{i}}\\right), \\text { value }_{\\mathrm{u}_{\\mathrm{i}}}, \\mathrm{v}_{\\mathrm{u}_{\\mathrm{i}}}\\right\\rangle \\end{aligned} UINuiâ€‹â€‹â€‹=âŸ¨Resuiâ€‹â€‹,Â positionÂ uiâ€‹â€‹,Â valueÂ uiâ€‹â€‹,vuiâ€‹â€‹âŸ©=âŸ¨{Reuiâ€‹1â€‹,â€¦,Reuiâ€‹lâ€‹},(xuiâ€‹â€‹,yuiâ€‹â€‹,zuiâ€‹â€‹),Â valueÂ uiâ€‹â€‹,vuiâ€‹â€‹âŸ©â€‹ 2.1.2 ä»»åŠ¡å»ºæ¨¡ $m$ ä¸ªä»»åŠ¡çš„ä»»åŠ¡é›†åˆ, $\\boldsymbol{T}=\\left{t{1}, t{2}, \\ldots, t_{m}\\right}$ ä»»åŠ¡çŠ¶æ€ä¿¡æ¯ $TIN$ æè¿°å¦‚ä¸‹ $\\operatorname{TIN}\\langle\\text { Res, position, TW, a }\\rangle$ $\\operatorname{TIN}=\\left{\\operatorname{TIN}{t{j}} \\mid j=1,2, \\ldots, m\\right}$ $\\operatorname{Res}{t{j}}=\\left{R e{t{j}}^{1}, R e{t{j}}^{2}, \\ldots, R e{t{j}}^{l}\\right}$ æ˜¯ä»»åŠ¡æ‰€éœ€çš„èµ„æºç±»å‹åŠæ•°ç›®ï¼Œ $R e{t{j}}^{k}$ æ˜¯ä»»åŠ¡æ‰€éœ€è¦çš„ç¬¬ k ç§èµ„æºçš„æ•°ç›®ã€‚ ä»»åŠ¡ $t{j}$ çš„ä½ç½®ä¿¡æ¯è®°ä¸º $\\operatorname{position}{\\mathrm{t}_{\\mathrm{j}}}$ ã€‚ $TW$ æ˜¯ä»»åŠ¡çš„ç¡¬æ—¶é—´çª—å£ä¿¡æ¯ï¼ŒæŒ‡å¯¹æ— äººæœºåˆ°è¾¾ä»»åŠ¡æ—¶é—´èŒƒå›´æå‡ºç¡¬æ€§è¦æ±‚ï¼Œè‹¥æ™šäºæŸä¸ªæ—¶é—´èŠ‚ç‚¹ï¼Œä»»åŠ¡å¤±è´¥ã€‚ $\\mathrm{TW}=\\left[t^{\\text {minstart }}, t^{\\text {maxstart }}\\right]$ å¨èƒæŒ‡æ•° $a{t{j}}$ å½“æ— äººæœºæ‰§è¡Œä¸åŒä»»åŠ¡æ—¶ï¼Œä»»åŠ¡æœ¬èº«å¯èƒ½å¯¹æ— äººæœºæœ‰ä¸€å®šçš„ç ´åèƒ½åŠ›ï¼Œå› æ­¤åœ¨å»ºæ¨¡ä¸­å¼•å…¥å¨èƒæŒ‡æ•° $a{t{j}}$ ï¼Œè¡¨ç¤ºä»»åŠ¡ $t_{j}$ å¯¹æ— äººæœºçš„å¨èƒç³»æ•°ã€‚ åˆ™ä»»åŠ¡ $tj$ çš„çŠ¶æ€ä¿¡æ¯æè¿° $TIN{t_j}$ å¦‚ä¸‹: TINâ¡tj=âŸ¨Â ResÂ tj,Â positionÂ tj,TWtj,atjâŸ©=âŸ¨{Reâ¡tj1,â€¦,Â ReÂ tjl},(xtj,ytj,ztj),[ttjminstartÂ ,ttjmaxstartÂ ],atjâŸ©. \\begin{array}{l}\\operatorname{TIN}_{t_{j}}=\\left\\langle\\text { Res }_{t_{j}}, \\text { position }_{\\mathrm{t}_{\\mathrm{j}}}, \\mathrm{TW}_{\\mathrm{t}_{\\mathrm{j}}}, \\mathrm{a}_{\\mathrm{t}_{\\mathrm{j}}}\\right\\rangle \\\\=\\left\\langle\\left\\{\\operatorname{Re}_{t_{j}}^{1}, \\ldots, \\text { Re }_{t_{j}}^{l}\\right\\},\\left(x_{t_{j}}, y_{t_{j}}, z_{t_{j}}\\right),\\left[t_{t_{j}}^{\\text {minstart }}, t_{t_{j}}^{\\text {maxstart }}\\right], a_{t_{j}}\\right\\rangle .\\end{array} TINtjâ€‹â€‹=âŸ¨Â ResÂ tjâ€‹â€‹,Â positionÂ tjâ€‹â€‹,TWtjâ€‹â€‹,atjâ€‹â€‹âŸ©=âŸ¨{Retjâ€‹1â€‹,â€¦,Â ReÂ tjâ€‹lâ€‹},(xtjâ€‹â€‹,ytjâ€‹â€‹,ztjâ€‹â€‹),[ttjâ€‹minstartÂ â€‹,ttjâ€‹maxstartÂ â€‹],atjâ€‹â€‹âŸ©.â€‹ 2.1.3 è”ç›Ÿå½¢æˆåšå¼ˆæ•°å­¦æ¨¡å‹ é€šè¿‡å°†æ— äººæœºé›†ç¾¤ä»»åŠ¡åˆ†é…é—®é¢˜å»ºæ¨¡ä¸ºè”ç›Ÿå½¢æˆåšå¼ˆï¼Œè¯æ˜äº†è¯¥åšå¼ˆæ¨¡å‹å¯ä»¥æ„é€ ä¸ºåŠ¿åšå¼ˆã€‚ åŠ¿åšå¼ˆçš„æ€§è´¨ä¿è¯äº†çº³ä»€å‡è¡¡è§£çš„å­˜åœ¨æ€§ï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡æœ€å°åŒ–æˆ–æœ€å¤§åŒ–åŠ¿å‡½æ•° $S R$ æ¥æ±‚è§£ã€‚ åŸºäºæ­¤ç†è®ºï¼Œå¯ä»¥è®¾è®¡åˆç†çš„è”ç›Ÿå½¢æˆåšå¼ˆç®—æ³•ï¼Œå®ç°æœ€ç»ˆçš„ä»»åŠ¡åˆ†é…ã€‚ 1. è”ç›Ÿå½¢æˆåšå¼ˆæ¨¡å‹ å°†æ— äººæœºé›†ç¾¤ä»»åŠ¡åˆ†é…é—®é¢˜å»ºæ¨¡ä¸ºè”ç›Ÿå½¢æˆåšå¼ˆæ¨¡å‹ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š åšå¼ˆæ¨¡å‹ï¼š$\\boldsymbol{G}=(\\boldsymbol{U}, \\boldsymbol{E}, \\varepsilon, \\boldsymbol{R})$ $\\boldsymbol{U}$ï¼šæ— äººæœºé›†åˆã€‚ $\\boldsymbol{E}=\\left[e{u{1}}, e{u{2}}, \\ldots, e{u{n}}\\right]$ï¼šæ— äººæœºé€‰æ‹©çš„ä»»åŠ¡é›†åˆï¼Œç­‰ä»·äºä»»åŠ¡é›†åˆ $\\boldsymbol{T}$ï¼Œå³ $\\boldsymbol{E}_{U}=\\boldsymbol{T}$ã€‚ $\\varepsilon$ï¼šè¯„ä¼°æ— äººæœºæ”¶ç›Šçš„æ•ˆç”¨å‡½æ•°ã€‚ $\\boldsymbol{R}$ï¼šè¯„ä¼°å„ä¸ªè”ç›Ÿæ•ˆç”¨çš„å‡½æ•°ã€‚ 2. è”ç›Ÿåˆ’åˆ†é—®é¢˜ åŸé—®é¢˜è½¬åŒ–ä¸ºè”ç›Ÿåˆ’åˆ†é—®é¢˜ï¼Œæ— äººæœºé€‰æ‹©ç­–ç•¥åå½¢æˆ $(m+1)$ ä¸ªä»»åŠ¡è”ç›Ÿã€‚åšå¼ˆç›®æ ‡æ˜¯æ— äººæœºé›†åˆé€‰æ‹©åˆé€‚ç­–ç•¥ï¼Œå¾—åˆ°ç¨³å®šçš„è”ç›Ÿç»“æ„ $\\boldsymbol{C S}$ï¼š è”ç›Ÿç»“æ„ï¼š$\\boldsymbol{C S}=\\left{\\boldsymbol{c}{t{0}}, \\boldsymbol{c}{t{1}}, \\boldsymbol{c}{t{2}}, \\ldots, \\boldsymbol{c}{t{m}}\\right}$ $\\boldsymbol{c}{t{0}}$ï¼šæœªåˆ†é…ä»»åŠ¡çš„æ— äººæœºè”ç›Ÿé›†åˆã€‚ $\\boldsymbol{c}{t{j}}$ï¼šæ‰§è¡Œä»»åŠ¡ $t_{j}$ çš„æ— äººæœºè”ç›Ÿé›†åˆã€‚ 3. æ— äººæœºæ”¶ç›Š æ— äººæœº $u{i}$ åŠ å…¥è”ç›Ÿ $c{t{j}}$ æ—¶ï¼Œæ”¶ç›Š $r{u{i}}\\left(t{j}\\right)$ åŒ…å«ä¸‰éƒ¨åˆ†ï¼š èµ„æºè´¡çŒ®ï¼š$\\operatorname{val}\\left(u{i}, t{j}\\right)$ è·¯å¾„æˆæœ¬ï¼š$\\operatorname{cost}\\left(u{i}, t{j}\\right)$ å¨èƒä»£ä»·ï¼š$\\operatorname{risk}\\left(u{i}, t{j}\\right)$ 3.1 èµ„æºè´¡çŒ® èµ„æºè´¡çŒ® $\\operatorname{val}\\left(u{i}, t{j}\\right)$ å®šä¹‰ä¸ºï¼š valâ¡(ui,tj)={K(j,:)Iâˆ’PO,Â ifÂ K(j,:)Iâˆ’PO>00,Â otherwiseÂ  \\operatorname{val}\\left(u_{i}, t_{j}\\right)=\\left\\{\\begin{array}{ll} \\boldsymbol{K}(j,:) \\boldsymbol{I}-P O, & \\text { if } \\boldsymbol{K}(j,:) \\boldsymbol{I}-P O>0 \\\\ 0, & \\text { otherwise } \\end{array}\\right. val(uiâ€‹,tjâ€‹)={K(j,:)Iâˆ’PO,0,â€‹Â ifÂ K(j,:)Iâˆ’PO>0Â otherwiseÂ â€‹ $\\boldsymbol{K}$ï¼šæƒé‡çŸ©é˜µï¼Œæƒè¡¡èµ„æºåœ¨ä»·å€¼æ”¶ç›Šä¸­çš„æ¯”é‡ã€‚ $\\boldsymbol{K}(j,:)=\\left{k{j 1}, k{j 2}, \\ldots, k{j l}\\right}$ï¼šä»»åŠ¡ $t{j}$ å„å¼‚æ„èµ„æºçš„é‡è¦ç¨‹åº¦ã€‚ $\\boldsymbol{I}=\\left{i{1}, i{2}, \\ldots, i_{l}\\right}$ï¼šæ— äººæœºå¯åˆ©ç”¨çš„æ¯ç±»èµ„æºçš„æ•°ç›®ã€‚ $O$ï¼šæ— äººæœºæœªåˆ©ç”¨çš„æ€»èµ„æºæ•°ç›®ã€‚ 3.2 è·¯å¾„æˆæœ¬ è·¯å¾„æˆæœ¬ $\\operatorname{cost}\\left(u{i}, t{j}\\right)$ å®šä¹‰ä¸ºï¼š costâ¡(ui,tj)={1âˆ’d(ui,tj)/x2+y2,valâ¡(ui,tj)>0Î¼,Â otherwiseÂ  \\operatorname{cost}\\left(u_{i}, t_{j}\\right)=\\left\\{\\begin{array}{ll} 1-\\boldsymbol{d}\\left(u_{i}, t_{j}\\right) / \\sqrt{x^{2}+y^{2}}, & \\operatorname{val}\\left(u_{i}, t_{j}\\right)>0 \\\\ \\mu, & \\text { otherwise } \\end{array}\\right. cost(uiâ€‹,tjâ€‹)={1âˆ’d(uiâ€‹,tjâ€‹)/x2+y2â€‹,Î¼,â€‹val(uiâ€‹,tjâ€‹)>0Â otherwiseÂ â€‹ $\\boldsymbol{d}$ï¼šæ— äººæœºä¸ä»»åŠ¡ä¹‹é—´çš„æ¬§æ°è·ç¦»ã€‚ $x$ å’Œ $y$ï¼šä»»åŠ¡ç¯å¢ƒåŒºåŸŸå¤§å°ã€‚ $\\mu$ï¼šå°äº 0 çš„å¸¸æ•°ã€‚ å½“ $\\operatorname{val}\\left(u{i}, t{j}\\right)$ ä¸º 0 æ—¶ï¼Œè®¾è®¡ $r{u{i}}\\left(t{j}\\right)$ å°äº 0 ã€‚å«ä¹‰æ˜¯å½“æ— äººæœº $u{i}$ åŠ å…¥ä»»åŠ¡ $t{j}$ è”ç›Ÿæ— æ³•è´¡çŒ®èµ„æºæ—¶ï¼ŒåŠ å…¥è¯¥è”ç›Ÿçš„æ”¶ç›Šå°äºåœ¨ $c{t_{0}}$ ä¸­çš„æ”¶ç›Šã€‚ 3.3 å¨èƒä»£ä»· å¨èƒä»£ä»· $\\operatorname{risk}\\left(u{i}, t{j}\\right)$ å®šä¹‰ä¸ºï¼š riskâ¡(ui,tj)=Â valueÂ uiatj \\operatorname{risk}\\left(u_{i}, t_{j}\\right)=\\text { value }_{\\mathrm{u}_{\\mathrm{i}}} \\mathrm{a}_{\\mathrm{t}_{\\mathrm{j}}} risk(uiâ€‹,tjâ€‹)=Â valueÂ uiâ€‹â€‹atjâ€‹â€‹ è¡¨ç¤ºä»»åŠ¡çš„æ¢æµ‹é›·è¾¾å’Œæ”»å‡»èƒ½åŠ›ç­‰å› ç´ å¯¹æ— äººæœºé€ æˆçš„å¨èƒä»£ä»·è¯„ä¼°ã€‚ 4. ä»»åŠ¡æ”¶ç›Š ä»»åŠ¡æ”¶ç›Š $r{u{i}}\\left(t_{j}\\right)$ å®šä¹‰ä¸ºï¼š rui(tj)=Î±val(ui,tj)+Î²costâ¡(ui,tj)âˆ’Î³riskâ¡(ui,tj) r_{u_{i}}\\left(t_{j}\\right)=\\alpha \\mathbf{v a l}\\left(u_{i}, t_{j}\\right)+\\beta \\operatorname{cost}\\left(u_{i}, t_{j}\\right)-\\gamma \\operatorname{risk}\\left(u_{i}, t_{j}\\right) ruiâ€‹â€‹(tjâ€‹)=Î±val(uiâ€‹,tjâ€‹)+Î²cost(uiâ€‹,tjâ€‹)âˆ’Î³risk(uiâ€‹,tjâ€‹) $\\alpha, ~ \\beta, ~ \\gamma$ï¼šå¸¸æ•°æƒé‡å€¼ï¼Œåˆ†åˆ«å†³å®šèµ„æºé‡å åº¦ã€è·¯å¾„æˆæœ¬å’Œå¨èƒä»£ä»·åœ¨æ”¶ç›Šä¸­çš„æ¯”é‡ã€‚ 5. è”ç›Ÿæ•ˆç”¨ ä»»åŠ¡ $t{j}$ çš„è”ç›Ÿæ•ˆç”¨ $\\boldsymbol{R}\\left(c{t_{j}}\\right)$ å®šä¹‰ä¸ºï¼š R(ctj)=âˆ‘uiâˆˆctjrui(tj) \\boldsymbol{R}\\left(c_{t_{j}}\\right)=\\sum_{u_{i} \\in c_{t_{j}}} r_{u_{i}}\\left(t_{j}\\right) R(ctjâ€‹â€‹)=uiâ€‹âˆˆctjâ€‹â€‹âˆ‘â€‹ruiâ€‹â€‹(tjâ€‹) ä»»åŠ¡åˆ†é…é—®é¢˜çš„æ€»æ”¶ç›Š $S R$ å®šä¹‰ä¸ºï¼š SR=âˆ‘ctjâˆˆCSR(ctj) S R=\\sum_{c_{t_{j}} \\in C S} \\boldsymbol{R}\\left(c_{t_{j}}\\right) SR=ctjâ€‹â€‹âˆˆCSâˆ‘â€‹R(ctjâ€‹â€‹) 6. æ— äººæœºæ•ˆç”¨å‡½æ•° æ— äººæœºæ•ˆç”¨å‡½æ•° $\\varepsilon{u{i}}\\left(e{u{i}}, \\boldsymbol{E}{-u{i}}\\right)$ å®šä¹‰ä¸ºï¼š Îµui(eui,Eâˆ’ui)=R(cui)âˆ’R(cuiâˆ£ui) \\varepsilon_{u_{i}}\\left(e_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right)=\\boldsymbol{R}\\left(c_{u_{i}}\\right)-\\boldsymbol{R}\\left(c_{u_{i}} \\mid u_{i}\\right) Îµuiâ€‹â€‹(euiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)=R(cuiâ€‹â€‹)âˆ’R(cuiâ€‹â€‹âˆ£uiâ€‹) $c{u{i}}$ï¼šæ— äººæœº $u{i}$ é€‰æ‹©ç­–ç•¥ $e{u_{i}}$ æ—¶åŠ å…¥çš„ä»»åŠ¡è”ç›Ÿã€‚ $\\boldsymbol{R}\\left(c{u{i}} \\mid u{i}\\right)$ï¼šå°† $u{i}$ ä»åŸæ‰€å±è”ç›Ÿä¸­åˆ é™¤åçš„å‰©ä½™è”ç›Ÿæ•ˆç”¨ã€‚ 7. è”ç›Ÿåšå¼ˆç†è®ºå’Œå»ºæ¨¡ çº³ä»€å‡è¡¡ åšå¼ˆçš„ç›®æ ‡æ˜¯è·å¾—æœ€ç»ˆç¨³å®šçš„çº³ä»€å‡è¡¡è§£ $\\boldsymbol{C S}^{*}$ã€‚çº³ä»€å‡è¡¡æ˜¯åšå¼ˆè®ºä¸­çš„ä¸€ç§è§£æ¦‚å¿µï¼Œå®šä¹‰å¦‚ä¸‹ï¼š å®šä¹‰ 1ï¼šçº³ä»€å‡è¡¡ çº³ä»€å‡è¡¡æ˜¯æŒ‡æ»¡è¶³ä»¥ä¸‹æ€§è´¨çš„ç­–ç•¥ç»„åˆï¼šåœ¨å…¶ä»–ç©å®¶ç­–ç•¥ä¸å˜çš„å‰æä¸‹ï¼Œä»»ä½•ä¸€ä½ç©å®¶åœ¨æ­¤ç­–ç•¥ç»„åˆä¸‹å•æ–¹é¢æ”¹å˜è‡ªå·±çš„ç­–ç•¥éƒ½ä¸ä¼šæé«˜è‡ªèº«çš„æ”¶ç›Šã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œçº³ä»€å‡è¡¡å®šä¹‰ä¸ºï¼š CSâˆ—=argâ¡maxâ¡SR(CS)â‡’Îµui(euiâˆ—,Eâˆ’uiâˆ—)â©¾Îµui(eË‰ui,Eâˆ’uiâˆ—),âˆ€uiâˆˆU \\boldsymbol{C S}^{*}=\\arg \\max S R(\\boldsymbol{C S}) \\Rightarrow \\varepsilon_{u_{i}}\\left(e_{u_{i}}^{*}, \\boldsymbol{E}_{-u_{i}}^{*}\\right) \\geqslant \\varepsilon_{u_{i}}\\left(\\bar{e}_{u_{i}}, \\boldsymbol{E}_{-u_{i}}^{*}\\right), \\forall u_{i} \\in \\boldsymbol{U} CSâˆ—=argmaxSR(CS)â‡’Îµuiâ€‹â€‹(euiâ€‹âˆ—â€‹,Eâˆ’uiâ€‹âˆ—â€‹)â©¾Îµuiâ€‹â€‹(eË‰uiâ€‹â€‹,Eâˆ’uiâ€‹âˆ—â€‹),âˆ€uiâ€‹âˆˆU $e{u{i}}^{}$ï¼šè”ç›Ÿç»“æ„ $\\boldsymbol{C S}^{}$ ä¸­æ— äººæœº $u_{i}$ çš„ç­–ç•¥ã€‚ $\\boldsymbol{E}{-u{i}}^{*}$ï¼š$u_{i}$ ä¹‹å¤–çš„æ— äººæœºåœ¨ç¨³å®šè”ç›Ÿç»“æœä¸­çš„ç­–ç•¥é›†åˆã€‚ $\\bar{e}{u{i}}$ï¼šé™¤ $e{u{i}}^{*}$ å¤–çš„ä»»æ„ç­–ç•¥ï¼Œ$\\bar{e}{u{i}} \\in \\boldsymbol{T}$ã€‚ å½“ä»»ä½•æ— äººæœºéƒ½æ— æ³•é€šè¿‡ç‹¬è‡ªè°ƒæ•´æ‰€åœ¨è”ç›Ÿæ¥æé«˜æ”¶ç›Šæ—¶ï¼Œè¾¾åˆ°ç¨³å®šçš„è”ç›Ÿç»“æ„ã€‚è”ç›Ÿå½¢æˆåšå¼ˆçš„ç›®æ ‡æ˜¯å¾—åˆ°ç¨³å®šçš„è”ç›Ÿç»“æ„ï¼Œä¸ä»»åŠ¡åˆ†é…çš„ç›®æ ‡ä¸€è‡´ã€‚ åŠ¿åšå¼ˆ åŠ¿åšå¼ˆæ˜¯ä¸€ç§ç‰¹æ®Šçš„åšå¼ˆæ¨¡å‹ï¼Œå…¶å®šä¹‰å¦‚ä¸‹ï¼š å®šä¹‰ 2ï¼šåŠ¿åšå¼ˆ åœ¨åšå¼ˆæ¨¡å‹ä¸­ï¼Œè‹¥å­˜åœ¨ä¸€ä¸ªåŠ¿å‡½æ•° $P$ï¼Œæ»¡è¶³ï¼š Îµui(eui,Eâˆ’ui)âˆ’Îµui(eË‰ui,Eâˆ’ui)=P(eui,Eâˆ’ui)âˆ’P(eË‰ui,Eâˆ’ui),âˆ€uiâˆˆU,âˆ€eui,eË‰uiâˆˆEU \\varepsilon_{u_{i}}\\left(e_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right)-\\varepsilon_{u_{i}}\\left(\\bar{e}_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right)=P\\left(e_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right)-P\\left(\\bar{e}_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right), \\forall u_{i} \\in \\boldsymbol{U}, \\forall e_{u_{i}}, \\bar{e}_{u_{i}} \\in \\boldsymbol{E}_{\\boldsymbol{U}} Îµuiâ€‹â€‹(euiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)âˆ’Îµuiâ€‹â€‹(eË‰uiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)=P(euiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)âˆ’P(eË‰uiâ€‹â€‹,Eâˆ’uiâ€‹â€‹),âˆ€uiâ€‹âˆˆU,âˆ€euiâ€‹â€‹,eË‰uiâ€‹â€‹âˆˆEUâ€‹ åˆ™è¯¥åšå¼ˆç§°ä¸ºåŠ¿åšå¼ˆã€‚åŠ¿å‡½æ•° $P$ èƒ½å¤Ÿåæ˜ å‚ä¸è€…æ”¹å˜ç­–ç•¥åçš„æ•ˆç”¨å˜åŒ–ã€‚ æ€§è´¨ 1ï¼šåŠ¿åšå¼ˆçš„æ€§è´¨ åŠ¿åšå¼ˆå¿…ç„¶å­˜åœ¨çº³ä»€å‡è¡¡ç‚¹ã€‚ é€šè¿‡æœ€å°åŒ–æˆ–æœ€å¤§åŒ–åŠ¿å‡½æ•°ï¼Œå¯ä»¥è¾¾åˆ°åšå¼ˆçš„çº³ä»€å‡è¡¡ã€‚ åœ¨æœ‰é™é€’å¢ç‰¹æ€§ä¸‹ï¼ŒåŠ¿åšå¼ˆèƒ½å¤Ÿåœ¨æœ‰é™æ—¶é—´å†…æ”¶æ•›åˆ°çº³ä»€å‡è¡¡çŠ¶æ€ã€‚ åšå¼ˆæ¨¡å‹çš„åŠ¿åšå¼ˆæ„é€  æœ¬æ–‡å»ºç«‹çš„åšå¼ˆæ¨¡å‹ $\\boldsymbol{G}=(\\boldsymbol{U}, \\boldsymbol{E}, \\varepsilon, \\boldsymbol{R})$ å¯ä»¥æ„é€ ä¸ºåŠ¿åšå¼ˆï¼Œä¸”å…¶çº³ä»€å‡è¡¡è§£å­˜åœ¨ã€‚ å®šç† 1ï¼šåšå¼ˆæ¨¡å‹çš„åŠ¿åšå¼ˆæ„é€  åšå¼ˆæ¨¡å‹ $\\boldsymbol{G}$ å¯ä»¥æ„é€ ä¸ºåŠ¿åšå¼ˆï¼Œä¸”å…¶çº³ä»€å‡è¡¡è§£å­˜åœ¨ã€‚ è¯æ˜ï¼š è®¾è®¡åŠ¿å‡½æ•°ä¸ºï¼š P(eui,Eâˆ’ui)=SR(eui,Eâˆ’ui)=âˆ‘ctjâˆˆCSR(ctj) P\\left(e_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right)=S R\\left(e_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right)=\\sum_{c_{t_{j}} \\in C S} \\boldsymbol{R}\\left(c_{t_{j}}\\right) P(euiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)=SR(euiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)=ctjâ€‹â€‹âˆˆCSâˆ‘â€‹R(ctjâ€‹â€‹) å½“æ— äººæœº $u{i}$ çš„ç­–ç•¥ç”± $e{u{i}}$ æ”¹ä¸º $\\bar{e}{u_{i}}$ æ—¶ï¼ŒåŠ¿å‡½æ•°çš„å˜åŒ–ä¸ºï¼š P(eui,Eâˆ’ui)âˆ’P(eË‰ui,Eâˆ’ui)=SR(eui,Eâˆ’ui)âˆ’SR(eË‰ui,Eâˆ’ui)=[R(ceui)+R(ceË‰ui)+âˆ‘cmâˆˆCSÎ”R(cm)]âˆ’[R(cË‰eui)+R(cË‰eË‰ui)+âˆ‘cmâˆˆCSÎ”R(cm)] \\begin{aligned} P\\left(e_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right)-P\\left(\\bar{e}_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right) &= S R\\left(e_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right)-S R\\left(\\bar{e}_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right) \\\\ &= \\left[\\boldsymbol{R}\\left(c_{e_{u_{i}}}\\right)+\\boldsymbol{R}\\left(c_{\\bar{e}_{u_{i}}}\\right)+\\sum_{c_{m} \\in C S_{\\Delta}} \\boldsymbol{R}\\left(c_{m}\\right)\\right] -\\left[\\boldsymbol{R}\\left(\\bar{c}_{e_{u_{i}}}\\right)+\\boldsymbol{R}\\left(\\bar{c}_{\\bar{e}_{u_{i}}}\\right)+\\sum_{c_{m} \\in C S_{\\Delta}} \\boldsymbol{R}\\left(c_{m}\\right)\\right] \\end{aligned} P(euiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)âˆ’P(eË‰uiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)â€‹=SR(euiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)âˆ’SR(eË‰uiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)=[R(ceuiâ€‹â€‹â€‹)+R(ceË‰uiâ€‹â€‹â€‹)+cmâ€‹âˆˆCSÎ”â€‹âˆ‘â€‹R(cmâ€‹)]âˆ’[R(cË‰euiâ€‹â€‹â€‹)+R(cË‰eË‰uiâ€‹â€‹â€‹)+cmâ€‹âˆˆCSÎ”â€‹âˆ‘â€‹R(cmâ€‹)]â€‹ å…¶ä¸­ï¼š $\\boldsymbol{C S}{\\Delta}=\\boldsymbol{C S} \\mid\\left{c{e{u{i}}}, c{\\bar{e}{u{i}}}\\right}$ï¼šä¸åŒ…å«ä»»åŠ¡ $e{u{i}}$ å’Œ $\\bar{e}{u_{i}}$ çš„æ‰€æœ‰ä»»åŠ¡è”ç›Ÿã€‚ $\\bar{c}{e{u{i}}}=c{e{u{i}}} \\mid u{i}$ï¼šä»è”ç›Ÿ $c{e{u{i}}}$ ä¸­ç§»é™¤æ— äººæœº $u_{i}$ã€‚ $c{\\bar{e}{u{i}}}=\\bar{c}{\\bar{e}{u{i}}} \\mid u{i}$ï¼šä»è”ç›Ÿ $\\bar{c}{\\bar{e}{u{i}}}$ ä¸­ç§»é™¤æ— äººæœº $u_{i}$ã€‚ è¿›ä¸€æ­¥æ¨å¯¼å¯å¾—ï¼š P(eui,Eâˆ’ui)âˆ’P(eË‰ui,Eâˆ’ui)=(R(ceui)âˆ’R(cË‰eui))âˆ’(R(cË‰eË‰ui)+R(ceË‰ui))=Îµui(eui,Eâˆ’ui)âˆ’Îµui(eË‰ui,Eâˆ’ui) \\begin{aligned} P\\left(e_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right)-P\\left(\\bar{e}_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right) &= \\left(\\boldsymbol{R}\\left(c_{e_{u_{i}}}\\right)-\\boldsymbol{R}\\left(\\bar{c}_{e_{u_{i}}}\\right)\\right)-\\left(\\boldsymbol{R}\\left(\\bar{c}_{\\bar{e}_{u_{i}}}\\right)+\\boldsymbol{R}\\left(c_{\\bar{e}_{u_{i}}}\\right)\\right) \\\\ &= \\varepsilon_{u_{i}}\\left(e_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right)-\\varepsilon_{u_{i}}\\left(\\bar{e}_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right) \\end{aligned} P(euiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)âˆ’P(eË‰uiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)â€‹=(R(ceuiâ€‹â€‹â€‹)âˆ’R(cË‰euiâ€‹â€‹â€‹))âˆ’(R(cË‰eË‰uiâ€‹â€‹â€‹)+R(ceË‰uiâ€‹â€‹â€‹))=Îµuiâ€‹â€‹(euiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)âˆ’Îµuiâ€‹â€‹(eË‰uiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)â€‹ å› æ­¤ï¼Œå­˜åœ¨åŠ¿å‡½æ•° $P$ èƒ½å¤Ÿç­‰é‡åæ˜ å•ä¸ªæ— äººæœºç­–ç•¥çš„å˜åŒ–ã€‚æ ¹æ®å®šä¹‰ 2ï¼Œåšå¼ˆæ¨¡å‹ $\\boldsymbol{G}$ å¯æ„é€ ä¸ºåŠ¿åšå¼ˆï¼Œä¸”å…¶çº³ä»€å‡è¡¡è§£å¿…ç„¶å­˜åœ¨ã€‚ 2.2 ç›®æ ‡å‡½æ•°ä¸çº¦æŸæ¡ä»¶ 1. ç›®æ ‡å‡½æ•° æ— äººæœºé›†ç¾¤ä»»åŠ¡åˆ†é…çš„ç›®æ ‡æ˜¯æœ€å¤§åŒ–æ€»æ”¶ç›Š $S R$ï¼Œå…·ä½“è¡¨ç¤ºä¸ºï¼š maxâ¡SR=maxâ¡âˆ‘ctjâˆˆCSR(ctj) \\max S R = \\max \\sum_{c_{t_{j}} \\in C S} \\boldsymbol{R}\\left(c_{t_{j}}\\right) maxSR=maxctjâ€‹â€‹âˆˆCSâˆ‘â€‹R(ctjâ€‹â€‹) $S R$ï¼šä»»åŠ¡åˆ†é…é—®é¢˜çš„æ€»æ”¶ç›Šã€‚ $\\boldsymbol{R}\\left(c{t{j}}\\right)$ï¼šä»»åŠ¡ $t{j}$ å¯¹åº”çš„è”ç›Ÿ $c{t_{j}}$ çš„æ•ˆç”¨ã€‚ 2. çº¦æŸæ¡ä»¶ ä»»åŠ¡åˆ†é…é—®é¢˜éœ€è¦æ»¡è¶³ä»¥ä¸‹çº¦æŸæ¡ä»¶ï¼š ï¼ˆ1ï¼‰æ— äººæœºé£è¡Œé€Ÿåº¦çº¦æŸ vuiâ©½vuimaxâ¡,âˆ€uiâˆˆU v_{u_{i}} \\leqslant v_{u_{i}}^{\\max }, \\forall u_{i} \\in U vuiâ€‹â€‹â©½vuiâ€‹maxâ€‹,âˆ€uiâ€‹âˆˆU $v{u{i}}$ï¼šæ— äººæœº $u_{i}$ çš„é£è¡Œé€Ÿåº¦ã€‚ $v{u{i}}^{\\max }$ï¼šæ— äººæœº $u_{i}$ çš„æœ€å¤§é£è¡Œé€Ÿåº¦ã€‚ å«ä¹‰ï¼šæ‰§è¡Œä»»åŠ¡çš„æ— äººæœºå…·æœ‰æœ€å¤§é€Ÿåº¦çº¦æŸï¼Œæ„å‘³ç€æ— äººæœºåˆ°è¾¾ä»»åŠ¡åœ°ç‚¹å…·æœ‰æœ€çŸ­æ‰€éœ€æ—¶é—´çº¦æŸã€‚ ï¼ˆ2ï¼‰ä»»åŠ¡æ—¶æ•ˆæ€§çº¦æŸ mintâ¡(ui,tj)â©½ttjmaxstartâ¡,âˆ€uiâˆˆU,tjâˆˆT \\operatorname{mint}\\left(u_{i}, t_{j}\\right) \\leqslant t_{t_{j}}^{\\operatorname{maxstart}}, \\forall u_{i} \\in U, t_{j} \\in T mint(uiâ€‹,tjâ€‹)â©½ttjâ€‹maxstartâ€‹,âˆ€uiâ€‹âˆˆU,tjâ€‹âˆˆT $\\operatorname{mint}\\left(u{i}, t{j}\\right)$ï¼šæ— äººæœº $u{i}$ åˆ°è¾¾ä»»åŠ¡ $t{j}$ çš„æœ€çŸ­æ‰€éœ€æ—¶é—´ã€‚ $t{t{j}}^{\\operatorname{maxstart}}$ï¼šä»»åŠ¡ $t_{j}$ çš„æœ€æ™šå¼€å§‹æ—¶é—´ã€‚ å«ä¹‰ï¼šä»»åŠ¡çš„æ—¶æ•ˆæ€§çº¦æŸï¼Œå³æ— äººæœºéœ€è¦åœ¨ä»»åŠ¡æˆªæ­¢æ—¶é—´å‰åˆ°è¾¾ä»»åŠ¡åœ°ç‚¹ã€‚ ï¼ˆ3ï¼‰æ— äººæœºæ‰§è¡Œä»»åŠ¡æ¨¡å¼çº¦æŸ ctjâˆ©cti=âˆ…,âˆ€ti,tjâˆˆT c_{t_{j}} \\cap c_{t_{i}}=\\varnothing, \\forall t_{i}, t_{j} \\in \\boldsymbol{T} ctjâ€‹â€‹âˆ©ctiâ€‹â€‹=âˆ…,âˆ€tiâ€‹,tjâ€‹âˆˆT $c{t{j}}$ å’Œ $c{t{i}}$ï¼šåˆ†åˆ«è¡¨ç¤ºæ‰§è¡Œä»»åŠ¡ $t{j}$ å’Œ $t{i}$ çš„æ— äººæœºè”ç›Ÿã€‚ å«ä¹‰ï¼šä¸åŒä»»åŠ¡å¯¹åº”çš„è”ç›Ÿä¹‹é—´äº¤é›†ä¸ºç©ºé›†ï¼Œå³æ¯æ¶æ— äººæœºæœ€å¤šåªèƒ½æ‰§è¡Œä¸€ä¸ªä»»åŠ¡ã€‚ 3. æ•°å­¦æ¨¡å‹ åŸºäºä¸Šè¿°ç›®æ ‡å‡½æ•°å’Œçº¦æŸæ¡ä»¶ï¼Œä»»åŠ¡åˆ†é…é—®é¢˜çš„æ•°å­¦æ¨¡å‹å¯è¡¨ç¤ºä¸ºï¼š maxâ¡CSSRÂ s.t.Â vuiâ©½vuimaxâ¡,âˆ€uiâˆˆU,mintâ¡(ui,tj)â©½ttjmaxstartâ¡,âˆ€uiâˆˆU,tjâˆˆT,ctjâˆ©cti=âˆ…,âˆ€ti,tjâˆˆT \\begin{array}{c} \\max _{C S} S R \\\\\\\\ \\text { s.t. } \\quad v_{u_{i}} \\leqslant v_{u_{i}}^{\\max }, \\forall u_{i} \\in U, \\\\\\\\ \\operatorname{mint}\\left(u_{i}, t_{j}\\right) \\leqslant t_{t_{j}}^{\\operatorname{maxstart}}, \\forall u_{i} \\in U, t_{j} \\in T, \\\\\\\\ c_{t_{j}} \\cap c_{t_{i}}=\\varnothing, \\forall t_{i}, t_{j} \\in \\boldsymbol{T} \\end{array} maxCSâ€‹SRÂ s.t.Â vuiâ€‹â€‹â©½vuiâ€‹maxâ€‹,âˆ€uiâ€‹âˆˆU,mint(uiâ€‹,tjâ€‹)â©½ttjâ€‹maxstartâ€‹,âˆ€uiâ€‹âˆˆU,tjâ€‹âˆˆT,ctjâ€‹â€‹âˆ©ctiâ€‹â€‹=âˆ…,âˆ€tiâ€‹,tjâ€‹âˆˆTâ€‹ 4. ä»»åŠ¡åˆ†é…ç®—æ³•çš„ç›®æ ‡ ä»»åŠ¡åˆ†é…ç®—æ³•çš„ç›®æ ‡æ˜¯æ±‚å–ä»»åŠ¡å¯¹åº”çš„æ— äººæœºè”ç›Ÿï¼Œæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š ä»»åŠ¡éœ€æ±‚ä¸çº¦æŸï¼šè”ç›Ÿå†…çš„æ— äººæœºèƒ½å¤Ÿæ»¡è¶³ä»»åŠ¡éœ€æ±‚å’Œçº¦æŸæ¡ä»¶ã€‚ é›†ç¾¤æ•ˆèƒ½ï¼šå……åˆ†å‘æŒ¥æ— äººæœºé›†ç¾¤çš„æ•ˆèƒ½ã€‚ è·¯å¾„æˆæœ¬ä¸èµ„æºä¼˜åŒ–ï¼šé™ä½è·¯å¾„æˆæœ¬ï¼Œå‡å°‘è”ç›Ÿå†…å†—ä½™èµ„æºçš„æ•°é‡ã€‚ è‡³æ­¤ï¼Œä»»åŠ¡åˆ†é…é—®é¢˜å·²å»ºæ¨¡ä¸ºæœ€å¤§åŒ–åŠ¿å‡½æ•°çš„è”ç›Ÿåˆ’åˆ†é—®é¢˜ã€‚æ¥ä¸‹æ¥çš„å·¥ä½œæ˜¯åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„ç®—æ³•è®¾è®¡ï¼Œä»¥å®ç°æœ€ä¼˜ä»»åŠ¡åˆ†é…ã€‚ 3 è”ç›Ÿå½¢æˆåšå¼ˆç®—æ³•è®¾è®¡ åŸºäºå¼‚æ„èµ„æºçš„æ”¹è¿› K-medoids èšç±»ç®—æ³• æ— äººæœºé›†ç¾¤èšç±» ä»»åŠ¡èšç±» åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„ä»»åŠ¡åˆ†é…ç®—æ³• ç®—æ³•å¤æ‚åº¦åˆ†æ ç®—æ³• 1: åŸºäºå¼‚æ„èµ„æºçš„æ”¹è¿› K-medoids èšç±»ç®—æ³• è¾“å…¥: æ— äººæœºé›†åˆ U çš„æœºè½½èµ„æºä¿¡æ¯ Res_u å’Œä½ç½®ä¿¡æ¯ position_uï¼Œç±»ç°‡ä¸ªæ•°: k, åˆå§‹èšç±»ç»“æœ ä¸»è¿­ä»£: for j = 1:l do feature_j = Î² do éšæœºé€‰æ‹© k ä¸ªæ— äººæœºä½œä¸ºåˆå§‹ç±»ç°‡ä¸­å¿ƒ prev_medoids_index; é‡å¤ K-medoids èšç±»ç®—æ³•å¾—åˆ°æ–°çš„èšç±»ç»“æœï¼› end while end for è¾“å‡º: æœ€ç»ˆæ— äººæœºé›†ç¾¤èšç±»ç»“æœ ç®—æ³• 2: æ— äººæœºè½¬ç§»è”ç›Ÿåˆ¤æ–­ç®—æ³• è¾“å…¥ æœ€å¤§åŠ æƒåŒ¹é…ç»“æœ E' å’Œ ä»»åŠ¡ä¿¡æ¯ TIN ä¸»è¿­ä»£: for j = 1:m do for ui \\in ctj and ui == arg_{uk \\in ctj} min ruk(tj) do epsilon_ui(eui, E_{-ui}) = epsilon_ui(\\bar{eui}, E_{-ui}) then ui \\in cui else ui \\in ct0 end if end for end for TINtj 3.1 åŸºäºå¼‚æ„èµ„æºçš„æ”¹è¿› K-medoids èšç±»ç®—æ³• èšç±»æ˜¯æŒ‰ç…§æŸä¸ªæŒ‡æ ‡å°†æ•°æ®é›†åˆ’åˆ†ä¸ºä¸åŒçš„ç°‡æˆ–ç±», æœ€å¸¸è§çš„æ˜¯åŸºäºè·ç¦»è¿›è¡Œåˆ†å‰², å°½å¯èƒ½å¢å¤§ç±»å†…å…ƒç´ çš„ç›¸ä¼¼æ€§, åŒæ—¶é™ä½ç±»é—´å…ƒç´ çš„ç›¸ä¼¼æ€§. å¯¹ç›¸ä¼¼çš„æ•°æ®è¿›è¡Œåˆ†å‰²å½’ç°‡, å®ç°èšç±». ä¸ºäº†é™ä½åŸé—®é¢˜çš„è§„æ¨¡å¤§å°, æœ¬æ–‡åœ¨è¿›è¡Œå…¨å±€ä»»åŠ¡åˆ†é…å‰, ä½œåŸºäºè·ç¦»å’Œèµ„æºå¯¹ä»»åŠ¡å’Œæ— äººæœºé›†ç¾¤èšç±»çš„é¢„å¤„ç†, ä»è€Œç¼©çŸ­ä»»åŠ¡åˆ†é…çš„è®¡ç®—æ—¶é—´, æé«˜ä»»åŠ¡åˆ†é…æ•ˆç‡ [18]. 3.1.1 æ— äººæœºé›†ç¾¤èšç±» 1. èšç±»ç›®æ ‡ ä¸ºäº†ä¿è¯åç»­ç±»ç°‡å†…å±€éƒ¨ä»»åŠ¡åˆ†é…çš„åˆç†æ€§ï¼Œèšç±»ç»“æœéœ€è¦æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š èµ„æºå‡è¡¡ï¼šæ¯ä¸ªç±»ç°‡å†…çš„èµ„æºç›¸å¯¹å‡è¡¡ã€‚ è·ç¦»ä¸å¼‚æ„èµ„æºç»“åˆï¼šåŸºäºè·ç¦»å’Œå¼‚æ„èµ„æºå¯¹æ— äººæœºè¿›è¡Œåˆç†èšç±»ã€‚ 2. K-medoids èšç±»ç®—æ³• æœ¬æ–‡é‡‡ç”¨ K-medoids ç®—æ³•å¯¹æ— äººæœºè¿›è¡Œåˆå§‹èšç±»ã€‚K-medoids ç®—æ³•ç›¸æ¯” K-means å…·æœ‰æ›´å¼ºçš„é²æ£’æ€§ï¼Œå¼‚å¸¸ç‚¹ä¸ä¼šä¸¥é‡å½±å“èšç±»ç»“æœã€‚ 2.1 ç®—æ³•å®šä¹‰ æ•°æ®é›†ï¼š$\\boldsymbol{P}=\\left{p{1}, p{2}, \\ldots, p_{n}\\right}$ï¼Œè¡¨ç¤º $n$ ä¸ªæ— äººæœºç‚¹ã€‚ ç±»ç°‡åˆ’åˆ†ï¼šå°†æ•°æ®é›†åˆ†ä¸º $k$ ä¸ªç±»ç°‡ï¼Œè®°ä¸º $\\boldsymbol{C}=\\left{\\boldsymbol{c}{1}, \\boldsymbol{c}{2}, \\ldots, \\boldsymbol{c}_{k}\\right}$ã€‚ ç±»ç°‡ä¸­å¿ƒï¼šæ¯ä¸ªç±»ç°‡ $\\boldsymbol{c}{i}$ çš„ä¸­å¿ƒç‚¹è®°ä¸º $o{i}$ã€‚ 2.2 ä»£ä»·å‡½æ•° è®¾è®¡ä»£ä»·å‡½æ•° $E$ è¯„ä¼°èšç±»ç»“æœï¼Œä½¿å…¶å°½å¯èƒ½å°ï¼š E=âˆ‘j=1kâˆ‘Pâˆˆcjâˆ¥pâˆ’oiâˆ¥2 E=\\sum_{j=1}^{k} \\sum_{P \\in c_{j}}\\left\\|p-o_{i}\\right\\|_{2} E=j=1âˆ‘kâ€‹Pâˆˆcjâ€‹âˆ‘â€‹âˆ¥pâˆ’oiâ€‹âˆ¥2â€‹ $E$ï¼šå„ä¸ªæ ·æœ¬ç‚¹è·ç¦»å„ç±»ç°‡ä¸­å¿ƒçš„è¯¯å·®ä¹‹å’Œã€‚ $\\left|p-o{i}\\right|{2}$ï¼šæ ·æœ¬ç‚¹ $p$ ä¸ç±»ç°‡ä¸­å¿ƒ $o_{i}$ çš„æ¬§æ°è·ç¦»ã€‚ 3. å¼‚æ„èµ„æºå‡è¡¡çº¦æŸ ä¸ºäº†åœ¨èšç±»ç»“æœä¸­è€ƒè™‘å¼‚æ„èµ„æºçš„å‡è¡¡æ€§ï¼Œæœ¬æ–‡åœ¨æ”¶æ•›æ¡ä»¶ä¸­åŠ å…¥å¯¹å¼‚æ„èµ„æºçš„çº¦æŸã€‚ 3.1 èµ„æºé›¶å‡å€¼åŒ–å¤„ç† å¯¹æ¯ç±»èµ„æºè¿›è¡Œé›¶å‡å€¼åŒ–å¤„ç†ï¼Œå°†èµ„æºæ•°ç›®è½¬åŒ–ä¸ºä¸€ç»„å’Œä¸ºé›¶çš„æ­£è´Ÿç‰¹å¾æ•°æ®ï¼š âˆ‘uiâˆˆURË‰uij=0 \\sum_{u_{i} \\in U} \\bar{R}_{u_{i}}^{j}=0 uiâ€‹âˆˆUâˆ‘â€‹RË‰uiâ€‹jâ€‹=0 $\\bar{R}{u{i}}^{j}$ï¼šæ— äººæœº $u_{i}$ çš„ç¬¬ $j$ ç±»èµ„æºç»è¿‡é›¶å‡å€¼åŒ–å¤„ç†åçš„å€¼ã€‚ 3.2 èµ„æºå‡è¡¡æ¡ä»¶ ç±»ç°‡å†…æ¯ç±»èµ„æºçš„å‡è¡¡åº¦é€šè¿‡ä»¥ä¸‹æ¡ä»¶çº¦æŸï¼š âˆ£âˆ‘UâˆˆciRË‰uijâˆ£Î²,i={1,2,â€¦,k},j={1,2,â€¦,l} \\left|\\sum_{U \\in \\boldsymbol{c}_{i}} \\bar{R}_{u_{i}}^{j}\\right|âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹Uâˆˆciâ€‹âˆ‘â€‹RË‰uiâ€‹jâ€‹âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹Î²,i={1,2,â€¦,k},j={1,2,â€¦,l} $\\beta$ï¼šè®¾å®šçš„å¸¸å€¼ï¼Œç”¨äºæ§åˆ¶èµ„æºå‡è¡¡çš„é˜ˆå€¼ã€‚ $\\sum{U \\in \\boldsymbol{c}{i}} \\bar{R}{u{i}}^{j}$ï¼šç±»ç°‡ $\\boldsymbol{c}_{i}$ å†…ç¬¬ $j$ ç±»èµ„æºçš„æ€»å’Œã€‚ å½“èšç±»ç»“æœæ»¡è¶³ä¸Šè¿°æ¡ä»¶æ—¶ï¼Œè¿­ä»£ç»“æŸï¼Œæ­¤æ—¶ç±»ç°‡å†…æ¯ç±»èµ„æºæ»¡è¶³å‡è¡¡è¦æ±‚ã€‚ 4. æ”¹è¿›çš„ K-medoids èšç±»ç®—æ³• åŸºäºå¼‚æ„èµ„æºçš„æ”¹è¿› K-medoids èšç±»ç®—æ³•çš„æ ¸å¿ƒæ­¥éª¤å¦‚ä¸‹ï¼š åˆå§‹åŒ–ï¼šéšæœºé€‰æ‹© $k$ ä¸ªç±»ç°‡ä¸­å¿ƒã€‚ è¿­ä»£èšç±»ï¼š å°†æ¯ä¸ªæ— äººæœºç‚¹åˆ†é…åˆ°æœ€è¿‘çš„ç±»ç°‡ä¸­å¿ƒã€‚ æ›´æ–°ç±»ç°‡ä¸­å¿ƒï¼Œé€‰æ‹©ä½¿ä»£ä»·å‡½æ•° $E$ æœ€å°çš„ç‚¹ä½œä¸ºæ–°çš„ä¸­å¿ƒã€‚ èµ„æºå‡è¡¡æ£€æŸ¥ï¼š æ£€æŸ¥æ¯ä¸ªç±»ç°‡çš„èµ„æºæ˜¯å¦æ»¡è¶³å‡è¡¡æ¡ä»¶ $\\left|\\sum{U \\in \\boldsymbol{c}{i}} \\bar{R}{u{i}}^{j}\\right| å¦‚æœæ»¡è¶³ï¼Œèšç±»ç»“æŸï¼›å¦åˆ™ï¼Œé‡æ–°åˆå§‹åŒ–ç±»ç°‡ä¸­å¿ƒå¹¶è¿›å…¥ä¸‹ä¸€è½®è¿­ä»£ã€‚ 5. ç®—æ³•ä¼˜åŠ¿ é™ä½é—®é¢˜è§„æ¨¡ï¼šé€šè¿‡åˆç†çš„é¢„å¤„ç†ï¼ˆå¦‚èµ„æºé›¶å‡å€¼åŒ–å¤„ç†ï¼‰ï¼Œé™ä½åŸä»»åŠ¡åˆ†é…é—®é¢˜çš„è§„æ¨¡ã€‚ èµ„æºå‡è¡¡æ€§ï¼šåœ¨èšç±»è¿‡ç¨‹ä¸­è€ƒè™‘å¼‚æ„èµ„æºçš„å‡è¡¡æ€§ï¼Œä¸ºåç»­ä»»åŠ¡åˆ†é…æä¾›æ›´åˆç†çš„ç±»ç°‡åˆ’åˆ†ã€‚ é²æ£’æ€§ï¼šK-medoids ç®—æ³•å¯¹å¼‚å¸¸ç‚¹å…·æœ‰è¾ƒå¼ºçš„é²æ£’æ€§ï¼Œèƒ½å¤Ÿæ›´å¥½åœ°é€‚åº”å®é™…åœºæ™¯ä¸­çš„å™ªå£°æ•°æ®ã€‚ 3.1.2 ä»»åŠ¡èšç±» ä»»åŠ¡èšç±»çš„å…·ä½“å®ç°æ­¥éª¤ä¸ä¸Šæ–‡ä¸€è‡´, å°† m ä¸ªä»»åŠ¡è¿›è¡Œèšç±»åˆ’åˆ†ä¸º k ä¸ªç±»ç°‡. ç»è¿‡èšç±»åçš„æ—  äººæœºé›†ç¾¤å’Œä»»åŠ¡ç±»ç°‡å¯ä¸€ä¸€å¯¹åº”, æ„æˆä¸€ä¸ªå®Œæ•´åˆ†åŒº. å½“æ— äººæœºé›†ç¾¤çš„æ€»èµ„æºæ»¡è¶³ä»»åŠ¡éœ€æ±‚ä¸”å•æ— äºº æœºå’Œå•ä»»åŠ¡èµ„æºç›¸å¯¹å‡è¡¡æ—¶, ç»è¿‡åŸºäºèµ„æºèšç±»åçš„åˆ†åŒºå†…æ— äººæœºèµ„æºäº¦èƒ½å¤Ÿæ»¡è¶³ä»»åŠ¡éœ€æ±‚. é€šè¿‡èšç±»çš„é¢„å¤„ç†æå¤§åœ°é™ä½äº†åŸé—®é¢˜çš„è§„æ¨¡, ä»è€Œç¼©çŸ­ä»»åŠ¡åˆ†é…çš„è®¡ç®—æ—¶é—´, æ˜¾è‘—æé«˜ä»»åŠ¡åˆ† é…æ•ˆç‡. 3.2 åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„ä»»åŠ¡åˆ†é…ç®—æ³• æœ¬æ–‡æå‡ºçš„åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•ï¼Œé€šè¿‡æœ€å¤§åŠ æƒåŒ¹é…å’Œæ— äººæœºè½¬ç§»è”ç›Ÿåˆ¤æ–­ï¼Œå®ç°äº†æ— äººæœºé›†ç¾¤çš„é«˜æ•ˆä»»åŠ¡åˆ†é…ã€‚ç®—æ³•å…·æœ‰çº³ä»€ç¨³å®šæ€§å’Œæ”¶æ•›æ€§ï¼Œèƒ½å¤Ÿå…¨å±€ä¼˜åŒ–æ•ˆç”¨å¹¶æé«˜å®æ—¶æ€§ã€‚ 1. ç®—æ³•æ¦‚è¿° æœ¬æ–‡æå‡ºäº†ä¸€ç§åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•ï¼Œé€šè¿‡èšç±»é¢„å¤„ç†å’Œåˆ†é˜¶æ®µæ±‚è§£ï¼Œå®ç°æ— äººæœºé›†ç¾¤çš„ä»»åŠ¡åˆ†é…ã€‚ç®—æ³•çš„ä¸»è¦æµç¨‹åŒ…æ‹¬ï¼š æœ€å¤§åŠ æƒåŒ¹é…é˜¶æ®µï¼šåŸºäºæ”¶ç›ŠçŸ©é˜µè¿›è¡Œä»»åŠ¡ä¸æ— äººæœºçš„åˆå§‹åŒ¹é…ã€‚ æ— äººæœºè½¬ç§»è”ç›Ÿåˆ¤æ–­é˜¶æ®µï¼šæ£€æŸ¥æ— äººæœºçš„è”ç›Ÿç¨³å®šæ€§ï¼Œæ›´æ–°ä»»åŠ¡éœ€æ±‚å’Œæ”¶ç›ŠçŸ©é˜µã€‚ è¿­ä»£ç›´è‡³ç¨³å®šï¼šé‡å¤åŒ¹é…å’Œæ£€æŸ¥ï¼Œç›´åˆ°æ‰€æœ‰æ— äººæœºè¾¾åˆ°ç¨³å®šçŠ¶æ€ã€‚ 2. ç®—æ³•å®šä¹‰ä¸æ ¸å¿ƒæ¦‚å¿µ å®šä¹‰ 3ï¼šåŒ¹é…ï¼ˆMatchingï¼‰ ç»™å®šä¸€ä¸ªäºŒåˆ†å›¾ $G$ï¼Œ$M$ æ˜¯ $G$ çš„ä¸€ä¸ªå­å›¾ï¼Œä¸”å…¶è¾¹é›† ${E}$ ä¸­çš„ä»»æ„ä¸¤æ¡è¾¹éƒ½ä¸ä¾é™„äºåŒä¸€ä¸ªé¡¶ç‚¹ï¼Œåˆ™ $M$ ç§°ä¸º $G$ çš„ä¸€ä¸ªåŒ¹é…ã€‚ å®šä¹‰ 4ï¼šæœ€å¤§åŠ æƒåŒ¹é…ï¼ˆMaximum Weighted Matchingï¼‰ åœ¨å¸¦æœ‰æƒå€¼è¾¹çš„äºŒåˆ†å›¾ä¸­ï¼Œä½¿åŒ¹é…è¾¹ä¸Šçš„æƒå€¼å’Œæœ€å¤§çš„åŒ¹é…ã€‚ 3. ç®—æ³•æµç¨‹ æœ€å¤§åŠ æƒåŒ¹é…é˜¶æ®µ æ— äººæœºè½¬ç§»è”ç›Ÿåˆ¤æ–­é˜¶æ®µ è¿­ä»£ç›´è‡³ç¨³å®š 3.1 æœ€å¤§åŠ æƒåŒ¹é…é˜¶æ®µ ç›®æ ‡: å°†ä»»åŠ¡å’Œæ— äººæœºé›†åˆçœ‹ä½œäºŒåˆ†å›¾ä¸­çš„ $X$ å’Œ $Y$ é›†åˆï¼ŒåŸºäºæ”¶ç›ŠçŸ©é˜µè¿›è¡Œæœ€å¤§åŠ æƒåŒ¹é…ã€‚ æ­¥éª¤ åˆå§‹åŒ–ï¼š æ‰€æœ‰ä»»åŠ¡æ ‡è®°ä¸ºæœªåˆ†é…ï¼Œå¯¹åº”çš„è”ç›Ÿç»“æ„ä¸ºç©ºé›†ã€‚ æ‰€æœ‰æ— äººæœºå‡æœªè¢«åˆ†é…ä»»åŠ¡ï¼Œåˆå§‹è”ç›Ÿ $c{t{0}}=\\boldsymbol{U}$ã€‚ è®¡ç®—æ”¶ç›ŠçŸ©é˜µï¼š è®¡ç®—æ¯ä¸ªæ— äººæœºå•ç‹¬æ‰§è¡Œæ¯é¡¹ä»»åŠ¡çš„æ”¶ç›Šï¼Œå¾—åˆ° $M \\times N$ ç»´æ”¶ç›ŠçŸ©é˜µ $V$ã€‚ è‹¥æ— äººæœºæ— æ³•åœ¨ä»»åŠ¡æˆªæ­¢æ—¶é—´å‰åˆ°è¾¾ï¼Œåˆ™æ”¶ç›Šè®°ä¸º $0$ã€‚ æ„å»ºåŠ æƒäºŒåˆ†å›¾ï¼š å°†æ”¶ç›ŠçŸ©é˜µè½¬åŒ–ä¸ºåŠ æƒäºŒåˆ†å›¾ï¼Œåˆå§‹åŒ–é¡¶æ ‡ï¼š ä»»åŠ¡é¡¶ç‚¹è®¾ç½®ä¸ºå„æ— äººæœºå•ç‹¬åŠ å…¥è¯¥è”ç›Ÿåæ”¶ç›Šçš„æœ€å¤§å€¼ $x[i]$ã€‚ æ— äººæœºé¡¶ç‚¹é¢„è®¾ä¸º $y[i]=0$ã€‚ åŒ¹é…åŸåˆ™ï¼šé¡¶ç‚¹å€¼ç›¸åŠ ç­‰äºä¸å…¶ç›¸è¿è¾¹çš„æƒé‡ $w[i][j]$ï¼Œå³ $x[i]+y[j]=w[i][j]$ã€‚ è™šæ‹ŸèŠ‚ç‚¹å¤„ç†ï¼š å¢åŠ è™šæ‹ŸèŠ‚ç‚¹ï¼Œæƒé‡è®¾ä¸ºç‰¹åˆ«å°çš„å€¼ï¼Œç¡®ä¿ä¸å½±å“æ­£å¸¸åŒ¹é…ã€‚ åŒ¹é…å®Œæˆååˆ é™¤è™šæ‹ŸèŠ‚ç‚¹åŒ¹é…éƒ¨åˆ†ã€‚ 3.2 æ— äººæœºè½¬ç§»è”ç›Ÿåˆ¤æ–­é˜¶æ®µ ç›®æ ‡: æ£€æŸ¥æ— äººæœºçš„è”ç›Ÿç¨³å®šæ€§ï¼Œæ›´æ–°ä»»åŠ¡éœ€æ±‚å’Œæ”¶ç›ŠçŸ©é˜µã€‚ æ­¥éª¤: æ›´æ–°ä»»åŠ¡éœ€æ±‚ï¼š æ ¹æ®åŒ¹é…ç»“æœæ›´æ–°ä»»åŠ¡å‰©ä½™æ‰€éœ€èµ„æºã€‚ æ£€æŸ¥æ— äººæœºæ•ˆç”¨ï¼š è®¡ç®—æ— äººæœºåœ¨å½“å‰è”ç›Ÿä¸­çš„æ•ˆç”¨ï¼š Îµui(eui,Eâˆ’ui)=R(cui)âˆ’R(cuiâˆ£ui) \\varepsilon_{u_{i}}\\left(e_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right)=\\boldsymbol{R}\\left(c_{u_{i}}\\right)-\\boldsymbol{R}\\left(c_{u_{i}} \\mid u_{i}\\right) Îµuiâ€‹â€‹(euiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)=R(cuiâ€‹â€‹)âˆ’R(cuiâ€‹â€‹âˆ£uiâ€‹) $c{u{i}}$ï¼šæ— äººæœº $u_{i}$ å½“å‰åŠ å…¥çš„ä»»åŠ¡è”ç›Ÿã€‚ $\\boldsymbol{R}\\left(c{u{i}} \\mid u{i}\\right)$ï¼šå°† $u{i}$ ä»åŸè”ç›Ÿä¸­åˆ é™¤åçš„è”ç›Ÿæ•ˆç”¨ã€‚ è®¡ç®—æ— äººæœºåŠ å…¥å…¶ä»–ä»»åŠ¡è”ç›Ÿæ—¶çš„æ•ˆç”¨ï¼š Îµui(eË‰ui,Eâˆ’ui)=R(cË‰uiâˆªui)âˆ’R(cË‰ui) \\varepsilon_{u_{i}}\\left(\\bar{e}_{u_{i}}, \\boldsymbol{E}_{-u_{i}}\\right)=\\boldsymbol{R}\\left(\\bar{c}_{u_{i}} \\cup u_{i}\\right)-\\boldsymbol{R}\\left(\\bar{c}_{u_{i}}\\right) Îµuiâ€‹â€‹(eË‰uiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)=R(cË‰uiâ€‹â€‹âˆªuiâ€‹)âˆ’R(cË‰uiâ€‹â€‹) $\\bar{c}{u{i}}$ï¼šæ— äººæœº $u{i}$ é€‰æ‹©ç­–ç•¥ $\\bar{e}{u_{i}}$ æ—¶åŠ å…¥çš„ä»»åŠ¡è”ç›Ÿã€‚ è½¬ç§»è§„åˆ™ï¼š è‹¥å­˜åœ¨ $\\bar{e}{u{i}}$ ä½¿ $\\varepsilon{u{i}}\\left(\\bar{e}{u{i}}, \\boldsymbol{E}{-u{i}}\\right) > \\varepsilon{u{i}}\\left(e{u{i}}, \\boldsymbol{E}{-u{i}}\\right)$ï¼Œåˆ™æ— äººæœºé€€å‡ºåŸè”ç›Ÿï¼Œç­‰å¾…é‡æ–°åˆ†é…ã€‚ å¦åˆ™ï¼Œæ— äººæœºä¿æŒå½“å‰è”ç›Ÿå…³ç³»ä¸å˜ã€‚ æ›´æ–°æ”¶ç›ŠçŸ©é˜µï¼š æ ¹æ®æ£€æŸ¥ç»“æœæ›´æ–°æœªåˆ†é…æ— äººæœºé›†åˆ $c{t{0}}$ å’Œä»»åŠ¡å‰©ä½™éœ€æ±‚ï¼Œè®¡ç®—æ–°çš„æ”¶ç›ŠçŸ©é˜µ $V$ã€‚ 3.3 è¿­ä»£ç›´è‡³ç¨³å®š ç›®æ ‡: é‡å¤åŒ¹é…å’Œæ£€æŸ¥ï¼Œç›´åˆ°æ‰€æœ‰æ— äººæœºè¾¾åˆ°ç¨³å®šçŠ¶æ€ã€‚ æ­¥éª¤: é‡å¤åŒ¹é…ï¼š æ ¹æ®æ–°çš„æ”¶ç›ŠçŸ©é˜µè¿›è¡Œæœ€å¤§åŠ æƒåŒ¹é…ã€‚ æ£€æŸ¥ç¨³å®šæ€§ï¼š å¯¹æ–°åŒ¹é…çš„æ— äººæœºè¿›è¡Œæ•ˆç”¨æ£€æŸ¥ï¼Œæ›´æ–°è”ç›Ÿç»“æ„ã€‚ æ”¶æ•›æ¡ä»¶ï¼š æ‰€æœ‰æ— äººæœºç¨³å®šï¼Œå³æ— æ³•é€šè¿‡æ›´æ”¹æ‰€å±è”ç›Ÿæé«˜è‡ªèº«æ”¶ç›Šã€‚ 4. ç®—æ³•æ€§è´¨ 4.1 çº³ä»€ç¨³å®šæ€§ æœ€ç»ˆè”ç›Ÿç»“æ„ $\\boldsymbol{C S}^{*}$ æ˜¯çº³ä»€ç¨³å®šçš„ã€‚è¯æ˜å¦‚ä¸‹ï¼š å‡è®¾ $\\boldsymbol{C S}^{*}$ ä¸ç¨³å®šï¼Œåˆ™å­˜åœ¨è‡³å°‘ä¸€ä¸ªæ— äººæœº $u_{i}$ å¯ä»¥é€šè¿‡åˆ‡æ¢è”ç›Ÿæé«˜æ”¶ç›Šã€‚ å³å­˜åœ¨ $\\bar{e}{u{i}}$: Îµui(eË‰ui,Eâˆ’ui)>Îµui(eui,Eâˆ’ui) \\varepsilon_{u_{i}}(\\bar{e}_{u_{i}}, \\boldsymbol{E}_{-u_{i}}) > \\varepsilon_{u_{i}}(e_{u_{i}}, \\boldsymbol{E}_{-u_{i}}) Îµuiâ€‹â€‹(eË‰uiâ€‹â€‹,Eâˆ’uiâ€‹â€‹)>Îµuiâ€‹â€‹(euiâ€‹â€‹,Eâˆ’uiâ€‹â€‹) æ ¹æ®è½¬ç§»è§„åˆ™ï¼Œ$u_{i}$ å¯ä»¥è½¬æ¢è‡³æ–°è”ç›Ÿï¼Œä¸å‡è®¾çŸ›ç›¾ã€‚ å› æ­¤ï¼Œ$\\boldsymbol{C S}^{*}$ æ˜¯çº³ä»€ç¨³å®šçš„ã€‚ 4.2 æ”¶æ•›æ€§ æ ¹æ®åŠ¿åšå¼ˆçš„æ€§è´¨ï¼Œè”ç›Ÿç»“æ„ç»è¿‡æœ‰é™æ¬¡æ”¹å˜ä¼šæ”¶æ•›è‡³çº³ä»€å‡è¡¡ã€‚ ç®—æ³•å…·æœ‰è‰¯å¥½çš„é²æ£’æ€§å’Œå®æ—¶æ€§ 3.3 ç®—æ³•å¤æ‚åº¦åˆ†æ é—®é¢˜æè¿° å°† $m$ é¡¹ä»»åŠ¡åˆ†é…ç»™ $n$ ä¸ªæ— äººæœºçš„ä»»åŠ¡åˆ†é…é—®é¢˜ï¼Œç®—æ³•çš„ä¸»è¦å·¥ä½œé‡åœ¨äºå¯¹è”ç›Ÿæ•ˆç”¨çš„è®¡ç®—ã€‚å‡è®¾æ¯æ¬¡è”ç›Ÿæ•ˆç”¨çš„è®¡ç®—å¤æ‚åº¦ä¸º $CP$ã€‚ å¤æ‚åº¦å¯¹æ¯” æšä¸¾æ³•ï¼š$O_{\\text{enum}} = (m+1)^{n} \\times CP$ï¼ˆæŒ‡æ•°çº§ï¼‰ã€‚ æœ¬æ–‡ç®—æ³•ï¼š$O_{CFG} \\leqslant (m n + m(m-1)) \\times CP \\times l$ï¼ˆå¤šé¡¹å¼çº§ï¼‰ã€‚ æšä¸¾æ³•çš„å¤æ‚åº¦ æšä¸¾æ³•çš„ç®—æ³•å¤æ‚åº¦ä¸ºï¼š Oenum=(m+1)nÃ—CP O_{\\text{enum}} = (m+1)^{n} \\times CP Oenumâ€‹=(m+1)nÃ—CP ç‰¹ç‚¹ï¼šè¿™æ˜¯ä¸€ä¸ªæŒ‡æ•°çº§çš„å¤æ‚åº¦ã€‚ é—®é¢˜ï¼šå¯¹äºè¾ƒå¤§çš„æ— äººæœºæ•°é‡ $n$ï¼Œè®¡ç®—é‡ä¼šæ€¥å‰§å¢åŠ ï¼Œéš¾ä»¥åœ¨å®é™…åº”ç”¨ä¸­é«˜æ•ˆè¿è¡Œã€‚ æœ¬æ–‡ç®—æ³•çš„å¤æ‚åº¦ æœ¬æ–‡æå‡ºçš„åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•çš„å¤æ‚åº¦ä¸ºï¼š OCFG=(mn+m(mâˆ’1))Ã—CP+(mnâ€²+m(mâˆ’1))Ã—CP+â‹¯â©½(mn+m(mâˆ’1))Ã—CPÃ—l \\begin{aligned} O_{CFG} &= (m n + m(m-1)) \\times CP + \\left(m n^{\\prime} + m(m-1)\\right) \\times CP + \\cdots \\\\ &\\leqslant (m n + m(m-1)) \\times CP \\times l \\end{aligned} OCFGâ€‹â€‹=(mn+m(mâˆ’1))Ã—CP+(mnâ€²+m(mâˆ’1))Ã—CP+â‹¯â©½(mn+m(mâˆ’1))Ã—CPÃ—lâ€‹ å‚æ•°è¯´æ˜ï¼š $m$ï¼šä»»åŠ¡æ•°é‡ã€‚ $n$ï¼šæ— äººæœºæ•°é‡ã€‚ $n^{\\prime}$ï¼šæœªåˆ†é…æ— äººæœºçš„æ•°é‡ï¼ˆéšç€è¿­ä»£å‡å°‘ï¼‰ã€‚ $l$ï¼šè¿­ä»£æ¬¡æ•°ï¼Œå–å†³äºæ— äººæœºå’Œä»»åŠ¡çš„å‚æ•°ã€‚ ç‰¹ç‚¹ï¼šè¿™æ˜¯ä¸€ä¸ªå¤šé¡¹å¼å‹å¤æ‚åº¦ã€‚ ä¼˜åŠ¿ï¼šç›¸æ¯”æšä¸¾æ³•çš„æŒ‡æ•°çº§å¤æ‚åº¦ï¼Œæœ¬æ–‡ç®—æ³•æ˜¾è‘—é™ä½äº†é—®é¢˜çš„å¤æ‚åº¦å’Œè®¡ç®—é‡ã€‚ æ€»ç»“ æœ¬æ–‡æå‡ºçš„åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•ï¼Œé€šè¿‡å¤šé¡¹å¼çº§çš„å¤æ‚åº¦ï¼Œæ˜¾è‘—é™ä½äº†ä»»åŠ¡åˆ†é…é—®é¢˜çš„è®¡ç®—é‡ï¼Œèƒ½å¤Ÿé«˜æ•ˆå¤„ç†è¾ƒå¤§è§„æ¨¡çš„æ— äººæœºé›†ç¾¤ä»»åŠ¡åˆ†é…é—®é¢˜ã€‚ 4 ä»¿çœŸéªŒè¯ åŸºäºå¼‚æ„èµ„æºçš„æ”¹è¿› K-medoids èšç±»ç®—æ³•ç»“æœåˆ†æ åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„ä»»åŠ¡åˆ†é…ç®—æ³•ç»“æœåˆ†æ åŸºäºå¼‚æ„èµ„æºçš„æ”¹è¿› K-medoids èšç±»ç®—æ³•ç»“æœåˆ†æ åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„ä»»åŠ¡åˆ†é…ç®—æ³•ç»“æœåˆ†æ ä¸ºäº†éªŒè¯æœ¬æ–‡åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆä»»åŠ¡åˆ†é…ç®—æ³•ï¼Œä»¿çœŸåœºæ™¯è®¾ç½®åœ¨æŸä¸€æ¬¡èšç±»ç»“æœçš„åˆ†åŒºå†…ï¼Œå…±æœ‰ä¹æ¶å¼‚æ„æ— äººæœºå’Œä¸‰ä¸ªä»»åŠ¡ï¼Œåˆå§‹å‚æ•°ä¸å…·ä½“å±•å¼€ï¼åœ¨ç›¸åŒå‚æ•°è®¾ç½®ä¸‹ä¸æšä¸¾æ³•è¿›è¡Œå¯¹æ¯”ï¼Œä»è€ŒéªŒè¯ç®—æ³•çš„æœ‰æ•ˆæ€§ã€‚ åŸºäºè”ç›Ÿå½¢æˆåšäº¦ç®—æ³•è¿è¡Œç»“æœå¦‚è¡¨ 3 æ‰€ç¤ºï¼Œé‡å¤è¿è¡Œ 10 æ¬¡ï¼Œå¹³å‡ä»¿çœŸæ—¶é—´ä¸º 0.094 s ï¼ä¸Šè¿°ç»“æœä¸­ï¼Œæ¯ä¸ªè”ç›Ÿå†…çš„èµ„æºèƒ½å¤Ÿæ»¡è¶³ä»»åŠ¡éœ€æ±‚ï¼›æ— äººæœºä¸éœ€è¦å…¨éƒ¨å‚ä¸åˆ°ä»»åŠ¡è”ç›Ÿä¸­ï¼Œé¿å…äº†èµ„æºçš„æµªè´¹ï¼åŸºäºç›¸åŒä»¿çœŸå‚æ•°è®¾ç½®ï¼Œåˆ©ç”¨æšä¸¾æ³•æ¥éªŒè¯ä¸Šè¿°ç»“æœï¼è¿è¡Œç»“æœç›¸åŒï¼Œé‡å¤è¿è¡Œåæ¬¡ï¼Œå¹³å‡ä»¿çœŸæ—¶é—´ä¸º 1.392 s ï¼ ä¸ºäº†è¿›ä¸€æ­¥éªŒè¯ç®—æ³•çš„æœ‰æ•ˆæ€§å’Œå®æ—¶æ€§ï¼Œè®¾ç½®åœ¨ä¸åŒçš„ä»»åŠ¡å’Œæ— äººæœºæ•°é‡ä¸‹ä¸æšä¸¾æ³•ï¼Œç²’å­ç¾¤ç®—æ³•ï¼Œé—ä¼ ç®—æ³•è¿›è¡Œè”ç›Ÿæ€»æ”¶ç›Šå’Œç®—æ³•è¿è¡Œæ—¶é—´çš„å¯¹æ¯”ï¼é¦–å…ˆå›ºå®šä»»åŠ¡æ•°é‡ m=3 ï¼Œå–æ— äººæœºæ•°é‡ $n \\in{5,6,7,8,9,10,11}$ ï¼Œå„ç®—æ³•é‡å¤è¿è¡Œ 50 æ¬¡ï¼å›¾ 5 æ˜¯æœ¬æ–‡ç®—æ³•ä¸é—ä¼ ç®—æ³•ï¼Œç²’å­ç¾¤ç®—æ³•ç›¸æ¯”äºå…¨å±€æœ€ä¼˜çš„æ”¶ç›Šè¡°å‡é‡ï¼Œå›¾ 6 ç»™å‡ºäº†ç®—æ³•ç›¸å¯¹äºæšä¸¾æ³•çš„å¹³å‡è¿è¡Œæ—¶é—´ä¹‹æ¯”ï¼ ç”±å›¾ 5 å¯çŸ¥ï¼Œå½“ä»»åŠ¡æ•°é‡å›ºå®šæ—¶ï¼Œé—ä¼ ç®—æ³•å’Œç²’å­ç¾¤ç®—æ³•åœ¨è§£å†³æ— äººæœºæ•°é‡è¾ƒå°‘çš„ä»»åŠ¡åˆ†é…é—®é¢˜å…·æœ‰ä¼˜åŠ¿ï¼Œè€Œéšç€æ— äººæœºæ•°é‡çš„å¢åŠ ï¼Œæœ¬æ–‡ç®—æ³•çš„ä¼˜åŠ¿æ›´åŠ æ˜æ˜¾ï¼å½“æ— äººæœºæ•°é‡ n=11 æ—¶ï¼Œæœ¬æ–‡ç®—æ³•å¾—åˆ°çš„è”ç›Ÿæ€»æ”¶ç›Šè¡°å‡é‡ä»æœªè¶…è¿‡ 3.30 \\% ï¼ç”±å›¾ 6 å¯ä»¥çœ‹å‡ºå½“ä»»åŠ¡æ•°é‡ m=3 å›ºå®šæ—¶ï¼Œæ— äººæœºæ•°é‡ n>8 æ—¶ï¼Œç®—æ³•è¿è¡Œæ—¶é—´å·²ä¸è¶³æšä¸¾æ³•è¿è¡Œæ—¶é—´çš„ 0.1 ï¼Œå…·æœ‰è¾ƒå¥½çš„å®æ—¶æ€§ã€‚æ— äººæœº - ä»»åŠ¡çš„ç»„åˆæ•°é‡å¢åŠ æ„å‘³ç€ç²’å­ç¾¤ç®—æ³•å’Œé—ä¼ ç®—æ³•çš„æœç´¢ç©ºé—´å˜å¤§ï¼Œè®¡ç®—é‡å¢åŠ ä¸”ç®—æ³•æœç´¢æœ€ä¼˜è§£éš¾åº¦å˜å¤§ï¼›è€Œé€šè¿‡æœ¬æ–‡ç®—æ³•é€»è¾‘çš„è®¾è®¡ä½¿å¯»ä¼˜å…·æœ‰å¯¼å‘æ€§ï¼Œç®—æ³•ç»è¿‡æœ‰é™æ¬¡çš„è¿­ä»£å³å¯æ”¶ç«åˆ°ä¸€ä¸ªç¨³å®šä¸”è´¨é‡è¾ƒé«˜çš„çº³ä»€å‡è¡¡è§£ã€‚ å…¶æ¬¡åˆ†åˆ«è®¾ç½®åœ¨ä»»åŠ¡æ•°é‡ $m \\in{1,2,3,4,5,6}$ ï¼Œå¯¹åº”çš„æ— äººæœºæ•°é‡ $n \\in{3,6,9,10,12,14}$ çš„åœºæ™¯ä¸‹ï¼å„ç®—æ³•é‡å¤è¿è¡Œ 50 æ¬¡ï¼Œå›¾ 7 æ˜¯ä¸åŒç®—æ³•ç›¸å¯¹äºæšä¸¾æ³•çš„ç›®æ ‡å‡½æ•°è¡°å‡é‡ä»¿çœŸç»“æœï¼Œå›¾ 8 ç»™å‡ºäº†å„ç®—æ³•è¿è¡Œæ—¶é—´ç¤ºæ„å›¾ï¼éœ€è¦ç‰¹åˆ«è¯´æ˜çš„æ˜¯ç”±äºç²’å­ç¾¤ç®—æ³•å’Œé—ä¼ ç®—æ³•çš„è¿è¡Œæ—¶é—´ä¸è®¾ç½®çš„è¿­ä»£æ¬¡æ•°ç›¸å…³ï¼Œæœ¬æ–‡å–è”ç›Ÿæ€»æ”¶ç›Šç¨³å®šæ”¶æ•›æ—¶å¹³å‡æ‰€éœ€è¿­ä»£æ¬¡æ•°ã€‚ ç”±å›¾ 7 å’Œå›¾ 8 å¯å¾—å½“æ— äººæœºå’Œä»»åŠ¡æ•°é‡è¾ƒå°‘æ—¶ï¼ŒåŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•å¯ä»¥è·å¾—ä¸æšä¸¾æ³•ç›¸åŒçš„æ”¶ç›Šã€‚éšç€æ— äººæœºå’Œä»»åŠ¡æ•°é‡çš„å¢åŠ ï¼Œæœ¬æ–‡ç®—æ³•ä»èƒ½åœ¨æ”¶ç›Šä¸Šè¡¨ç°å‡ºä¸é—ä¼ ç®—æ³•ç›¸ä¼¼è¾ƒå¥½çš„æ€§èƒ½ï¼Œå¾—åˆ°è¾ƒé«˜çš„æ€»è”ç›Ÿæ”¶ç›Šå€¼ï¼ŒåŒæ—¶åœ¨å®æ—¶æ€§ä¸Šæ›´åŠ ä¼˜è¶Šã€‚ä»å›¾ä¸­å¯ä»¥çœ‹å‡ºå½“ä»»åŠ¡æ•°é‡ m=6 ï¼Œæ— äººæœºæ•°é‡ n=14 æ—¶ï¼Œæœ¬æ–‡ç®—æ³•æ”¶ç›Šå¯è¿‘ä¼¼è¾¾åˆ°å…¨å±€æœ€ä¼˜çš„ 96 \\% ä»¥ä¸Šï¼ŒåŒæ—¶ç®—æ³•è¿è¡Œæ—¶é—´æ¥è¿‘é—ä¼ ç®—æ³•æ‰€éœ€è¿è¡Œæ—¶é—´çš„ 1 / 2 ï¼ç²’å­ç¾¤ç®—æ³•æ”¶æ•›é€Ÿåº¦è¾ƒå¿«ï¼Œä½†æœ€ç»ˆè§£çš„è´¨é‡å¹³å‡è´¨é‡æœ‰å¾…æé«˜ï¼Œè¿‡æ—©æ”¶æ•›ç°è±¡ä½¿å…¶å®¹æ˜“é™·å…¥å±€éƒ¨æœ€ä¼˜ï¼Œç®—æ³•æ€§èƒ½ä¾èµ–äºå‚æ•°çš„è®¾è®¡ã€‚ ä»¿çœŸè¡¨æ˜ï¼Œæœ¬æ–‡æå‡ºçš„åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„å¼‚æ„æ— äººæœºé›†ç¾¤åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•èƒ½å¤Ÿç»¼åˆè€ƒè™‘èµ„æºçš„å¼‚æ„æ€§ï¼Œä¿è¯è¾ƒä½å¤æ‚åº¦çš„åŒæ—¶å¾—åˆ°è¾ƒä¼˜çš„ä»»åŠ¡åˆ†é…æ–¹æ¡ˆï¼Œæå¤§æé«˜äº†ä»»åŠ¡åˆ†é…çš„å®æ—¶æ€§ï¼Œå……åˆ†å‘æŒ¥é›†ç¾¤æ•ˆèƒ½ã€‚ 5 ç»“è®º æœ¬æ–‡ç»™å‡ºäº†ä¸€ç§åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„å¼‚æ„æ— äººæœºé›†ç¾¤åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•ï¼Œè€ƒè™‘äº†å¤§è§„æ¨¡æ— äººæœºé›†ç¾¤æœºè½½èµ„æºçš„å¼‚æ„æ€§ä»¥åŠä»»åŠ¡çš„å¼‚æ„éœ€æ±‚ã€‚ åŸºäºå¼‚æ„èµ„æºçš„æ”¹è¿› Kï¼medoids èšç±»æ–¹æ³•èƒ½å¤Ÿæ›´åˆç†çš„å¯¹é—®é¢˜è¿›è¡Œé¢„å¤„ç†ï¼Œé™ä½åŸé—®é¢˜çš„è§„æ¨¡ï¼›å»ºç«‹çš„è”ç›Ÿå½¢æˆåšäº¦æ¨¡å‹å°†åŸä»»åŠ¡åˆ†é…é—®é¢˜è½¬åŒ–ä¸ºè”ç›Ÿåˆ’åˆ†é—®é¢˜ï¼Œå…¶å…·æœ‰åŠ¿åšå¼ˆçš„ç‰¹æ€§ä¸ºä»»åŠ¡åˆ†é…ç®—æ³•æä¾›ç†è®ºåŸºç¡€ï¼›åˆ©ç”¨è®¾è®¡çš„åŸºäºè”ç›Ÿå½¢æˆåšå¼ˆçš„åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ç®—æ³•è¿›è¡Œæ±‚è§£ï¼Œæ— éœ€å…¨å±€ä¿¡æ¯äº¤äº’ï¼Œæé«˜äº†æ—¶æ•ˆæ€§å’Œå¯¹é€šä¿¡æ•…éšœçš„å®¹é”™æ€§ã€‚ æ¶åŠ£çš„å·¥ä½œç¯å¢ƒæˆ–çªå‘äº‹ä»¶çš„å‘ç”Ÿæœ‰æ—¶ä¼šå¯¼è‡´æ— äººæœºæ•…éšœï¼Œå¯¼è‡´æ•´ä½“æ€§èƒ½çš„é™ä½ï¼Œä¼—å¤šå›½å†…å¤–å­¦è€…å›´ç»•æ•…éšœæ£€æµ‹ä»¥åŠå®¹é”™æ§åˆ¶é—®é¢˜å±•å¼€ç ”ç©¶ { }^{[19]} ã€‚ä»æ§åˆ¶å±‚é¢å·²æœ‰å¾ˆå¤šè¾ƒä¸ºæˆç†Ÿçš„é’ˆå¯¹å„ç§æ‰§è¡Œå™¨æ•…éšœçš„å®¹é”™è‡ªé€‚åº”æ–¹æ¡ˆ { }^{[20]} ï¼Œæ­¤æ—¶è¿˜éœ€è¦è€ƒè™‘é›†ç¾¤å¯¹ç¯å¢ƒæ€åŠ¿å’ŒåŠ¨æ€ä»»åŠ¡è¿…é€Ÿåšå‡ºååº”ï¼Œåœ¨æœ‰é™æ—¶é—´å†…å®Œæˆè”ç›Ÿçš„é‡æ„ä¸ä¼˜åŒ–ï¼Œè¾¾æˆæ–°çš„æ— å†²çªçš„ä»»åŠ¡é‡åˆ†é…æ–¹æ¡ˆã€‚å› æ­¤ï¼Œç ”ç©¶ä»»åŠ¡é‡åˆ†é…æ˜¯åç»­ç ”ç©¶é‡ç‚¹ã€‚ 6 List of references Poudel S, Moh S. Task assignment algorithms for unmanned aerial vehicle networks: A comprehensive survey. IEEE Trans Veh Commun, 2022, 35: 100469. doi-link æ é¸¿ä¸€, é™ˆ é”¦æ¶›, ä»» é¸¿å„’. Random-sampling-based multi-UAV cooperative search planning for high-rise firefighting. Sci Sin-Inf, 2022, 52: 1610-1626. doi-link Zhou W, Kuang M, Zhu J. An unmanned air combat system based on swarm intelligence. Sci Sin-Inf, 2020, 50: 363-374. doi-link Lei Y Q, Duan H B. Decision-making of multi-UAV combat game via enhanced competitive learning pigeon-inspired optimization. Sci Sin Tech, 2024, 54: 136-148. doi-link Ju K, Mao Z H, Jiang B, et al. Task allocation and reallocation for heterogeneous multiagent systems based on potential game. Act Autom Sin, 2022, 48: 2416-2428. Cui W, Li R, Feng Y. Distributed Task Allocation for a Multi-UAV System with Time Window Constraints. Drones, 2022, 6: doi-link Chen X, Wei X M, Xu G Y. Multiple unmanned aerial vehicle decentralized cooperative air combat decision making with fuzzy situation. J Shanghai Jiaotong Univ. 2014, 48: 907-913+921. Yan F, Zhu X, Zhou Z. Real-time task allocation for a heterogeneous multi-UAV simultaneous attack. Sci Sin-Inf, 2019, 49: 555-569. doi-link Lyu Y, Zhou R, Li X, et al. Multi-task assignment algorithm based on multi-round distributed auction. J Beijing Univ Aeronaut Astronaut, 2023, 1-14. Chen Y, Sun Y, Yu H. Joint Task and Computing Resource Allocation in Distributed Edge Computing Systems via Multi-Agent Deep Reinforcement Learning. IEEE Trans Netw Sci Eng, 2024, 11: 3479-3494. doi-link Xu Y, Jiang B, Yang H. Two-Level Game-Based Distributed Optimal Fault-Tolerant Control for Nonlinear Interconnected Systems. IEEE Trans Neural Netw Learn Syst, 2020, 31: 4892-4906. doi-link Wu H, Shang H. Potential game for dynamic task allocation in multi-agent system. ISA Trans, 2020, 102: 208-220. doi-link Czarnecki E, Dutta A. Scalable hedonic coalition formation for task allocation with heterogeneous robots. Intel Serv Robotics, 2021, 14: 501-517. doi-link Zhang M, Li J, Wu X. Coalition Game Based Distributed Clustering Approach for Group Oriented Unmanned Aerial Vehicle Networks. Drones, 2023, 7: doi-link Zhang T, Wang Y, Ma Z. Task Assignment in UAV-Enabled Front Jammer Swarm: A Coalition Formation Game Approach. IEEE Trans Aerosp Electron Syst, 2023, 59: 9562-9575. doi-link Qi N, Huang Z, Zhou F. A Task-Driven Sequential Overlapping Coalition Formation Game for Resource Allocation in Heterogeneous UAV Networks. IEEE Trans Mobile Comput, 2023, 22: 4439-4455. doi-link Wang J, Jia G, Lin J. Cooperative task allocation for heterogeneous multi-UAV using multi-objective optimization algorithm. J Cent South Univ, 2020, 27: 432-448. doi-link Gao C, Du Y L, Bu Y N, et al. Heterogeneous UAV swarm grouping deployment for complex multiple tasks. J Syst Eng Electron, 2024, 46: 972-981. Ma Y, Jiang B, Tao G. Uncertainty decomposition-based fault-tolerant adaptive control of flexible spacecraft. IEEE Trans Aerosp Electron Syst, 2015, 51: 1053-1068. doi-link Mao Z, Jiang B, Shi P. Fault-tolerant control for a class of nonlinear sampled-data systems via a Euler approximate observer. Automatica, 2010, 46: 1852-1859. doi-link "},"Learn/LearnDrones/TaskAssignment/2024.12-Application_of_Task_Allocation_Algorithms_in_Multi-UAV_Intelligent_Transportation_Systems_A_Critical_Review.html":{"url":"Learn/LearnDrones/TaskAssignment/2024.12-Application_of_Task_Allocation_Algorithms_in_Multi-UAV_Intelligent_Transportation_Systems_A_Critical_Review.html","title":"2024.12 Application_of_Task_Allocation_Algorithms_in_Multi-UAV_Intelligent_Transportation_Systems_A_Critical_Review","keywords":"","body":"Application of Task Allocation Algorithms in Multi-UAV Intelligent Transportation Systems: A Critical Review Big Data and Cognitive Computing IF(3.7 2023) mdpi doi 1 Department of Mechanical and Aerospace Engineering, Politecnico di Torino, Corso Duca degli Abruzzi 24, 10129 Torino, Italy éƒ½çµç†å·¥å­¦é™¢æœºæ¢°ä¸èˆªç©ºèˆªå¤©å·¥ç¨‹ç³», Corso Duca degli Abruzzi 24, 10129 éƒ½çµ, æ„å¤§åˆ© 2 School of Language and Literature, Harbin Institute of Technology (Weihai), Weihai, 264200, China å“ˆå°”æ»¨å·¥ä¸šå¤§å­¦ï¼ˆå¨æµ·ï¼‰è¯­è¨€æ–‡å­¦å­¦é™¢, å¨æµ·, 264200 3 Department of Mechanical Engineering, SÃ£o Carlos School of Engineering, University of SÃ£o Paulo, Av. Trab. SÃ£o Carlense, 400, Parque Arnold Schimidt, SÃ£o Carlos 13566-590, SP, Brazil åœ£ä¿ç½—å¤§å­¦åœ£å¡æ´›æ–¯å·¥ç¨‹å­¦é™¢æœºæ¢°å·¥ç¨‹ç³»ï¼ŒAv.ç‰¹æ‹‰å¸ƒã€‚ SÃ£o Carlense, 400, Parque Arnold Schmidt, SÃ£o Carlos 13566-590, SP, å·´è¥¿ Abstract Unmanned aerial vehicles (UAVs), commonly known as drones, are being seen as the most promising type of autonomous vehicles in the context of intelligent transportation system (ITS) technology. A key enabling factor for the current development of ITS technology based on autonomous vehicles is the task allocation architecture. This approach allows tasks to be efficiently assigned to robots of a multi-agent system, taking into account both the robotsâ€™ capabilities and service requirements. Consequently, this study provides an overview of the application of drones in ITSs, focusing on the applications of task allocation algorithms for UAV networks. Currently, there are different types of algorithms that are employed for task allocation in drone-based intelligent transportation systems, including market-based approaches, game-theory-based algorithms, optimization-based algorithms, machine learning techniques, and other hybrid methodologies. This paper offers a comprehensive literature review of how such approaches are being utilized to optimize the allocation of tasks in UAV-based ITSs. The main characteristics, constraints, and limitations are detailed to highlight their advantages, current achievements, and applicability to different types of UAV-based ITSs. Current research trends in this field as well as gaps in the literature are also thoughtfully discussed. æ— äººæœºï¼ˆUnmanned Aerial Vehicles, UAVsï¼‰ï¼Œé€šå¸¸è¢«ç§°ä¸ºæ— äººæœºï¼Œåœ¨æ™ºèƒ½äº¤é€šç³»ç»Ÿï¼ˆIntelligent Transportation System, ITSï¼‰æŠ€æœ¯èƒŒæ™¯ä¸‹è¢«è§†ä¸ºæœ€å…·å‰æ™¯çš„è‡ªåŠ¨é©¾é©¶è½¦è¾†ç±»å‹ã€‚å½“å‰åŸºäºè‡ªåŠ¨é©¾é©¶è½¦è¾†çš„ITSæŠ€æœ¯å‘å±•çš„ä¸€ä¸ªå…³é”®æ¨åŠ¨å› ç´ æ˜¯ä»»åŠ¡åˆ†é…æ¶æ„ã€‚è¿™ç§æ–¹æ³•èƒ½å¤Ÿé«˜æ•ˆåœ°å°†ä»»åŠ¡åˆ†é…ç»™å¤šæ™ºèƒ½ä½“ç³»ç»Ÿä¸­çš„æœºå™¨äººï¼ŒåŒæ—¶è€ƒè™‘æœºå™¨äººçš„èƒ½åŠ›å’ŒæœåŠ¡éœ€æ±‚ã€‚å› æ­¤ï¼Œæœ¬ç ”ç©¶æ¦‚è¿°äº†æ— äººæœºåœ¨ITSä¸­çš„åº”ç”¨ï¼Œé‡ç‚¹å…³æ³¨æ— äººæœºç½‘ç»œä¸­ä»»åŠ¡åˆ†é…ç®—æ³•çš„åº”ç”¨ã€‚ç›®å‰ï¼ŒåŸºäºæ— äººæœºçš„æ™ºèƒ½äº¤é€šç³»ç»Ÿä¸­é‡‡ç”¨äº†å¤šç§ç±»å‹çš„ä»»åŠ¡åˆ†é…ç®—æ³•ï¼ŒåŒ…æ‹¬åŸºäºå¸‚åœºçš„æ–¹æ³•ã€åŸºäºåšå¼ˆè®ºçš„ç®—æ³•ã€åŸºäºä¼˜åŒ–çš„ç®—æ³•ã€æœºå™¨å­¦ä¹ æŠ€æœ¯ä»¥åŠå…¶ä»–æ··åˆæ–¹æ³•ã€‚æœ¬æ–‡å…¨é¢ç»¼è¿°äº†è¿™äº›æ–¹æ³•å¦‚ä½•è¢«ç”¨äºä¼˜åŒ–åŸºäºæ— äººæœºçš„ITSä¸­çš„ä»»åŠ¡åˆ†é…ã€‚é€šè¿‡è¯¦ç»†æè¿°å…¶ä¸»è¦ç‰¹å¾ã€çº¦æŸå’Œå±€é™æ€§ï¼Œçªå‡ºäº†å®ƒä»¬çš„ä¼˜åŠ¿ã€å½“å‰æˆå°±ä»¥åŠåœ¨ä¸åŒç±»å‹æ— äººæœºITSä¸­çš„é€‚ç”¨æ€§ã€‚åŒæ—¶ï¼Œæœ¬æ–‡è¿˜æ·±å…¥è®¨è®ºäº†è¯¥é¢†åŸŸå½“å‰çš„ç ”ç©¶è¶‹åŠ¿ä»¥åŠæ–‡çŒ®ä¸­çš„ç ”ç©¶ç©ºç™½ã€‚ Keywords: UAS; task allocation; aerial robotics; multi-agent system; UAV network; intelligent transportation system; MRTA; optimization; task scheduling; autonomous vehicles; auction; heuristics; dynamic task; multi-UAV; metaheuristics; software architecture; automation; drones å…³é”®è¯ï¼š æ— äººæœºï¼›ä»»åŠ¡åˆ†é…ï¼›ç©ºä¸­æœºå™¨äººæŠ€æœ¯ï¼›å¤šæ™ºèƒ½ä½“ç³»ç»Ÿï¼›æ— äººæœºç½‘ç»œï¼›æ™ºèƒ½äº¤é€šç³»ç»Ÿï¼› MRTA ï¼›ä¼˜åŒ–;ä»»åŠ¡è°ƒåº¦ï¼›è‡ªåŠ¨é©¾é©¶æ±½è½¦ï¼›æ‹å–ï¼›å¯å‘å¼ï¼›åŠ¨æ€ä»»åŠ¡ï¼›å¤šæ— äººæœºï¼›å…ƒå¯å‘æ³•ï¼›è½¯ä»¶æ¶æ„ï¼›è‡ªåŠ¨åŒ–ï¼›æ— äººæœº Table of Contents ç›®å½• Abstract Introduction ä»‹ç» Game-Theory-Based Algorithms åŸºäºåšå¼ˆè®ºçš„ç®—æ³• Learning-Based Algorithms åŸºäºå­¦ä¹ çš„ç®—æ³• Market-Based Algorithms åŸºäºå¸‚åœºçš„ç®—æ³• Optimization-Based Algorithms åŸºäºä¼˜åŒ–çš„ç®—æ³• Hybrid Allocation Algorithms æ··åˆåˆ†é…ç®—æ³• Discussion è®¨è®º Conclusions ç»“è®º Funding èµ„é‡‘ Acknowledgments è‡´è°¢ Conflicts of Interest åˆ©ç›Šå†²çª References å‚è€ƒ Introduction ä»‹ç» The UAV task allocation problem in the context of intelligent transportation systems can be divided into four main categories. First, based on whether UAVs can perform multiple different tasks simultaneously, they are classified as either Single-Task-UAVs (S-T-UAVs) or Multi-Task-UAVs (M-T-UAVs). Second, depending on whether a task requires multi-UAVs to work together, it is categorized as either a Single-UAV-Task (S-UAV-T) or a Multi-UAV-Task (M-UAV-T). Third, depending on whether the drone task allocation is completed in real time, it can be categorized into Online-Task-Allocation (O-T-A) and Offline-Task-Allocation (OF-T-A). Fourth, based on the presence of dependencies between tasks, tasks can be divided into two types: Independent-Tasks (I-T) and Dependent-Tasks (D-T). æ™ºèƒ½äº¤é€šç³»ç»ŸèƒŒæ™¯ä¸‹çš„æ— äººæœºä»»åŠ¡åˆ†é…é—®é¢˜å¯åˆ†ä¸ºå››å¤§ç±»ã€‚ é¦–å…ˆï¼Œæ ¹æ®æ— äººæœºæ˜¯å¦å¯ä»¥åŒæ—¶æ‰§è¡Œå¤šä¸ªä¸åŒçš„ä»»åŠ¡ï¼Œå°†å…¶åˆ†ä¸ºå•ä»»åŠ¡æ— äººæœºï¼ˆST-UAVï¼‰æˆ–å¤šä»»åŠ¡æ— äººæœºï¼ˆMT-UAVï¼‰ã€‚ å…¶æ¬¡ï¼Œæ ¹æ®ä»»åŠ¡æ˜¯å¦éœ€è¦å¤šæ— äººæœºååŒå·¥ä½œï¼Œå®ƒè¢«åˆ†ç±»ä¸ºå•æ— äººæœºä»»åŠ¡ï¼ˆS-UAV-Tï¼‰æˆ–å¤šæ— äººæœºä»»åŠ¡ï¼ˆM-UAV-Tï¼‰ã€‚ ç¬¬ä¸‰ï¼Œæ ¹æ®æ— äººæœºä»»åŠ¡åˆ†é…æ˜¯å¦å®æ—¶å®Œæˆï¼Œå¯ä»¥åˆ†ä¸ºåœ¨çº¿ä»»åŠ¡åˆ†é…ï¼ˆOTAï¼‰å’Œç¦»çº¿ä»»åŠ¡åˆ†é…ï¼ˆOF-TAï¼‰ã€‚ ç¬¬å››ï¼Œæ ¹æ®ä»»åŠ¡ä¹‹é—´æ˜¯å¦å­˜åœ¨ä¾èµ–å…³ç³»ï¼Œä»»åŠ¡å¯ä»¥åˆ†ä¸ºä¸¤ç§ç±»å‹ï¼šç‹¬ç«‹ä»»åŠ¡ï¼ˆITï¼‰å’Œä¾èµ–ä»»åŠ¡ï¼ˆDTï¼‰ã€‚ The two most used drones in the six task allocation models (S-UAV-T, M-UAV-T, O-T-A, OF-T-A, I-T, and D-T) mentioned above are S-T-UAV and M-T-UAV, and all six task allocation models involve several common objectives, including maximizing the total revenue of the task set, minimizing the flight distance, and minimizing the total cost of the fleet [7]. Some UAV task allocation issues in ITS technology are the same as those previously defined. For example, in distribution systems, due to the large-scale characteristics of some distribution problems, a fleet composed of multiple UAVs needs to cooperate to complete the set of tasks. This M-UAV-T allocation problem is defined as the Vehicle Routing Problem (VRP) [8]. In small-scale delivery systems using a single UAV, the S-UAV-T allocation problem is defined as the Traveling Salesman Problem (TSP). The task allocation problem of a UAV-based ITS is a Non-deterministic Polynomial time (NP-hard) problem. In synthesis, the UAV task allocation problem is the determination of the task sequences for a single UAV or a UAV fleet based on the scope and objectives of the entire task set, thereby ensuring its smooth and efficient completion [9]. At the same time, for the UAV to successfully complete its mission, various constraints of both the task and the UAV need to be considered, including the payload capacity, operational speed, task due date, and the maximum flight distance of the UAV. ä¸Šè¿°å…­ç§ä»»åŠ¡åˆ†é…æ¨¡å‹ï¼ˆS-UAV-Tã€M-UAV-Tã€OTAã€OF-TAã€IT å’Œ DTï¼‰ä¸­ä½¿ç”¨æœ€å¤šçš„ä¸¤ç§æ— äººæœºæ˜¯ ST-UAV å’Œ MT-UAVï¼Œå¹¶ä¸”æ‰€æœ‰å…­ç§ä»»åŠ¡åˆ†é…æ¨¡å‹æ¶‰åŠå‡ ä¸ªå…±åŒç›®æ ‡ï¼ŒåŒ…æ‹¬æœ€å¤§åŒ–ä»»åŠ¡é›†çš„æ€»æ”¶å…¥ã€æœ€å°åŒ–é£è¡Œè·ç¦»ä»¥åŠæœ€å°åŒ–æœºé˜Ÿçš„æ€»æˆæœ¬[ 7 ]ã€‚ ITS æŠ€æœ¯ä¸­çš„ä¸€äº›æ— äººæœºä»»åŠ¡åˆ†é…é—®é¢˜ä¸ä¹‹å‰å®šä¹‰çš„ç›¸åŒã€‚ä¾‹å¦‚ï¼Œåœ¨é…é€ç³»ç»Ÿä¸­ï¼Œç”±äºä¸€äº›é…é€é—®é¢˜çš„å¤§è§„æ¨¡ç‰¹å¾ï¼Œéœ€è¦ç”±å¤šæ¶æ— äººæœºç»„æˆçš„æœºé˜ŸååŒå®Œæˆä¸€ç»„ä»»åŠ¡ã€‚è¿™ç§ M-UAV-T åˆ†é…é—®é¢˜è¢«å®šä¹‰ä¸ºè½¦è¾†è·¯å¾„é—®é¢˜ï¼ˆVRPï¼‰[ 8 ]ã€‚åœ¨ä½¿ç”¨å•ä¸ªæ— äººæœºçš„å°è§„æ¨¡é…é€ç³»ç»Ÿä¸­ï¼ŒS-UAV-T åˆ†é…é—®é¢˜è¢«å®šä¹‰ä¸ºæ—…è¡Œå•†é—®é¢˜ï¼ˆTSPï¼‰ã€‚åŸºäºæ— äººæœºçš„æ™ºèƒ½äº¤é€šç³»ç»Ÿçš„ä»»åŠ¡åˆ†é…é—®é¢˜æ˜¯ä¸€ä¸ªéç¡®å®šæ€§å¤šé¡¹å¼æ—¶é—´ï¼ˆNP-hardï¼‰é—®é¢˜ã€‚ç»¼ä¸Šæ‰€è¿°ï¼Œæ— äººæœºä»»åŠ¡åˆ†é…é—®é¢˜æ˜¯æ ¹æ®æ•´ä¸ªä»»åŠ¡é›†çš„èŒƒå›´å’Œç›®æ ‡ç¡®å®šå•ä¸ªæ— äººæœºæˆ–æ— äººæœºæœºé˜Ÿçš„ä»»åŠ¡åºåˆ—ï¼Œä»è€Œç¡®ä¿å…¶é¡ºåˆ©é«˜æ•ˆåœ°å®Œæˆ[ 9 ]ã€‚åŒæ—¶ï¼Œä¸ºäº†ä½¿æ— äººæœºé¡ºåˆ©å®Œæˆä»»åŠ¡ï¼Œéœ€è¦è€ƒè™‘ä»»åŠ¡å’Œæ— äººæœºçš„å„ç§çº¦æŸï¼ŒåŒ…æ‹¬æœ‰æ•ˆè½½è·èƒ½åŠ›ã€ä½œä¸šé€Ÿåº¦ã€ä»»åŠ¡åˆ°æœŸæ—¥æœŸå’Œæ— äººæœºçš„æœ€å¤§é£è¡Œè·ç¦»ã€‚ With the rise of robotic systems technology, the concept of multi-robot task allocation has been established as a dynamic research area in the broad context of operations research applications, and some literature reviews have been recently proposed that also consider UAV-based systems [7,10,11,12]. But, to the best of our knowledge, the literature lacks a critical survey of the application of multi-agent system (MAS)-based task allocation paradigms to a fleet of UAVs conceptualized as an intelligent transportation network. This paper presents a survey of MAS task allocation techniques and their application to drone-based networks for intelligent transportation applications. The main contributions of this work are threefold: éšç€æœºå™¨äººç³»ç»ŸæŠ€æœ¯çš„å…´èµ·ï¼Œå¤šæœºå™¨äººä»»åŠ¡åˆ†é…çš„æ¦‚å¿µå·²è¢«ç¡®ç«‹ä¸ºè¿ç­¹å­¦åº”ç”¨å¹¿æ³›èƒŒæ™¯ä¸‹çš„åŠ¨æ€ç ”ç©¶é¢†åŸŸï¼Œå¹¶ä¸”æœ€è¿‘æå‡ºäº†ä¸€äº›æ–‡çŒ®ç»¼è¿°ï¼Œå…¶ä¸­ä¹Ÿè€ƒè™‘äº†åŸºäºæ— äººæœºçš„ç³»ç»Ÿ[ 7 ã€ 10 ã€ 11 ã€ 12 ]ã€‚ä½†æ˜¯ï¼Œæ®æˆ‘ä»¬æ‰€çŸ¥ï¼Œæ–‡çŒ®ç¼ºä¹å¯¹åŸºäºå¤šæ™ºèƒ½ä½“ç³»ç»Ÿï¼ˆMASï¼‰çš„ä»»åŠ¡åˆ†é…èŒƒä¾‹åœ¨æ¦‚å¿µåŒ–ä¸ºæ™ºèƒ½äº¤é€šç½‘ç»œçš„æ— äººæœºæœºé˜Ÿä¸­çš„åº”ç”¨çš„æ‰¹åˆ¤æ€§è°ƒæŸ¥ã€‚æœ¬æ–‡å¯¹ MAS ä»»åŠ¡åˆ†é…æŠ€æœ¯åŠå…¶åœ¨åŸºäºæ— äººæœºçš„æ™ºèƒ½äº¤é€šåº”ç”¨ç½‘ç»œä¸­çš„åº”ç”¨è¿›è¡Œäº†è°ƒæŸ¥ã€‚è¿™é¡¹å·¥ä½œçš„ä¸»è¦è´¡çŒ®æœ‰ä¸‰ä¸ªï¼š The development of a critical review about MAS task allocation methodologies focusing on multi-UAV networks. This review paper is for engineers, researchers, and scholars who need a critical overview of these emerging topics; é’ˆå¯¹å¤šæ— äººæœºç½‘ç»œçš„ MAS ä»»åŠ¡åˆ†é…æ–¹æ³•è¿›è¡Œä¸¥æ ¼å®¡æŸ¥ã€‚è¿™ç¯‡ç»¼è¿°è®ºæ–‡é€‚ç”¨äºéœ€è¦å¯¹è¿™äº›æ–°å…´ä¸»é¢˜è¿›è¡Œæ‰¹åˆ¤æ€§æ¦‚è¿°çš„å·¥ç¨‹å¸ˆã€ç ”ç©¶äººå‘˜å’Œå­¦è€…ï¼› The discussion of state-of-the-art allocation strategies for UAV-based ITSs, focusing on their suitability to the most established applications; è®¨è®ºåŸºäºæ— äººæœºçš„æ™ºèƒ½äº¤é€šç³»ç»Ÿçš„æœ€å…ˆè¿›åˆ†é…ç­–ç•¥ï¼Œé‡ç‚¹å…³æ³¨å…¶å¯¹æœ€æˆç†Ÿåº”ç”¨çš„é€‚ç”¨æ€§ï¼› The discussion of the challenges of task allocation algorithms for UAV-based ITSs as well as the gaps in the literature for informing future trends. è®¨è®ºåŸºäºæ— äººæœºçš„æ™ºèƒ½äº¤é€šç³»ç»Ÿçš„ä»»åŠ¡åˆ†é…ç®—æ³•çš„æŒ‘æˆ˜ä»¥åŠäº†è§£æœªæ¥è¶‹åŠ¿çš„æ–‡çŒ®ä¸­çš„å·®è·ã€‚ This paper is organized as follows. Game-theory-based approaches are presented in Section 2. Learning-based algorithms, auction-based algorithms, and optimization-based allocation algorithms are presented in Section 3, Section 4, and Section 5, respectively. Other hybrid approaches are discussed in Section 6. Finally, a comprehensive discussion of UAV state-of-the-art allocation techniques as well as their pros and cons, their applicability to multi-UAV ITSs, and the current gaps in this field are presented in Section 7. Our conclusions are drawn in Section 8. æœ¬æ–‡çš„ç»“æ„å¦‚ä¸‹ã€‚ ç¬¬ 2 èŠ‚ä»‹ç»äº†åŸºäºåšå¼ˆè®ºçš„æ–¹æ³•ã€‚ åŸºäºå­¦ä¹ çš„ç®—æ³•ã€åŸºäºæ‹å–çš„ç®—æ³•å’ŒåŸºäºä¼˜åŒ–çš„åˆ†é…ç®—æ³•åˆ†åˆ«åœ¨ç¬¬ 3 èŠ‚ã€ç¬¬ 4 èŠ‚å’Œç¬¬ 5 èŠ‚ä¸­ä»‹ç»ã€‚ å…¶ä»–æ··åˆæ–¹æ³•å°†åœ¨ç¬¬ 6 èŠ‚ä¸­è®¨è®ºã€‚ æœ€åï¼Œç¬¬ 7 èŠ‚å…¨é¢è®¨è®ºäº†æ— äººæœºæœ€å…ˆè¿›çš„åˆ†é…æŠ€æœ¯åŠå…¶ä¼˜ç¼ºç‚¹ã€å®ƒä»¬å¯¹å¤šæ— äººæœº ITS çš„é€‚ç”¨æ€§ä»¥åŠè¯¥é¢†åŸŸå½“å‰çš„å·®è·ã€‚ æˆ‘ä»¬çš„ç»“è®ºåœ¨ç¬¬ 8 èŠ‚ä¸­å¾—å‡ºã€‚ Challenges of Task Allocation Algorithms ä»»åŠ¡åˆ†é…ç®—æ³•çš„æŒ‘æˆ˜ According to the works of [13,14], UAV task allocation for ITSs can mainly be divided into two categories: OF-T-A (also known as static task allocation) and O-T-A (also known as dynamic task allocation). Unlike static task allocation, dynamic task allocation typically requires the use of fewer computing resources to generate real-time solutions. Centralized algorithms and distributed algorithms are the mainstream algorithms applied to static task allocation and dynamic task allocation, respectively. Currently, algorithms used for static task allocation mainly rely on biologically inspired operators, such as genetic algorithms (GAS) [15], particle swarm optimization (PSO) approaches [16], and differential evolution (DE) algorithms [17], aiming to find approximate optimal solutions in a short period of time. After more than two decades of development, although centralized algorithms have become mature, the aspects of computational time and convergence accuracy still remain significant challenges. æ ¹æ®[ 13 , 14 ]çš„å·¥ä½œï¼Œæ™ºèƒ½äº¤é€šç³»ç»Ÿçš„æ— äººæœºä»»åŠ¡åˆ†é…ä¸»è¦åˆ†ä¸ºä¸¤ç±»ï¼šOF-TAï¼ˆä¹Ÿç§°ä¸ºé™æ€ä»»åŠ¡åˆ†é…ï¼‰å’Œ OTAï¼ˆä¹Ÿç§°ä¸ºåŠ¨æ€ä»»åŠ¡åˆ†é…ï¼‰ã€‚ä¸é™æ€ä»»åŠ¡åˆ†é…ä¸åŒï¼ŒåŠ¨æ€ä»»åŠ¡åˆ†é…é€šå¸¸éœ€è¦ä½¿ç”¨è¾ƒå°‘çš„è®¡ç®—èµ„æºæ¥ç”Ÿæˆå®æ—¶è§£å†³æ–¹æ¡ˆã€‚é›†ä¸­å¼ç®—æ³•å’Œåˆ†å¸ƒå¼ç®—æ³•åˆ†åˆ«æ˜¯åº”ç”¨äºé™æ€ä»»åŠ¡åˆ†é…å’ŒåŠ¨æ€ä»»åŠ¡åˆ†é…çš„ä¸»æµç®—æ³•ã€‚ç›®å‰ï¼Œç”¨äºé™æ€ä»»åŠ¡åˆ†é…çš„ç®—æ³•ä¸»è¦ä¾èµ–äºå—ç”Ÿç‰©å­¦å¯å‘çš„ç®—å­ï¼Œä¾‹å¦‚é—ä¼ ç®—æ³•ï¼ˆGASï¼‰[ 15 ]ã€ç²’å­ç¾¤ä¼˜åŒ–ï¼ˆPSOï¼‰æ–¹æ³•[ 16 ]å’Œå·®åˆ†è¿›åŒ–ï¼ˆDEï¼‰ç®—æ³•[ 17 ]ï¼Œæ—¨åœ¨åœ¨çŸ­æ—¶é—´å†…æ‰¾åˆ°è¿‘ä¼¼æœ€ä¼˜è§£ã€‚ç»è¿‡äºŒåå¤šå¹´çš„å‘å±•ï¼Œä¸­å¿ƒåŒ–ç®—æ³•è™½ç„¶å·²ç»æˆç†Ÿï¼Œä½†è®¡ç®—æ—¶é—´å’Œæ”¶æ•›ç²¾åº¦æ–¹é¢ä»ç„¶å­˜åœ¨é‡å¤§æŒ‘æˆ˜ã€‚ In comparison to OF-T-A algorithms, the development of O-T-A algorithm faces other significant challenges. Firstly, real-time task allocation increases the computational demand of solution algorithms, requiring them to solve NP-hard problems with fewer computational resources. It is well known that real-time algorithms often sacrifice decision quality to ensure their real-time performance; thus, balancing decision quality and algorithmic real-time performance is also a significant challenge. In addition, the generalization capability of the task allocation algorithms poses significant challenges in the task scheduling context of UAV-based ITSs. Determining how algorithms that perform satisfactorily in small-scale networks can adapt to large-scale drone networks has also become an emerging issue for researchers. Finally, the algorithmsâ€™ robustness presents further challenges. In unexpected situations, such as the loss of control of a drone or inadequate communication network coverage, real-time algorithms should be able to make immediate decisions to ensure that the completion of the task set is not compromised. Therefore, task reallocation is also being addressed in the literature. There are different types of algorithms that are employed in state-of-the-art drone-based intelligent transportation systems, including auction (market)-based approaches, game-theory-based algorithms, optimization-based algorithms, and machine learning (ML) techniques. These approaches and their application to UAV-based ITSs are thoughtfully presented and discussed in the next sections. ä¸ OF-TA ç®—æ³•ç›¸æ¯”ï¼ŒOTA ç®—æ³•çš„å‘å±•è¿˜é¢ä¸´ç€å…¶ä»–é‡å¤§æŒ‘æˆ˜ã€‚ é¦–å…ˆï¼Œå®æ—¶ä»»åŠ¡åˆ†é…å¢åŠ äº†æ±‚è§£ç®—æ³•çš„è®¡ç®—éœ€æ±‚ï¼Œè¦æ±‚å®ƒä»¬ç”¨æ›´å°‘çš„è®¡ç®—èµ„æºè§£å†³ NP éš¾é¢˜ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œå®æ—¶ç®—æ³•å¾€å¾€ä¼šç‰ºç‰²å†³ç­–è´¨é‡æ¥ä¿è¯å…¶å®æ—¶æ€§ï¼›å› æ­¤ï¼Œå¹³è¡¡å†³ç­–è´¨é‡å’Œç®—æ³•å®æ—¶æ€§èƒ½ä¹Ÿæ˜¯ä¸€ä¸ªé‡å¤§æŒ‘æˆ˜ã€‚ æ­¤å¤–ï¼Œä»»åŠ¡åˆ†é…ç®—æ³•çš„æ³›åŒ–èƒ½åŠ›å¯¹åŸºäºæ— äººæœºçš„ ITS çš„ä»»åŠ¡è°ƒåº¦ç¯å¢ƒæå‡ºäº†é‡å¤§æŒ‘æˆ˜ã€‚ç¡®å®šåœ¨å°å‹ç½‘ç»œä¸­è¡¨ç°ä»¤äººæ»¡æ„çš„ç®—æ³•å¦‚ä½•é€‚åº”å¤§è§„æ¨¡æ— äººæœºç½‘ç»œä¹Ÿæˆä¸ºç ”ç©¶äººå‘˜é¢ä¸´çš„ä¸€ä¸ªæ–°é—®é¢˜ã€‚ æœ€åï¼Œç®—æ³•çš„é²æ£’æ€§æå‡ºäº†è¿›ä¸€æ­¥çš„æŒ‘æˆ˜ã€‚åœ¨æ„å¤–æƒ…å†µä¸‹ï¼Œä¾‹å¦‚æ— äººæœºå¤±å»æ§åˆ¶æˆ–é€šä¿¡ç½‘ç»œè¦†ç›–èŒƒå›´ä¸è¶³ï¼Œå®æ—¶ç®—æ³•åº”è¯¥èƒ½å¤Ÿç«‹å³åšå‡ºå†³ç­–ï¼Œä»¥ç¡®ä¿ä»»åŠ¡é›†çš„å®Œæˆä¸å—å½±å“ã€‚å› æ­¤ï¼Œæ–‡çŒ®ä¸­ä¹Ÿè®¨è®ºäº†ä»»åŠ¡é‡æ–°åˆ†é…ã€‚ æœ€å…ˆè¿›çš„åŸºäºæ— äººæœºçš„æ™ºèƒ½äº¤é€šç³»ç»Ÿé‡‡ç”¨äº†ä¸åŒç±»å‹çš„ç®—æ³•ï¼ŒåŒ…æ‹¬åŸºäºæ‹å–ï¼ˆå¸‚åœºï¼‰çš„æ–¹æ³•ã€åŸºäºåšå¼ˆè®ºçš„ç®—æ³•ã€åŸºäºä¼˜åŒ–çš„ç®—æ³•å’Œæœºå™¨å­¦ä¹ ï¼ˆMLï¼‰ ï¼‰æŠ€æœ¯ã€‚è¿™äº›æ–¹æ³•åŠå…¶åœ¨åŸºäºæ— äººæœºçš„ ITS ä¸­çš„åº”ç”¨å°†åœ¨ä¸‹ä¸€èŠ‚ä¸­è¿›è¡Œæ·±å…¥ä»‹ç»å’Œè®¨è®ºã€‚ Game-Theory-Based Algorithms åŸºäºåšå¼ˆè®ºçš„ç®—æ³• åœ¨[ 18 ]çš„å·¥ä½œä¸­ï¼ŒåŸºäºåšå¼ˆè®ºçš„è‡ªä¸»æ§åˆ¶é—®é¢˜è¢«å®šä¹‰å¹¶ç”¨å‡ ä¸ªæ— äººæœºä»»åŠ¡è§„åˆ’çš„ä¾‹å­æ¥è¯´æ˜ã€‚åŸºäºåšå¼ˆè®ºçš„ä»»åŠ¡åˆ†é…é—®é¢˜è¢«å®šä¹‰ä¸ºéç»“æ„åŒ–ç¯å¢ƒï¼ˆéšæœºç¯å¢ƒï¼‰æˆ–å…·æœ‰æ•Œå¯¹ä»£ç†çš„ç¡®å®šæ€§ç¯å¢ƒä¸­çš„å†³ç­–é—®é¢˜ã€‚æ­¤åï¼Œåšå¼ˆè®ºç®—æ³•ä½œä¸ºå»ä¸­å¿ƒåŒ–åˆ†å¸ƒå¼ M-UAV-T åˆ†é…ç®—æ³•å¾—åˆ°äº†å¹¿æ³›çš„ç ”ç©¶[ 19 ]ã€‚åœ¨åŸºäºåšå¼ˆè®ºçš„æ™ºèƒ½äº¤é€šç³»ç»Ÿæ— äººæœºä»»åŠ¡åˆ†é…é—®é¢˜ä¸­ï¼Œæ¯æ¶æ— äººæœºè¢«å®šä¹‰ä¸ºèƒ½å¤Ÿåšå‡ºå†³ç­–å’Œæ‰§è¡Œä»»åŠ¡çš„â€œç©å®¶â€ã€‚åœ¨å®é™…ä»»åŠ¡ä¸­ï¼Œç”±äºé€šä¿¡é™åˆ¶ï¼Œç©å®¶å¯èƒ½å®Œå…¨ã€éƒ¨åˆ†æˆ–ä¸äº†è§£ç½‘ç»œä¸­çš„å…¶ä»–æ— äººæœºã€‚åœ¨åŸºäºåšå¼ˆè®ºçš„ M-UAV-T åˆ†é…é—®é¢˜ä¸­ï¼Œä¸€ç»„æ— äººæœºè¢«å®šä¹‰ä¸º $A=\\left{1,2,3, \\ldots, a{M A X}\\right}$ã€‚å¯¹äºä»»ä½•æ— äººæœº $a$ï¼Œå¯¹åº”çš„ç­–ç•¥é›†ä¸º $D{a}=\\left{d{a, 1}, d{a, 2}, d{a, 3}, \\ldots, d{a, n}\\right}$ ã€‚ç®—æ³•ç»“æŸæ—¶, æ¯æ¶æ— äººæœºé€‰æ‹©çš„ç­–ç•¥å¯¹åº”çš„ä¸€ç»„æ— äººæœºçš„æ”¶ç›Šä¸º $Z=\\left{z{1}, z{2}, z{3}, \\ldots, z{a_{M A X}}\\right}$ ã€‚å‚ä¸è€…ã€ç­–ç•¥é›†å’Œæ”¶ç›Šé›†æ„æˆäº†æ™ºèƒ½äº¤é€šç³»ç»Ÿä¸­å¤šæ— äººæœºä»»åŠ¡åˆ†é…åšå¼ˆçš„ä¸‰ä¸ªç»„æˆéƒ¨åˆ†ã€‚å¦å¤–ï¼Œåšå³¦è®ºå¯ä»¥åˆ†ä¸ºä¸¤ç±»æ¨¡å‹ï¼šåˆä½œåšå¼ˆå’Œéåˆä½œåšå³¦ã€‚ 2.1. Non-Cooperative-Game-Based Task Allocation 2.1.åŸºäºéåˆä½œåšå¼ˆçš„ä»»åŠ¡åˆ†é… 2.2. Cooperative Game-Based Task Allocation 2.2.åŸºäºåˆä½œåšå¼ˆçš„ä»»åŠ¡åˆ†é… Learning-Based Algorithms åŸºäºå­¦ä¹ çš„ç®—æ³• For real-time task allocation (O-T-A), the learning-based algorithm is another good approach. Compared to traditional artificial neural networks and deep neural networks, reinforcement learning can handle complex tasks and continuously optimize strategies from the optimization process, making it widely used by researchers in real-time task allocation problems for multi-UAVs. In order to solve the M-UAV-T allocation problem, a deep reinforcement learning algorithm is proposed in [27] with the aim of improving the computational efficiency and the convergence accuracy of the task allocation algorithm. Unlike game-theory-based methods, reinforcement-learning-based algorithms typically establish a nonlinear model based on the task allocation problem, as shown in Equation (1). å¯¹äºå®æ—¶ä»»åŠ¡åˆ†é…ï¼ˆOTAï¼‰ï¼ŒåŸºäºå­¦ä¹ çš„ç®—æ³•æ˜¯å¦ä¸€ç§å¥½æ–¹æ³•ã€‚ä¸ä¼ ç»Ÿçš„äººå·¥ç¥ç»ç½‘ç»œå’Œæ·±åº¦ç¥ç»ç½‘ç»œç›¸æ¯”ï¼Œå¼ºåŒ–å­¦ä¹ å¯ä»¥å¤„ç†å¤æ‚çš„ä»»åŠ¡ï¼Œå¹¶ä»ä¼˜åŒ–è¿‡ç¨‹ä¸­ä¸æ–­ä¼˜åŒ–ç­–ç•¥ï¼Œä½¿å…¶è¢«ç ”ç©¶äººå‘˜å¹¿æ³›åº”ç”¨äºå¤šæ— äººæœºçš„å®æ—¶ä»»åŠ¡åˆ†é…é—®é¢˜ã€‚ä¸ºäº†è§£å†³ M-UAV-T åˆ†é…é—®é¢˜ï¼Œæ–‡çŒ®[ 27 ]æå‡ºäº†ä¸€ç§æ·±åº¦å¼ºåŒ–å­¦ä¹ ç®—æ³•ï¼Œæ—¨åœ¨æé«˜ä»»åŠ¡åˆ†é…ç®—æ³•çš„è®¡ç®—æ•ˆç‡å’Œæ”¶æ•›ç²¾åº¦ã€‚ä¸åŸºäºåšå¼ˆè®ºçš„æ–¹æ³•ä¸åŒï¼ŒåŸºäºå¼ºåŒ–å­¦ä¹ çš„ç®—æ³•é€šå¸¸åŸºäºä»»åŠ¡åˆ†é…é—®é¢˜å»ºç«‹éçº¿æ€§æ¨¡å‹ï¼Œå¦‚æ–¹ç¨‹ï¼ˆ1ï¼‰æ‰€ç¤ºã€‚ The objective function aims to minimize the cost of the problem, which is the same as the reward function in game-based models. ğ‘â‰¤ğµğ‘šğ‘ğ‘¥ denotes a set of constraints considering the boundary conditions. ç›®æ ‡å‡½æ•°æ—¨åœ¨æœ€å°åŒ–é—®é¢˜çš„æˆæœ¬ï¼Œè¿™ä¸åŸºäºåšå¼ˆçš„æ¨¡å‹ä¸­çš„å¥–åŠ±å‡½æ•°ç›¸åŒã€‚ ğ‘â‰¤ğµğ‘šğ‘ğ‘¥ è¡¨ç¤ºè€ƒè™‘è¾¹ç•Œæ¡ä»¶çš„ä¸€ç»„çº¦æŸã€‚ In addition, the work of [28] also aims at improving the convergence accuracy of the algorithm, thus developing an improved reinforcement learning algorithm. The reinforcement learning algorithm introduces the transfer learning theory. After finding a similar UAV task allocation model in the policy library, the algorithm transfers the training parameter results of the previous source task to the new model through transfer learning. The simulation results show that the algorithm not only effectively improves the performance of UAV task allocation schemes, but also has a strong generalization capability. The authors of [29] developed a multi-agent reinforcement learning method aimed at generating task allocation schemes for heterogeneous UAV fleets. This algorithm can run in locally known environments and has strong robustness. æ­¤å¤–ï¼Œ[ 28 ]çš„å·¥ä½œè¿˜æ—¨åœ¨æé«˜ç®—æ³•çš„æ”¶æ•›ç²¾åº¦ï¼Œä»è€Œå¼€å‘å‡ºæ”¹è¿›çš„å¼ºåŒ–å­¦ä¹ ç®—æ³•ã€‚å¼ºåŒ–å­¦ä¹ ç®—æ³•å¼•å…¥äº†è¿ç§»å­¦ä¹ ç†è®ºã€‚åœ¨ç­–ç•¥åº“ä¸­æ‰¾åˆ°ç±»ä¼¼çš„æ— äººæœºä»»åŠ¡åˆ†é…æ¨¡å‹åï¼Œç®—æ³•é€šè¿‡è¿ç§»å­¦ä¹ å°†å…ˆå‰æºä»»åŠ¡çš„è®­ç»ƒå‚æ•°ç»“æœè¿ç§»åˆ°æ–°æ¨¡å‹ä¸­ã€‚ä»¿çœŸç»“æœè¡¨æ˜ï¼Œè¯¥ç®—æ³•ä¸ä»…æœ‰æ•ˆæé«˜äº†æ— äººæœºä»»åŠ¡åˆ†é…æ–¹æ¡ˆçš„æ€§èƒ½ï¼Œè€Œä¸”å…·æœ‰è¾ƒå¼ºçš„æ³›åŒ–èƒ½åŠ›ã€‚ [ 29 ]çš„ä½œè€…å¼€å‘äº†ä¸€ç§å¤šæ™ºèƒ½ä½“å¼ºåŒ–å­¦ä¹ æ–¹æ³•ï¼Œæ—¨åœ¨ä¸ºå¼‚æ„æ— äººæœºæœºé˜Ÿç”Ÿæˆä»»åŠ¡åˆ†é…æ–¹æ¡ˆã€‚è¯¥ç®—æ³•å¯ä»¥åœ¨æœ¬åœ°å·²çŸ¥çš„ç¯å¢ƒä¸­è¿è¡Œï¼Œå…·æœ‰å¾ˆå¼ºçš„é²æ£’æ€§ã€‚ Ref. Algorithm Characteristics Main Constraints Limitations [27] Deep Q-learning approach UAVs learn the network state and adapt their locations Considered all constraints of UAV-based networking tasks. - [28] Deep migration reinforcement learning algorithm based on QMIX Compared with heuristic algorithms, this method can improve solving efficiency without increasing solving time. UAV range constraint Does not consider time constraints for practical scenarios [29] Multi-agent reinforcement learning It can be used in dynamic task scenarios and can achieve real-time task allocation. Considers the uncertainty of dynamic tasks - [30] Gradient descent method based on deep reinforcement learning UAVs can automatically and dynamically adjust task allocation strategies in real time. Time delay of UAV data transmission Verified only for a specific application scenario Market-Based Algorithms åŸºäºå¸‚åœºçš„ç®—æ³• Auction-based algorithms are widely used for task allocation in drone applications. These algorithms are based on economic principles, as they are alternatively called market-based algorithms, with agents using a negotiation protocol to bid in an auction for task allocation, informed by their local perception of the environment. The agents aim to complete the task assigned with the highest utility or lowest cost by bidding based on the cost or utility they calculate. According to the agentsâ€™ utility functions, a global objective function is optimized. According to [31], auction-based algorithms present several advantages, including a high solution efficiency and moderate computational costs, in addition to having a dynamic protocol, as they can include or remove new tasks from the allocation procedure. åŸºäºæ‹å–çš„ç®—æ³•å¹¿æ³›ç”¨äºæ— äººæœºåº”ç”¨ä¸­çš„ä»»åŠ¡åˆ†é…ã€‚è¿™äº›ç®—æ³•åŸºäºç»æµåŸç†ï¼Œå› ä¸ºå®ƒä»¬ä¹Ÿç§°ä¸ºåŸºäºå¸‚åœºçš„ç®—æ³•ï¼Œä»£ç†ä½¿ç”¨åå•†åè®®åœ¨ä»»åŠ¡åˆ†é…æ‹å–ä¸­ç«æ ‡ï¼Œå¹¶æ ¹æ®å…¶å¯¹ç¯å¢ƒçš„æœ¬åœ°æ„ŸçŸ¥è¿›è¡Œäº†è§£ã€‚ä»£ç†çš„ç›®æ ‡æ˜¯æ ¹æ®ä»–ä»¬è®¡ç®—çš„æˆæœ¬æˆ–æ•ˆç”¨è¿›è¡ŒæŠ•æ ‡ï¼Œä»¥æœ€é«˜æ•ˆç”¨æˆ–æœ€ä½æˆæœ¬å®Œæˆåˆ†é…çš„ä»»åŠ¡ã€‚æ ¹æ®æ™ºèƒ½ä½“çš„æ•ˆç”¨å‡½æ•°ï¼Œä¼˜åŒ–å…¨å±€ç›®æ ‡å‡½æ•°ã€‚æ ¹æ®[ 31 ]ï¼ŒåŸºäºæ‹å–çš„ç®—æ³•é™¤äº†å…·æœ‰åŠ¨æ€åè®®ä¹‹å¤–ï¼Œè¿˜å…·æœ‰å¤šç§ä¼˜åŠ¿ï¼ŒåŒ…æ‹¬é«˜è§£å†³æ•ˆç‡å’Œé€‚ä¸­çš„è®¡ç®—æˆæœ¬ï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥åœ¨åˆ†é…è¿‡ç¨‹ä¸­åŒ…å«æˆ–åˆ é™¤æ–°ä»»åŠ¡ã€‚ The literature presents several works related to auction methodology. A time-sensitive sequential auction (TSSA) algorithm considering time window constraints is proposed in [32] for task allocation in a multi-agent system. An auction-based algorithm for multi-agent task allocation is also proposed in [33]. In this way, auction-based task allocation has received increasing attention since there are different factors that may be considered, including UAVsâ€™ capability, battery consumption, execution time, and path routes, among others. The work of [34] proposes an auction-based algorithm for multiple UAVs. A multi-layer cost computation strategy is developed to handle multiple constraints and determine the bidâ€™s value. æ–‡çŒ®ä¸­ä»‹ç»äº†ä¸€äº›ä¸æ‹å–æ–¹æ³•ç›¸å…³çš„è‘—ä½œã€‚ [ 32 ]æå‡ºäº†ä¸€ç§è€ƒè™‘æ—¶é—´çª—å£çº¦æŸçš„æ—¶é—´æ•æ„Ÿé¡ºåºæ‹å–ï¼ˆTSSAï¼‰ç®—æ³•ï¼Œç”¨äºå¤šæ™ºèƒ½ä½“ç³»ç»Ÿä¸­çš„ä»»åŠ¡åˆ†é…ã€‚ [ 33 ]ä¸­è¿˜æå‡ºäº†ä¸€ç§åŸºäºæ‹å–çš„å¤šæ™ºèƒ½ä½“ä»»åŠ¡åˆ†é…ç®—æ³•ã€‚è¿™æ ·ï¼ŒåŸºäºæ‹å–çš„ä»»åŠ¡åˆ†é…å—åˆ°äº†è¶Šæ¥è¶Šå¤šçš„å…³æ³¨ï¼Œå› ä¸ºå¯ä»¥è€ƒè™‘ä¸åŒçš„å› ç´ ï¼ŒåŒ…æ‹¬æ— äººæœºçš„èƒ½åŠ›ã€ç”µæ± æ¶ˆè€—ã€æ‰§è¡Œæ—¶é—´å’Œè·¯å¾„è·¯çº¿ç­‰ã€‚ [ 34 ]çš„å·¥ä½œæå‡ºäº†ä¸€ç§é’ˆå¯¹å¤šä¸ªæ— äººæœºçš„åŸºäºæ‹å–çš„ç®—æ³•ã€‚å¼€å‘äº†å¤šå±‚æˆæœ¬è®¡ç®—ç­–ç•¥æ¥å¤„ç†å¤šä¸ªçº¦æŸå¹¶ç¡®å®šå‡ºä»·çš„ä»·å€¼ã€‚ Most of the proposed auction algorithms yield a poor performance for multi-dynamic tasks for multiples drones. To address this issue, a hybrid auction algorithm, based on a decision mechanism and an enhanced objective function, is proposed in [35]. The work of [36] exploits a dynamic decentralized auction-based algorithm for multi-agent systems, such as UAVs. A dynamic task allocation protocol is used, since the agent utilities may change throughout their path towards their targets. This strategy aims to assign a maximum of one task to each member of the fleet, while the same task can be allocated to multiple agents. Thus, the task utilities are calculated according to the agentâ€™s states; i.e., they depend on both the rewards from the accomplishment of the assigned tasks and the costs associated with their execution. Differently from game-based algorithms that may not always achieve high levels of global utility, the auction-based algorithm is able to greedily achieve global utility, due to its simplicity and fast convergence. å¤§å¤šæ•°æå‡ºçš„æ‹å–ç®—æ³•å¯¹äºå¤šæ¶æ— äººæœºçš„å¤šåŠ¨æ€ä»»åŠ¡æ€§èƒ½è¾ƒå·®ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œ[ 35 ]æå‡ºäº†ä¸€ç§åŸºäºå†³ç­–æœºåˆ¶å’Œå¢å¼ºç›®æ ‡å‡½æ•°çš„æ··åˆæ‹å–ç®—æ³•ã€‚ [ 36 ]çš„å·¥ä½œä¸ºå¤šä»£ç†ç³»ç»Ÿï¼ˆä¾‹å¦‚æ— äººæœºï¼‰å¼€å‘äº†ä¸€ç§åŸºäºåŠ¨æ€å»ä¸­å¿ƒåŒ–æ‹å–çš„ç®—æ³•ã€‚ä½¿ç”¨åŠ¨æ€ä»»åŠ¡åˆ†é…åè®®ï¼Œå› ä¸ºä»£ç†å®ç”¨ç¨‹åºå¯èƒ½ä¼šåœ¨å…¶é€šå¾€ç›®æ ‡çš„æ•´ä¸ªè·¯å¾„ä¸­å‘ç”Ÿå˜åŒ–ã€‚è¯¥ç­–ç•¥æ—¨åœ¨ä¸ºèˆ°é˜Ÿçš„æ¯ä¸ªæˆå‘˜æœ€å¤šåˆ†é…ä¸€é¡¹ä»»åŠ¡ï¼Œè€ŒåŒä¸€ä»»åŠ¡å¯ä»¥åˆ†é…ç»™å¤šä¸ªä»£ç†ã€‚å› æ­¤ï¼Œä»»åŠ¡æ•ˆç”¨æ˜¯æ ¹æ®æ™ºèƒ½ä½“çš„çŠ¶æ€è®¡ç®—çš„ï¼›å³ï¼Œå®ƒä»¬æ—¢å–å†³äºå®ŒæˆæŒ‡å®šä»»åŠ¡çš„å›æŠ¥ï¼Œä¹Ÿå–å†³äºä¸æ‰§è¡Œä»»åŠ¡ç›¸å…³çš„æˆæœ¬ã€‚ä¸åŸºäºæ¸¸æˆçš„ç®—æ³•å¯èƒ½å¹¶ä¸æ€»èƒ½å®ç°é«˜æ°´å¹³çš„å…¨å±€æ•ˆç”¨ä¸åŒï¼ŒåŸºäºæ‹å–çš„ç®—æ³•ç”±äºå…¶ç®€å•æ€§å’Œå¿«é€Ÿæ”¶æ•›è€Œèƒ½å¤Ÿè´ªå©ªåœ°å®ç°å…¨å±€æ•ˆç”¨ã€‚ The use of different auction-based algorithms to solve a heterogenous task allocation problem for multiple UAVs in a drone delivery context is investigated in [37]. The strategy is used to minimize the battery consumption of a UAS-based parcel transportation service by allocating delivery tasks with due date constraints to multiple drones that demand a lower consumption of energy. The allocation of charge tasks is also addressed. These auction-based algorithms were implemented by means of both single-item and multiple-item strategies. Scalar constrained optimization problems are solved by each agent to calculate the UAVâ€™s bid for each task. For delivery tasks, the protocolâ€™s bid is related to the consumption of energy, while the flight time is chosen for charge task bids. Path planning is also included in the framework to compute the risk-aware path for each task-UAV bid by means of a 2D risk map of the operational area. [ 37 ] ç ”ç©¶äº†ä½¿ç”¨ä¸åŒçš„åŸºäºæ‹å–çš„ç®—æ³•æ¥è§£å†³æ— äººæœºäº¤ä»˜ç¯å¢ƒä¸­å¤šä¸ªæ— äººæœºçš„å¼‚æ„ä»»åŠ¡åˆ†é…é—®é¢˜ã€‚è¯¥ç­–ç•¥ç”¨äºé€šè¿‡å°†å…·æœ‰åˆ°æœŸæ—¥æœŸé™åˆ¶çš„äº¤ä»˜ä»»åŠ¡åˆ†é…ç»™éœ€è¦è¾ƒä½èƒ½æºæ¶ˆè€—çš„å¤šæ¶æ— äººæœºæ¥æœ€å¤§é™åº¦åœ°å‡å°‘åŸºäºæ— äººæœºçš„åŒ…è£¹è¿è¾“æœåŠ¡çš„ç”µæ± æ¶ˆè€—ã€‚è¿˜è§£å†³äº†å……ç”µä»»åŠ¡çš„åˆ†é…é—®é¢˜ã€‚è¿™äº›åŸºäºæ‹å–çš„ç®—æ³•æ˜¯é€šè¿‡å•é¡¹å’Œå¤šé¡¹ç­–ç•¥æ¥å®ç°çš„ã€‚æ¯ä¸ªä»£ç†è§£å†³æ ‡é‡çº¦æŸä¼˜åŒ–é—®é¢˜ï¼Œä»¥è®¡ç®—æ— äººæœºå¯¹æ¯ä¸ªä»»åŠ¡çš„å‡ºä»·ã€‚å¯¹äºæŠ•é€’ä»»åŠ¡ï¼Œåè®®çš„å‡ºä»·ä¸èƒ½é‡æ¶ˆè€—ç›¸å…³ï¼Œè€Œå¯¹äºå……ç”µä»»åŠ¡çš„å‡ºä»·åˆ™é€‰æ‹©é£è¡Œæ—¶é—´ã€‚æ¡†æ¶ä¸­è¿˜åŒ…å«è·¯å¾„è§„åˆ’ï¼Œé€šè¿‡æ“ä½œåŒºåŸŸçš„äºŒç»´é£é™©å›¾æ¥è®¡ç®—æ¯ä¸ªä»»åŠ¡æ— äººæœºæŠ•æ ‡çš„é£é™©æ„ŸçŸ¥è·¯å¾„ã€‚ The work of [38] investigates the use of a second price auction algorithm for drone intelligent transportation. A deep learning methodology is also included to enhance the auction algorithmâ€™s robustness by revenue optimality. In addition, an improved implementation of an auction algorithm for drone delivery is addressed in [39]. Lightweight distributed task allocation is proposed for this application, simplifying the management of delivery and charge tasks with minimal energy consumption. Each agent runs a decentralized protocol, running path planning and optimization algorithms. In contrast to conventional auction-based methods for task scheduling, each agent is designed to function as both the networkâ€™s auctioneer and bidder, depending on the task type. Recent works combine the auction-based algorithm with other methodologies, as seen in [40,41,42]. [ 38 ]çš„å·¥ä½œç ”ç©¶äº†æ— äººæœºæ™ºèƒ½äº¤é€šçš„ç¬¬äºŒä»·æ ¼æ‹å–ç®—æ³•çš„ä½¿ç”¨ã€‚è¿˜åŒ…æ‹¬æ·±åº¦å­¦ä¹ æ–¹æ³•ï¼Œä»¥é€šè¿‡æ”¶å…¥æœ€ä¼˜æ€§å¢å¼ºæ‹å–ç®—æ³•çš„ç¨³å¥æ€§ã€‚æ­¤å¤–ï¼Œ[ 39 ]ä¸­è¿˜è®¨è®ºäº†æ— äººæœºäº¤ä»˜æ‹å–ç®—æ³•çš„æ”¹è¿›å®ç°ã€‚é’ˆå¯¹è¯¥åº”ç”¨æå‡ºäº†è½»é‡çº§åˆ†å¸ƒå¼ä»»åŠ¡åˆ†é…ï¼Œä»¥æœ€å°çš„èƒ½è€—ç®€åŒ–é…é€å’Œæ”¶è´¹ä»»åŠ¡çš„ç®¡ç†ã€‚æ¯ä¸ªä»£ç†è¿è¡Œä¸€ä¸ªå»ä¸­å¿ƒåŒ–åè®®ï¼Œè¿è¡Œè·¯å¾„è§„åˆ’å’Œä¼˜åŒ–ç®—æ³•ã€‚ä¸ä¼ ç»Ÿçš„åŸºäºæ‹å–çš„ä»»åŠ¡è°ƒåº¦æ–¹æ³•ç›¸æ¯”ï¼Œæ¯ä¸ªä»£ç†éƒ½è¢«è®¾è®¡ä¸ºæ ¹æ®ä»»åŠ¡ç±»å‹åŒæ—¶å……å½“ç½‘ç»œçš„æ‹å–äººå’ŒæŠ•æ ‡äººã€‚æœ€è¿‘çš„å·¥ä½œå°†åŸºäºæ‹å–çš„ç®—æ³•ä¸å…¶ä»–æ–¹æ³•ç›¸ç»“åˆï¼Œå¦‚ [40 41 42] ä¸­æ‰€ç¤ºã€‚ Table 4 provides an overview of the reviewed approaches, including the main characteristics, constraints, and limitations. è¡¨ 4æ¦‚è¿°äº†æ‰€å®¡æŸ¥çš„æ–¹æ³•ï¼ŒåŒ…æ‹¬ä¸»è¦ç‰¹å¾ã€çº¦æŸå’Œé™åˆ¶ã€‚ Ref. Algorithm Characteristics Main Constraints Limitations [32] Time-Sensitive Sequential Auction Improved allocation of tasks that have time constraints Time window deadlines - [33] Auction Increases robustness and non-exclusive task assignment Battery consumption, execution time, and path Poor performance when tasks could saddle agents with leaden tasks [34] Auction-based Multiple Constraints Solves multiple constraints and provides a way of calculating the price of a bid Sensor, time window, and fuel cost Most of the parameters are variable, but the area is fixed. The effectiveness is not investigated. [35] Hybrid Auction Algorithm Promotes its performance and robustness in dynamic task assignment and avoids obstacles Mission cost, coverage factor Each UAV can only perform limited tasks and must return to the base to replenish resources [36] Greedy Coalition Auction Allows for dynamic task allocation for spatially distributed multi-agent systems with a positive time efficiency Path and targets In the presence of large fleet of autonomous systems, scalability issues may arise due to the high computation cost [37] Greedy Auction Able to effectively handle the complexity and heterogeneity of the problem Energy efficiency, task due dates, safe path planning Distributed implementation is not addressed [38] Learning-Based Second Price Auction Enables the algorithm to be truthful, distributed, and scalable Energy consumption The data performance is limited to investigate the proposed conditions [39] Multi- Auctioneer Market-Based Enables one to tackle tasks with temporal constraints, minimizing the heterogeneous fleet of UAVsâ€™ energy consumption Comprehensive optimization of energy consumption, hard task due dates Robustness to lossy communication network is not addressed [40] Neural Myerson Auction Designed for UAV charging scheduling. It can provide collision avoidance to build secure and privacy-preserving systems Energy consumption and cluster selection The external forces, such as wind and other physical factors, are not considered [41] Improved Multi-Objective Auction Improves the setting of the quotation threshold parameters by the distance factor and designs an adaptive operator strategy Distance and target - [42] Combinatorial Double Auction Yields a set of feasible solutions for undertaking complex winner determination problem models Costs and market satisfaction Unavoidable limitation regarding the data simulation procedures Optimization-Based Algorithms åŸºäºä¼˜åŒ–çš„ç®—æ³• The optimization methodology is widely used in applied mathematics to find the optimal solution to a specific problem. The goal of the optimization is to reduce costs or maximize profit through an objective function, aiming to find the best solution from a set of possible solutions. Various constraints can be applied to optimize the cost function and achieve an improved solution. A variety of optimization techniques are evaluated, including three main groups: deterministic, metaheuristic (or stochastic), and heuristic. Methods based on deterministic optimization do not consider randomness; i.e., the output is equal when the same initial condition is adopted. Graphical methods, sequential and linear programming, and mixed integer linear programming (MILP) are some examples of deterministic techniques. Stochastic methods, on the other hand, include randomness in the algorithm, leading to different outcomes even in the presence of the same initial conditions. Evolutionary algorithms, swarm intelligence, Monte Carlo methods, and simulated annealing are some of the current examples for this group of algorithms. Furthermore, heuristic algorithms are an interesting alternative to deterministic methods (that yield a high computational cost), providing fast solutions in good computational time. Heuristic algorithms use practical approaches and shortcuts to obtain solutions that are not necessarily optimal, but sufficient for finding good local solutions. ä¼˜åŒ–æ–¹æ³•å¹¿æ³›åº”ç”¨äºåº”ç”¨æ•°å­¦ä¸­ï¼Œä»¥å¯»æ‰¾ç‰¹å®šé—®é¢˜çš„æœ€ä¼˜è§£å†³æ–¹æ¡ˆã€‚ä¼˜åŒ–çš„ç›®æ ‡æ˜¯é€šè¿‡ç›®æ ‡å‡½æ•°é™ä½æˆæœ¬æˆ–æœ€å¤§åŒ–åˆ©æ¶¦ï¼Œæ—¨åœ¨ä»ä¸€ç»„å¯èƒ½çš„è§£å†³æ–¹æ¡ˆä¸­æ‰¾åˆ°æœ€ä½³è§£å†³æ–¹æ¡ˆã€‚å¯ä»¥åº”ç”¨å„ç§çº¦æŸæ¥ä¼˜åŒ–æˆæœ¬å‡½æ•°å¹¶å®ç°æ”¹è¿›çš„è§£å†³æ–¹æ¡ˆã€‚è¯„ä¼°äº†å„ç§ä¼˜åŒ–æŠ€æœ¯ï¼ŒåŒ…æ‹¬ä¸‰ä¸ªä¸»è¦ç»„ï¼šç¡®å®šæ€§ã€å…ƒå¯å‘å¼ï¼ˆæˆ–éšæœºï¼‰å’Œå¯å‘å¼ã€‚åŸºäºç¡®å®šæ€§ä¼˜åŒ–çš„æ–¹æ³•ä¸è€ƒè™‘éšæœºæ€§ï¼›å³é‡‡ç”¨ç›¸åŒåˆå§‹æ¡ä»¶æ—¶ï¼Œè¾“å‡ºç›¸ç­‰ã€‚å›¾å½¢æ–¹æ³•ã€é¡ºåºå’Œçº¿æ€§è§„åˆ’ä»¥åŠæ··åˆæ•´æ•°çº¿æ€§è§„åˆ’ (MILP) æ˜¯ç¡®å®šæ€§æŠ€æœ¯çš„ä¸€äº›ç¤ºä¾‹ã€‚å¦ä¸€æ–¹é¢ï¼Œéšæœºæ–¹æ³•åœ¨ç®—æ³•ä¸­åŒ…å«éšæœºæ€§ï¼Œå³ä½¿å­˜åœ¨ç›¸åŒçš„åˆå§‹æ¡ä»¶ä¹Ÿä¼šå¯¼è‡´ä¸åŒçš„ç»“æœã€‚è¿›åŒ–ç®—æ³•ã€ç¾¤ä½“æ™ºèƒ½ã€è’™ç‰¹å¡ç½—æ–¹æ³•å’Œæ¨¡æ‹Ÿé€€ç«æ˜¯è¿™ç»„ç®—æ³•çš„ä¸€äº›å½“å‰ç¤ºä¾‹ã€‚æ­¤å¤–ï¼Œå¯å‘å¼ç®—æ³•æ˜¯ç¡®å®šæ€§æ–¹æ³•ï¼ˆè®¡ç®—æˆæœ¬è¾ƒé«˜ï¼‰çš„æœ‰è¶£æ›¿ä»£æ–¹æ¡ˆï¼Œå¯ä»¥åœ¨è‰¯å¥½çš„è®¡ç®—æ—¶é—´å†…æä¾›å¿«é€Ÿè§£å†³æ–¹æ¡ˆã€‚å¯å‘å¼ç®—æ³•ä½¿ç”¨å®ç”¨çš„æ–¹æ³•å’Œæ·å¾„æ¥è·å¾—ä¸ä¸€å®šæ˜¯æœ€ä¼˜çš„è§£å†³æ–¹æ¡ˆï¼Œä½†è¶³ä»¥æ‰¾åˆ°è‰¯å¥½çš„å±€éƒ¨è§£å†³æ–¹æ¡ˆã€‚ 5.1. Deterministic 5.1.ç¡®å®šæ€§ Hybrid Allocation Algorithms æ··åˆåˆ†é…ç®—æ³• Hybrid allocation strategies are also designed to improve the transportation efficiency for UAV-based ITSs by merging different types of allocation algorithms.æ··åˆåˆ†é…ç­–ç•¥è¿˜æ—¨åœ¨é€šè¿‡åˆå¹¶ä¸åŒç±»å‹çš„åˆ†é…ç®—æ³•æ¥æé«˜åŸºäºæ— äººæœºçš„æ™ºèƒ½äº¤é€šç³»ç»Ÿçš„è¿è¾“æ•ˆç‡ã€‚ The work of [74] combines mixed-integer linear programming (MILP) and a simulated annealing (SA)-based heuristic algorithm to find optimal routes for a drone delivery application. Both battery consumption and payload weight are considered to calculate the droneâ€™s energy consumption. MILP is employed to minimize costs and the delivery time up to a budget constraint, while the SA is used to find suboptimal solutions of practical scenarios, i.e., the relation between the delivery time and budget. As a drawback, the SA algorithm fails to utilize geographical information to attenuate the choice of impractical routes. Hybrid algorithms can also be used to investigate the optimization of the service itself, as in [75]. Particle swarm optimization (PSO) and the grey wolf optimizer (GWO) are combined to minimize the number of deployed drones, cost, and flight time. The proposed algorithm incorporates different strategies, such as interval transformation, dynamic weighting rules, and a nonlinear convergence factor, to enhance the performance accuracy and to lower the cost. [ 74 ]çš„å·¥ä½œç»“åˆäº†æ··åˆæ•´æ•°çº¿æ€§è§„åˆ’ï¼ˆMILPï¼‰å’ŒåŸºäºæ¨¡æ‹Ÿé€€ç«ï¼ˆSAï¼‰çš„å¯å‘å¼ç®—æ³•æ¥å¯»æ‰¾æ— äººæœºé€è´§åº”ç”¨çš„æœ€ä½³è·¯çº¿ã€‚è®¡ç®—æ— äººæœºçš„èƒ½è€—æ—¶ä¼šè€ƒè™‘ç”µæ± æ¶ˆè€—å’Œæœ‰æ•ˆè´Ÿè½½é‡é‡ã€‚ MILP ç”¨äºåœ¨é¢„ç®—çº¦æŸä¸‹æœ€å°åŒ–æˆæœ¬å’Œäº¤ä»˜æ—¶é—´ï¼Œè€Œ SA ç”¨äºå¯»æ‰¾å®é™…åœºæ™¯çš„æ¬¡ä¼˜è§£å†³æ–¹æ¡ˆï¼Œå³äº¤ä»˜æ—¶é—´ä¸é¢„ç®—ä¹‹é—´çš„å…³ç³»ã€‚ SA ç®—æ³•çš„ç¼ºç‚¹æ˜¯æ— æ³•åˆ©ç”¨åœ°ç†ä¿¡æ¯æ¥å‡å°‘ä¸åˆ‡å®é™…çš„è·¯çº¿çš„é€‰æ‹©ã€‚æ··åˆç®—æ³•ä¹Ÿå¯ä»¥ç”¨äºç ”ç©¶æœåŠ¡æœ¬èº«çš„ä¼˜åŒ–ï¼Œå¦‚[ 75 ]ä¸­æ‰€ç¤ºã€‚ç²’å­ç¾¤ä¼˜åŒ–ï¼ˆPSOï¼‰å’Œç°ç‹¼ä¼˜åŒ–å™¨ï¼ˆGWOï¼‰ç›¸ç»“åˆï¼Œå¯ä»¥æœ€å¤§ç¨‹åº¦åœ°å‡å°‘éƒ¨ç½²çš„æ— äººæœºæ•°é‡ã€æˆæœ¬å’Œé£è¡Œæ—¶é—´ã€‚è¯¥ç®—æ³•ç»“åˆäº†åŒºé—´å˜æ¢ã€åŠ¨æ€åŠ æƒè§„åˆ™å’Œéçº¿æ€§æ”¶æ•›å› å­ç­‰ä¸åŒç­–ç•¥ï¼Œä»¥æé«˜æ€§èƒ½ç²¾åº¦å¹¶é™ä½æˆæœ¬ã€‚ The work of [76] combines the Hungarian algorithm (HA) and machine learning (ML) to optimize the task assignment problem in a drone delivery application. Different mathematical models, such as linear and polynomial regressions, are used to generate distinct cost functions, based on distance and time metrics. Once the cost function is estimated, the Hungarian algorithm is employed for solving the drone intelligent delivery problem. The Hungarian algorithm is defined by a matrix of costs, which represents the cost of each agent or task. [ 76 ]çš„å·¥ä½œç»“åˆäº†åŒˆç‰™åˆ©ç®—æ³•ï¼ˆHAï¼‰å’Œæœºå™¨å­¦ä¹ ï¼ˆMLï¼‰æ¥ä¼˜åŒ–æ— äººæœºäº¤ä»˜åº”ç”¨ä¸­çš„ä»»åŠ¡åˆ†é…é—®é¢˜ã€‚ä¸åŒçš„æ•°å­¦æ¨¡å‹ï¼ˆä¾‹å¦‚çº¿æ€§å’Œå¤šé¡¹å¼å›å½’ï¼‰ç”¨äºæ ¹æ®è·ç¦»å’Œæ—¶é—´åº¦é‡ç”Ÿæˆä¸åŒçš„æˆæœ¬å‡½æ•°ã€‚ä¸€æ—¦æˆæœ¬å‡½æ•°è¢«ä¼°è®¡å‡ºæ¥ï¼ŒåŒˆç‰™åˆ©ç®—æ³•å°±è¢«ç”¨æ¥è§£å†³æ— äººæœºæ™ºèƒ½äº¤ä»˜é—®é¢˜ã€‚åŒˆç‰™åˆ©ç®—æ³•ç”±æˆæœ¬çŸ©é˜µå®šä¹‰ï¼Œè¯¥çŸ©é˜µè¡¨ç¤ºæ¯ä¸ªä»£ç†æˆ–ä»»åŠ¡çš„æˆæœ¬ã€‚ Similarly, the combination of a multi-agent RL algorithm and a conflict-free method is investigated in [77] to optimize task allocation and path planning for multiple drones. The strategy guarantees that the shortest path is chosen for the drones, while multi-agent proximal policy optimization (MAPPO) enables collision avoidance between the drones. The work of [78] investigates the design of a rapid allocation algorithm, based on the combination of a greedy auction algorithm and a reassignment strategy. The combination of both strategies enables swift and effective responses, which result in a rapid and efficient completion of tasks while preventing the occurrence of deadlocks. In addition, neural networks are widely employed for task allocation [79]. An assisted learning invasive encroachment neutralization (ALIEN) technique is designed for a secure drone transportation system. The objective function of the ALIEN algorithm aims to maximize the security of the drone transportation system, and it is represented by $I{max}=t_iD_i+t_iD^d{rÎ»i} +t_iD{N_i}$, where the decision variables represent drone detection, object recognition, and neutralization, respectively. ç±»ä¼¼åœ°ï¼Œ[ 77 ]ç ”ç©¶äº†å¤šæ™ºèƒ½ä½“å¼ºåŒ–å­¦ä¹ ç®—æ³•å’Œæ— å†²çªæ–¹æ³•çš„ç»“åˆï¼Œä»¥ä¼˜åŒ–å¤šæ¶æ— äººæœºçš„ä»»åŠ¡åˆ†é…å’Œè·¯å¾„è§„åˆ’ã€‚è¯¥ç­–ç•¥ä¿è¯ä¸ºæ— äººæœºé€‰æ‹©æœ€çŸ­è·¯å¾„ï¼Œè€Œå¤šæ™ºèƒ½ä½“è¿‘ç«¯ç­–ç•¥ä¼˜åŒ–ï¼ˆMAPPOï¼‰å¯ä»¥é¿å…æ— äººæœºä¹‹é—´çš„ç¢°æ’ã€‚ [ 78 ]çš„å·¥ä½œç ”ç©¶äº†åŸºäºè´ªå©ªæ‹å–ç®—æ³•å’Œé‡æ–°åˆ†é…ç­–ç•¥çš„ç»„åˆçš„å¿«é€Ÿåˆ†é…ç®—æ³•çš„è®¾è®¡ã€‚ä¸¤ç§ç­–ç•¥çš„ç»“åˆå¯ä»¥å®ç°å¿«é€Ÿæœ‰æ•ˆçš„å“åº”ï¼Œä»è€Œå¿«é€Ÿé«˜æ•ˆåœ°å®Œæˆä»»åŠ¡ï¼ŒåŒæ—¶é˜²æ­¢æ­»é”çš„å‘ç”Ÿã€‚æ­¤å¤–ï¼Œç¥ç»ç½‘ç»œå¹¿æ³›ç”¨äºä»»åŠ¡åˆ†é…[ 79 ]ã€‚è¾…åŠ©å­¦ä¹ ä¾µå…¥æ€§ä¾µå ä¸­å’Œï¼ˆALIENï¼‰æŠ€æœ¯æ˜¯ä¸ºå®‰å…¨çš„æ— äººæœºè¿è¾“ç³»ç»Ÿè€Œè®¾è®¡çš„ã€‚ ALIEN ç®—æ³•çš„ç›®æ ‡å‡½æ•°æ—¨åœ¨æœ€å¤§åŒ–æ— äººæœºè¿è¾“ç³»ç»Ÿçš„å®‰å…¨æ€§ï¼Œå…¶è¡¨ç¤ºä¸º $I{max}=t_iD_i+t_iD^d{rÎ»i} +t_iD{N_i}$ ï¼Œå…¶ä¸­å†³ç­–å˜é‡åˆ†åˆ«ä»£è¡¨æ— äººæœºæ£€æµ‹ã€ç‰©ä½“è¯†åˆ«å’Œä¸­å’Œã€‚ Moreover, the maximum task allocation algorithm is proposed in [80]. The maximum task allocation algorithm for multiple UAVs under time constraints has been significant in meeting requirements for quality of service. The TRMaxAlloc algorithm is designed based on two phases: assignment and reassignment. The PI algorithm is used, in the first stage, to allocate the tasks to the drones, while, in the next stage, the proposed TRMaxAlloc algorithm enables the creation of feasible time slots for the unassigned tasks. As a result, the assignment enables each task to be completed before its corresponding deadline with a lower time cost. Each UAV is assigned to several tasks, as described by the task list ${s1,s2,â€¦,sN}$. Then, the cost function, expressed as $J=max |si|$, aims to optimize the task allocation problem. æ­¤å¤–ï¼Œ[ 80 ]ä¸­æå‡ºäº†æœ€å¤§ä»»åŠ¡åˆ†é…ç®—æ³•ã€‚æ—¶é—´çº¦æŸä¸‹å¤šæ— äººæœºæœ€å¤§ä»»åŠ¡åˆ†é…ç®—æ³•å¯¹äºæ»¡è¶³æœåŠ¡è´¨é‡è¦æ±‚å…·æœ‰é‡è¦æ„ä¹‰ã€‚ TRMaxAlloc ç®—æ³•çš„è®¾è®¡åŸºäºä¸¤ä¸ªé˜¶æ®µï¼šåˆ†é…å’Œé‡æ–°åˆ†é…ã€‚åœ¨ç¬¬ä¸€é˜¶æ®µï¼Œä½¿ç”¨ PI ç®—æ³•å°†ä»»åŠ¡åˆ†é…ç»™æ— äººæœºï¼Œè€Œåœ¨ä¸‹ä¸€é˜¶æ®µï¼Œæ‰€æå‡ºçš„ TRMaxAlloc ç®—æ³•å¯ä»¥ä¸ºæœªåˆ†é…çš„ä»»åŠ¡åˆ›å»ºå¯è¡Œçš„æ—¶éš™ã€‚å› æ­¤ï¼Œåˆ†é…ä½¿æ¯ä¸ªä»»åŠ¡èƒ½å¤Ÿåœ¨ç›¸åº”çš„æˆªæ­¢æ—¥æœŸä¹‹å‰ä»¥è¾ƒä½çš„æ—¶é—´æˆæœ¬å®Œæˆã€‚æ¯æ¶æ— äººæœºè¢«åˆ†é…å¤šä¸ªä»»åŠ¡ï¼Œå¦‚ä»»åŠ¡åˆ—è¡¨æ‰€è¿° ${s1,s2,â€¦,sN}$ ã€‚é‚£ä¹ˆï¼Œæˆæœ¬å‡½æ•°ï¼Œè¡¨ç¤ºä¸º $J=max |si|$ ï¼Œæ—¨åœ¨ä¼˜åŒ–ä»»åŠ¡åˆ†é…é—®é¢˜ã€‚ A real-time market-based task allocation mechanism is proposed in [81] for a dynamic coalition formation (DCF) problem. Autonomous agents can collaborate independently, creating an optimal global coalition structure to efficiently execute the emerging tasks. The auction algorithm is used for real-time assignment, and a mutual-selection method is employed for obtaining an improved performance in terms of the agent utilization rate and task completion rate. In addition, the work of [82] investigated the combination of a distributed evolutionary algorithm and a greedy algorithm to simultaneously optimize multiple objective functions. This combined methodology aims to improve the modelâ€™s local optimizing ability with different constraints, such as spatial constraints, time costs, and energy consumption. The proposed strategy aims to efficiently solve large-scale task allocation problems with enhanced and more diverse non-dominated solutions. [ 81 ]é’ˆå¯¹åŠ¨æ€è”ç›Ÿå½¢æˆï¼ˆDCFï¼‰é—®é¢˜æå‡ºäº†ä¸€ç§åŸºäºå¸‚åœºçš„å®æ—¶ä»»åŠ¡åˆ†é…æœºåˆ¶ã€‚è‡ªæ²»ä»£ç†å¯ä»¥ç‹¬ç«‹åä½œï¼Œåˆ›å»ºæœ€ä½³çš„å…¨çƒè”ç›Ÿç»“æ„ï¼Œä»¥æœ‰æ•ˆåœ°æ‰§è¡Œæ–°å…´ä»»åŠ¡ã€‚é‡‡ç”¨æ‹å–ç®—æ³•è¿›è¡Œå®æ—¶åˆ†é…ï¼Œå¹¶é‡‡ç”¨ç›¸äº’é€‰æ‹©çš„æ–¹æ³•åœ¨ä»£ç†åˆ©ç”¨ç‡å’Œä»»åŠ¡å®Œæˆç‡æ–¹é¢è·å¾—æ”¹è¿›çš„æ€§èƒ½ã€‚æ­¤å¤–ï¼Œ[ 82 ]çš„å·¥ä½œç ”ç©¶äº†åˆ†å¸ƒå¼è¿›åŒ–ç®—æ³•å’Œè´ªå©ªç®—æ³•çš„ç»„åˆæ¥åŒæ—¶ä¼˜åŒ–å¤šä¸ªç›®æ ‡å‡½æ•°ã€‚è¿™ç§ç»„åˆæ–¹æ³•æ—¨åœ¨æé«˜æ¨¡å‹åœ¨ä¸åŒçº¦æŸä¸‹çš„å±€éƒ¨ä¼˜åŒ–èƒ½åŠ›ï¼Œä¾‹å¦‚ç©ºé—´çº¦æŸã€æ—¶é—´æˆæœ¬å’Œèƒ½é‡æ¶ˆè€—ã€‚æ‰€æå‡ºçš„ç­–ç•¥æ—¨åœ¨é€šè¿‡å¢å¼ºä¸”æ›´å¤šæ ·åŒ–çš„éæ”¯é…è§£å†³æ–¹æ¡ˆæ¥æœ‰æ•ˆè§£å†³å¤§è§„æ¨¡ä»»åŠ¡åˆ†é…é—®é¢˜ã€‚ Discussion The primary objective of this paper is to serve as a state-of-the-art reference for researchers and engineers about the science of task allocation applied to various UAV-based ITSs. Such technology is foreseen to become popular in the next decades in different contexts: smart cities, urban air mobility, smart logistics, connected vehicles, etc.æœ¬æ–‡çš„ä¸»è¦ç›®çš„æ˜¯ä¸ºç ”ç©¶äººå‘˜å’Œå·¥ç¨‹å¸ˆæä¾›æœ‰å…³åº”ç”¨äºå„ç§åŸºäºæ— äººæœºçš„ ITS çš„ä»»åŠ¡åˆ†é…ç§‘å­¦çš„æœ€æ–°å‚è€ƒã€‚é¢„è®¡æ­¤ç±»æŠ€æœ¯å°†åœ¨æœªæ¥å‡ åå¹´åœ¨ä¸åŒçš„ç¯å¢ƒä¸­æµè¡Œï¼šæ™ºæ…§åŸå¸‚ã€åŸå¸‚ç©ºä¸­äº¤é€šã€æ™ºèƒ½ç‰©æµã€äº’è”è½¦è¾†ç­‰ã€‚ The main conclusions drawn from this survey are summarized as follows:æœ¬æ¬¡è°ƒæŸ¥å¾—å‡ºçš„ä¸»è¦ç»“è®ºæ€»ç»“å¦‚ä¸‹ï¼š Market-based allocation algorithms are, in general, less computationally demanding than other methods, but the bidding procedure has to be designed carefully to avoid unfair allocations. Market-based allocation architectures should be developed for applications with a high level of autonomy and inherent dynamicity (e.g., parcel delivery, traffic monitoring, search and rescue, and passenger transportation), with the drones being able to adjust their bids based on their current status as well as both the service demand and the environmental conditions; ä¸€èˆ¬æ¥è¯´ï¼ŒåŸºäºå¸‚åœºçš„åˆ†é…ç®—æ³•æ¯”å…¶ä»–æ–¹æ³•çš„è®¡ç®—è¦æ±‚è¾ƒä½ï¼Œä½†å¿…é¡»ä»”ç»†è®¾è®¡æŠ•æ ‡ç¨‹åºä»¥é¿å…ä¸å…¬å¹³çš„åˆ†é…ã€‚åº”ä¸ºå…·æœ‰é«˜åº¦è‡ªä¸»æ€§å’Œå›ºæœ‰åŠ¨æ€æ€§çš„åº”ç”¨ï¼ˆä¾‹å¦‚åŒ…è£¹é€’é€ã€äº¤é€šç›‘æ§ã€æœç´¢å’Œæ•‘æ´ä»¥åŠå®¢è¿ï¼‰å¼€å‘åŸºäºå¸‚åœºçš„åˆ†é…æ¶æ„ï¼Œæ— äººæœºèƒ½å¤Ÿæ ¹æ®å½“å‰æƒ…å†µè°ƒæ•´å…¶å‡ºä»·çŠ¶å†µä»¥åŠæœåŠ¡éœ€æ±‚å’Œç¯å¢ƒæ¡ä»¶ï¼› Optimization-based approaches produce more efficient allocation but should be used to allocate tasks to UAVs in static scenarios with well-defined constraints (e.g., inspection and data collection). The main drawback is the scalability of these approaches with larger fleets due to their computational complexity. Also, complex application scenarios may be difficult to model, and discrepancies between a real application and a simulation model may severely affect the quality of the obtained solution; åŸºäºä¼˜åŒ–çš„æ–¹æ³•å¯ä»¥äº§ç”Ÿæ›´æœ‰æ•ˆçš„åˆ†é…ï¼Œä½†åº”è¯¥ç”¨äºåœ¨å…·æœ‰æ˜ç¡®å®šä¹‰çš„çº¦æŸï¼ˆä¾‹å¦‚æ£€æŸ¥å’Œæ•°æ®æ”¶é›†ï¼‰çš„é™æ€åœºæ™¯ä¸­å°†ä»»åŠ¡åˆ†é…ç»™æ— äººæœºã€‚ä¸»è¦ç¼ºç‚¹æ˜¯ç”±äºè®¡ç®—å¤æ‚æ€§ï¼Œè¿™äº›æ–¹æ³•åœ¨è¾ƒå¤§è½¦é˜Ÿä¸­çš„å¯æ‰©å±•æ€§ã€‚æ­¤å¤–ï¼Œå¤æ‚çš„åº”ç”¨åœºæ™¯å¯èƒ½éš¾ä»¥å»ºæ¨¡ï¼Œå®é™…åº”ç”¨ä¸ä»¿çœŸæ¨¡å‹ä¹‹é—´çš„å·®å¼‚å¯èƒ½ä¼šä¸¥é‡å½±å“æ‰€è·å¾—è§£å†³æ–¹æ¡ˆçš„è´¨é‡ï¼› Learning-based task allocation algorithms are suitable for highly dynamic scenarios in which the UAVs can exploit large datasets of past experiences to adapt to variable environmental conditions. A preferable application can be identified as the UAV traffic monitoring service. On the other hand, a learning-based task allocation architecture is not suitable for every type of scenario involving environmental variability; for instance, considering a critical emergency scenario such as disaster response, the trustworthiness of UAV task allocations plays a crucial role, thereby limiting the deployment of such an allocation architecture. Also, the questionable level of generalizability to unseen conditions may be a limiting factor; åŸºäºå­¦ä¹ çš„ä»»åŠ¡åˆ†é…ç®—æ³•é€‚ç”¨äºé«˜åº¦åŠ¨æ€çš„åœºæ™¯ï¼Œå…¶ä¸­æ— äººæœºå¯ä»¥åˆ©ç”¨è¿‡å»ç»éªŒçš„å¤§å‹æ•°æ®é›†æ¥é€‚åº”å¯å˜çš„ç¯å¢ƒæ¡ä»¶ã€‚ä¸€ä¸ªä¼˜é€‰çš„åº”ç”¨æ˜¯æ— äººæœºäº¤é€šç›‘æ§æœåŠ¡ã€‚å¦ä¸€æ–¹é¢ï¼ŒåŸºäºå­¦ä¹ çš„ä»»åŠ¡åˆ†é…æ¶æ„å¹¶ä¸é€‚åˆæ‰€æœ‰æ¶‰åŠç¯å¢ƒå˜åŒ–çš„åœºæ™¯ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘åˆ°ç¾éš¾å“åº”ç­‰å…³é”®ç´§æ€¥æƒ…å†µï¼Œæ— äººæœºä»»åŠ¡åˆ†é…çš„å¯ä¿¡åº¦èµ·ç€è‡³å…³é‡è¦çš„ä½œç”¨ï¼Œä»è€Œé™åˆ¶äº†è¿™ç§åˆ†é…æ¶æ„çš„éƒ¨ç½²ã€‚æ­¤å¤–ï¼Œå¯¹æœªè§æ¡ä»¶çš„æ™®éé€‚ç”¨æ€§å€¼å¾—æ€€ç–‘ï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªé™åˆ¶å› ç´ ï¼› Game-theory-based approaches are well suited for applications in which the UAVs can compete against one another or cooperate in the completion of a task with well-defined utilities. Coverage and traffic monitoring tasks represent a valid example since the UAVs of the ITS can compete for the best coverage/monitoring location. The limitations of a game-theory-based task allocation strategy in UAV-based ITS contexts are both the computational burden with large fleets and the capability of the utility function to adequately represent the real-world reward related to the allocation; åŸºäºåšå¼ˆè®ºçš„æ–¹æ³•éå¸¸é€‚åˆæ— äººæœºå¯ä»¥ç›¸äº’ç«äº‰æˆ–ä¸æ˜ç¡®å®šä¹‰çš„å®ç”¨ç¨‹åºåˆä½œå®Œæˆä»»åŠ¡çš„åº”ç”¨ã€‚è¦†ç›–å’Œäº¤é€šç›‘æ§ä»»åŠ¡æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ä¾‹å­ï¼Œå› ä¸º ITS çš„æ— äººæœºå¯ä»¥ç«äº‰æœ€ä½³çš„è¦†ç›–/ç›‘æ§ä½ç½®ã€‚åœ¨åŸºäºæ— äººæœºçš„ ITS ç¯å¢ƒä¸­ï¼ŒåŸºäºåšå¼ˆè®ºçš„ä»»åŠ¡åˆ†é…ç­–ç•¥çš„å±€é™æ€§æ—¢åœ¨äºå¤§å‹æœºé˜Ÿçš„è®¡ç®—è´Ÿæ‹…ï¼Œåˆåœ¨äºæ•ˆç”¨å‡½æ•°å……åˆ†ä»£è¡¨ä¸åˆ†é…ç›¸å…³çš„ç°å®ä¸–ç•Œå¥–åŠ±çš„èƒ½åŠ›ï¼› The design of a hybrid allocation architecture incorporating multiple approaches is the most promising strategy for leveraging the characteristics of each method, thus enhancing the capability of the allocation algorithm to meet the requirements of (i) the environment, (ii) the service, and (iii) the UAV-based ITS. Also, hybrid allocation algorithms feature a higher generalization capability with respect to both the service and the robot type. ç»“åˆå¤šç§æ–¹æ³•çš„æ··åˆåˆ†é…æ¶æ„çš„è®¾è®¡æ˜¯åˆ©ç”¨æ¯ç§æ–¹æ³•çš„ç‰¹æ€§çš„æœ€æœ‰å‰é€”çš„ç­–ç•¥ï¼Œä»è€Œå¢å¼ºåˆ†é…ç®—æ³•çš„èƒ½åŠ›ä»¥æ»¡è¶³ï¼ˆiï¼‰ç¯å¢ƒã€ï¼ˆiiï¼‰æœåŠ¡å’Œï¼ˆ iii) åŸºäºæ— äººæœºçš„æ™ºèƒ½äº¤é€šç³»ç»Ÿã€‚æ­¤å¤–ï¼Œæ··åˆåˆ†é…ç®—æ³•å¯¹äºæœåŠ¡å’Œæœºå™¨äººç±»å‹éƒ½å…·æœ‰æ›´é«˜çš„æ³›åŒ–èƒ½åŠ›ã€‚ Finally, Table 8 summarizes the characteristics of the allocation methods in terms of computational cost, efficiency in finding optimal solutions, scalability to large fleets, capability of handling dynamic tasks, robots, and environments, and the most suitable application domains in the context of UAV-based ITSs. æœ€åï¼Œè¡¨ 8æ€»ç»“äº†åˆ†é…æ–¹æ³•çš„ç‰¹å¾ï¼ŒåŒ…æ‹¬è®¡ç®—æˆæœ¬ã€å¯»æ‰¾æœ€ä½³è§£å†³æ–¹æ¡ˆçš„æ•ˆç‡ã€å¤§å‹æœºé˜Ÿçš„å¯æ‰©å±•æ€§ã€å¤„ç†åŠ¨æ€ä»»åŠ¡ã€æœºå™¨äººå’Œç¯å¢ƒçš„èƒ½åŠ›ï¼Œä»¥åŠæ— äººæœºèƒŒæ™¯ä¸‹æœ€åˆé€‚çš„åº”ç”¨é¢†åŸŸåŸºäº ITSã€‚ Algorithm Cost Efficiency Scalability Dynamic Tasks and Robots Dynamic Environment Application Auction + + + + + + + + + + + + + + + D, TM, SR Learning + + + + + + + + + + + + + + + + + + + + TM, DR, A Game Theory + + + + + + + + + + + + + + + + C, TM, DC Deterministic + + + + + + + + + + + + + I, DC Heuristic + + + + + + + + + + + + + + D, C Metaheuristic + + + + + + + + + + + + + + + + D, C 8. Conclusions å…«ã€ç»“è®º For the sake of completeness, before delving into a discussion of the reviewed methodologies along with the applicability of the task allocation methods to the most established applications of UAVs in the context of ITS technology, the main applications of UAVs in the context of ITS technology are listed as follows: Search and rescue (SR) [83,84,85,86]; Delivery (D) [87,88,89]; Traffic monitoring (TM) [90]; Inspection (I) [91,92,93]; Disaster response (DR) [94,95,96]; Surveillance (S) [97,98]; Coverage (C) [99,100]; Data collection (DC) [101]; Smart mobility (SM) [102]; Agriculture (A) [103,104,105]. The use of unmanned aerial vehicles has gained significant attention in the context of intelligent transportation. The use of different sensors and high-resolution cameras enables the drones to support road transportation vehicles and to be used for a variety of parcel delivery tasks, among other applications. However, a scalable and efficient task allocation architecture must be designed for optimizing the coordination of the fleet of drones of an intelligent transportation system. Generally, task allocation is used to minimize the execution time of the tasks with a reliable and well-defined procedure. A categorization can be defined depending on the number and type of vehicles and tasks employed, including single-task UAVs or multi-task UAVs, single-UAV tasks or multi-UAV tasks, online or offline task allocation, and independent or dependent tasks. In addition, a combination of multiple UAVs and trucks as well as the inclusion of several constraints can significantly improve the overall efficiency. Therefore, the constant development of task allocation enables us to create more efficient methodologies that cover a large variety of scenarios. åœ¨æ™ºèƒ½äº¤é€šé¢†åŸŸï¼Œæ— äººæœºçš„ä½¿ç”¨å—åˆ°äº†å¹¿æ³›å…³æ³¨ã€‚é€šè¿‡ä½¿ç”¨ä¸åŒçš„ä¼ æ„Ÿå™¨å’Œé«˜åˆ†è¾¨ç‡æ‘„åƒå¤´ï¼Œæ— äººæœºå¯ä»¥æ”¯æŒé“è·¯è¿è¾“è½¦è¾†ï¼Œå¹¶å¯ç”¨äºå„ç§åŒ…è£¹é€’é€ä»»åŠ¡ä»¥åŠå…¶ä»–åº”ç”¨ã€‚ç„¶è€Œï¼Œå¿…é¡»è®¾è®¡ä¸€ä¸ªå¯æ‰©å±•ä¸”é«˜æ•ˆçš„ä»»åŠ¡åˆ†é…æ¶æ„ï¼Œä»¥ä¼˜åŒ–æ™ºèƒ½äº¤é€šç³»ç»Ÿæ— äººæœºæœºé˜Ÿçš„åè°ƒã€‚é€šå¸¸ï¼Œä»»åŠ¡åˆ†é…ç”¨äºé€šè¿‡å¯é ä¸”å®šä¹‰æ˜ç¡®çš„è¿‡ç¨‹æ¥æœ€å°åŒ–ä»»åŠ¡çš„æ‰§è¡Œæ—¶é—´ã€‚å¯ä»¥æ ¹æ®æ‰€ä½¿ç”¨çš„è½¦è¾†å’Œä»»åŠ¡çš„æ•°é‡å’Œç±»å‹æ¥å®šä¹‰åˆ†ç±»ï¼ŒåŒ…æ‹¬å•ä»»åŠ¡æ— äººæœºæˆ–å¤šä»»åŠ¡æ— äººæœºã€å•æ— äººæœºä»»åŠ¡æˆ–å¤šæ— äººæœºä»»åŠ¡ã€åœ¨çº¿æˆ–ç¦»çº¿ä»»åŠ¡åˆ†é…ä»¥åŠç‹¬ç«‹æˆ–ç›¸å…³ä»»åŠ¡ã€‚æ­¤å¤–ï¼Œå¤šä¸ªæ— äººæœºå’Œå¡è½¦çš„ç»„åˆä»¥åŠåŒ…å«å¤šä¸ªçº¦æŸå¯ä»¥æ˜¾ç€æé«˜æ•´ä½“æ•ˆç‡ã€‚å› æ­¤ï¼Œä»»åŠ¡åˆ†é…çš„ä¸æ–­å‘å±•ä½¿æˆ‘ä»¬èƒ½å¤Ÿåˆ›å»ºæ›´æœ‰æ•ˆçš„æ–¹æ³•æ¥è¦†ç›–å„ç§åœºæ™¯ã€‚ In this sense, this paper provides a comprehensive literature review of how such approaches are being utilized to optimize the allocation of tasks in UAV-based ITSs. Market-based algorithms, game-theory-based algorithms, optimization-based algorithms, machine learning techniques, and other hybrid methodologies are reviewed and discussed. Furthermore, the main applications of unmanned aerial vehicles in ITSs are presented as well as the suitability of the task allocation algorithms presented throughout the paper with respect to the different applications. The main characteristics of, limitations of, and differences between the algorithms are highlighted, showing their main uses over the last few years. Understanding the main characteristics and the applicability of each type of allocation enables engineers and researchers to properly choose the most appropriate type of task scheduling logic. Moreover, the emerging trends and gaps in the literature are also discussed. ä»è¿™ä¸ªæ„ä¹‰ä¸Šè¯´ï¼Œæœ¬æ–‡å¯¹å¦‚ä½•åˆ©ç”¨è¿™äº›æ–¹æ³•æ¥ä¼˜åŒ–åŸºäºæ— äººæœºçš„æ™ºèƒ½äº¤é€šç³»ç»Ÿä¸­çš„ä»»åŠ¡åˆ†é…è¿›è¡Œäº†å…¨é¢çš„æ–‡çŒ®ç»¼è¿°ã€‚å›é¡¾å’Œè®¨è®ºäº†åŸºäºå¸‚åœºçš„ç®—æ³•ã€åŸºäºåšå¼ˆè®ºçš„ç®—æ³•ã€åŸºäºä¼˜åŒ–çš„ç®—æ³•ã€æœºå™¨å­¦ä¹ æŠ€æœ¯å’Œå…¶ä»–æ··åˆæ–¹æ³•ã€‚æ­¤å¤–ï¼Œè¿˜ä»‹ç»äº†æ— äººæœºåœ¨æ™ºèƒ½äº¤é€šç³»ç»Ÿä¸­çš„ä¸»è¦åº”ç”¨ï¼Œä»¥åŠæœ¬æ–‡æå‡ºçš„ä»»åŠ¡åˆ†é…ç®—æ³•å¯¹äºä¸åŒåº”ç”¨çš„é€‚ç”¨æ€§ã€‚çªå‡ºæ˜¾ç¤ºäº†ç®—æ³•çš„ä¸»è¦ç‰¹å¾ã€å±€é™æ€§å’Œå·®å¼‚ï¼Œæ˜¾ç¤ºäº†å®ƒä»¬åœ¨è¿‡å»å‡ å¹´ä¸­çš„ä¸»è¦ç”¨é€”ã€‚äº†è§£æ¯ç§åˆ†é…ç±»å‹çš„ä¸»è¦ç‰¹å¾å’Œé€‚ç”¨æ€§ä½¿å·¥ç¨‹å¸ˆå’Œç ”ç©¶äººå‘˜èƒ½å¤Ÿæ­£ç¡®é€‰æ‹©æœ€åˆé€‚çš„ä»»åŠ¡è°ƒåº¦é€»è¾‘ç±»å‹ã€‚æ­¤å¤–ï¼Œè¿˜è®¨è®ºäº†æ–‡çŒ®ä¸­çš„æ–°å…´è¶‹åŠ¿å’Œå·®è·ã€‚ In conclusion, we stress the importance of considering the requirements of the service as well as the environmental conditions and the operational capability of the UAV-based intelligent transportation system when designing a task allocation strategy. æ€»ä¹‹ï¼Œæˆ‘ä»¬å¼ºè°ƒåœ¨è®¾è®¡ä»»åŠ¡åˆ†é…ç­–ç•¥æ—¶è€ƒè™‘æœåŠ¡è¦æ±‚ä»¥åŠåŸºäºæ— äººæœºçš„æ™ºèƒ½äº¤é€šç³»ç»Ÿçš„ç¯å¢ƒæ¡ä»¶å’Œè¿è¡Œèƒ½åŠ›çš„é‡è¦æ€§ã€‚ As a further consideration, it is worth noticing that the design of communication channels and their security are fundamental for both implementing (if the allocation architecture is fully decentralized) and validating (if the allocation architecture is centralized or distributed) the allocation of tasks in a fleet of UAVs. Also, the security of the communication channels is a significant challenge for achieving a safe, regulatory-compliant, and resilient real-world deployment of a UAV-based ITS. The efficiency of the task allocation process can be heavily influenced by aspects such as the security of the communication channels as well as their fallibility. ä½œä¸ºè¿›ä¸€æ­¥çš„è€ƒè™‘ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œé€šä¿¡é€šé“çš„è®¾è®¡åŠå…¶å®‰å…¨æ€§å¯¹äºå®ç°ï¼ˆå¦‚æœåˆ†é…æ¶æ„æ˜¯å®Œå…¨å»ä¸­å¿ƒåŒ–çš„ï¼‰å’ŒéªŒè¯ï¼ˆå¦‚æœåˆ†é…æ¶æ„æ˜¯é›†ä¸­å¼çš„è¿˜æ˜¯åˆ†å¸ƒå¼çš„ï¼‰ä»»åŠ¡åˆ†é…è‡³å…³é‡è¦ã€‚æ— äººæœºæœºé˜Ÿã€‚æ­¤å¤–ï¼Œé€šä¿¡é€šé“çš„å®‰å…¨æ€§æ˜¯å®ç°åŸºäºæ— äººæœºçš„ ITS çš„å®‰å…¨ã€åˆè§„å’Œå¼¹æ€§ç°å®éƒ¨ç½²çš„é‡å¤§æŒ‘æˆ˜ã€‚ä»»åŠ¡åˆ†é…è¿‡ç¨‹çš„æ•ˆç‡å¯èƒ½ä¼šå—åˆ°é€šä¿¡é€šé“çš„å®‰å…¨æ€§åŠå…¶å¯é æ€§ç­‰æ–¹é¢çš„ä¸¥é‡å½±å“ã€‚ Future survey-based research will focus on investigating how the UAV communication protocol can influence the efficiency of the task allocation architecture in terms of both security and robustness to fallible communication networks. Also, conceptual modelling frameworks used to implement task allocation algorithms in UAV-based ITSs may also be discussed. æœªæ¥åŸºäºè°ƒæŸ¥çš„ç ”ç©¶å°†é‡ç‚¹è°ƒæŸ¥æ— äººæœºé€šä¿¡åè®®å¦‚ä½•å½±å“ä»»åŠ¡åˆ†é…æ¶æ„çš„æ•ˆç‡ï¼ŒåŒ…æ‹¬å®‰å…¨æ€§å’Œå¯¹æ˜“å‡ºé”™é€šä¿¡ç½‘ç»œçš„é²æ£’æ€§ã€‚æ­¤å¤–ï¼Œè¿˜å¯ä»¥è®¨è®ºç”¨äºåœ¨åŸºäºæ— äººæœºçš„ ITS ä¸­å®ç°ä»»åŠ¡åˆ†é…ç®—æ³•çš„æ¦‚å¿µå»ºæ¨¡æ¡†æ¶ã€‚ "},"Learn/LearnDrones/Ceres-Solver.html":{"url":"Learn/LearnDrones/Ceres-Solver.html","title":"Ceres-Solver","keywords":"","body":"Ceres-Solver doc Install (on debian12) # CMake sudo apt-get install cmake # google-glog + gflags # libgoogle-glog-dev: library that implements application-level logging # libgflags-dev: commandline flags module for C++ sudo apt-get install libgoogle-glog-dev libgflags-dev # Use ATLAS for BLAS & LAPACK # libatlas-base-dev: Automatically Tuned Linear Algebra Software, generic static sudo apt-get install libatlas-base-dev # Eigen3 # libeigen3-dev: lightweight C++ template library for linear algebra sudo apt-get install libeigen3-dev # SuiteSparse (optional) # libsuitesparse-dev: libraries for sparse matrices computations (development files) sudo apt-get install libsuitesparse-dev # to slow, skip it # FindTBB.cmake file(STRINGS \"${TBB_INCLUDE_DIR}/tbb/version.h\" # tbb_stddef.h -> version.h # https://github.com/ceres-solver/ceres-solver/issues/1036 TBB_VERSION_CONTENTS REGEX \"VERSION\") tar zxf ceres-solver-2.2.0.tar.gz mkdir ceres-bin cd ceres-bin cmake ../ceres-solver-2.2.0 make -j3 make test # Optionally install Ceres, it can also be exported using CMake which # allows Ceres to be used without requiring installation, see the documentation # for the EXPORT_BUILD_DIR option for more information. make install "},"Learn/LearnDrones/Eigen.html":{"url":"Learn/LearnDrones/Eigen.html","title":"Eigen","keywords":"","body":"Eigen eigen gitlab-eigen Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms. Eigen æ˜¯ä¸€ä¸ªç”¨äºçº¿æ€§ä»£æ•°çš„ C++ æ¨¡æ¿åº“ï¼šçŸ©é˜µã€å‘é‡ã€æ•°å€¼æ±‚è§£å™¨å’Œç›¸å…³ç®—æ³•ã€‚ "},"Learn/GPU2CPU.html":{"url":"Learn/GPU2CPU.html","title":"GPU2CPU","keywords":"","body":"GPU to CPU MocCUDA MocCUDA High-Performance GPU-to-CPU Transpilation and Optimization via High-Level Parallel Constructs é€šè¿‡é«˜çº§å¹¶è¡Œç»“æ„å®ç°é«˜æ€§èƒ½ GPU åˆ° CPU çš„è½¬è¯‘å’Œä¼˜åŒ– William S. Moses, Ivan R. Ivanov, Jens Domke, Toshio Endo, Johannes Doerfert, Oleksandr Zinenko PPoPP '23: Proceedings of the 28th ACM SIGPLAN Annual Symposium on Principles and Practice of Parallel Programming PPoPP '23ï¼šç¬¬ 28 å±Š ACM SIGPLAN å¹¶è¡Œç¼–ç¨‹åŸç†ä¸å®è·µå¹´åº¦ç ”è®¨ä¼šè®ºæ–‡é›† While parallelism remains the main source of performance, architectural implementations and programming models change with each new hardware generation, often leading to costly application re-engineering. Most tools for performance portability require manual and costly application porting to yet another programming model. è™½ç„¶å¹¶è¡Œæ€§ä»ç„¶æ˜¯æ€§èƒ½çš„ä¸»è¦æ¥æºï¼Œä½†æ¶æ„å®ç°å’Œç¼–ç¨‹æ¨¡å‹ä¼šéšç€æ¯ä¸€ä»£æ–°ç¡¬ä»¶çš„å˜åŒ–è€Œå˜åŒ–ï¼Œè¿™é€šå¸¸ä¼šå¯¼è‡´æ˜‚è´µçš„åº”ç”¨ç¨‹åºé‡æ–°è®¾è®¡ã€‚å¤§å¤šæ•°æ€§èƒ½å¯ç§»æ¤æ€§å·¥å…·éƒ½éœ€è¦æ‰‹åŠ¨ä¸”æ˜‚è´µçš„åº”ç”¨ç¨‹åºç§»æ¤åˆ°å¦ä¸€ä¸ªç¼–ç¨‹æ¨¡å‹ã€‚ We propose an alternative approach that automatically translates programs written in one programming model (CUDA), into another (CPU threads) based on Polygeist/MLIR. Our approach includes a representation of parallel constructs that allows conventional compiler transformations to apply transparently and without modification and enables parallelism-specific optimizations. We evaluate our framework by transpiling and optimizing the CUDA Rodinia benchmark suite for a multi-core CPU and achieve a 76% geomean speedup over handwritten OpenMP code. Further, we show how CUDA kernels from PyTorch can efficiently run and scale on the CPU-only Supercomputer Fugaku without user intervention. Our PyTorch compatibility layer making use of transpiled CUDA PyTorch kernels outperforms the PyTorch CPU native backend by 2.7Ã— . æˆ‘ä»¬æå‡ºäº†ä¸€ç§æ›¿ä»£æ–¹æ³•ï¼Œå°†ç”¨ä¸€ç§ç¼–ç¨‹æ¨¡å‹ ï¼ˆCUDAï¼‰ ç¼–å†™çš„ç¨‹åºè‡ªåŠ¨è½¬æ¢ä¸ºåŸºäº Polygeist/MLIR çš„å¦ä¸€ä¸ªç¼–ç¨‹æ¨¡å‹ï¼ˆ CPU çº¿ç¨‹ï¼‰ã€‚æˆ‘ä»¬çš„æ–¹æ³•åŒ…æ‹¬å¹¶è¡Œç»“æ„çš„è¡¨ç¤ºï¼Œå®ƒå…è®¸ä¼ ç»Ÿçš„ç¼–è¯‘å™¨è½¬æ¢é€æ˜ä¸”æ— éœ€ä¿®æ”¹åœ°åº”ç”¨ï¼Œå¹¶æ”¯æŒç‰¹å®šäºå¹¶è¡Œæ€§çš„ä¼˜åŒ–ã€‚æˆ‘ä»¬é€šè¿‡ä¸ºå¤šæ ¸ CPU è½¬è¯‘å’Œä¼˜åŒ– CUDA Rodinia åŸºå‡†æµ‹è¯•å¥—ä»¶æ¥è¯„ä¼°æˆ‘ä»¬çš„æ¡†æ¶ï¼Œå¹¶ä¸æ‰‹å†™çš„ OpenMP ä»£ç ç›¸æ¯”å®ç°äº† 76% çš„å‡ ä½•å¹³å‡é€Ÿåº¦æå‡ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜å±•ç¤ºäº† PyTorch çš„ CUDA å†…æ ¸å¦‚ä½•åœ¨çº¯ CPU è¶…çº§è®¡ç®—æœº Fugaku ä¸Šé«˜æ•ˆè¿è¡Œå’Œæ‰©å±•ï¼Œè€Œæ— éœ€ç”¨æˆ·å¹²é¢„ã€‚æˆ‘ä»¬çš„ PyTorch å…¼å®¹å±‚ä½¿ç”¨è½¬è¯‘çš„ CUDA PyTorch å†…æ ¸ï¼Œå…¶æ€§èƒ½æ¯” PyTorch CPU æœ¬æœºåç«¯é«˜å‡º 2.7 Ã— å€ã€‚ We propose a compiler model for most common GPU constructs: multi-level parallelism, level-wide synchronization, and level-local memory. This differs from CPU parallelism, which provides a single level of parallelism, a unified memory and peer synchronization. In contrast to source and AST-level approaches, which operate before the optimization pipeline, and existing compiler approaches, which model synchronization as a â€œblack-boxâ€ optimization barrier, we model synchronization entirely from memory semantics. This both allows synchronization-based code to inter-operate with existing optimizations and enables novel parallel-specific optimizations. æˆ‘ä»¬ä¸ºæœ€å¸¸è§çš„ GPU ç»“æ„æå‡ºäº†ä¸€ä¸ªç¼–è¯‘å™¨æ¨¡å‹ï¼šå¤šçº§å¹¶è¡Œã€çº§åˆ«èŒƒå›´åŒæ­¥å’Œçº§åˆ«æœ¬åœ°å†…å­˜ã€‚è¿™ä¸ CPU å¹¶è¡Œä¸åŒï¼Œåè€…æä¾›å•çº§å¹¶è¡Œã€ç»Ÿä¸€å†…å­˜å’Œå¯¹ç­‰åŒæ­¥ã€‚ä¸åœ¨ä¼˜åŒ–ç®¡é“ä¹‹å‰è¿è¡Œçš„æºå’Œ AST çº§æ–¹æ³•ä»¥åŠå°†åŒæ­¥å»ºæ¨¡ä¸ºâ€œé»‘ç›’â€ä¼˜åŒ–å±éšœçš„ç°æœ‰ç¼–è¯‘å™¨æ–¹æ³•ç›¸æ¯”ï¼Œæˆ‘ä»¬å®Œå…¨æ ¹æ®å†…å­˜è¯­ä¹‰å¯¹åŒæ­¥è¿›è¡Œå»ºæ¨¡ã€‚è¿™æ—¢å…è®¸åŸºäºåŒæ­¥çš„ä»£ç ä¸ç°æœ‰ä¼˜åŒ–è¿›è¡Œäº’æ“ä½œï¼Œåˆå¯ä»¥å®ç°æ–°é¢–çš„å¹¶è¡Œç‰¹å®šä¼˜åŒ–ã€‚ Our model is implemented in the MLIR layer [20] of the LLVM compiler infrastructure [21] and it leverages MLIRâ€™s nested-module approach for GPU codes [22] We extended the Polygeist [23] C/C++ frontend to support CUDA and to produce MLIR which preserves high-level parallelism and program structure. Our prototype compiler is capable of compiling PyTorch CUDA kernels, as well as other compute-intensive benchmarks, to any CPU architecture supported by LLVM. In addition to transformations accounting for the differences in the execution model, we also exploit parallelism on the CPU via OpenMP. Finally, our MocCUDA PyTorch integration uses our approach to compile and execute CUDA kernels in absence of a GPU while substituting unsupported calls. æˆ‘ä»¬çš„æ¨¡å‹åœ¨ LLVM ç¼–è¯‘å™¨åŸºç¡€è®¾æ–½[ 21 ]çš„ MLIR å±‚[ 20 ]ä¸­å®ç°ï¼Œå®ƒåˆ©ç”¨ MLIR çš„ GPU ä»£ç åµŒå¥—æ¨¡å—æ–¹æ³•[ 22 ]æˆ‘ä»¬æ‰©å±•äº† Polygeist [ 23 ] C/C++ å‰ç«¯ä»¥æ”¯æŒ CUDA å¹¶ç”ŸæˆMLIR ä¿ç•™äº†é«˜çº§å¹¶è¡Œæ€§å’Œç¨‹åºç»“æ„ã€‚æˆ‘ä»¬çš„åŸå‹ç¼–è¯‘å™¨èƒ½å¤Ÿå°† PyTorch CUDA å†…æ ¸ä»¥åŠå…¶ä»–è®¡ç®—å¯†é›†å‹åŸºå‡†ç¼–è¯‘åˆ° LLVM æ”¯æŒçš„ä»»ä½• CPU æ¶æ„ã€‚é™¤äº†è€ƒè™‘æ‰§è¡Œæ¨¡å‹å·®å¼‚çš„è½¬æ¢ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜é€šè¿‡ OpenMP åˆ©ç”¨ CPU ä¸Šçš„å¹¶è¡Œæ€§ã€‚æœ€åï¼Œæˆ‘ä»¬çš„ MocCUDA PyTorch é›†æˆä½¿ç”¨æˆ‘ä»¬çš„æ–¹æ³•åœ¨æ²¡æœ‰ GPU çš„æƒ…å†µä¸‹ç¼–è¯‘å’Œæ‰§è¡Œ CUDA å†…æ ¸ï¼ŒåŒæ—¶æ›¿æ¢ä¸æ”¯æŒçš„è°ƒç”¨ã€‚ Overall, our paper makes the following contributions: æ€»çš„æ¥è¯´ï¼Œæˆ‘ä»¬çš„è®ºæ–‡åšå‡ºäº†ä»¥ä¸‹è´¡çŒ®ï¼š A common high-level and platform-agnostic representation of SIMT-style parallelism backed by a semantic definition of barrier synchronization that ensures correctness through memory semantics, which ensures transparent application of existing optimizations. SIMT å¼å¹¶è¡Œæ€§çš„é€šç”¨é«˜çº§ä¸”ä¸å¹³å°æ— å…³çš„è¡¨ç¤ºå½¢å¼ï¼Œç”±å±éšœåŒæ­¥çš„è¯­ä¹‰å®šä¹‰æ”¯æŒï¼Œé€šè¿‡å†…å­˜è¯­ä¹‰ç¡®ä¿æ­£ç¡®æ€§ï¼Œä»è€Œç¡®ä¿ç°æœ‰ä¼˜åŒ–çš„é€æ˜åº”ç”¨ã€‚ Novel parallel-specific optimizations which can exploit our high-level parallel semantics to optimize programs. æ–°é¢–çš„å¹¶è¡Œç‰¹å®šä¼˜åŒ–å¯ä»¥åˆ©ç”¨æˆ‘ä»¬çš„é«˜çº§å¹¶è¡Œè¯­ä¹‰æ¥ä¼˜åŒ–ç¨‹åºã€‚ An extension to the Polygeist C/C++ frontend for MLIR which is capable of directly mapping GPU and CPU parallel constructs into our high-level parallelism primitives. MLIR çš„ Polygeist C/C++ å‰ç«¯çš„æ‰©å±•ï¼Œèƒ½å¤Ÿç›´æ¥å°† GPU å’Œ CPU å¹¶è¡Œç»“æ„æ˜ å°„åˆ°æˆ‘ä»¬çš„é«˜çº§å¹¶è¡ŒåŸè¯­ä¸­ã€‚ An end-to-end transpilation of CUDA to CPU for a subset of the Rodinia [24] benchmark suite and the internal CUDA kernels within PyTorch [2] necessary to run a Resnet-50 on the CPU-only Fugaku supercomputer. å°† CUDA ç«¯åˆ°ç«¯è½¬è¯‘ä¸º CPUï¼Œç”¨äº Rodinia [ 24 ]åŸºå‡†æµ‹è¯•å¥—ä»¶çš„å­é›†ä»¥åŠ PyTorch [ 2 ]ä¸­çš„å†…éƒ¨ CUDA å†…æ ¸ï¼Œè¿™æ˜¯åœ¨çº¯ CPU Fugaku è¶…çº§è®¡ç®—æœºä¸Šè¿è¡Œ Resnet-50 æ‰€å¿…éœ€çš„ã€‚ II-CPolygeist II-Cå¤šçµ Polygeist is a C and C++ frontend for MLIR based on Clang [23]. It is capable of translating a broad range of C++ programs into a mix of MLIR dialects that preserve elements of the high-level structure of the program. In particular, Polygeist preserves structured control flow (loops and conditionals) as MLIR SCF dialect. It also simplifies analyses by preserving multi-dimensional array constructs whenever possible by relying on the MLIRâ€™s multi-dimensional memory reference (memref) type. Finally, Poylgeist is able to identify parts of the program suitable for polyhedral optimization [28] and represent them using the Affine dialect. Polygeist æ˜¯åŸºäº Clang [ 23 ] çš„MLIR çš„ C å’Œ C++ å‰ç«¯ã€‚å®ƒèƒ½å¤Ÿå°†å„ç§ C++ ç¨‹åºè½¬æ¢ä¸º MLIR æ–¹è¨€çš„æ··åˆï¼Œä»è€Œä¿ç•™ç¨‹åºé«˜çº§ç»“æ„çš„å…ƒç´ ã€‚ç‰¹åˆ«æ˜¯ï¼ŒPolygeist å°†ç»“æ„åŒ–æ§åˆ¶æµï¼ˆå¾ªç¯å’Œæ¡ä»¶ï¼‰ä¿ç•™ä¸º MLIR SCF æ–¹è¨€ã€‚å®ƒè¿˜é€šè¿‡ä¾èµ– MLIR çš„å¤šç»´å†…å­˜å¼•ç”¨ (memref) ç±»å‹å°½å¯èƒ½ä¿ç•™å¤šç»´æ•°ç»„ç»“æ„æ¥ç®€åŒ–åˆ†æã€‚æœ€åï¼ŒPoylgeist èƒ½å¤Ÿè¯†åˆ«ç¨‹åºä¸­é€‚åˆå¤šé¢ä½“ä¼˜åŒ–çš„éƒ¨åˆ†[ 28 ]å¹¶ä½¿ç”¨ä»¿å°„æ–¹è¨€è¡¨ç¤ºå®ƒä»¬ã€‚ Representation of GPU Kernel Launch We define the representation of a GPU kernel launch as follows (illustrated in Fig. 3): A 3D parallel for-loop over all blocks in the grid. A stack allocation for any shared memory, scoped to be unique per block. A 3D parallel for-loop over all threads in a block. A custom Polygeist barrier operation that provides equivalent semantics to a CUDA/ROCm synchronization. æˆ‘ä»¬å®šä¹‰GPUå†…æ ¸å¯åŠ¨çš„è¡¨ç¤ºå¦‚ä¸‹(å¦‚å›¾3æ‰€ç¤º): åœ¨ç½‘æ ¼ä¸­æ‰€æœ‰å—ä¸Šçš„3Då¹¶è¡Œforå¾ªç¯ã€‚ å¯¹ä»»ä½•å…±äº«å†…å­˜çš„å †æ ˆåˆ†é…,æ¯ä¸ªå—çš„èŒƒå›´æ˜¯å”¯ä¸€çš„ã€‚ åœ¨ä¸€ä¸ªå—ä¸­æ‰€æœ‰çº¿ç¨‹ä¸Šçš„3Då¹¶è¡Œforå¾ªç¯ã€‚ æä¾›ä¸ CUDA / ROCmåŒæ­¥ç­‰æ•ˆè¯­ä¹‰çš„è‡ªå®šä¹‰ Polygeist å±éšœæ“ä½œã€‚ PolygeistGPU-Docker From CUDA to OpenCL: Towards a performance-portable solution for multi-platform GPU programmin https://www.sciencedirect.com/science/article/abs/pii/S0167819111001335 In this work, we evaluate OpenCL as a programming tool for developing performance-portable applications for GPGPU. While the Khronos group developed OpenCL with programming portability in mind, performance is not necessarily portable. OpenCL has required performance-impacting initializations that do not exist in other languages such as CUDA. Understanding these implications allows us to provide a single library with decent performance on a variety of platforms. We choose triangular solver (TRSM) and matrix multiplication (GEMM) as representative level 3 BLAS routines to implement in OpenCL. We profile TRSM to get the time distribution of the OpenCL runtime system. We then provide tuned GEMM kernels for both the NVIDIA Tesla C2050 and ATI Radeon 5870, the latest GPUs offered by both companies. We explore the benefits of using the texture cache, the performance ramifications of copying data into images, discrepancies in the OpenCL and CUDA compilersâ€™ optimizations, and other issues that affect the performance. Experimental results show that nearly 50% of peak performance can be obtained in GEMM on both GPUs in OpenCL. We also show that the performance of these kernels is not highly portable. Finally, we propose the use of auto-tuning to better explore these kernelsâ€™ parameter space using search harness. åœ¨è¿™é¡¹å·¥ä½œä¸­ï¼Œæˆ‘ä»¬å°† OpenCL è¯„ä¼°ä¸ºç”¨äºä¸º GPGPU å¼€å‘æ€§èƒ½å¯ç§»æ¤åº”ç”¨ç¨‹åºçš„ç¼–ç¨‹å·¥å…·ã€‚è™½ç„¶ Khronos å°ç»„åœ¨å¼€å‘ OpenCL æ—¶è€ƒè™‘åˆ°äº†ç¼–ç¨‹çš„å¯ç§»æ¤æ€§ï¼Œä½†æ€§èƒ½ä¸ä¸€å®šæ˜¯å¯ç§»æ¤çš„ã€‚OpenCL éœ€è¦å½±å“æ€§èƒ½çš„åˆå§‹åŒ–ï¼Œè€Œå…¶ä»–è¯­è¨€ï¼ˆå¦‚ CUDAï¼‰ä¸­ä¸å­˜åœ¨è¿™äº›åˆå§‹åŒ–ã€‚äº†è§£è¿™äº›å«ä¹‰ä½¿æˆ‘ä»¬èƒ½å¤Ÿåœ¨å„ç§å¹³å°ä¸Šæä¾›å…·æœ‰è‰¯å¥½æ€§èƒ½çš„å•ä¸ªåº“ã€‚æˆ‘ä»¬é€‰æ‹©ä¸‰è§’æ±‚è§£å™¨ ï¼ˆTRSMï¼‰ å’ŒçŸ©é˜µä¹˜æ³• ï¼ˆGEMMï¼‰ ä½œä¸ºåœ¨ OpenCL ä¸­å®ç°çš„ä»£è¡¨æ€§ 3 çº§ BLAS ä¾‹ç¨‹ã€‚æˆ‘ä»¬åˆ†æ TRSM ä»¥è·å¾— OpenCL è¿è¡Œæ—¶ç³»ç»Ÿçš„æ—¶é—´åˆ†å¸ƒã€‚ç„¶åï¼Œæˆ‘ä»¬ä¸º NVIDIA Tesla C2050 å’Œ ATI Radeon 5870ï¼ˆä¸¤å®¶å…¬å¸æä¾›çš„æœ€æ–° GPUï¼‰æä¾›ç»è¿‡è°ƒæ•´çš„ GEMM å†…æ ¸ã€‚æˆ‘ä»¬æ¢è®¨äº†ä½¿ç”¨çº¹ç†ç¼“å­˜çš„å¥½å¤„ã€å°†æ•°æ®å¤åˆ¶åˆ°å›¾åƒä¸­çš„æ€§èƒ½å½±å“ã€OpenCL å’Œ CUDA ç¼–è¯‘å™¨ä¼˜åŒ–ä¸­çš„å·®å¼‚ä»¥åŠå½±å“æ€§èƒ½çš„å…¶ä»–é—®é¢˜ã€‚å®éªŒç»“æœè¡¨æ˜ï¼Œåœ¨ OpenCL çš„ä¸¤ä¸ª GPU ä¸Šï¼ŒGEMM éƒ½å¯ä»¥è·å¾—è¿‘ 50% çš„å³°å€¼æ€§èƒ½ã€‚æˆ‘ä»¬è¿˜è¡¨æ˜ï¼Œè¿™äº›å†…æ ¸çš„æ€§èƒ½å¹¶ä¸æ˜¯é«˜åº¦å¯ç§»æ¤çš„ã€‚æœ€åï¼Œæˆ‘ä»¬å»ºè®®ä½¿ç”¨è‡ªåŠ¨è°ƒæ•´ï¼Œä»¥ä½¿ç”¨æœç´¢å·¥å…·æ›´å¥½åœ°æ¢ç´¢è¿™äº›å†…æ ¸çš„å‚æ•°ç©ºé—´ã€‚ Kokkos: Enabling manycore performance portability through polymorphic memory access patterns Kokkosï¼šé€šè¿‡å¤šæ€å†…å­˜è®¿é—®æ¨¡å¼å®ç°ä¼—æ ¸æ€§èƒ½å¯ç§»æ¤æ€§ Achieving Portability and Performance through OpenACC é€šè¿‡ OpenACC å®ç°å¯ç§»æ¤æ€§å’Œæ€§èƒ½ https://ieeexplore.ieee.org/document/7081674 OpenACC is a directive-based programming model designed to allow easy access to emerging advanced architecture systems for existing production codes based on Fortran, C and C++. It also provides an approach to coding contemporary technologies without the need to learn complex vendor-specific languages, or understand the hardware at the deepest level. Portability and performance are the key features of this programming model, which are essential to productivity in real scientific applications. OpenACC support is provided by a number of vendors and is defined by an open standard. However the standard is relatively new, and the implementations are relatively immature. This paper experimentally evaluates the currently available compilers by assessing two approaches to the OpenACC programming model: the \"parallel\" and \"kernels\" constructs. The implementation of both of these construct is compared, for each vendor, showing performance differences of up to 84%. Additionally, we observe performance differences of up to 13% between the best vendor implementations. OpenACC features which appear to cause performance issues in certain compilers are identified and linked to differing default vector length clauses between vendors. These studies are carried out over a range of hardware including GPU, APU, Xeon and Xeon Phi based architectures. Finally, OpenACC performance, and productivity, are compared against the alternative native programming approaches on each targeted platform, including CUDA, OpenCL, OpenMP 4.0 and Intel Offload, in addition to MPI and OpenMP. OpenACC æ˜¯ä¸€ç§åŸºäºæŒ‡ä»¤çš„ç¼–ç¨‹æ¨¡å‹ï¼Œæ—¨åœ¨å…è®¸è½»æ¾è®¿é—®åŸºäº Fortranã€C å’Œ C++ çš„ç°æœ‰äº§å“ä»£ç çš„æ–°å…´é«˜çº§æ¶æ„ç³»ç»Ÿã€‚å®ƒè¿˜æä¾›äº†ä¸€ç§å¯¹ç°ä»£æŠ€æœ¯è¿›è¡Œç¼–ç çš„æ–¹æ³•ï¼Œè€Œæ— éœ€å­¦ä¹ å¤æ‚çš„ä¾›åº”å•†ç‰¹å®šè¯­è¨€ï¼Œä¹Ÿæ— éœ€æ›´æ·±å…¥åœ°äº†è§£ç¡¬ä»¶ã€‚å¯ç§»æ¤æ€§å’Œæ€§èƒ½æ˜¯è¯¥ç¼–ç¨‹æ¨¡å‹çš„å…³é”®ç‰¹æ€§ï¼Œè¿™å¯¹äºå®é™…ç§‘å­¦åº”ç”¨ä¸­çš„ç”Ÿäº§åŠ›è‡³å…³é‡è¦ã€‚OpenACC æ”¯æŒç”±è®¸å¤šä¾›åº”å•†æä¾›ï¼Œå¹¶ç”±å¼€æ”¾æ ‡å‡†å®šä¹‰ã€‚ä½†æ˜¯ï¼Œè¯¥æ ‡å‡†ç›¸å¯¹è¾ƒæ–°ï¼Œå®ç°ä¹Ÿç›¸å¯¹ä¸æˆç†Ÿã€‚æœ¬æ–‡é€šè¿‡è¯„ä¼° OpenACC ç¼–ç¨‹æ¨¡å‹çš„ä¸¤ç§æ–¹æ³•ï¼ˆâ€œå¹¶è¡Œâ€å’Œâ€œå†…æ ¸â€ç»“æ„ï¼‰æ¥å®éªŒè¯„ä¼°å½“å‰å¯ç”¨çš„ç¼–è¯‘å™¨ã€‚å¯¹æ¯ä¸ªä¾›åº”å•†çš„è¿™ä¸¤ç§ç»“æ„çš„å®æ–½è¿›è¡Œäº†æ¯”è¾ƒï¼Œæ˜¾ç¤ºæ€§èƒ½å·®å¼‚é«˜è¾¾ 84%ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è§‚å¯Ÿåˆ°æœ€ä½³ä¾›åº”å•†å®æ–½ä¹‹é—´çš„æ€§èƒ½å·®å¼‚é«˜è¾¾ 13%ã€‚è¯†åˆ«å‡ºåœ¨æŸäº›ç¼–è¯‘å™¨ä¸­ä¼¼ä¹ä¼šå¯¼è‡´æ€§èƒ½é—®é¢˜çš„ OpenACC åŠŸèƒ½ï¼Œå¹¶å°†å…¶é“¾æ¥åˆ°ä¾›åº”å•†ä¹‹é—´ä¸åŒçš„é»˜è®¤å‘é‡é•¿åº¦å­å¥ã€‚è¿™äº›ç ”ç©¶æ˜¯åœ¨ä¸€ç³»åˆ—ç¡¬ä»¶ä¸Šè¿›è¡Œçš„ï¼ŒåŒ…æ‹¬åŸºäº GPUã€APUã€Xeon å’Œ Xeon Phi çš„æ¶æ„ã€‚æœ€åï¼Œå°† OpenACC çš„æ€§èƒ½å’Œç”Ÿäº§åŠ›ä¸æ¯ä¸ªç›®æ ‡å¹³å°ä¸Šçš„æ›¿ä»£åŸç”Ÿç¼–ç¨‹æ–¹æ³•è¿›è¡Œäº†æ¯”è¾ƒï¼ŒåŒ…æ‹¬ CUDAã€OpenCLã€OpenMP 4.0 å’Œ Intel Offloadï¼Œä»¥åŠ MPI å’Œ OpenMPã€‚ GPU(CUDA) to CPU GPUOcelot GPUOcelot GPUOcelot: A dynamic compilation framework for PTX GPUOcelotï¼šPTX çš„åŠ¨æ€ç¼–è¯‘æ¡†æ¶ Ocelot is a just-in-time compiler, which retargets PTX assembler (used internally by CUDA) for non-NVIDIA hardware. Ocelotæ˜¯ä¸€ä¸ªå³æ—¶ç¼–è¯‘å™¨ï¼Œå®ƒé’ˆå¯¹é NVIDIA ç¡¬ä»¶é‡æ–°å®šä½ PTX æ±‡ç¼–å™¨ï¼ˆç”± CUDA å†…éƒ¨ä½¿ç”¨ï¼‰ã€‚ HIPIFY HIPIFY: Convert CUDA to Portable C++ Code hipify-clang and hipify-perl are tools that automatically translate NVIDIA CUDA source code into portable HIP C++. hipify-clangå’Œhipify-perlæ˜¯è‡ªåŠ¨å°† NVIDIA CUDA æºä»£ç è½¬æ¢ä¸ºå¯ç§»æ¤ HIP C++ çš„å·¥å…·ã€‚ HIP HIP: C++ Heterogeneous-Compute Interface for Portability HIP is a C++ Runtime API and Kernel Language that allows developers to create portable applications for AMD and NVIDIA GPUs from single source code. HIP æ˜¯ä¸€ç§ C++ è¿è¡Œæ—¶ API å’Œå†…æ ¸è¯­è¨€ï¼Œå…è®¸å¼€å‘äººå‘˜ä»å•ä¸€æºä»£ç åˆ›å»ºé€‚ç”¨äº AMD å’Œ NVIDIA GPU çš„å¯ç§»æ¤åº”ç”¨ç¨‹åºã€‚ Key features include: ä¸»è¦ç‰¹ç‚¹åŒ…æ‹¬ï¼š HIP is very thin and has little or no performance impact over coding directly in CUDA mode. HIP éå¸¸è–„ï¼Œä¸ç›´æ¥åœ¨ CUDA æ¨¡å¼ä¸‹ç¼–ç ç›¸æ¯”ï¼Œå‡ ä¹æ²¡æœ‰æ€§èƒ½å½±å“ã€‚ HIP allows coding in a single-source C++ programming language including features such as templates, C++11 lambdas, classes, namespaces, and more. HIP å…è®¸ä½¿ç”¨å•æº C++ ç¼–ç¨‹è¯­è¨€è¿›è¡Œç¼–ç ï¼ŒåŒ…æ‹¬æ¨¡æ¿ã€C++11 lambdaã€ç±»ã€å‘½åç©ºé—´ç­‰åŠŸèƒ½ã€‚ HIP allows developers to use the \"best\" development environment and tools on each target platform. HIPå…è®¸å¼€å‘äººå‘˜åœ¨æ¯ä¸ªç›®æ ‡å¹³å°ä¸Šä½¿ç”¨â€œæœ€å¥½çš„â€å¼€å‘ç¯å¢ƒå’Œå·¥å…·ã€‚ The HIPIFY tools automatically convert source from CUDA to HIP. HIPIFYå·¥å…·è‡ªåŠ¨å°†æºä» CUDA è½¬æ¢ä¸º HIPã€‚ Developers can specialize for the platform (CUDA or AMD) to tune for performance or handle tricky cases. å¼€å‘äººå‘˜å¯ä»¥ä¸“é—¨é’ˆå¯¹å¹³å°ï¼ˆCUDA æˆ– AMDï¼‰æ¥è°ƒæ•´æ€§èƒ½æˆ–å¤„ç†æ£˜æ‰‹çš„æƒ…å†µã€‚ Domain-Specific Multi-Level IR Rewriting for GPU: The Open Earth Compiler for GPU-accelerated Climate Simulation é¢†åŸŸç‰¹å®šå¤šçº§ IR é‡å†™ç”¨äº GPUï¼šGPU åŠ é€Ÿæ°”å€™æ¨¡æ‹Ÿçš„å¼€æ”¾åœ°çƒç¼–è¯‘å™¨ https://dl.acm.org/doi/10.1145/3469030 2021.9.03 Most compilers have a single core intermediate representation (IR) (e.g., LLVM) sometimes complemented with vaguely defined IR-like data structures. This IR is commonly low-level and close to machine instructions. As a result, optimizations relying on domain-specific information are either not possible or require complex analysis to recover the missing information. In contrast, multi-level rewriting instantiates a hierarchy of dialects (IRs), lowers programs level-by-level, and performs code transformations at the most suitable level. We demonstrate the effectiveness of this approach for the weather and climate domain. In particular, we develop a prototype compiler and design stencil- and GPU-specific dialects based on a set of newly introduced design principles. We find that two domain-specific optimizations (500 lines of code) realized on top of LLVMâ€™s extensible MLIR compiler infrastructure suffice to outperform state-of-the-art solutions. In essence, multi-level rewriting promises to herald the age of specialized compilers composed from domain- and target-specific dialects implemented on top of a shared infrastructure. å¤§å¤šæ•°ç¼–è¯‘å™¨éƒ½æœ‰ä¸€ä¸ªå•ä¸€æ ¸å¿ƒçš„ä¸­é—´è¡¨ç¤ºï¼ˆIRï¼‰ï¼ˆä¾‹å¦‚ï¼ŒLLVMï¼‰ï¼Œæœ‰æ—¶è¾…ä»¥æ¨¡ç³Šå®šä¹‰çš„ç±»ä¼¼ IR çš„æ•°æ®ç»“æ„ã€‚è¿™ä¸ª IR é€šå¸¸æ˜¯ä½çº§ä¸”æ¥è¿‘æœºå™¨æŒ‡ä»¤çš„ã€‚å› æ­¤ï¼Œä¾èµ–äºç‰¹å®šé¢†åŸŸä¿¡æ¯çš„ä¼˜åŒ–è¦ä¹ˆä¸å¯èƒ½å®ç°ï¼Œè¦ä¹ˆéœ€è¦å¤æ‚çš„åˆ†ææ¥æ¢å¤ç¼ºå¤±çš„ä¿¡æ¯ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œå¤šçº§é‡å†™å®ä¾‹åŒ–äº†ä¸€ç»„æ–¹è¨€ï¼ˆIRï¼‰çš„å±‚æ¬¡ç»“æ„ï¼Œé€çº§é™ä½ç¨‹åºçº§åˆ«ï¼Œå¹¶åœ¨æœ€åˆé€‚çš„çº§åˆ«æ‰§è¡Œä»£ç è½¬æ¢ã€‚æˆ‘ä»¬å±•ç¤ºäº†è¿™ç§æ–¹æ³•åœ¨å¤©æ°”å’Œæ°”å€™é¢†åŸŸä¸­çš„æœ‰æ•ˆæ€§ã€‚ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬å¼€å‘äº†ä¸€ä¸ªåŸå‹ç¼–è¯‘å™¨ï¼Œå¹¶åŸºäºä¸€ç»„æ–°å¼•å…¥çš„è®¾è®¡åŸåˆ™è®¾è®¡äº†æ¨¡æ¿å’Œ GPU ç‰¹å®šçš„æ–¹è¨€ã€‚æˆ‘ä»¬å‘ç°ï¼Œåœ¨ LLVM çš„å¯æ‰©å±• MLIR ç¼–è¯‘å™¨åŸºç¡€è®¾æ–½ä¹‹ä¸Šå®ç°çš„ä¸¤ä¸ªç‰¹å®šé¢†åŸŸä¼˜åŒ–ï¼ˆ500 è¡Œä»£ç ï¼‰è¶³ä»¥è¶…è¶Šæœ€å…ˆè¿›çš„è§£å†³æ–¹æ¡ˆã€‚æœ¬è´¨ä¸Šï¼Œå¤šçº§é‡å†™æœ‰æœ›é¢„ç¤ºç€ç”±é¢†åŸŸå’Œç›®æ ‡ç‰¹å®šæ–¹è¨€ç»„æˆçš„ä¸“ç”¨ç¼–è¯‘å™¨çš„æ—¶ä»£ï¼Œè¿™äº›æ–¹è¨€æ˜¯åœ¨å…±äº«åŸºç¡€è®¾æ–½ä¹‹ä¸Šå®ç°çš„ã€‚ "},"Learn/LearnAIMA/":{"url":"Learn/LearnAIMA/","title":"LearnAIMA","keywords":"","body":"ç¬¬ä¸€éƒ¨åˆ† äººå·¥æ™ºèƒ½åŸºç¡€ ç¬¬ 1 ç«  ç»ªè®º 1.1 ä»€ä¹ˆæ˜¯äººå·¥æ™ºèƒ½ 1.1.1 ç±»äººè¡Œä¸ºï¼šå›¾çµæµ‹è¯•æ–¹æ³• 1.1.2 ç±»äººæ€è€ƒï¼šè®¤çŸ¥å»ºæ¨¡æ–¹æ³• 1.1.3 ç†æ€§æ€è€ƒï¼šâ€œæ€ç»´æ³•åˆ™â€æ–¹æ³• 1.1.4 ç†æ€§è¡Œä¸ºï¼šç†æ€§æ™ºèƒ½ä½“æ–¹æ³• 1.1.5 ç›Šæœº 1.2 äººå·¥æ™ºèƒ½çš„åŸºç¡€ 1.2.1 å“²å­¦ 1.2.2 æ•°å­¦ 1.2.3 ç»æµå­¦ 1.2.4 ç¥ç»ç§‘å­¦ 1.2.5 å¿ƒç†å­¦ 1.2.6 è®¡ç®—æœºå·¥ç¨‹ 1.2.7 æ§åˆ¶ç†è®ºä¸æ§åˆ¶è®º 1.2.8 è¯­è¨€å­¦ 1.3 äººå·¥æ™ºèƒ½çš„å†å² 1.3.1 äººå·¥æ™ºèƒ½çš„è¯ç”Ÿï¼ˆ1943â€”1956ï¼‰ 1.3.2 æ—©æœŸçƒ­æƒ…é«˜æ¶¨ï¼ŒæœŸæœ›æ— é™ï¼ˆ1952â€”1969ï¼‰ 1.3.3 ä¸€äº›ç°å®ï¼ˆ1966â€”1973ï¼‰ 1.3.4 ä¸“å®¶ç³»ç»Ÿï¼ˆ1969â€”1986ï¼‰ 1.3.5 ç¥ç»ç½‘ç»œçš„å›å½’ï¼ˆ1986â€”ç°åœ¨ï¼‰ 1.3.6 æ¦‚ç‡æ¨ç†å’Œæœºå™¨å­¦ä¹ ï¼ˆ1987â€”ç°åœ¨ï¼‰ 1.3.7 å¤§æ•°æ®ï¼ˆ2001â€”ç°åœ¨ï¼‰ 1.3.8 æ·±åº¦å­¦ä¹ ï¼ˆ2011â€”ç°åœ¨ï¼‰ 1.4 ç›®å‰çš„å…ˆè¿›æŠ€æœ¯ 1.5 äººå·¥æ™ºèƒ½çš„é£é™©å’Œæ”¶ç›Š ç¬¬ 2 ç«  æ™ºèƒ½ä½“ 2.1 æ™ºèƒ½ä½“å’Œç¯å¢ƒ 2.2 è‰¯å¥½è¡Œä¸ºï¼šç†æ€§çš„æ¦‚å¿µ 2.2.1 æ€§èƒ½åº¦é‡ 2.2.2 ç†æ€§ 2.2.3 å…¨çŸ¥ã€å­¦ä¹ å’Œè‡ªä¸» 2.3 ç¯å¢ƒçš„æœ¬è´¨ 2.3.1 æŒ‡å®šä»»åŠ¡ç¯å¢ƒ 2.3.2 ä»»åŠ¡ç¯å¢ƒçš„å±æ€§ 2.4 æ™ºèƒ½ä½“çš„ç»“æ„ 2.4.1 æ™ºèƒ½ä½“ç¨‹åº 2.4.2 ç®€å•åå°„å‹æ™ºèƒ½ä½“ 2.4.3 åŸºäºæ¨¡å‹çš„åå°„å‹æ™ºèƒ½ä½“ 2.4.4 åŸºäºç›®æ ‡çš„æ™ºèƒ½ä½“ 2.4.5 åŸºäºæ•ˆç”¨çš„æ™ºèƒ½ä½“ 2.4.6 å­¦ä¹ å‹æ™ºèƒ½ä½“ 2.4.7 æ™ºèƒ½ä½“ç¨‹åºçš„ç»„ä»¶å¦‚ä½•å·¥ä½œ ç¬¬äºŒéƒ¨åˆ† é—®é¢˜æ±‚è§£ ç¬¬ 3 ç«  é€šè¿‡æœç´¢è¿›è¡Œé—®é¢˜æ±‚è§£ 3.1 é—®é¢˜æ±‚è§£æ™ºèƒ½ä½“ 3.1.1 æœç´¢é—®é¢˜å’Œè§£ 3.1.2 é—®é¢˜å½¢å¼åŒ– 3.2 é—®é¢˜ç¤ºä¾‹ 3.2.1 æ ‡å‡†åŒ–é—®é¢˜ 3.2.2 çœŸå®ä¸–ç•Œé—®é¢˜ 3.3 æœç´¢ç®—æ³• 3.3.1 æœ€ä½³ä¼˜å…ˆæœç´¢ 3.3.2 æœç´¢æ•°æ®ç»“æ„ 3.3.3 å†—ä½™è·¯å¾„ 3.3.4 é—®é¢˜æ±‚è§£æ€§èƒ½è¯„ä¼° 3.4 æ— ä¿¡æ¯æœç´¢ç­–ç•¥ 3.4.1 å¹¿åº¦ä¼˜å…ˆæœç´¢ 3.4.2 Dijkstra ç®—æ³•æˆ–ä¸€è‡´ä»£ä»·æœç´¢ 3.4.3 æ·±åº¦ä¼˜å…ˆæœç´¢ä¸å†…å­˜é—®é¢˜ 3.4.4 æ·±åº¦å—é™å’Œè¿­ä»£åŠ æ·±æœç´¢ 3.4.5 åŒå‘æœç´¢ 3.4.6 æ— ä¿¡æ¯æœç´¢ç®—æ³•å¯¹æ¯” 3.5 æœ‰ä¿¡æ¯ï¼ˆå¯å‘å¼ï¼‰æœç´¢ç­–ç•¥ 3.5.1 è´ªå¿ƒæœ€ä½³ä¼˜å…ˆæœç´¢ 3.5.2 A*æœç´¢ 3.5.3 æœç´¢ç­‰å€¼çº¿ 3.5.4 æ»¡æ„æœç´¢ï¼šä¸å¯å®¹è®¸çš„å¯å‘å¼å‡½æ•°ä¸åŠ æƒ A*æœç´¢ 3.5.5 å†…å­˜å—é™æœç´¢ 3.5.6 åŒå‘å¯å‘å¼æœç´¢ 3.6 å¯å‘å¼å‡½æ•° 3.6.1 å¯å‘å¼å‡½æ•°çš„å‡†ç¡®æ€§å¯¹æ€§èƒ½çš„å½±å“ 3.6.2 ä»æ¾å¼›é—®é¢˜å‡ºå‘ç”Ÿæˆå¯å‘å¼å‡½æ•° 3.6.3 ä»å­é—®é¢˜å‡ºå‘ç”Ÿæˆå¯å‘å¼å‡½æ•°ï¼šæ¨¡å¼æ•°æ®åº“ 3.6.4 ä½¿ç”¨åœ°æ ‡ç”Ÿæˆå¯å‘å¼å‡½æ•° 3.6.5 å­¦ä¹ ä»¥æ›´å¥½åœ°æœç´¢ 3.6.6 ä»ç»éªŒä¸­å­¦ä¹ å¯å‘å¼å‡½æ•° ç¬¬ 4 ç«  å¤æ‚ç¯å¢ƒä¸­çš„æœç´¢ 4.1 å±€éƒ¨æœç´¢å’Œæœ€ä¼˜åŒ–é—®é¢˜ 4.1.1 çˆ¬å±±æœç´¢ 4.1.2 æ¨¡æ‹Ÿé€€ç« 4.1.3 å±€éƒ¨æŸæœç´¢ 4.1.4 è¿›åŒ–ç®—æ³• 4.2 è¿ç»­ç©ºé—´ä¸­çš„å±€éƒ¨æœç´¢ 4.3 ä½¿ç”¨éç¡®å®šæ€§åŠ¨ä½œçš„æœç´¢ 4.3.1 ä¸ç¨³å®šçš„çœŸç©ºå¸å°˜å™¨ä¸–ç•Œ 4.3.2 ä¸æˆ–æœç´¢æ ‘ 4.3.3 åå¤å°è¯• 4.4 éƒ¨åˆ†å¯è§‚æµ‹ç¯å¢ƒä¸­çš„æœç´¢ 4.4.1 æ— è§‚æµ‹ä¿¡æ¯çš„æœç´¢ 4.4.2 éƒ¨åˆ†å¯è§‚æµ‹ç¯å¢ƒä¸­çš„æœç´¢ 4.4.3 æ±‚è§£éƒ¨åˆ†å¯è§‚æµ‹é—®é¢˜ 4.4.4 éƒ¨åˆ†å¯è§‚æµ‹ç¯å¢ƒä¸­çš„æ™ºèƒ½ä½“ 4.5 åœ¨çº¿æœç´¢æ™ºèƒ½ä½“å’ŒæœªçŸ¥ç¯å¢ƒ 4.5.1 åœ¨çº¿æœç´¢é—®é¢˜ 4.5.2 åœ¨çº¿æœç´¢æ™ºèƒ½ä½“ 4.5.3 åœ¨çº¿å±€éƒ¨æœç´¢ 4.5.4 åœ¨çº¿æœç´¢ä¸­çš„å­¦ä¹  ç¬¬ 5 ç«  å¯¹æŠ—æœç´¢å’Œåšå¼ˆ 5.1 åšå¼ˆè®º 5.2 åšå¼ˆä¸­çš„ä¼˜åŒ–å†³ç­– 5.2.1 æå°åŒ–æå¤§æœç´¢ç®—æ³• 5.2.2 å¤šäººåšå¼ˆä¸­çš„æœ€ä¼˜å†³ç­– 5.2.3 å‰ªæ 5.2.4 ç§»åŠ¨é¡ºåº 5.3 å¯å‘å¼æ ‘æœç´¢ 5.3.1 è¯„ä»·å‡½æ•° 5.3.2 æˆªæ–­æœç´¢ 5.3.3 å‰å‘å‰ªæ 5.3.4 æœç´¢å’ŒæŸ¥è¡¨ 5.4 è’™ç‰¹å¡ç½—æ ‘æœç´¢ 5.5 éšæœºåšå¼ˆ æœºä¼šåšå¼ˆçš„è¯„ä»·å‡½æ•° 5.6 éƒ¨åˆ†å¯è§‚æµ‹åšå¼ˆ 5.6.1 å››å›½å†›æ£‹ï¼šéƒ¨åˆ†å¯è§‚æµ‹çš„å›½é™…è±¡æ£‹ 5.6.2 çº¸ç‰Œæ¸¸æˆ 5.7 åšå¼ˆæœç´¢ç®—æ³•çš„å±€é™æ€§ ç¬¬ 6 ç«  çº¦æŸæ»¡è¶³é—®é¢˜ 6.1 å®šä¹‰çº¦æŸæ»¡è¶³é—®é¢˜ 6.1.1 é—®é¢˜ç¤ºä¾‹ï¼šåœ°å›¾ç€è‰² 6.1.2 é—®é¢˜ç¤ºä¾‹ï¼šè½¦é—´ä½œä¸šè°ƒåº¦ 6.1.3 CSP å½¢å¼ä½“ç³»çš„å˜ä½“ 6.2 çº¦æŸä¼ æ’­ï¼šCSP ä¸­çš„æ¨æ–­ 6.2.1 èŠ‚ç‚¹ä¸€è‡´æ€§ 6.2.2 å¼§ä¸€è‡´æ€§ 6.2.3 è·¯å¾„ä¸€è‡´æ€§ 6.2.4 k ä¸€è‡´æ€§ 6.2.5 å…¨å±€çº¦æŸ 6.2.6 æ•°ç‹¬ 6.3 CSP çš„å›æº¯æœç´¢ 6.3.1 å˜é‡æ’åºå’Œå€¼æ’åº 6.3.2 äº¤æ›¿è¿›è¡Œæœç´¢å’Œæ¨ç† 6.3.3 æ™ºèƒ½å›æº¯ï¼šå‘åçœ‹ 6.3.4 çº¦æŸå­¦ä¹  6.4 CSP çš„å±€éƒ¨æœç´¢ 6.5 é—®é¢˜çš„ç»“æ„ 6.5.1 å‰²é›†è°ƒæ•´ 6.5.2 æ ‘åˆ†è§£ 6.5.3 å€¼å¯¹ç§° ç¬¬ä¸‰éƒ¨åˆ† çŸ¥è¯†ã€æ¨ç†å’Œè§„åˆ’ ç¬¬ 7 ç«  é€»è¾‘æ™ºèƒ½ä½“ 7.1 åŸºäºçŸ¥è¯†çš„æ™ºèƒ½ä½“ 7.2 wumpus ä¸–ç•Œ 7.3 é€»è¾‘ 7.4 å‘½é¢˜é€»è¾‘ï¼šä¸€ç§éå¸¸ç®€å•çš„é€»è¾‘ 7.4.1 è¯­æ³• 7.4.2 è¯­ä¹‰ 7.4.3 ä¸€ä¸ªç®€å•çš„çŸ¥è¯†åº“ 7.4.4 ä¸€ä¸ªç®€å•çš„æ¨æ–­è¿‡ç¨‹ 7.5 å‘½é¢˜å®šç†è¯æ˜ 7.5.1 æ¨æ–­ä¸è¯æ˜ 7.5.2 é€šè¿‡å½’ç»“è¯æ˜ 7.5.3 éœæ©å­å¥ä¸ç¡®å®šå­å¥ 7.5.4 å‰å‘é“¾æ¥ä¸åå‘é“¾æ¥ 7.6 é«˜æ•ˆå‘½é¢˜æ¨¡å‹æ£€éªŒ 7.6.1 å®Œå¤‡çš„å›æº¯ç®—æ³• 7.6.2 å±€éƒ¨æœç´¢ç®—æ³• 7.6.3 éšæœº SAT é—®é¢˜æ¦‚è§ˆ 7.7 åŸºäºå‘½é¢˜é€»è¾‘çš„æ™ºèƒ½ä½“ 7.7.1 ä¸–ç•Œçš„å½“å‰çŠ¶æ€ 7.7.2 æ··åˆæ™ºèƒ½ä½“ 7.7.3 é€»è¾‘çŠ¶æ€ä¼°è®¡ 7.7.4 ç”¨å‘½é¢˜æ¨æ–­è¿›è¡Œè§„åˆ’ ç¬¬ 8 ç«  ä¸€é˜¶é€»è¾‘ 8.1 å›é¡¾è¡¨ç¤º 8.1.1 æ€æƒ³çš„è¯­è¨€ 8.1.2 ç»“åˆå½¢å¼è¯­è¨€å’Œè‡ªç„¶è¯­è¨€çš„ä¼˜ç‚¹ 8.2 ä¸€é˜¶é€»è¾‘çš„è¯­æ³•å’Œè¯­ä¹‰ 8.2.1 ä¸€é˜¶é€»è¾‘æ¨¡å‹ 8.2.2 ç¬¦å·ä¸è§£é‡Š 8.2.3 é¡¹ 8.2.4 åŸå­è¯­å¥ 8.2.5 å¤åˆè¯­å¥ 8.2.6 é‡è¯ 8.2.7 ç­‰è¯ 8.2.8 æ•°æ®åº“è¯­ä¹‰ 8.3 ä½¿ç”¨ä¸€é˜¶é€»è¾‘ 8.3.1 ä¸€é˜¶é€»è¾‘çš„æ–­è¨€ä¸æŸ¥è¯¢ 8.3.2 äº²å±å…³ç³»è®ºåŸŸ 8.3.3 æ•°ã€é›†åˆä¸åˆ—è¡¨ 8.3.4 wumpus ä¸–ç•Œ 8.4 ä¸€é˜¶é€»è¾‘ä¸­çš„çŸ¥è¯†å·¥ç¨‹ 8.4.1 çŸ¥è¯†å·¥ç¨‹çš„è¿‡ç¨‹ 8.4.2 ç”µå­ç”µè·¯è®ºåŸŸ ç¬¬ 9 ç«  ä¸€é˜¶é€»è¾‘ä¸­çš„æ¨æ–­ 9.1 å‘½é¢˜æ¨æ–­ä¸ä¸€é˜¶æ¨æ–­ çº¦ç®€ä¸ºå‘½é¢˜æ¨æ–­ 9.2 åˆä¸€ä¸ä¸€é˜¶æ¨æ–­ 9.2.1 åˆä¸€ 9.2.2 å­˜å‚¨ä¸æ£€ç´¢ 9.3 å‰å‘é“¾æ¥ 9.3.1 ä¸€é˜¶ç¡®å®šå­å¥ 9.3.2 ç®€å•çš„å‰å‘é“¾æ¥ç®—æ³• 9.3.3 é«˜æ•ˆå‰å‘é“¾æ¥ 9.4 åå‘é“¾æ¥ 9.4.1 åå‘é“¾æ¥ç®—æ³• 9.4.2 é€»è¾‘ç¼–ç¨‹ 9.4.3 å†—ä½™æ¨æ–­å’Œæ— é™å¾ªç¯ 9.4.4 Prolog çš„æ•°æ®åº“è¯­ä¹‰ 9.4.5 çº¦æŸé€»è¾‘ç¼–ç¨‹ 9.5 å½’ç»“ 9.5.1 ä¸€é˜¶é€»è¾‘çš„åˆå–èŒƒå¼ 9.5.2 å½’ç»“æ¨æ–­è§„åˆ™ 9.5.3 è¯æ˜èŒƒä¾‹ 9.5.4 å½’ç»“çš„å®Œå¤‡æ€§ 9.5.5 ç­‰è¯ 9.5.6 å½’ç»“ç­–ç•¥ ç¬¬ 10 ç«  çŸ¥è¯†è¡¨ç¤º 10.1 æœ¬ä½“è®ºå·¥ç¨‹ 10.2 ç±»åˆ«ä¸å¯¹è±¡ 10.2.1 ç‰©ç†ç»„æˆ 10.2.2 é‡åº¦ 10.2.3 å¯¹è±¡ï¼šäº‹ç‰©å’Œç‰©è´¨ 10.3 äº‹ä»¶ 10.3.1 æ—¶é—´ 10.3.2 æµå’Œå¯¹è±¡ 10.4 ç²¾ç¥å¯¹è±¡å’Œæ¨¡æ€é€»è¾‘ å…¶ä»–æ¨¡æ€é€»è¾‘ 10.5 ç±»åˆ«çš„æ¨ç†ç³»ç»Ÿ 10.5.1 è¯­ä¹‰ç½‘ç»œ 10.5.2 æè¿°é€»è¾‘ 10.6 ç”¨ç¼ºçœä¿¡æ¯æ¨ç† 10.6.1 é™å®šä¸ç¼ºçœé€»è¾‘ 10.6.2 çœŸå€¼ç»´æŠ¤ç³»ç»Ÿ ç¬¬ 11 ç«  è‡ªåŠ¨è§„åˆ’ 11.1 ç»å…¸è§„åˆ’çš„å®šä¹‰ 11.1.1 èŒƒä¾‹é¢†åŸŸï¼šèˆªç©ºè´§ç‰©è¿è¾“ 11.1.2 èŒƒä¾‹é¢†åŸŸï¼šå¤‡ç”¨è½®èƒé—®é¢˜ 11.1.3 èŒƒä¾‹é¢†åŸŸï¼šç§¯æœ¨ä¸–ç•Œ 11.2 ç»å…¸è§„åˆ’çš„ç®—æ³• 11.2.1 è§„åˆ’çš„å‰å‘çŠ¶æ€ç©ºé—´æœç´¢ 11.2.2 è§„åˆ’çš„åå‘çŠ¶æ€ç©ºé—´æœç´¢ 11.2.3 ä½¿ç”¨å¸ƒå°”å¯æ»¡è¶³æ€§è§„åˆ’ 11.2.4 å…¶ä»–ç»å…¸è§„åˆ’æ–¹æ³• 11.3 è§„åˆ’çš„å¯å‘å¼æ–¹æ³• 11.3.1 é¢†åŸŸæ— å…³å‰ªæ 11.3.2 è§„åˆ’ä¸­çš„çŠ¶æ€æŠ½è±¡ 11.4 åˆ†å±‚è§„åˆ’ 11.4.1 é«˜å±‚åŠ¨ä½œ 11.4.2 æœç´¢åŸºå…ƒè§£ 11.4.3 æœç´¢æŠ½è±¡è§£ 11.5 éç¡®å®šæ€§åŸŸçš„è§„åˆ’å’Œè¡ŒåŠ¨ 11.5.1 æ— ä¼ æ„Ÿå™¨è§„åˆ’ 11.5.2 åº”å˜è§„åˆ’ 11.5.3 åœ¨çº¿è§„åˆ’ 11.6 æ—¶é—´ã€è°ƒåº¦å’Œèµ„æº 11.6.1 æ—¶é—´çº¦æŸå’Œèµ„æºçº¦æŸçš„è¡¨ç¤º 11.6.2 è§£å†³è°ƒåº¦é—®é¢˜ 11.7 è§„åˆ’æ–¹æ³•åˆ†æ ç¬¬å››éƒ¨åˆ† ä¸ç¡®å®šçŸ¥è¯†å’Œä¸ç¡®å®šæ¨ç† ç¬¬ 12 ç«  ä¸ç¡®å®šæ€§çš„é‡åŒ– 12.1 ä¸ç¡®å®šæ€§ä¸‹çš„åŠ¨ä½œ 12.1.1 ä¸ç¡®å®šæ€§æ¦‚è¿° 12.1.2 ä¸ç¡®å®šæ€§ä¸ç†æ€§å†³ç­– 12.2 åŸºæœ¬æ¦‚ç‡è®°å· 12.2.1 æ¦‚ç‡æ˜¯å…³äºä»€ä¹ˆçš„ 12.2.2 æ¦‚ç‡æ–­è¨€ä¸­çš„å‘½é¢˜è¯­è¨€ 12.2.3 æ¦‚ç‡å…¬ç†åŠå…¶åˆç†æ€§ 12.3 ä½¿ç”¨å®Œå…¨è”åˆåˆ†å¸ƒè¿›è¡Œæ¨æ–­ 12.4 ç‹¬ç«‹æ€§ 12.5 è´å¶æ–¯æ³•åˆ™åŠå…¶åº”ç”¨ 12.5.1 åº”ç”¨è´å¶æ–¯æ³•åˆ™ï¼šç®€å•å®ä¾‹ 12.5.2 åº”ç”¨è´å¶æ–¯æ³•åˆ™ï¼šåˆå¹¶è¯æ® 12.6 æœ´ç´ è´å¶æ–¯æ¨¡å‹ ä½¿ç”¨æœ´ç´ è´å¶æ–¯è¿›è¡Œæ–‡æœ¬åˆ†ç±» 12.7 é‡æ¸¸ wumpus ä¸–ç•Œ ç¬¬ 13 ç«  æ¦‚ç‡æ¨ç† 13.1 ä¸ç¡®å®šåŸŸçš„çŸ¥è¯†è¡¨ç¤º 13.2 è´å¶æ–¯ç½‘ç»œçš„è¯­ä¹‰ 13.2.1 è´å¶æ–¯ç½‘ç»œä¸­çš„æ¡ä»¶ç‹¬ç«‹æ€§å…³ç³» 13.2.2 æ¡ä»¶åˆ†å¸ƒçš„é«˜æ•ˆè¡¨ç¤º 13.2.3 è¿ç»­å˜é‡çš„è´å¶æ–¯ç½‘ç»œ 13.2.4 æ¡ˆä¾‹ç ”ç©¶ï¼šæ±½è½¦ä¿é™© 13.3 è´å¶æ–¯ç½‘ç»œä¸­çš„ç²¾ç¡®æ¨æ–­ 13.3.1 é€šè¿‡æšä¸¾è¿›è¡Œæ¨æ–­ 13.3.2 å˜é‡æ¶ˆå…ƒç®—æ³• 13.3.3 ç²¾ç¡®æ¨æ–­çš„å¤æ‚æ€§ 13.3.4 èšç±»ç®—æ³• 13.4 è´å¶æ–¯ç½‘ç»œä¸­çš„è¿‘ä¼¼æ¨ç† 13.4.1 ç›´æ¥é‡‡æ ·æ–¹æ³• 13.4.2 é€šè¿‡é©¬å°”å¯å¤«é“¾æ¨¡æ‹Ÿè¿›è¡Œæ¨æ–­ 13.4.3 ç¼–è¯‘è¿‘ä¼¼æ¨æ–­ 13.5 å› æœç½‘ç»œ 13.5.1 è¡¨ç¤ºåŠ¨ä½œï¼šdo æ“ä½œ 13.5.2 åé—¨å‡†åˆ™ ç¬¬ 14 ç«  æ—¶é—´ä¸Šçš„æ¦‚ç‡æ¨ç† 14.1 æ—¶é—´ä¸ä¸ç¡®å®šæ€§ 14.1.1 çŠ¶æ€ä¸è§‚æµ‹ 14.1.2 è½¬ç§»æ¨¡å‹ä¸ä¼ æ„Ÿå™¨æ¨¡å‹ 14.2 æ—¶åºæ¨¡å‹ä¸­çš„æ¨æ–­ 14.2.1 æ»¤æ³¢ä¸é¢„æµ‹ 14.2.2 å¹³æ»‘ 14.2.3 å¯»æ‰¾æœ€å¯èƒ½åºåˆ— 14.3 éšé©¬å°”å¯å¤«æ¨¡å‹ 14.3.1 ç®€åŒ–çŸ©é˜µç®—æ³• 14.3.2 éšé©¬å°”å¯å¤«æ¨¡å‹ç¤ºä¾‹ï¼šå®šä½ 14.4 å¡å°”æ›¼æ»¤æ³¢å™¨ 14.4.1 æ›´æ–°é«˜æ–¯åˆ†å¸ƒ 14.4.2 ç®€å•çš„ä¸€ç»´ç¤ºä¾‹ 14.4.3 ä¸€èˆ¬æƒ…å†µ 14.4.4 å¡å°”æ›¼æ»¤æ³¢çš„é€‚ç”¨èŒƒå›´ 14.5 åŠ¨æ€è´å¶æ–¯ç½‘ç»œ 14.5.1 æ„å»ºåŠ¨æ€è´å¶æ–¯ç½‘ç»œ 14.5.2 åŠ¨æ€è´å¶æ–¯ç½‘ç»œä¸­çš„ç²¾ç¡®æ¨æ–­ 14.5.3 åŠ¨æ€è´å¶æ–¯ç½‘ç»œä¸­çš„è¿‘ä¼¼æ¨æ–­ ç¬¬ 15 ç«  æ¦‚ç‡ç¼–ç¨‹ 15.1 å…³ç³»æ¦‚ç‡æ¨¡å‹ 15.1.1 è¯­æ³•ä¸è¯­ä¹‰ 15.1.2 å®ä¾‹ï¼šè¯„å®šç©å®¶çš„æŠ€èƒ½ç­‰çº§ 15.1.3 å…³ç³»æ¦‚ç‡æ¨¡å‹ä¸­çš„æ¨æ–­ 15.2 å¼€å®‡å®™æ¦‚ç‡æ¨¡å‹ 15.2.1 è¯­ä¹‰ä¸è¯­æ³• 15.2.2 å¼€å®‡å®™æ¦‚ç‡æ¨¡å‹çš„æ¨æ–­ 15.2.3 ç¤ºä¾‹ 15.3 è¿½è¸ªå¤æ‚ä¸–ç•Œ 15.3.1 ç¤ºä¾‹ï¼šå¤šç›®æ ‡è·Ÿè¸ª 15.3.2 ç¤ºä¾‹ï¼šäº¤é€šç›‘æ§ 15.4 ä½œä¸ºæ¦‚ç‡æ¨¡å‹çš„ç¨‹åº 15.4.1 ç¤ºä¾‹ï¼šæ–‡æœ¬é˜…è¯» 15.4.2 è¯­æ³•ä¸è¯­ä¹‰ 15.4.3 æ¨æ–­ç»“æœ 15.4.4 ç»“åˆé©¬å°”å¯å¤«æ¨¡å‹æ”¹è¿›ç”Ÿæˆç¨‹åº 15.4.5 ç”Ÿæˆç¨‹åºçš„æ¨æ–­ ç¬¬ 16 ç«  åšç®€å•å†³ç­– 16.1 åœ¨ä¸ç¡®å®šæ€§ä¸‹ç»“åˆä¿¡å¿µä¸æ„¿æœ› 16.2 æ•ˆç”¨ç†è®ºåŸºç¡€ 16.2.1 ç†æ€§åå¥½çš„çº¦æŸ 16.2.2 ç†æ€§åå¥½å¯¼è‡´æ•ˆç”¨ 16.3 æ•ˆç”¨å‡½æ•° 16.3.1 æ•ˆç”¨è¯„ä¼°å’Œæ•ˆç”¨å°ºåº¦ 16.3.2 é‡‘é’±çš„æ•ˆç”¨ 16.3.3 æœŸæœ›æ•ˆç”¨ä¸å†³ç­–åå¤±æœ› 16.3.4 äººç±»åˆ¤æ–­ä¸éç†æ€§ 16.4 å¤šå±æ€§æ•ˆç”¨å‡½æ•° 16.4.1 å ä¼˜ 16.4.2 åå¥½ç»“æ„ä¸å¤šå±æ€§æ•ˆç”¨ 16.5 å†³ç­–ç½‘ç»œ 16.5.1 ä½¿ç”¨å†³ç­–ç½‘ç»œè¡¨ç¤ºå†³ç­–é—®é¢˜ 16.5.2 è¯„ä¼°å†³ç­–ç½‘ç»œ 16.6 ä¿¡æ¯ä»·å€¼ 16.6.1 ç®€å•ç¤ºä¾‹ 16.6.2 å®Œç¾ä¿¡æ¯çš„ä¸€èˆ¬å…¬å¼ 16.6.3 ä»·å€¼ä¿¡æ¯çš„æ€§è´¨ 16.6.4 ä¿¡æ¯æ”¶é›†æ™ºèƒ½ä½“çš„å®ç° 16.6.5 éçŸ­è§†ä¿¡æ¯æ”¶é›† 16.6.6 æ•æ„Ÿæ€§åˆ†æä¸å¥å£®å†³ç­– 16.7 æœªçŸ¥åå¥½ 16.7.1 ä¸ªäººåå¥½çš„ä¸ç¡®å®šæ€§ 16.7.2 é¡ºä»äººç±» ç¬¬ 17 ç«  åšå¤æ‚å†³ç­– 17.1 åºè´¯å†³ç­–é—®é¢˜ 17.1.1 æ—¶é—´ä¸Šçš„æ•ˆç”¨ 17.1.2 æœ€ä¼˜ç­–ç•¥ä¸çŠ¶æ€æ•ˆç”¨ 17.1.3 å¥–åŠ±è§„æ¨¡ 17.1.4 è¡¨ç¤º MDP 17.2 MDP çš„ç®—æ³• 17.2.1 ä»·å€¼è¿­ä»£ 17.2.2 ç­–ç•¥è¿­ä»£ 17.2.3 çº¿æ€§è§„åˆ’ 17.2.4 MDP çš„åœ¨çº¿ç®—æ³• 17.3 è€è™æœºé—®é¢˜ 17.3.1 è®¡ç®—åŸºå»·æ–¯æŒ‡æ•° 17.3.2 ä¼¯åŠªåˆ©è€è™æœº 17.3.3 è¿‘ä¼¼æœ€ä¼˜è€è™æœºç­–ç•¥ 17.3.4 ä¸å¯ç´¢å¼•å˜ä½“ 17.4 éƒ¨åˆ†å¯è§‚æµ‹ MDP POMDP çš„å®šä¹‰ 17.5 æ±‚è§£ POMDP çš„ç®—æ³• 17.5.1 POMDP çš„ä»·å€¼è¿­ä»£ 17.5.2 POMDP çš„åœ¨çº¿ç®—æ³• ç¬¬ 18 ç«  å¤šæ™ºèƒ½ä½“å†³ç­– 18.1 å¤šæ™ºèƒ½ä½“ç¯å¢ƒçš„ç‰¹æ€§ 18.1.1 å•ä¸ªå†³ç­–è€… 18.1.2 å¤šå†³ç­–è€… 18.1.3 å¤šæ™ºèƒ½ä½“è§„åˆ’ 18.1.4 å¤šæ™ºèƒ½ä½“è§„åˆ’ï¼šåˆä½œä¸åè°ƒ 18.2 éåˆä½œåšå¼ˆè®º 18.2.1 å•æ­¥åšå¼ˆï¼šæ­£åˆ™å½¢å¼åšå¼ˆ 18.2.2 ç¤¾ä¼šç¦åˆ© 18.2.3 é‡å¤åšå¼ˆ 18.2.4 åºè´¯åšå¼ˆï¼šæ‰©å±•å½¢å¼ 18.2.5 ä¸ç¡®å®šæ”¶ç›Šä¸è¾…åŠ©åšå¼ˆ 18.3 åˆä½œåšå¼ˆè®º 18.3.1 è”ç›Ÿç»“æ„ä¸ç»“æœ 18.3.2 åˆä½œåšå¼ˆä¸­çš„ç­–ç•¥ 18.3.3 åˆä½œåšå¼ˆä¸­çš„è®¡ç®— 18.4 åšé›†ä½“å†³ç­– 18.4.1 åœ¨åˆåŒç½‘ä¸­åˆ†é…ä»»åŠ¡ 18.4.2 é€šè¿‡æ‹å–åˆ†é…ç¨€ç¼ºèµ„æº 18.4.3 æŠ•ç¥¨ 18.4.4 è®®ä»· ç¬¬äº”éƒ¨åˆ† æœºå™¨å­¦ä¹  ç¬¬ 19 ç«  æ ·ä¾‹å­¦ä¹  19.1 å­¦ä¹ çš„å½¢å¼ 19.2 ç›‘ç£å­¦ä¹  é—®é¢˜ç¤ºä¾‹ï¼šé¤å…ç­‰å¾…é—®é¢˜ 19.3 å†³ç­–æ ‘å­¦ä¹  19.3.1 å†³ç­–æ ‘çš„è¡¨è¾¾èƒ½åŠ› 19.3.2 ä»æ ·ä¾‹ä¸­å­¦ä¹ å†³ç­–æ ‘ 19.3.3 é€‰æ‹©æµ‹è¯•å±æ€§ 19.3.4 æ³›åŒ–ä¸è¿‡æ‹Ÿåˆ 19.3.5 æ‹“å±•å†³ç­–æ ‘çš„é€‚ç”¨èŒƒå›´ 19.4 æ¨¡å‹é€‰æ‹©ä¸æ¨¡å‹ä¼˜åŒ– 19.4.1 æ¨¡å‹é€‰æ‹© 19.4.2 ä»é”™è¯¯ç‡åˆ°æŸå¤±å‡½æ•° 19.4.3 æ­£åˆ™åŒ– 19.4.4 è¶…å‚æ•°è°ƒæ•´ 19.5 å­¦ä¹ ç†è®º PAC å­¦ä¹ ç¤ºä¾‹ï¼šå­¦ä¹ å†³ç­–åˆ—è¡¨ 19.6 çº¿æ€§å›å½’ä¸åˆ†ç±» 19.6.1 å•å˜é‡çº¿æ€§å›å½’ 19.6.2 æ¢¯åº¦ä¸‹é™ 19.6.3 å¤šå˜é‡çº¿æ€§å›å½’ 19.6.4 å¸¦æœ‰ç¡¬é˜ˆå€¼çš„çº¿æ€§åˆ†ç±»å™¨ 19.6.5 åŸºäºé€»è¾‘æ–¯è°›å›å½’çš„çº¿æ€§åˆ†ç±»å™¨ 19.7 éå‚æ•°æ¨¡å‹ 19.7.1 æœ€è¿‘é‚»æ¨¡å‹ 19.7.2 ä½¿ç”¨ k-d æ ‘å¯»æ‰¾æœ€è¿‘é‚» 19.7.3 å±€éƒ¨æ•æ„Ÿå“ˆå¸Œ 19.7.4 éå‚æ•°å›å½’ 19.7.5 æ”¯æŒå‘é‡æœº 19.7.6 æ ¸æŠ€å·§ 19.8 é›†æˆå­¦ä¹  19.8.1 è‡ªåŠ©èšåˆæ³• 19.8.2 éšæœºæ£®æ—æ³• 19.8.3 å †å æ³• 19.8.4 è‡ªé€‚åº”æå‡æ³• 19.8.5 æ¢¯åº¦æå‡æ³• 19.8.6 åœ¨çº¿å­¦ä¹  19.9 å¼€å‘æœºå™¨å­¦ä¹ ç³»ç»Ÿ 19.9.1 é—®é¢˜å½¢å¼åŒ– 19.9.2 æ•°æ®æ”¶é›†ã€è¯„ä¼°å’Œç®¡ç† 19.9.3 æ¨¡å‹é€‰æ‹©ä¸è®­ç»ƒ 19.9.4 ä¿¡ä»»ã€å¯è§£é‡Šæ€§ã€å¯è¯´æ˜æ€§ 19.9.5 æ“ä½œã€ç›‘æ§å’Œç»´æŠ¤ ç¬¬ 20 ç«  æ¦‚ç‡æ¨¡å‹å­¦ä¹  20.1 ç»Ÿè®¡å­¦ä¹  20.2 å®Œå…¨æ•°æ®å­¦ä¹  20.2.1 æœ€å¤§ä¼¼ç„¶å‚æ•°å­¦ä¹ ï¼šç¦»æ•£æ¨¡å‹ 20.2.2 æœ´ç´ è´å¶æ–¯æ¨¡å‹ 20.2.3 ç”Ÿæˆæ¨¡å‹å’Œåˆ¤åˆ«æ¨¡å‹ 20.2.4 æœ€å¤§ä¼¼ç„¶å‚æ•°å­¦ä¹ ï¼šè¿ç»­æ¨¡å‹ 20.2.5 è´å¶æ–¯å‚æ•°å­¦ä¹  20.2.6 è´å¶æ–¯çº¿æ€§å›å½’ 20.2.7 è´å¶æ–¯ç½‘ç»œç»“æ„å­¦ä¹  20.2.8 éå‚æ•°æ¨¡å‹å¯†åº¦ä¼°è®¡ 20.3 éšå˜é‡å­¦ä¹ ï¼šEM ç®—æ³• 20.3.1 æ— ç›‘ç£èšç±»ï¼šå­¦ä¹ æ··åˆé«˜æ–¯ 20.3.2 å­¦ä¹ å¸¦éšå˜é‡çš„è´å¶æ–¯ç½‘ç»œå‚æ•°å€¼ 20.3.3 å­¦ä¹ éšé©¬å°”å¯å¤«æ¨¡å‹ 20.3.4 EM ç®—æ³•çš„ä¸€èˆ¬å½¢å¼ 20.3.5 å­¦ä¹ å¸¦éšå˜é‡çš„è´å¶æ–¯ç½‘ç»œç»“æ„ ç¬¬ 21 ç«  æ·±åº¦å­¦ä¹  21.1 ç®€å•å‰é¦ˆç½‘ç»œ 21.1.1 ç½‘ç»œä½œä¸ºå¤æ‚å‡½æ•° 21.1.2 æ¢¯åº¦ä¸å­¦ä¹  21.2 æ·±åº¦å­¦ä¹ çš„è®¡ç®—å›¾ 21.2.1 è¾“å…¥ç¼–ç  21.2.2 è¾“å‡ºå±‚ä¸æŸå¤±å‡½æ•° 21.2.3 éšè—å±‚ 21.3 å·ç§¯ç½‘ç»œ 21.3.1 æ± åŒ–ä¸ä¸‹é‡‡æ · 21.3.2 å·ç§¯ç¥ç»ç½‘ç»œçš„å¼ é‡è¿ç®— 21.3.3 æ®‹å·®ç½‘ç»œ 21.4 å­¦ä¹ ç®—æ³• 21.4.1 è®¡ç®—å›¾ä¸­çš„æ¢¯åº¦è®¡ç®— 21.4.2 æ‰¹é‡å½’ä¸€åŒ– 21.5 æ³›åŒ– 21.5.1 é€‰æ‹©æ­£ç¡®çš„ç½‘ç»œæ¶æ„ 21.5.2 ç¥ç»æ¶æ„æœç´¢ 21.5.3 æƒé‡è¡°å‡ 21.5.4 æš‚é€€æ³• 21.6 å¾ªç¯ç¥ç»ç½‘ç»œ 21.6.1 è®­ç»ƒåŸºæœ¬çš„å¾ªç¯ç¥ç»ç½‘ç»œ 21.6.2 é•¿çŸ­æœŸè®°å¿† RNN 21.7 æ— ç›‘ç£å­¦ä¹ ä¸è¿ç§»å­¦ä¹  21.7.1 æ— ç›‘ç£å­¦ä¹  21.7.2 è¿ç§»å­¦ä¹ å’Œå¤šä»»åŠ¡å­¦ä¹  21.8 åº”ç”¨ 21.8.1 è§†è§‰ 21.8.2 è‡ªç„¶è¯­è¨€å¤„ç† 21.8.3 å¼ºåŒ–å­¦ä¹  ç¬¬ 22 ç«  å¼ºåŒ–å­¦ä¹  22.1 ä»å¥–åŠ±ä¸­å­¦ä¹  22.2 è¢«åŠ¨å¼ºåŒ–å­¦ä¹  22.2.1 ç›´æ¥æ•ˆç”¨ä¼°è®¡ 22.2.2 è‡ªé€‚åº”åŠ¨æ€è§„åˆ’ 22.2.3 æ—¶åºå·®åˆ†å­¦ä¹  22.3 ä¸»åŠ¨å¼ºåŒ–å­¦ä¹  22.3.1 æ¢ç´¢ 22.3.2 å®‰å…¨æ¢ç´¢ 22.3.3 æ—¶åºå·®åˆ† Q å­¦ä¹  22.4 å¼ºåŒ–å­¦ä¹ ä¸­çš„æ³›åŒ– 22.4.1 è¿‘ä¼¼ç›´æ¥æ•ˆç”¨ä¼°è®¡ 22.4.2 è¿‘ä¼¼æ—¶åºå·®åˆ†å­¦ä¹  22.4.3 æ·±åº¦å¼ºåŒ–å­¦ä¹  22.4.4 å¥–åŠ±å‡½æ•°è®¾è®¡ 22.4.5 åˆ†å±‚å¼ºåŒ–å­¦ä¹  22.5 ç­–ç•¥æœç´¢ 22.6 å­¦å¾’å­¦ä¹ ä¸é€†å¼ºåŒ–å­¦ä¹  22.7 å¼ºåŒ–å­¦ä¹ çš„åº”ç”¨ 22.7.1 åœ¨ç”µå­æ¸¸æˆä¸­çš„åº”ç”¨ 22.7.2 åœ¨æœºå™¨äººæ§åˆ¶ä¸­çš„åº”ç”¨ ç¬¬å…­éƒ¨åˆ† æ²Ÿé€šã€æ„ŸçŸ¥å’Œè¡ŒåŠ¨ ç¬¬ 23 ç«  è‡ªç„¶è¯­è¨€å¤„ç† 23.1 è¯­è¨€æ¨¡å‹ 23.1.1 è¯è¢‹æ¨¡å‹ 23.1.2 n å…ƒå•è¯æ¨¡å‹ 23.1.3 å…¶ä»– n å…ƒæ¨¡å‹ 23.1.4 n å…ƒæ¨¡å‹çš„å¹³æ»‘ 23.1.5 å•è¯è¡¨ç¤º 23.1.6 è¯æ€§æ ‡æ³¨ 23.1.7 è¯­è¨€æ¨¡å‹çš„æ¯”è¾ƒ 23.2 æ–‡æ³• E0 çš„è¯å…¸ 23.3 å¥æ³•åˆ†æ 23.3.1 ä¾å­˜åˆ†æ 23.3.2 ä»æ ·ä¾‹ä¸­å­¦ä¹ å¥æ³•åˆ†æå™¨ 23.4 æ‰©å±•æ–‡æ³• 23.4.1 è¯­ä¹‰è§£é‡Š 23.4.2 å­¦ä¹ è¯­ä¹‰æ–‡æ³• 23.5 çœŸå®è‡ªç„¶è¯­è¨€çš„å¤æ‚æ€§ 23.6 è‡ªç„¶è¯­è¨€ä»»åŠ¡ ç¬¬ 24 ç«  è‡ªç„¶è¯­è¨€å¤„ç†ä¸­çš„æ·±åº¦å­¦ä¹  24.1 è¯åµŒå…¥ 24.2 è‡ªç„¶è¯­è¨€å¤„ç†ä¸­çš„å¾ªç¯ç¥ç»ç½‘ç»œ 24.2.1 ä½¿ç”¨å¾ªç¯ç¥ç»ç½‘ç»œçš„è¯­è¨€æ¨¡å‹ 24.2.2 ç”¨å¾ªç¯ç¥ç»ç½‘ç»œè¿›è¡Œåˆ†ç±» 24.2.3 è‡ªç„¶è¯­è¨€å¤„ç†ä»»åŠ¡ä¸­çš„ LSTM æ¨¡å‹ 24.3 åºåˆ—åˆ°åºåˆ—æ¨¡å‹ 24.3.1 æ³¨æ„åŠ› 24.3.2 è§£ç  24.4 Transformer æ¶æ„ 24.4.1 è‡ªæ³¨æ„åŠ› 24.4.2 ä»è‡ªæ³¨æ„åŠ›åˆ° Transformer 24.5 é¢„è®­ç»ƒå’Œè¿ç§»å­¦ä¹  24.5.1 é¢„è®­ç»ƒè¯åµŒå…¥ 24.5.2 é¢„è®­ç»ƒä¸Šä¸‹æ–‡è¡¨ç¤º 24.5.3 æ©ç è¯­è¨€æ¨¡å‹ 24.6 æœ€é«˜æ°´å¹³ï¼ˆSOTAï¼‰ ç¬¬ 25 ç«  è®¡ç®—æœºè§†è§‰ 25.1 å¼•è¨€ 25.2 å›¾åƒå½¢æˆ 25.2.1 æ— é€é•œæˆåƒï¼šé’ˆå­”ç…§ç›¸æœº 25.2.2 é€é•œç³»ç»Ÿ 25.2.3 ç¼©æ”¾æ­£äº¤æŠ•å½± 25.2.4 å…‰çº¿ä¸æ˜æš— 25.2.5 é¢œè‰² 25.3 ç®€å•å›¾åƒç‰¹å¾ 25.3.1 è¾¹ç¼˜ 25.3.2 çº¹ç† 25.3.3 å…‰æµ 25.3.4 è‡ªç„¶å›¾åƒåˆ†å‰² 25.4 å›¾åƒåˆ†ç±» 25.4.1 åŸºäºå·ç§¯ç¥ç»ç½‘ç»œçš„å›¾åƒåˆ†ç±» 25.4.2 å·ç§¯ç¥ç»ç½‘ç»œå¯¹å›¾åƒåˆ†ç±»é—®é¢˜æœ‰æ•ˆçš„åŸå›  25.5 ç‰©ä½“æ£€æµ‹ 25.6 ä¸‰ç»´ä¸–ç•Œ 25.6.1 å¤šä¸ªè§†å›¾ä¸‹çš„ä¸‰ç»´çº¿ç´¢ 25.6.2 åŒç›®ç«‹ä½“è§†è§‰ 25.6.3 ç§»åŠ¨æ‘„åƒæœºç»™å‡ºçš„ä¸‰ç»´çº¿ç´¢ 25.6.4 å•ä¸ªè§†å›¾çš„ä¸‰ç»´çº¿ç´¢ 25.7 è®¡ç®—æœºè§†è§‰çš„åº”ç”¨ 25.7.1 ç†è§£äººç±»è¡Œä¸º 25.7.2 åŒ¹é…å›¾ç‰‡ä¸æ–‡å­— 25.7.3 å¤šè§†å›¾é‡å»º 25.7.4 å•è§†å›¾ä¸­çš„å‡ ä½• 25.7.5 ç”Ÿæˆå›¾ç‰‡ 25.7.6 åˆ©ç”¨è§†è§‰æ§åˆ¶è¿åŠ¨ ç¬¬ 26 ç«  æœºå™¨äººå­¦ 26.1 æœºå™¨äºº 26.2 æœºå™¨äººç¡¬ä»¶ 26.2.1 æœºå™¨äººçš„ç¡¬ä»¶å±‚é¢åˆ†ç±» 26.2.2 æ„ŸçŸ¥ä¸–ç•Œ 26.2.3 äº§ç”Ÿè¿åŠ¨ 26.3 æœºå™¨äººå­¦è§£å†³å“ªäº›é—®é¢˜ 26.4 æœºå™¨äººæ„ŸçŸ¥ 26.4.1 å®šä½ä¸åœ°å›¾æ„å»º 26.4.2 å…¶ä»–æ„ŸçŸ¥ç±»å‹ 26.4.3 æœºå™¨äººæ„ŸçŸ¥ä¸­çš„ç›‘ç£å­¦ä¹ ä¸æ— ç›‘ç£å­¦ä¹  26.5 è§„åˆ’ä¸æ§åˆ¶ 26.5.1 æ„å½¢ç©ºé—´ 26.5.2 è¿åŠ¨è§„åˆ’ 26.5.3 è½¨è¿¹è·Ÿè¸ªæ§åˆ¶ 26.5.4 æœ€ä¼˜æ§åˆ¶ 26.6 è§„åˆ’ä¸ç¡®å®šçš„è¿åŠ¨ 26.7 æœºå™¨äººå­¦ä¸­çš„å¼ºåŒ–å­¦ä¹  26.7.1 åˆ©ç”¨æ¨¡å‹ 26.7.2 åˆ©ç”¨å…¶ä»–ä¿¡æ¯ 26.8 äººç±»ä¸æœºå™¨äºº 26.8.1 åè°ƒ 26.8.2 å­¦ä¹ åšäººç±»æœŸæœ›çš„äº‹æƒ… 26.9 å…¶ä»–æœºå™¨äººæ¡†æ¶ 26.9.1 ååº”å¼æ§åˆ¶å™¨ 26.9.2 åŒ…å®¹æ¶æ„ 26.10 åº”ç”¨é¢†åŸŸ ç¬¬ä¸ƒéƒ¨åˆ† æ€»ç»“ ç¬¬ 27 ç«  äººå·¥æ™ºèƒ½çš„å“²å­¦ã€ä¼¦ç†å’Œå®‰å…¨æ€§ 27.1 äººå·¥æ™ºèƒ½çš„æé™ 27.1.1 ç”±éå½¢å¼åŒ–å¾—å‡ºçš„è®ºæ® 27.1.2 ç”±èƒ½åŠ›ç¼ºé™·å¾—å‡ºçš„è®ºæ® 27.1.3 æ•°å­¦å¼‚è®® 27.1.4 è¡¡é‡äººå·¥æ™ºèƒ½ 27.2 æœºå™¨èƒ½çœŸæ­£åœ°æ€è€ƒå— 27.2.1 ä¸­æ–‡æˆ¿é—´ 27.2.2 æ„è¯†ä¸æ„Ÿè´¨ 27.3 äººå·¥æ™ºèƒ½çš„ä¼¦ç† 27.3.1 è‡´å‘½æ€§è‡ªä¸»æ­¦å™¨ 27.3.2 ç›‘æ§ã€å®‰å…¨ä¸éšç§ 27.3.3 å…¬å¹³ä¸åè§ 27.3.4 ä¿¡ä»»ä¸é€æ˜åº¦ 27.3.5 å·¥ä½œå‰æ™¯ 27.3.6 æœºå™¨äººæƒåˆ© 27.3.7 äººå·¥æ™ºèƒ½å®‰å…¨æ€§ ç¬¬ 28 ç«  äººå·¥æ™ºèƒ½çš„æœªæ¥ 28.1 äººå·¥æ™ºèƒ½ç»„ä»¶ 28.2 äººå·¥æ™ºèƒ½æ¶æ„ é™„å½• A æ•°å­¦èƒŒæ™¯çŸ¥è¯† A.1 å¤æ‚æ€§åˆ†æå’Œ$O()$è®°å· A.1.1 æ¸è¿‘åˆ†æ A.1.2 NP å›°éš¾å’Œå›ºæœ‰çš„éš¾é¢˜ A.2 å‘é‡ï¼ŒçŸ©é˜µå’Œçº¿æ€§ä»£æ•° A.3 æ¦‚ç‡åˆ†å¸ƒ è¯»è€…æœåŠ¡ "},"Learn/LearnAIMA/Ch12.html":{"url":"Learn/LearnAIMA/Ch12.html","title":"Ch12","keywords":"","body":"Ch12 æœ¬ç« è¡¨æ˜æ¦‚ç‡è®ºæ˜¯ä¸ç¡®å®šæ¨ç†çš„åˆé€‚åŸºç¡€ï¼Œå¹¶ç®€è¦ä»‹ç»äº†å®ƒçš„åº”ç”¨ã€‚ ä¸ç¡®å®šæ€§çš„äº§ç”Ÿæ˜¯ç”±äºæƒ°æ€§å’Œæ— çŸ¥ã€‚åœ¨å¤æ‚çš„ã€éç¡®å®šæ€§çš„æˆ–éƒ¨åˆ†å¯è§‚æµ‹çš„ç¯å¢ƒä¸­ï¼Œä¸ç¡®å®šæ€§æ˜¯ä¸å¯é¿å…çš„ã€‚ æ¦‚ç‡è¡¨è¾¾äº†æ™ºèƒ½ä½“æ— æ³•å¯¹ä¸€ä¸ªè¯­å¥çš„çœŸå€¼åšå‡ºæ˜ç¡®çš„åˆ¤æ–­ã€‚æ¦‚ç‡æ¦‚æ‹¬äº†æ™ºèƒ½ä½“å¯¹äºè¯æ®çš„ä¿¡å¿µã€‚ å†³ç­–è®ºç»“åˆäº†æ™ºèƒ½ä½“çš„ä¿¡å¿µå’Œæ¬²æœ›ï¼Œå°†æœ€å¤§æœŸæœ›æ•ˆç”¨çš„åŠ¨ä½œå®šä¹‰ä¸ºæœ€ä½³åŠ¨ä½œã€‚ å†³ç­–è®º = æ¦‚ç‡è®º + æ•ˆç”¨ç†è®ºï¼ŒMEU åŸºæœ¬çš„æ¦‚ç‡é™ˆè¿°åŒ…æ‹¬ç®€å•å‘½é¢˜å’Œå¤æ‚å‘½é¢˜ä¸Šçš„å…ˆéªŒæ¦‚ç‡ï¼ˆæˆ–æ— æ¡ä»¶æ¦‚ç‡ï¼‰å’ŒåéªŒæ¦‚ç‡ï¼ˆæˆ–æ¡ä»¶æ¦‚ç‡ï¼‰ã€‚ æ¦‚ç‡å…¬ç†çº¦æŸé€»è¾‘ç›¸å…³å‘½é¢˜çš„æ¦‚ç‡ã€‚è¿èƒŒå…¬ç†çš„æ™ºèƒ½ä½“åœ¨æŸäº›æƒ…å†µä¸‹çš„è¡Œä¸ºå¿…å®šæ˜¯ä¸ç†æ€§çš„ã€‚ å®Œå…¨è”åˆæ¦‚ç‡åˆ†å¸ƒä¸ºéšæœºå˜é‡çš„æ¯ç§å®Œæ•´èµ‹å€¼æŒ‡å®šäº†æ¦‚ç‡ã€‚é€šå¸¸ï¼Œå®Œå…¨è”åˆæ¦‚ç‡åˆ†å¸ƒè¿‡äºåºå¤§ï¼Œä»¥è‡³äºæ— æ³•æ˜¾å¼åœ°åˆ›å»ºå’Œä½¿ç”¨ï¼Œä½†å¦‚æœå…¶å¯ç”¨æ—¶ï¼Œå®ƒå¯ä»¥ç”¨äºå›ç­”æŸ¥è¯¢ï¼Œåªéœ€è¦ç®€å•åœ°å°†å…¶ä¸­ä¸æŸ¥è¯¢å‘½é¢˜å¯¹åº”çš„å¯èƒ½ä¸–ç•Œçš„æ¡ç›®ç›¸åŠ å³å¯ã€‚ éšæœºå˜é‡å­é›†é—´çš„ç»å¯¹ç‹¬ç«‹æ€§å…è®¸å°†å®Œå…¨è”åˆåˆ†å¸ƒåˆ†è§£æˆå°çš„è”åˆåˆ†å¸ƒï¼Œæå¤§åœ°é™ä½å®ƒçš„å¤æ‚åº¦ã€‚ è´å¶æ–¯æ³•åˆ™å…è®¸é€šè¿‡å·²çŸ¥çš„æ¡ä»¶æ¦‚ç‡å»è®¡ç®—æœªçŸ¥æ¦‚ç‡ï¼Œæ¡ä»¶æ¦‚ç‡é€šå¸¸åœ¨å› æœæ–¹å‘ä¸Šã€‚å°†è´å¶æ–¯æ³•åˆ™åº”ç”¨äºå¤šæ¡è¯æ®æ—¶ä¼šé‡åˆ°ä¸å®Œå…¨è”åˆåˆ†å¸ƒç›¸åŒçš„è§„æ¨¡æ‰©å±•é—®é¢˜ã€‚ åŸŸä¸­çš„ç›´æ¥å› æœå…³ç³»å¸¦æ¥çš„æ¡ä»¶ç‹¬ç«‹æ€§å…è®¸å®Œå…¨è”åˆåˆ†å¸ƒè¢«åˆ†è§£æˆå°çš„æ¡ä»¶åˆ†å¸ƒã€‚æœ´ç´ è´å¶æ–¯æ¨¡å‹å‡è®¾ç»™å®šå•åŸå› å˜é‡æ—¶ï¼Œæ‰€æœ‰ç»“æœå˜é‡å…·æœ‰æ¡ä»¶ç‹¬ç«‹æ€§ã€‚æ¨¡å‹å¤§å°éšç»“æœä¸ªæ•°çº¿æ€§å¢é•¿ã€‚ wumpus ä¸–ç•Œçš„æ™ºèƒ½ä½“å¯ä»¥è®¡ç®—ä¸–ç•Œä¸­æœªè§‚æµ‹çš„æ–¹é¢çš„æ¦‚ç‡ï¼Œä»è€Œæ”¹è¿›çº¯é€»è¾‘æ™ºèƒ½ä½“çš„å†³ç­–ã€‚æ¡ä»¶ç‹¬ç«‹æ€§ç®€åŒ–äº†è¿™äº›è®¡ç®—ã€‚ (33 å°ç§ä¿¡ / 81 æ¡æ¶ˆæ¯) ç›¸äº’ç‹¬ç«‹å’Œæ¡ä»¶ç‹¬ç«‹çš„å…³ç³»ï¼Ÿ - çŸ¥ä¹ (zhihu.com) æ¦‚ç‡å®šä¹‰ æ¦‚ç‡çš„å…¬ç†åŒ–å®šä¹‰ æ¦‚ç‡æ˜¯ä¸€ä¸ªäº‹ä»¶é›†åˆä¸Šçš„åº¦é‡, æ»¡è¶³ä»¥ä¸‹ 3 æ¡å…¬ç†ã€‚ æ¯ä¸ªäº‹ä»¶çš„åº¦é‡åœ¨ 0 å’Œ 1 ä¹‹é—´, å¯å†™ä¸º 0â©½P(X=xi)â©½10 \\leqslant P\\left(X=x_{i}\\right) \\leqslant 10â©½P(X=xiâ€‹)â©½1 ï¼Œå…¶ä¸­ $X$ æ˜¯è¡¨ç¤ºäº‹ä»¶çš„éšæœºå˜é‡, $x_{i}$ æ˜¯ X çš„å¯èƒ½çš„å€¼ã€‚ä¸€èˆ¬æ¥è¯´, éšæœºå˜é‡ç”¨å¤§å†™å­—æ¯è¡¨ç¤º, å®ƒä»¬çš„å€¼ç”¨å°å†™å­—æ¯è¡¨ç¤ºã€‚ æ•´ä¸ªé›†åˆçš„åº¦é‡ä¸º 1 , å³ âˆ‘i=1nP(X=xi)=1 \\sum_{i=1}^{n} P\\left(X=x_{i}\\right)=1 i=1âˆ‘nâ€‹P(X=xiâ€‹)=1 ä¸ç›¸äº¤äº‹ä»¶çš„å¹¶é›†çš„æ¦‚ç‡ç­‰äºå•ä¸ªäº‹ä»¶æ¦‚ç‡çš„å’Œ, å³ P(X=x1âˆ¨X=x2)=P(X=x1)+P(X=x2) P\\left(X=x_{1} \\vee X=x_{2}\\right)=P\\left(X=x_{1}\\right)+ P\\left(X=x_{2}\\right) P(X=x1â€‹âˆ¨X=x2â€‹)=P(X=x1â€‹)+P(X=x2â€‹) è¿™é‡Œ$x_{1}$å’Œ$x_{2}$æ˜¯ä¸ç›¸äº¤çš„ã€‚ å®¹æ–¥åŸç†ï¼š P(aâˆ¨b)=P(a)+P(b)âˆ’P(aâˆ§b) P(a \\vee b) = P(a) + P(b) - P(a \\wedge b) P(aâˆ¨b)=P(a)+P(b)âˆ’P(aâˆ§b) ä»€ä¹ˆå«â€œæ¦‚ç‡å…¬ç†çš„è®ºæ®â€ï¼Ÿ ä¸ºä»€ä¹ˆä¸æœ‰è¿èƒŒâ€œæ¦‚ç‡å…¬ç†â€çš„ä¿¡å¿µé›†åˆå‘¢ï¼Ÿ å› ä¸ºè¿èƒŒæ¦‚ç‡å…¬ç†çš„ä¿¡å¿µé›†åˆæ˜¯ä¸åˆç†çš„ï¼Œè®¾æƒ³ä¸€ä¸ªèµŒå±€ï¼Œå‚åŠ è€…æŒ‰ç…§ä»–æŒæœ‰çš„ä¿¡å¿µçŠ¶æ€ä¸‹æ³¨ï¼Œä¸‹æ³¨æ•°é‡ä¸è‡ªå·±æŒæœ‰çš„ä¿¡å¿µçŠ¶æ€æˆæ­£æ¯”ã€‚å¯ä»¥è¯æ˜ï¼Œå¯¹äºæŒ‰ç…§è¿åæ¦‚ç‡å…¬ç†çš„ä¿¡å¿µçŠ¶æ€è¿›è¡Œä¸‹æ³¨çš„æ™ºèƒ½ä½“ï¼Œä¸€å®šå­˜åœ¨æŸç§èµŒå±€çš„ç»„åˆï¼Œä½¿å¾—è¯¥æ™ºèƒ½ä½“æ¯æ¬¡éƒ½ä¼šè¾“é’±ã€‚ï¼Ÿï¼Ÿï¼Ÿ å®Œå…¨è”åˆæ¦‚ç‡åˆ†å¸ƒï¼šæ‰€æœ‰éšæœºå˜é‡çš„è”åˆåˆ†å¸ƒï¼Œå³ç»™å®šæ‰€æœ‰å˜é‡çš„æ‰€æœ‰å–å€¼ç»„åˆçš„æ¦‚ç‡å¯†åº¦/æ¦‚ç‡ ä¸€ä¸ªæ¦‚ç‡æ¨¡å‹å¯ä»¥ç”±å®Œå…¨è”åˆæ¦‚ç‡åˆ†å¸ƒå®Œå…¨ç¡®å®š è€Œæ¯ä¸ªå‘½é¢˜çš„æ¦‚ç‡æ˜¯è¯¥å‘½é¢˜ä¸ºçœŸçš„å¯èƒ½ä¸–ç•Œçš„æ¦‚ç‡çš„æ±‚å’Œï¼Œé‚£ä¹ˆï¼Œå¦‚æœå·²çŸ¥å®Œå…¨è”åˆæ¦‚ç‡åˆ†å¸ƒï¼Œæˆ‘ä»¬åŸåˆ™ä¸Šå¯ä»¥è®¡ç®—ä»»ä½•å‘½é¢˜çš„æ¦‚ç‡ï¼ˆå› ä¸ºæˆ‘ä»¬å·²ç»æŒ‡å®š/ç»™å‡ºäº†æ¯ä¸€ä¸ªå¯èƒ½çš„æ ·æœ¬ç‚¹çš„æ¦‚ç‡ï¼Œè¦åšçš„åªæ˜¯æ‰¾å‡ºæ»¡è¶³è¦æ±‚çš„æ ·æœ¬ç‚¹ï¼Œç„¶åæ±‚å’Œï¼‰ã€‚ å®é™…ä¸Šå‘¢ï¼Ÿ å®Œå…¨è”åˆæ¦‚ç‡åˆ†å¸ƒå®é™…ä¸Šä¸å¯çŸ¥/ä¸çŸ¥é“ å®Œå…¨æ¦‚ç‡åˆ†å¸ƒçš„æ±‚å’Œè®¡ç®—å¤æ‚åº¦éš¾ä»¥æ‰¿å— ä½¿ç”¨å®Œå…¨è”åˆæ¦‚ç‡åˆ†å¸ƒè¿›è¡Œæ¨æ–­ æ¦‚ç‡æ¨æ–­ï¼šä½¿ç”¨å®Œå…¨è”åˆæ¦‚ç‡åˆ†å¸ƒä½œä¸ºçŸ¥è¯†åº“ï¼Œç»™å®šè§‚æµ‹è¯æ®ï¼Œä¸ºæ¯ä¸ªæŸ¥è¯¢å‘½é¢˜è®¡ç®—åéªŒæ¦‚ç‡ã€‚ è¾¹ç¼˜æ¦‚ç‡ï¼šæŠ½å–å˜é‡å­é›† or å•ä¸ªå˜é‡çš„åˆ†å¸ƒ è¾¹ç¼˜åŒ–/æ±‚å’Œæ¶ˆå…ƒï¼šå¯¹å…¶ä»–/ä¸å…³æ³¨çš„å˜é‡åœ¨å…¶å€¼åŸŸä¸Šæ±‚å’Œ P(Y)=âˆ‘zP(Y,Z=z) \\mathbf{P}(\\mathbf{Y})=\\sum_{\\mathbf{z}} \\mathbf{P}(\\mathbf{Y}, \\mathbf{Z}=\\mathbf{z}) P(Y)=zâˆ‘â€‹P(Y,Z=z) æ¡ä»¶åŒ–ï¼š P(Y)=âˆ‘zP(Yâˆ£z)P(z) \\mathbf{P}(\\mathbf{Y})=\\sum_{\\mathbf{z}} \\mathbf{P}(\\mathbf{Y} \\mid \\mathbf{z}) P(\\mathbf{z}) P(Y)=zâˆ‘â€‹P(Yâˆ£z)P(z) é€šç”¨æ¨æ–­è¿‡ç¨‹ï¼š X å¾…æŸ¥è¯¢å•å˜é‡ E è¯æ®å˜é‡åˆ—è¡¨ï¼Œe ä¸ºè§‚æµ‹å€¼åˆ—è¡¨ Y å‰©ä½™ä¸ºè§‚æµ‹å˜é‡ P(Xâˆ£e)=Î±P(X,e)=Î±âˆ‘yP(X,e,y) \\mathbf{P}(X \\mid \\mathbf{e})=\\alpha \\mathbf{P}(X, \\mathbf{e})=\\alpha \\sum_{\\mathbf{y}} \\mathbf{P}(X, \\mathbf{e}, \\mathbf{y}) P(Xâˆ£e)=Î±P(X,e)=Î±yâˆ‘â€‹P(X,e,y) å…¶ä¸­æ±‚å’Œæ˜¯é’ˆå¯¹æ‰€æœ‰å¯èƒ½çš„$\\boldsymbol{y}$(ä¹Ÿå°±æ˜¯æœªè§‚æµ‹å˜é‡$\\boldsymbol{Y}$çš„å€¼çš„æ‰€æœ‰å¯èƒ½ç»„åˆ)ã€‚æ³¨æ„ï¼Œå˜é‡$X$ã€$\\boldsymbol{E}$å’Œ$\\boldsymbol{Y}$æ„æˆäº†åŸŸå˜é‡çš„å®Œæ•´é›†åˆ, æ‰€ä»¥$\\boldsymbol{P}(X, \\boldsymbol{e}, \\boldsymbol{y})$ä»…ä»…æ˜¯å®Œå…¨è”åˆåˆ†å¸ƒçš„ä¸€ä¸ªæ¦‚ç‡å­é›†ã€‚ -$\\alpha$ä¸ºå½’ä¸€åŒ–å¸¸æ•°ï¼Œè¦ä¼šåˆç†åˆ©ç”¨ä»¥ç®€åŒ–è®¡ç®— ç‹¬ç«‹æ€§ Independence Independence (probability theory) - Wikipedia) ç‹¬ç«‹æ€§æ˜¯â€œäº‹ç†â€ä¸Šå¯¹ä¸¤ä¸ªéšæœºäº‹ä»¶çš„çš„å…³ç³»è¿›è¡Œè¯„åˆ¤ï¼Œå³ä¸ç›¸å…³ï¼Œäº’ä¸å½±å“ï¼Œå¯¹æ–¹å‘ç”Ÿä¸å¦ä¸å½±å“æˆ‘å‘ç”Ÿçš„æ¦‚ç‡ï¼Œæˆ‘å‘ç”Ÿä¸å¦ä¹Ÿä¸å½±å“å¯¹æ–¹å‘ç”Ÿçš„æ¦‚ç‡ã€‚ ç‹¬ç«‹æ€§å®šä¹‰ä¸ºï¼š ä¸¤ä¸ªå‘½é¢˜ a å’Œ b æ˜¯ç›¸äº’ç‹¬ç«‹çš„ï¼Œå³ a å’Œ b çš„æ¦‚ç‡æ»¡è¶³å¦‚ä¸‹å…³ç³»ï¼š P(aâˆ£b)=P(a)orP(bâˆ£a)=P(b)orP(aâˆ§b)=P(a)P(b) P(a \\mid b)=P(a) \\quad or \\quad P(b \\mid a)=P(b) \\quad or \\quad P(a \\wedge b)=P(a) P(b) P(aâˆ£b)=P(a)orP(bâˆ£a)=P(b)orP(aâˆ§b)=P(a)P(b) ä¸¤ä¸ªéšæœºå˜é‡ X å’Œ Y æ˜¯ç‹¬ç«‹çš„ï¼Œå½“ä¸”ä»…å½“ï¼š P(Xâˆ£Y)=P(X)orP(Yâˆ£X)=P(Y)orP(X,Y)=P(X)P(Y) \\mathbf{P}(X \\mid Y)=\\mathbf{P}(X) \\quad or \\quad \\mathbf{P}(Y \\mid X)=\\mathbf{P}(Y) \\quad or \\quad \\mathbf{P}(X, Y)=\\mathbf{P}(X) \\mathbf{P}(Y) P(Xâˆ£Y)=P(X)orP(Yâˆ£X)=P(Y)orP(X,Y)=P(X)P(Y) â€œç‹¬ç«‹æ€§â€æ˜¯ä¸€ç§å®šä¹‰ï¼Œæ˜¯ä¸€ä¸ªæ–­è¨€ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼š å¦‚æœä¸¤ä¸ªäº‹ä»¶ç‹¬ç«‹ï¼Œé‚£ä¹ˆä¸€å®šæ»¡è¶³ä¸‹è¿°å…³ç³»å¼ï¼› å¦‚æœä¸¤ä¸ªäº‹ä»¶æ»¡è¶³ä¸Šè¿°å…³ç³»å¼ï¼Œé‚£ä¹ˆå°±ç§°è¿™ä¸¤ä¸ªäº‹ä»¶ç›¸äº’ç‹¬ç«‹ã€‚ å¤šå˜é‡ï¼š ä¸¤ä¸¤ç‹¬ç«‹ pairwise independent æœ‰é™äº‹ä»¶çš„é›†åˆ$\\left{A_{i}\\right}_{i=1}^{n}$ä¸­æ¯å¯¹äº‹ä»¶éƒ½æ˜¯ç›¸äº’ç‹¬ç«‹çš„ï¼Œåˆ™ç§°è¿™äº›äº‹ä»¶æ˜¯ä¸¤ä¸¤ç‹¬ç«‹çš„ï¼š Prâ¡(Aiâˆ©Aj)=Prâ¡(Ai)Prâ¡(Aj)(Â âˆ€i,jâˆˆ{1,â‹¯â€‰,n},Â iâ‰ jÂ ) \\operatorname{Pr}\\left(A_{i} \\cap A_{j}\\right)=\\operatorname{Pr}\\left(A_{i}\\right) \\operatorname{Pr}\\left(A_{j}\\right) \\quad (~ \\forall i,j \\in \\{ 1,\\cdots,n\\},~ i\\neq j~) Pr(Aiâ€‹âˆ©Ajâ€‹)=Pr(Aiâ€‹)Pr(Ajâ€‹)(Â âˆ€i,jâˆˆ{1,â‹¯,n},Â iî€ â€‹=jÂ ) ç›¸äº’ç‹¬ç«‹ mutually independent æœ‰é™äº‹ä»¶çš„é›†åˆ$\\left{A_{i}\\right}_{i=1}^{n}$ä¸­ï¼Œæ¯ä¸ªäº‹ä»¶éƒ½ä¸å…¶ä»–ä»»ä½•äº‹ä»¶æ„æˆçš„äº¤é›†ç‹¬ç«‹ï¼Œåˆ™è¿™äº›äº‹ä»¶æ˜¯ç›¸äº’ç‹¬ç«‹ çš„ å¯¹æ ·æœ¬ç©ºé—´çš„ä»»æ„æœ‰é™å­é›†åºåˆ—$A_1, \\cdots A_n$ï¼Œæœ‰ï¼š Prâ¡(A1âˆ©â‹¯âˆ©An)=Prâ¡(A1)â‹¯Prâ¡(An) \\operatorname{Pr}\\left(A_{1} \\cap \\cdots \\cap A_{n}\\right)=\\operatorname{Pr}\\left(A_{1}\\right) \\cdots \\operatorname{Pr}\\left(A_{n}\\right) Pr(A1â€‹âˆ©â‹¯âˆ©Anâ€‹)=Pr(A1â€‹)â‹¯Pr(Anâ€‹) æˆ–ï¼š Prâ¡(â‹‚i=1nAi)=âˆi=1nPrâ¡(Ai) \\operatorname{Pr}\\left(\\bigcap_{i=1}^{n} A_{i}\\right)=\\prod_{i=1}^{n} \\operatorname{Pr}\\left(A_{i}\\right) Pr(i=1â‹‚nâ€‹Aiâ€‹)=i=1âˆnâ€‹Pr(Aiâ€‹) è´å¶æ–¯æ³•åˆ™ P(Yâˆ£X)=P(Xâˆ£Y)P(Y)P(X) \\mathbf{P}(Y \\mid X)=\\frac{\\mathbf{P}(X \\mid Y) \\mathbf{P}(Y)}{\\mathbf{P}(X)} P(Yâˆ£X)=P(X)P(Xâˆ£Y)P(Y)â€‹ æœ‰è¯æ®å˜é‡çš„å½¢å¼ï¼š P(Yâˆ£X,e)=P(Xâˆ£Y,e)P(Yâˆ£e)P(Xâˆ£e) \\mathbf{P}(Y \\mid X, \\mathbf{e})=\\frac{\\mathbf{P}(X \\mid Y, \\mathbf{e}) \\mathbf{P}(Y \\mid \\mathbf{e})}{\\mathbf{P}(X \\mid \\mathbf{e})} P(Yâˆ£X,e)=P(Xâˆ£e)P(Xâˆ£Y,e)P(Yâˆ£e)â€‹ æ¡ä»¶ç‹¬ç«‹æ€§ ä¸€èˆ¬å®šä¹‰ï¼š P(X,Yâˆ£Z)=P(Xâˆ£Z)P(Yâˆ£Z) \\mathbf{P}(X, Y \\mid Z)=\\mathbf{P}(X \\mid Z) \\mathbf{P}(Y \\mid Z) P(X,Yâˆ£Z)=P(Xâˆ£Z)P(Yâˆ£Z) ç»å¯¹ç‹¬ç«‹æ€§ vs æ¡ä»¶ç‹¬ç«‹æ€§ ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä¸¤è€…ä¸èƒ½äº’æ¨ï¼Œå³ï¼šæ¡ä»¶ç‹¬ç«‹å¾—ä¸å‡ºç‹¬ç«‹ï¼Œç‹¬ç«‹å¾—ä¸å‡ºæ¡ä»¶ç‹¬ç«‹ ç»å¯¹ç‹¬ç«‹çš„ä¸¤ä¸ªå˜é‡ï¼Œåœ¨ç»™å®šå¦ä¸€ä¸ªå˜é‡åï¼Œå¯èƒ½ä¼šç›¸å…³ã€‚ ç›¸å…³çš„ä¸¤ä¸ªå˜é‡ï¼Œåœ¨ç»™å®šå¦ä¸€ä¸ªå˜é‡åï¼Œå¯èƒ½ä¼šæ¡ä»¶ç‹¬ç«‹ã€‚ æœ´ç´ è´å¶æ–¯æ¨¡å‹ ä½¿ç”¨æœ´ç´ è´å¶æ–¯è¿›è¡Œæ–‡æœ¬åˆ†ç±» ç»™å®šåŸå› æ—¶ï¼Œæ‰€æœ‰ç»“æœéƒ½æ˜¯æ¡ä»¶ç‹¬ç«‹çš„ï¼Œé‚£ä¹ˆå®Œå…¨è”åˆåˆ†å¸ƒå¯å†™ä½œï¼š P(Cause,Â Effect1,â€¦,Effectn)=P(Cause)âˆiP(Effectiâˆ£Cause) \\mathbf{P}\\left(\\right. Cause,~ Effect_{1}, \\ldots, Effect \\left._{n}\\right) = \\mathbf{P}( Cause ) \\prod_{i} \\mathbf{P}\\left(\\right. Effect _{i} \\mid Cause ) P(Cause,Â Effect1â€‹,â€¦,Effectnâ€‹)=P(Cause)iâˆâ€‹P(Effectiâ€‹âˆ£Cause) ç»å¸¸ä½œä¸ºåœ¨ç»™å®šåŸå› æ—¶ï¼Œç»“æœå˜é‡å¹¶ä¸æ˜¯ä¸¥æ ¼ç‹¬ç«‹çš„æƒ…å†µçš„è¿‘ä¼¼ã€‚ ç»™å®šä¸€äº›è§‚æµ‹ç»“æœï¼š P(Causeâˆ£e)=Î±âˆ‘yP(Cause,e,y) \\mathbf{P}( Cause \\mid \\mathbf{e})=\\alpha \\sum_{\\mathbf{y}} \\mathbf{P}( Cause , \\mathbf{e}, \\mathbf{y}) P(Causeâˆ£e)=Î±yâˆ‘â€‹P(Cause,e,y) è¿›ä¸€æ­¥ï¼š P(Â CauseÂ âˆ£e)=Î±âˆ‘yP(Â CauseÂ )P(yâˆ£Â CauseÂ )(âˆjP(ejâˆ£Â CauseÂ ))=Î±P(Â CauseÂ )(âˆjP(ejâˆ£Â CauseÂ ))âˆ‘yP(yâˆ£Â CauseÂ )=Î±P(Â CauseÂ )âˆjP(ejâˆ£Â CauseÂ ) \\begin{aligned} \\mathbf{P}(\\text { Cause } \\mid \\mathbf{e}) & =\\alpha \\sum_{\\mathbf{y}} \\mathbf{P}(\\text { Cause }) \\mathbf{P}(\\mathbf{y} \\mid \\text { Cause })\\left(\\prod_{j} \\mathbf{P}\\left(e_{j} \\mid \\text { Cause }\\right)\\right) \\\\ & =\\alpha \\mathbf{P}(\\text { Cause })\\left(\\prod_{j} \\mathbf{P}\\left(e_{j} \\mid \\text { Cause }\\right)\\right) \\sum_{\\mathbf{y}} \\mathbf{P}(\\mathbf{y} \\mid \\text { Cause }) \\\\ & =\\alpha \\mathbf{P}(\\text { Cause }) \\prod_{j} \\mathbf{P}\\left(e_{j} \\mid \\text { Cause }\\right) \\end{aligned} P(Â CauseÂ âˆ£e)â€‹=Î±yâˆ‘â€‹P(Â CauseÂ )P(yâˆ£Â CauseÂ )(jâˆâ€‹P(ejâ€‹âˆ£Â CauseÂ ))=Î±P(Â CauseÂ )(jâˆâ€‹P(ejâ€‹âˆ£Â CauseÂ ))yâˆ‘â€‹P(yâˆ£Â CauseÂ )=Î±P(Â CauseÂ )jâˆâ€‹P(ejâ€‹âˆ£Â CauseÂ )â€‹ å¯¹äºæ¯ä¸€ä¸ªå¯èƒ½çš„åŸå› ï¼Œå°†åŸå› çš„å…ˆéªŒæ¦‚ç‡è¯šæ„åœ¨ç»™å®šåŸå› æ—¶æ‰€è§‚æµ‹åˆ°çš„ç»“æœçš„æ¡ä»¶æ¦‚ç‡ï¼Œç„¶åå°†ç»“æœå½’ä¸€åŒ–ã€‚ è®¡ç®—å¤æ‚åº¦äºè§‚æµ‹åˆ°çš„ç»“æœæ•°é‡å‘ˆçº¿æ€§å…³ç³»ï¼Ÿä¸ä¾èµ–äºä¸ºè§‚æµ‹åˆ°çš„ç»“æœæ•°é‡ã€‚ "},"Learn/LearnAIMA/Ch13/Ch13.html":{"url":"Learn/LearnAIMA/Ch13/Ch13.html","title":"Ch13","keywords":"","body":"ç¬¬ 13 ç«  æ¦‚ç‡æ¨ç† 13.1 ä¸ç¡®å®šåŸŸçš„çŸ¥è¯†è¡¨ç¤º 13.2 è´å¶æ–¯ç½‘ç»œçš„è¯­ä¹‰ 13.2.1 è´å¶æ–¯ç½‘ç»œä¸­çš„æ¡ä»¶ç‹¬ç«‹æ€§å…³ç³» 13.2.2 æ¡ä»¶åˆ†å¸ƒçš„é«˜æ•ˆè¡¨ç¤º 13.2.3 è¿ç»­å˜é‡çš„è´å¶æ–¯ç½‘ç»œ 13.2.4 æ¡ˆä¾‹ç ”ç©¶ï¼šæ±½è½¦ä¿é™© 13.3 è´å¶æ–¯ç½‘ç»œä¸­çš„ç²¾ç¡®æ¨æ–­ 13.3.1 é€šè¿‡æšä¸¾è¿›è¡Œæ¨æ–­ 13.3.2 å˜é‡æ¶ˆå…ƒç®—æ³• 13.3.3 ç²¾ç¡®æ¨æ–­çš„å¤æ‚æ€§ 13.3.4 èšç±»ç®—æ³• 13.4 è´å¶æ–¯ç½‘ç»œä¸­çš„è¿‘ä¼¼æ¨ç† 13.4.1 ç›´æ¥é‡‡æ ·æ–¹æ³• 13.4.2 é€šè¿‡é©¬å°”å¯å¤«é“¾æ¨¡æ‹Ÿè¿›è¡Œæ¨æ–­ 13.4.3 ç¼–è¯‘è¿‘ä¼¼æ¨æ–­ 13.5 å› æœç½‘ç»œ 13.5.1 è¡¨ç¤ºåŠ¨ä½œï¼šdo æ“ä½œ 13.5.2 åé—¨å‡†åˆ™ æœ¬ç« ä»‹ç»äº†è´å¶æ–¯ç½‘ç»œï¼Œå®ƒæ˜¯ä¸€ç§å‘å±•æˆç†Ÿçš„ä¸ç¡®å®šçŸ¥è¯†è¡¨ç¤ºæ–¹æ³•ã€‚è´å¶æ–¯ç½‘ç»œçš„ä½œç”¨å¤§è‡´ç±»ä¼¼äºç¡®å®šçŸ¥è¯†çš„å‘½é¢˜é€»è¾‘ã€‚ è´å¶æ–¯ç½‘ç»œæ˜¯æœ‰å‘æ— ç¯å›¾ï¼Œå…¶ä¸­èŠ‚ç‚¹å¯¹åº”ç€éšæœºå˜é‡ï¼›ç»™å®šçˆ¶èŠ‚ç‚¹ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½èƒ½æ±‚å‡ºè¯¥èŠ‚ç‚¹çš„æ¡ä»¶åˆ†å¸ƒã€‚ è´å¶æ–¯ç½‘ç»œæä¾›äº†ä¸€ç§ç®€æ´çš„æ–¹æ³•æ¥è¡¨ç¤ºåŸŸå†…çš„æ¡ä»¶ç‹¬ç«‹æ€§å…³ç³»ã€‚ è´å¶æ–¯ç½‘ç»œæŒ‡å®šäº†å…¶å˜é‡çš„è”åˆæ¦‚ç‡åˆ†å¸ƒã€‚å¯¹æ‰€æœ‰å˜é‡çš„ä»»ä¸€èµ‹å€¼çš„æ¦‚ç‡å®šä¹‰ä¸ºå±€éƒ¨æ¡ä»¶åˆ†å¸ƒä¸­ç›¸åº”é¡¹çš„ä¹˜ç§¯ã€‚è´å¶æ–¯ç½‘ç»œé€šå¸¸æ¯”æ˜¾å¼æšä¸¾çš„è”åˆåˆ†å¸ƒå°å¾—å¤šã€‚ è®¸å¤šæ¡ä»¶åˆ†å¸ƒå¯ä»¥ç”¨æ­£è§„åˆ†å¸ƒæ—ç´§è‡´åœ°è¡¨ç¤ºã€‚æ··åˆè´å¶æ–¯ç½‘ç»œï¼ŒåŒ…æ‹¬ç¦»æ•£å˜é‡å’Œè¿ç»­å˜é‡ï¼Œä½¿ç”¨å„ç§æ­£åˆ™åˆ†å¸ƒã€‚ è´å¶æ–¯ç½‘ç»œä¸­çš„æ¨æ–­æ˜¯æŒ‡åœ¨ç»™å®šä¸€ç»„è¯æ®å˜é‡çš„æƒ…å†µä¸‹ï¼Œè®¡ç®—ä¸€ç»„æŸ¥è¯¢å˜é‡çš„æ¦‚ç‡åˆ†å¸ƒã€‚ç²¾ç¡®æ¨æ–­ç®—æ³•ï¼Œå¦‚å˜é‡æ¶ˆå…ƒï¼Œå°½å¯èƒ½é«˜æ•ˆåœ°è¯„ä¼°æ¡ä»¶æ¦‚ç‡ä¹˜ç§¯ä¹‹å’Œã€‚ åœ¨å¤šé‡æ ‘ï¼ˆå•è¿é€šç½‘ç»œï¼‰ä¸­ï¼Œç²¾ç¡®æ¨æ–­çš„æ—¶é—´ä¸ç½‘ç»œçš„è§„æ¨¡å‘ˆçº¿æ€§å…³ç³»ã€‚åœ¨ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œè¿™ä¸ªé—®é¢˜æ˜¯æ£˜æ‰‹çš„ã€‚ åƒä¼¼ç„¶åŠ æƒå’Œé©¬å°”å¯å¤«é“¾è’™ç‰¹å¡ç½—è¿™æ ·çš„éšæœºé‡‡æ ·æŠ€æœ¯å¯ä»¥ç»™å‡ºç½‘ç»œä¸­çš„çœŸå®åéªŒåˆ†å¸ƒåˆç†çš„ä¼°è®¡ï¼Œä¸ç²¾ç¡®ç®—æ³•ç›¸æ¯”ï¼Œå®ƒä»¬å¯ä»¥å¤„ç†è§„æ¨¡æ›´å¤§çš„ç½‘ç»œã€‚ è´å¶æ–¯ç½‘ç»œæ•æ‰æ¦‚ç‡å½±å“ï¼Œè€Œå› æœç½‘ç»œæ•æ‰å› æœå…³ç³»ï¼Œå¹¶å…è®¸å¯¹å¹²é¢„ç»“æœå’Œè§‚æµ‹å€¼è¿›è¡Œé¢„æµ‹ã€‚ "},"Learn/LearnAIMA/Ch13/BayesianNetwork.html":{"url":"Learn/LearnAIMA/Ch13/BayesianNetwork.html","title":"BayesianNetwork","keywords":"","body":"è´å¶æ–¯ç½‘ç»œ Bayesian Network å…³äºç†è§£è´å¶æ–¯ç½‘ç»œçš„å‡ ç‚¹æ³¨æ„äº‹é¡¹ è´å¶æ–¯ç½‘ç»œä¸¤ç§å‡ºå‘ç‚¹ç•¥æœ‰å·®å¼‚çš„å®šä¹‰ï¼š ç¬¬ä¸€ç§å®šä¹‰ï¼Œä¹Ÿæ˜¯ AIMA ä¸­çš„å®šä¹‰ï¼Œå…¶é€»è¾‘æ˜¯ï¼š é¦–å…ˆå®šä¹‰èŠ‚ç‚¹å…·æœ‰å‚æ•°$\\theta$ï¼Œå°†å®Œå…¨è”åˆåˆ†å¸ƒå®šä¹‰ä¸ºï¼š P(x1,â€¦,xn)=âˆi=1nÎ¸(xiâˆ£parents(Xi)) P\\left(x_{1}, \\ldots, x_{n}\\right)=\\prod_{i=1}^{n} \\theta\\left(x_{i} \\mid\\right. parents \\left.\\left(X_{i}\\right)\\right) P(x1â€‹,â€¦,xnâ€‹)=i=1âˆnâ€‹Î¸(xiâ€‹âˆ£parents(Xiâ€‹)) ç„¶åæ¥ç€ç”±æ¡ä»¶åˆ†å¸ƒçš„å®šä¹‰å¼ï¼Œä»£å…¥å‚æ•°$\\theta$ï¼Œå‘ç°æ¡ä»¶æ¦‚ç‡â€œæ°å¥½â€ç­‰äº$\\theta$ï¼š P(xiâˆ£Â parentsÂ (Xi))â‰¡P(xi,Â parentsÂ (Xi))P(Â parentsÂ (Xi))=âˆ‘yP(xi,parentsâ¡(Xi),y)âˆ‘xiâ€²,yP(xiâ€²,parentsâ¡(Xi),y)=Î¸(xiâˆ£parents(Xi)) \\begin{aligned} P\\left(x_{i} \\mid \\text { parents }\\left(X_{i}\\right)\\right) & \\equiv \\frac{P\\left(x_{i}, \\text { parents }\\left(X_{i}\\right)\\right)}{P\\left(\\text { parents }\\left(X_{i}\\right)\\right)} \\\\ \\\\ & =\\frac{\\sum_{\\mathbf{y}} P\\left(x_{i}, \\operatorname{parents}\\left(X_{i}\\right), \\mathbf{y}\\right)}{\\sum x_{i}^{\\prime}, \\mathbf{y} P\\left(x_{i}^{\\prime}, \\operatorname{parents}\\left(X_{i}\\right), \\mathbf{y} \\right) } \\\\\\\\ & = \\theta\\left(x_{i} \\mid\\right. \\text{parents} \\left.\\left(X_{i}\\right)\\right) \\end{aligned} P(xiâ€‹âˆ£Â parentsÂ (Xiâ€‹))â€‹â‰¡P(Â parentsÂ (Xiâ€‹))P(xiâ€‹,Â parentsÂ (Xiâ€‹))â€‹=âˆ‘xiâ€²â€‹,yP(xiâ€²â€‹,parents(Xiâ€‹),y)âˆ‘yâ€‹P(xiâ€‹,parents(Xiâ€‹),y)â€‹=Î¸(xiâ€‹âˆ£parents(Xiâ€‹))â€‹ äºæ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç½‘ç»œä¸­çš„å‚æ•°ï¼Œâ€œè§£é‡Šâ€ä¸ºæ¡ä»¶æ¦‚ç‡ã€‚ äºæ˜¯ï¼Œå®Œå…¨è”åˆåˆ†å¸ƒå¯ä»¥æ”¹å†™ä¸ºï¼šï¼ˆç”±å®šä¹‰ã€æ¦‚ç‡å…¬ç†å¯¼å‡ºçš„å®šç†ï¼‰ P(x1,â€¦,xn)=âˆi=1nP(xiâˆ£parents(Xi)) P\\left(x_{1}, \\ldots, x_{n}\\right)=\\prod_{i=1}^{n} P\\left(x_{i} \\mid\\right. parents \\left.\\left(X_{i}\\right)\\right) P(x1â€‹,â€¦,xnâ€‹)=i=1âˆnâ€‹P(xiâ€‹âˆ£parents(Xiâ€‹)) åŸºäºä¸Šå¼ï¼ˆå®Œå…¨è”åˆåˆ†å¸ƒçš„æ”¹å†™å¼ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥å¯¼å‡ºä¸€äº›ç‹¬ç«‹æ€§å…³ç³»ï¼Œå¦‚â€œç»™å®šçˆ¶èŠ‚ç‚¹æ—¶çš„æ¡ä»¶ç‹¬ç«‹æ€§â€ï¼Œâ€œç»™å®šé©¬å°”å¯å¤«æ¯¯æ—¶çš„æ¡ä»¶ç‹¬ç«‹æ€§â€ã€‚ ï¼ˆæ³¨æ„ï¼Œè¿™äº›ç‹¬ç«‹æ€§å®šç†ï¼Œæ˜¯ç”±æ¦‚ç‡å›¾æ¨¡å‹çš„å®šä¹‰æ‰€æ¨å‡ºçš„ï¼Œä¹Ÿå°±æ˜¯æ¨å‡ºäº†æ¡ä»¶ç‹¬ç«‹çš„å®šä¹‰å¼ï¼Œè¿›è€Œè¯´æ˜å­˜åœ¨ä¸Šè¿°çš„ç‹¬ç«‹æ€§å®šç†ï¼‰ ç¬¬äºŒç§ç±»å‹çš„å®šä¹‰ï¼Œæ˜¯ç›´æ¥å°†è´å¶æ–¯ç½‘ç»œèŠ‚ç‚¹çš„å‚æ•°$\\theta\\left(x{i} \\mid\\right. parents \\left.\\left(X{i}\\right)\\right)$ï¼Œå®šä¹‰ä¸ºæ¡ä»¶æ¦‚ç‡åˆ†å¸ƒ$P\\left(x{i} \\mid\\right. parents \\left.\\left(X{i}\\right)\\right)$ï¼Œä¹Ÿå°±æ˜¯ç›´æ¥ç»™å‡ºæ¨¡å‹çš„å‚æ•°çš„è¯­ä¹‰ï¼š P(xiâˆ£parents(Xi))=Î¸(xiâˆ£parents(Xi)) P\\left(x_{i} \\mid\\right. parents \\left.\\left(X_{i}\\right)\\right) = \\theta\\left(x_{i} \\mid\\right. parents \\left.\\left(X_{i}\\right)\\right) P(xiâ€‹âˆ£parents(Xiâ€‹))=Î¸(xiâ€‹âˆ£parents(Xiâ€‹)) ç„¶åå†ç»™å‡ºå‡è®¾â€œç»™å®šçˆ¶èŠ‚ç‚¹ï¼Œå­èŠ‚ç‚¹æ¡ä»¶ç‹¬ç«‹â€ï¼Œè¯¥å‡è®¾åˆç§°ä¸ºâ€œé©¬å°”å¯å¤«å‡è®¾â€ã€‚ ä¸Šè¿°å®šä¹‰+å‡è®¾ï¼ŒåŒæ ·å¯ä»¥æ¨å¯¼å‡ºâ€œå®Œå…¨è”åˆåˆ†å¸ƒçš„æ”¹å†™å¼â€ï¼Œå³ï¼š P(x1,â€¦,xn)=âˆi=1nP(xiâˆ£parents(Xi)) P\\left(x_{1}, \\ldots, x_{n}\\right)=\\prod_{i=1}^{n} P\\left(x_{i} \\mid\\right. parents \\left.\\left(X_{i}\\right)\\right) P(x1â€‹,â€¦,xnâ€‹)=i=1âˆnâ€‹P(xiâ€‹âˆ£parents(Xiâ€‹)) äºæ˜¯ï¼Œè¿™ä¸¤ç§å®šä¹‰æ–¹å¼ï¼Œå®é™…ä¸Šæ˜¯ç­‰ä»·çš„ï¼Œåªæ˜¯å‡ºå‘ç‚¹ä¸åŒã€‚ ç¬¬ä¸€ç§å®šä¹‰å‡ºå‘ç‚¹åœ¨äºâ€œä¸€ä¸ªæ¦‚ç‡æ¨¡å‹å¯ä»¥ç”±å®Œå…¨è”åˆæ¦‚ç‡åˆ†å¸ƒå®Œå…¨ç¡®å®šâ€ï¼Œå› æ­¤ç›´æ¥å®šä¹‰äº†å®Œå…¨è”åˆæ¦‚ç‡åˆ†å¸ƒã€‚ ç¬¬äºŒç§å®šä¹‰æ›´è´´åˆå®é™…å»ºæ¨¡çš„éœ€è¦ï¼Œå³ï¼Œåœ¨å¯¹é—®é¢˜å»ºæ¨¡æ—¶ï¼Œæˆ‘ä»¬â€œåˆç†åœ°â€å¼•å…¥é©¬å°”ç§‘å¤«å‡è®¾ï¼Œæ„å»ºèµ·é—®é¢˜çš„æ¦‚ç‡å›¾æ¨¡å‹ï¼Œä»¥æ±‚è§£é—®é¢˜æŸ¥è¯¢ã€‚ æ³¨æ„ï¼Œâ€œç»™å®šçˆ¶èŠ‚ç‚¹ï¼Œå­èŠ‚ç‚¹ä¹‹é—´ç›¸äº’æ¡ä»¶ç‹¬ç«‹â€ï¼Œè¿™ä¸ªå‘½é¢˜æ˜¯ä¸ä¸€å®šæˆç«‹çš„ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ç¬¬ä¸€ç§å®šä¹‰ä¸­ï¼Œæ¨å¯¼å‡ºè¿™æ¡å®šç†ï¼Œä¹Ÿå¯ä»¥åœ¨ç¬¬äºŒç§å®šä¹‰ä¸­ï¼Œç›´æ¥å¼•å…¥å‰æå‡è®¾ã€‚è¿™ä¸ªå‘½é¢˜ä¸æ˜¯æ˜¾ç„¶åœ°ï¼Œå¹³å‡¡åœ°æˆç«‹çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ä¸ªå‘½é¢˜çš„æˆç«‹æ˜¯ä¸€ä¸ªå‡è®¾ â€” ç»™å®šçˆ¶èŠ‚ç‚¹ï¼Œå­èŠ‚ç‚¹å½“ç„¶å¯èƒ½ä¸æ¡ä»¶ç‹¬ç«‹ã€‚ æ³¨æ„ï¼Œâ€œæ¡ä»¶ç‹¬ç«‹â€çš„æ€§è´¨ï¼Œä¸æ˜¯ä»â€œäº‹ç†â€ä¸Šè¯æ˜çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸æ˜¯â€œç»™å®šçˆ¶èŠ‚ç‚¹ï¼Œå­èŠ‚ç‚¹è‡ªç„¶è€Œç„¶å°±æ¡ä»¶ç‹¬ç«‹äº†â€ï¼Œå­èŠ‚ç‚¹çš„æ¡ä»¶ç‹¬ç«‹æ˜¯é€šè¿‡æ¦‚ç‡å›¾æ¨¡å‹çš„å®šä¹‰å¯¼å‡ºçš„ã€‚ è‡³äºæ‰€è°“çš„â€œç»™å®šåŸå› ï¼Œç»“æœå°±æ¡ä»¶ç‹¬ç«‹â€çš„ç›´è§‚è®¤è¯†ï¼Œæ˜¯ä¸ºäº†ä¾¿äºæˆ‘ä»¬æ›´å¥½åœ°ç†è§£è¿™æ¡å®šç†ï¼Œè€Œä¸æ˜¯ä½œä¸ºè¿™æ¡å®šç†æˆç«‹çš„åŸå› ã€‚ æ¦‚ç‡å›¾æ¨¡å‹+é©¬å°”å¯å¤«å‡è®¾=è´å¶æ–¯ç½‘ç»œï¼Ÿ åˆç§° ä¿¡å¿µç½‘ç»œ Belief Network ä½¿ç”¨æœ‰å‘æ— ç¯å›¾ DAG æ¥åˆ»ç”»å±æ€§ä¹‹é—´çš„ä¾èµ–å…³ç³» ä½¿ç”¨æ¡ä»¶æ¦‚ç‡è¡¨ CPT æ¥æè¿°å±æ€§çš„è”åˆæ¦‚ç‡åˆ†å¸ƒ å®šä¹‰ ä¸€ä¸ªè´å¶æ–¯ç½‘ $B$ ç”±ç»“æ„ $G$ å’Œå‚æ•° $\\Theta$ ä¸¤éƒ¨åˆ†æ„æˆ, å³ $B=\\langle G, \\Theta\\rangle$ ç½‘ç»œç»“æ„ $G$ æ˜¯ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼Œå…¶æ¯ä¸ªç»“ç‚¹å¯¹åº”äºä¸€ä¸ªå±æ€§ï¼Œè‹¥ä¸¤ä¸ªå±æ€§æœ‰ç›´æ¥ä¾èµ–å…³ç³»ï¼Œåˆ™å®ƒä»¬ç”±ä¸€æ¡è¾¹è¿æ¥èµ·æ¥ï¼› å‚æ•° $\\Theta$ å®šé‡æè¿°è¿™ç§ä¾èµ–å…³ç³»ï¼Œå‡è®¾å±æ€§ $x{i} $åœ¨ $G$ ä¸­çš„çˆ¶ç»“ç‚¹é›†ä¸º $\\pi{i}$ï¼Œåˆ™$ \\Theta$ åŒ…å«äº†æ¯ä¸ªå±æ€§çš„æ¡ä»¶æ¦‚ç‡è¡¨ $\\theta{x{i} \\mid \\pi{i}}=P{B}\\left(x{i} \\mid \\pi{i}\\right)$ å…¸å‹ç»“æ„ï¼š åŒçˆ¶ç»“æ„/åˆ†å‰ç»“æ„ï¼š ç»™å®šçˆ¶èŠ‚ç‚¹$x_1$çš„å–å€¼ï¼Œ$x_3$ä¸$x_4$æ¡ä»¶ç‹¬ç«‹ï¼› è‹¥çˆ¶èŠ‚ç‚¹å–å€¼æœªçŸ¥ï¼Œåˆ™å­èŠ‚ç‚¹ä¸æ¡ä»¶ç‹¬ç«‹ï¼› é¡ºåºç»“æ„/ä¸²è¡Œç»“æ„ï¼š ç»™å®šä¸­é—´èŠ‚ç‚¹$x$çš„å–å€¼ï¼Œ$y$ä¸$z$æ¡ä»¶ç‹¬ç«‹ï¼› åŒç†ï¼Ÿ V å‹ç»“æ„/æ±‡èšç»“æ„/å†²æ’ç»“æ„ï¼š ç»™å®šå­èŠ‚ç‚¹$x_4$çš„å–å€¼ï¼Œ$x_1$ä¸$x_2$å¿…ä¸ç‹¬ç«‹ï¼› è‹¥å­èŠ‚ç‚¹$x_4$æœªçŸ¥ï¼Œåˆ™$x_1$ä¸$x_2$ç‹¬ç«‹ï¼Œç§°ä½œâ€œè¾¹é™…ç‹¬ç«‹æ€§â€Marginal Independenceã€‚ $x_4 $ç§°ä½œç¢°æ’å› å­ å¦‚ä½•åˆ†æè´å¶æ–¯ç½‘ç»œä¸­å˜é‡é—´çš„æ¡ä»¶ç‹¬ç«‹æ€§å‘¢ï¼Ÿ æœ‰å‘åˆ†ç¦» D-Speration å¯¹äºç½‘ç»œä¸­çš„å˜é‡$x$ï¼Œ$y$å’Œå˜é‡é›†åˆ$\\mathbf{Z}$ï¼Œ$x$å’Œ$y$è¢«$\\mathbf{Z}$æœ‰å‘åˆ†ç¦»ï¼ˆ$x \\perp y \\mid \\mathbf{Z}$ï¼‰ï¼Œå®šä¹‰ä¸ºï¼š åªç ”ç©¶ç¥–å…ˆå­å›¾Ancestral Subgraphï¼š$\\mathbf{X}$ã€$\\mathbf{Y}$ã€$\\mathbf{Z}$å’Œ å®ƒä»¬çš„ç¥–å…ˆ é“å¾·åŒ–ï¼šå°† DAG è½¬æ¢æˆé“å¾·å›¾ï¼š æ‰¾å‡º DAG ä¸­æ‰€æœ‰çš„ V å‹ç»“æ„ï¼Œåœ¨ V å‹ç»“æ„çš„ä¸¤ä¸ªçˆ¶èŠ‚ç‚¹ä¹‹é—´æ·»åŠ ä¸€æ¡æ— å‘è¾¹ å°†æ‰€æœ‰çš„æœ‰å‘è¾¹æ”¹ä¸ºæ— å‘è¾¹ PSï¼šâ€œé“å¾·åŒ–â€çš„å«ä¹‰æ˜¯-å­©å­çš„çˆ¶æ¯ä¹‹é—´åº”å»ºç«‹ç‰¢å›ºçš„å…³ç³»ï¼Œå¦åˆ™æ˜¯ä¸â€œé“å¾·â€çš„ã€‚ $\\mathbf{Z}$é˜»å¡äº†$x$ä¸$y$ä¹‹é—´çš„è·¯å¾„ï¼Œä¹Ÿå°±æ˜¯å°†å˜é‡é›†åˆ$\\mathbf{Z}$å»é™¤ä¹‹åï¼Œ$x$å’Œ$y$åˆ†å±äºä¸¤ä¸ªè”é€šåˆ†æ”¯ã€‚ åˆ™ç§°$x$å’Œ$y$è¢«$\\mathbf{Z}$æœ‰å‘åˆ†ç¦»ï¼Œ$x$å’Œ$y$åœ¨ç»™å®š$\\mathbf{Z}$æ—¶æ¡ä»¶ç‹¬ç«‹ã€‚ MLBOP è´å¶æ–¯å’Œä¼˜åŒ–æ–¹æ³• å®šä¹‰ æ´»è·ƒé“¾ èŠ‚ç‚¹é“¾$x_1, \\cdots x_n$åœ¨ç»™å®šé›†åˆ$\\mathbf{Z}$æ—¶æ˜¯æ´»è·ƒçš„ï¼Œæ»¡è¶³ï¼š å¯¹äºèŠ‚ç‚¹é“¾ä¸­ä»»æ„çš„ä¸€ä¸ª V å‹ç»“æ„$x{i-1}\\rightarrow x_i \\leftarrow x{i+1}$ï¼Œéƒ½æœ‰$x_i$æˆ–$x_i$çš„æŸä¸ªåä»£åœ¨$\\mathbf{Z}$ä¸­ï¼› é™¤ä¸Šè¿°ä¹‹å¤–ï¼Œæ²¡æœ‰å…¶ä»–ä»»ä½•èŠ‚ç‚¹åœ¨$\\mathbf{Z}$ä¸­ã€‚ å³ï¼šåœ¨ä¸€æ¡æ´»è·ƒçš„é“¾ä¸­ï¼Œæ¦‚ç‡è¯æ®ç»è¿‡$\\mathbf{Z}$ï¼Œå¯ä»¥ç•…é€šåœ°ä»$x_1$æµåˆ°$x_n$ï¼ˆæˆ–åå‘ï¼‰ å®šä¹‰ æœ‰å‘åˆ†ç¦» å¯¹äºè´å¶æ–¯ç½‘ç»œ Bï¼Œ$\\mathbf{X}$ã€$\\mathbf{Y}$ã€$\\mathbf{Z}$æ˜¯ B ä¸­ä¸‰ä¸ªä¸ç›¸äº¤çš„èŠ‚ç‚¹é›†ï¼Œè‹¥ç»™å®š $\\mathbf{Z}$ çš„æ¡ä»¶ä¸‹ï¼Œ$\\mathbf{X}$ å’Œ$\\mathbf{Y}$ ä¹‹é—´çš„ä»»æ„èŠ‚ç‚¹å¯¹ $\\forall x\\in \\mathbf{X}, y \\in \\mathbf{Y}, ~ (x,y)$ ä¹‹é—´ï¼Œéƒ½ä¸å­˜åœ¨æ´»è·ƒé“¾ã€‚åˆ™ç§° $\\mathbf{X}$ å’Œ$\\mathbf{Y}$ åœ¨ç»™å®š $\\mathbf{Z}$ çš„æ¡ä»¶ä¸‹æ˜¯â€œæœ‰å‘åˆ†ç¦»â€çš„ã€‚å¦‚æœä¸æ˜¯æœ‰å‘åˆ†ç¦»çš„ï¼Œåˆ™ç§° $\\mathbf{X}$ å’Œ $\\mathbf{Y}$ æ˜¯æœ‰å‘è¿é€šçš„ã€‚ AIMA2 è¯­æ³•ï¼šæ¯ä¸€ä¸ªèŠ‚ç‚¹$Xi$éƒ½é™„åŠ ä¸€äº›å±€éƒ¨æ¦‚ç‡ä¿¡$\\theta\\left(x{i} \\mid\\right. parents \\left.\\left(X_{i}\\right)\\right)$çš„æœ‰å‘æ— ç¯å›¾ è¯­ä¹‰ï¼šä¸Šè¿°æ¦‚ç‡ä¿¡æ¯å’Œå›¾å¦‚ä½•å¯¹åº”äºç½‘ç»œä¸­å˜é‡çš„è”åˆæ¦‚ç‡åˆ†å¸ƒï¼Ÿ å°†è”åˆæ¦‚ç‡åˆ†å¸ƒä¸­çš„æ¯ä¸ªæ¡ç›®â€œå®šä¹‰â€å¦‚ä¸‹ï¼š P(x1,â€¦,xn)=âˆi=1nÎ¸(xiâˆ£parents(Xi)) P\\left(x_{1}, \\ldots, x_{n}\\right)=\\prod_{i=1}^{n} \\theta\\left(x_{i} \\mid\\right. parents \\left.\\left(X_{i}\\right)\\right) P(x1â€‹,â€¦,xnâ€‹)=i=1âˆnâ€‹Î¸(xiâ€‹âˆ£parents(Xiâ€‹)) æˆ‘ä»¬æ˜¯è¿™æ ·å®šä¹‰çš„ï¼Œä½†æ˜¯ï¼Œå±€éƒ¨æ¦‚ç‡å€¼åˆ°åº•æ˜¯ä»€ä¹ˆï¼Ÿå¯¹åº”äºä»€ä¹ˆå‘¢ï¼Ÿ ç­”æ¡ˆæ˜¯ï¼Œç½‘ç»œä¸­çš„â€œå‚æ•°â€/å±€éƒ¨æ¦‚ç‡å€¼ï¼Œå°±æ˜¯è”åˆåˆ†å¸ƒä¸­æ‰€éšå«çš„æ¡ä»¶æ¦‚ç‡$P\\left(x{i} \\mid\\right. parents \\left.\\left(X{i}\\right)\\right)$ æ¡ä»¶æ¦‚ç‡åˆ†å¸ƒ\">è¯æ˜ è´å¶æ–¯ç½‘ç»œå‚æ•°æ¡ä»¶æ¦‚ç‡åˆ†å¸ƒ ä¸ºä»€ä¹ˆä¸ç›´æ¥å°†å‚æ•°å®šä¹‰æˆæ¡ä»¶æ¦‚ç‡å€¼ï¼Ÿ è€Œæ˜¯å…ˆç”±å‚æ•°å®šä¹‰è”åˆæ¦‚ç‡ï¼Œç„¶åå†æ¨å¯¼å‡ºè¿™äº›å‚æ•°å°±æ˜¯æ¡ä»¶æ¦‚ç‡ï¼Ÿ è´å¶æ–¯ç½‘ç»œä¸­çš„æ¡ä»¶ç‹¬ç«‹æ€§å…³ç³» æ€§è´¨ 1-éå­å­™æ€§è´¨ï¼šç»™å®šçˆ¶èŠ‚ç‚¹ï¼Œæ¯ä¸ªæ¡ä»¶å˜é‡ç‹¬ç«‹äºå®ƒçš„éå­å­™èŠ‚ç‚¹ æ€§è´¨ 2-é©¬å°”å¯å¤«æ¯¯æ€§è´¨ï¼šç»™å®šä¸€ä¸ªå˜é‡çš„çˆ¶èŠ‚ç‚¹ã€å­èŠ‚ç‚¹ã€å­èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œè¯¥å˜é‡æ¡ä»¶ç‹¬ç«‹äºç½‘ç»œä¸­çš„æ‰€æœ‰å…¶ä»–èŠ‚ç‚¹ã€‚ å¦‚ä½•è¯æ˜ä¸Šè¿°æ€§è´¨ï¼Ÿ æ¡ä»¶åˆ†å¸ƒçš„é«˜æ•ˆè¡¨ç¤º è´å¶æ–¯ç½‘ç»œèŠ‚ç‚¹é—´çš„ä¾èµ–å…³ç³»ç”±æ¡ä»¶åˆ†å¸ƒè¡¨ç¤ºï¼Œå‡è®¾æŸèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹éƒ½ä¸ºå¸ƒå°”å‹å˜é‡ï¼Œçˆ¶èŠ‚ç‚¹æ•°ä¸º kï¼Œåˆ™å¡«å†™è¯¥èŠ‚ç‚¹çš„æ¡ä»¶æ¦‚ç‡è¡¨ CPT å°±è¦æœ‰$2^k$ä¸ªæ•°å€¼ï¼Œä¸”éœ€è¦æˆ‘ä»¬å¯¹æ‰€æœ‰å¯èƒ½çš„æ¡ä»¶äº‹å®æœ‰å¤§é‡çš„ç»éªŒï¼ˆæ„å‘³ç€è¦æœ‰å¾ˆå¤šçš„æ•°æ®å—ï¼Ÿï¼‰ è´å¶æ–¯ç½‘ç»œç³»ç»Ÿï¼Ÿï¼Ÿæœ‰è½¯ä»¶å¯ä»¥ä½¿ç”¨å—ï¼Ÿ ç»™å®šä¸€äº›â€œæ¨¡å¼â€ï¼Œå¹¶æä¾›ä¸€äº›å‚æ•°ï¼Œä¸¤è€…ç»„åˆæ¥æŒ‡å®šå®Œæ•´çš„è¡¨ï¼Ÿ ç¡®å®šæ€§èŠ‚ç‚¹ï¼šå…¶å€¼ç”±å…¶çˆ¶èŠ‚ç‚¹çš„å€¼å®Œå…¨ç¡®å®šï¼Œæ²¡æœ‰ä¸ç¡®å®šæ€§ã€‚å¯ä»¥æ˜¯é€»è¾‘å…³ç³»ã€æ•°å€¼å…³ç³» ç‰¹å®šäºä¸Šä¸‹æ–‡çš„ç‹¬ç«‹æ€§ï¼ŸCSI å¦‚æœç»™å®šå…¶ä»–å˜é‡çš„æŸäº›å€¼ï¼Œä¸€ä¸ªå˜é‡æ¡ä»¶ç‹¬ç«‹äºå®ƒçš„ä¸€äº›çˆ¶èŠ‚ç‚¹ï¼Œåˆ™è¿™ä¸ªæ¡ä»¶åˆ†å¸ƒå­˜åœ¨ CSIã€‚ å¦‚ï¼šæ±½è½¦æ˜¯å¦æŸå Damage ä¾èµ–äºè½¦çš„åšå›ºç¨‹åº¦ Ruggedeness å’Œæ±½è½¦å¦å‘ç”Ÿäº†äº‹æ•… Accidentã€‚ ä½†æ˜¯ï¼Œå¦‚æœçŸ¥é“ Accident=Falseï¼Œå³æ±½è½¦æ²¡æœ‰å‘ç”Ÿäº‹æ•…ï¼Œé‚£ä¹ˆï¼ŒDamage ä¸å†ä¾èµ–äºå…¶æ±½è½¦çš„åšå›ºç¨‹åº¦ï¼ˆå¿½ç•¥å¯èƒ½å¯¼è‡´æ±½è½¦æŸåçš„å…¶ä»–å› ç´ ï¼‰ã€‚è´å¶æ–¯ç³»ç»Ÿé€šå¸¸ä½¿ç”¨æ¡ä»¶åˆ¤æ–­ ifelse è¯­æ³•æ¥æŒ‡å®šæ¡ä»¶åˆ†å¸ƒï¼Œä»¥å®ç° CSIï¼Œå¦‚ï¼š P(Â DamageÂ âˆ£Â Ruggedness,Â Â AccidentÂ )=Â ifÂ (Â AccidentÂ =Â falseÂ )Â thenÂ d1Â elseÂ d2Â (RuggednessÂ ) \\begin{array}{l}\\mathbf{P}(\\text { Damage } \\mid \\text { Ruggedness, } \\text { Accident })= \\\\ \\left.\\text { if }(\\text { Accident }=\\text { false }) \\text { then } d_{1} \\text { else } d_{2} \\text { (Ruggedness }\\right)\\end{array} P(Â DamageÂ âˆ£Â Ruggedness,Â Â AccidentÂ )=Â ifÂ (Â AccidentÂ =Â falseÂ )Â thenÂ d1â€‹Â elseÂ d2â€‹Â (RuggednessÂ )â€‹ å™ªå£°é€»è¾‘å…³ç³»-åˆ»ç”»ä¸ç¡®å®šå…³ç³» â€œå™ªå£°æˆ–â€å…³ç³»ï¼Œä¸ºçˆ¶èŠ‚ç‚¹å¯¼è‡´å­èŠ‚ç‚¹ä¸ºçœŸçš„èƒ½åŠ›å¼•å…¥ä¸ç¡®å®šæ€§ï¼Œçˆ¶èŠ‚ç‚¹ä¸å­èŠ‚ç‚¹é—´çš„å› æœå…³ç³»å¯èƒ½ä¼šè¢«æŠ‘åˆ¶ï¼Œä¹Ÿå°±æ˜¯å¤±æ•ˆã€‚ æ¨¡å‹çš„ä¸¤ä¸ªå‡è®¾ï¼š å‡è®¾æ‰€æœ‰å¯èƒ½çš„åŸå› éƒ½è¢«åˆ—å‡º å‡è®¾æ¯ä¸ªçˆ¶èŠ‚ç‚¹å¯¹å­èŠ‚ç‚¹çš„å› æœå…³ç³»çš„æŠ‘åˆ¶æ˜¯ç›¸äº’ç‹¬ç«‹çš„ ç”±æ­¤å¯çŸ¥ï¼Œå­èŠ‚ç‚¹ä¸ºå‡ï¼Œå½“ä¸”ä»…å½“ï¼Œå®ƒæ‰€æœ‰ä¸ºçœŸçš„çˆ¶èŠ‚ç‚¹éƒ½è¢«æŠ‘åˆ¶ï¼Œå…¶æ¡ä»¶æ¦‚ç‡è¡¨ä¸ºï¼š P(xiâˆ£parents(Xi))=1âˆ’âˆ{j:Xj=Â trueÂ }qj P\\left(x_{i} \\mid\\right. parents \\left.\\left(X_{i}\\right)\\right)=1-\\prod_{\\left\\{j: X_{j}=\\text { true }\\right\\}} q_{j} P(xiâ€‹âˆ£parents(Xiâ€‹))=1âˆ’{j:Xjâ€‹=Â trueÂ }âˆâ€‹qjâ€‹ ä¾èµ–äº$k$ä¸ªçˆ¶èŠ‚ç‚¹çš„å˜é‡çš„å™ªå£°é€»è¾‘å…³ç³»ï¼Œå¯ä»¥ä½¿ç”¨$O(k)$ä¸ªå‚æ•°ï¼Œè€Œé$O(2^k)$ä¸ªï¼Œæ¥æè¿°å®Œå…¨æ¡ä»¶æ¦‚ç‡è¡¨ã€‚ è¿ç»­å˜é‡çš„è´å¶æ–¯ç½‘ç»œ æ–¹æ³•ï¼š1 è¿ç»­å˜é‡ç¦»æ•£åŒ– 2 ç”¨ä¸€æ—æ ‡å‡†çš„æ¦‚ç‡å¯†åº¦å‡½æ•°æ¥å®šä¹‰è¿ç»­å˜é‡ æ··åˆè´å¶æ–¯ç½‘ç»œ-åŒæ—¶å…·æœ‰ç¦»æ•£å’Œè¿ç»­å˜é‡ è¿ç»­ â†’ è¿ç»­ï¼›è¿ç»­ â†’ ç¦»æ•£ï¼›ç¦»æ•£ â†’ è¿ç»­ï¼›ç¦»æ•£ â†’ ç¦»æ•£ã€‚ å¿…é¡»æŒ‡å®š/ç¡®å®šä¸¤ç§åˆ†å¸ƒï¼š å…·æœ‰ç¦»æ•£æˆ–è¿ç»­çˆ¶èŠ‚ç‚¹çš„è¿ç»­å‹å˜é‡çš„æ¡ä»¶åˆ†å¸ƒ å…·æœ‰è¿ç»­çˆ¶èŠ‚ç‚¹çš„ç¦»æ•£å‹éšæœºå˜é‡çš„æ¡ä»¶åˆ†å¸ƒ ç¦»æ•£ â†’ è¿ç»­ï¼šæšä¸¾ç¦»æ•£çˆ¶èŠ‚ç‚¹çš„å¯èƒ½å€¼ï¼Œä¸ºæ¯ä¸ªå¯èƒ½å€¼é€‰æ‹©ä¸€ä¸ªåˆ†å¸ƒã€‚ è¿ç»­ xâ†’ è¿ç»­ yï¼šæŒ‡å®š y çš„åˆ†å¸ƒå¦‚ä½•ä¾èµ–äº xï¼Œå³å°† y çš„æ ‡å‡†åˆ†å¸ƒä¸­çš„å‚æ•°ï¼ŒæŒ‡å®šä¸º x çš„å‡½æ•°ã€‚ y çš„åˆ†å¸ƒå±äºä¸€ç»„æ¦‚ç‡å¯†åº¦å‡½æ•°ï¼Œy åˆ†å¸ƒçš„å‚æ•°ä¾èµ–äº xã€‚ å¦‚çº¿æ€§é«˜æ–¯åˆ†å¸ƒï¼š P(yâˆ£x)=N(y;aâ‹…x+b,Ïƒ2)=1Ïƒ(2Ï€)1/2eâˆ’12(yâˆ’(aâ‹…h+b)Ïƒ)2 P(y \\mid x)= \\mathcal{N}\\left(y ; a \\cdot x +b, \\sigma^{2}\\right)= \\frac{1}{\\sigma (2 \\pi)^{1/2}} e^{-\\frac{1}{2}\\left(\\frac{y-\\left(a\\cdot h+b\\right)}{\\sigma}\\right)^{2}} P(yâˆ£x)=N(y;aâ‹…x+b,Ïƒ2)=Ïƒ(2Ï€)1/21â€‹eâˆ’21â€‹(Ïƒyâˆ’(aâ‹…h+b)â€‹)2 y çš„æ¡ä»¶åˆ†å¸ƒçš„å‡å€¼$\\mu=a \\cdot x +b$éšçˆ¶èŠ‚ç‚¹çš„å€¼$x$çº¿æ€§å˜åŒ–ï¼Œæ ‡å‡†å·®$\\sigma^{2}$å›ºå®šã€‚ è¿ç»­ â†’ ç¦»æ•£ï¼šæ ¹æ®æƒ…æ™¯ç¡®å®šï¼Ÿ Costâ†’Buysï¼šä»·æ ¼ä½ï¼Œä¼šè´­ä¹°ï¼›ä»·æ ¼é«˜ï¼Œä¸ä¼šä¹°ï¼›ä»·æ ¼å¤„äºä¸­é—´åŒºåŸŸï¼Œä¹°çš„æ¦‚ç‡å¹³ç¨³å˜åŒ–ã€‚ åƒä¸€ä¸ªâ€œè½¯â€é˜ˆå€¼å‡½æ•°ï¼ˆè½¯æ¿€æ´»å‡½æ•°ï¼ŸSoftMaxï¼Ÿï¼‰ å¦‚ä½•ç ”ç©¶ä¸¤ä¸ªå˜é‡çš„çš„ç›¸å…³æ€§ï¼Ÿ å‡è®¾æˆ‘ä»¬æƒ³è¦ç ”ç©¶ä¸ªäººæ”¶å…¥ä¸å“ªäº›å› ç´ æœ‰å…³ï¼Œæˆ‘ä»¬é€šè¿‡è°ƒæŸ¥è·å¾—äº†è°ƒæŸ¥æ•°æ®ï¼Œå…¸å‹çš„è¡¨é¡¹ä¸ºï¼š å§“å æ”¶å…¥ çˆ¶æ¯å—æ•™è‚²ç¨‹åº¦ å®¶åº­æ”¶å…¥ å—æ•™è‚²ç¨‹åº¦ å¼ ä¸‰ 5600 å¤§å­¦æ¯•ä¸š 14000 å¤§å­¦æ¯•ä¸š ç°åœ¨å‡è®¾æˆ‘ä»¬è¦ç ”ç©¶ä¸ªäººæ”¶å…¥ä¸ä¸ªäººå—æ•™è‚²ç¨‹åº¦çš„å…³ç³»ï¼Œæˆ‘ä»¬åº”è¯¥æ€ä¹ˆåšï¼Ÿ ç›´è§‚åœ°ï¼Œæˆ‘ä»¬åœ¨ä¸­å­¦æ—¶éƒ½å­¦è¿‡çš„â€œæ§åˆ¶å˜é‡æ³•â€ï¼Œå› æ­¤å¯ä»¥æ§åˆ¶å…¶ä»–å˜é‡ï¼ˆPEï¼ŒIï¼‰ä¸å˜/ç›¸åŒï¼Œè§‚å¯Ÿä¸ªäººæ”¶å…¥éšå—æ•™è‚²ç¨‹åº¦çš„å˜åŒ–è§„å¾‹ã€‚ç”±äºå…¶ä»–å˜é‡éƒ½ç›¸åŒï¼Œå—ä¸ªäººæ”¶å…¥çš„å˜åŒ–åº”å®Œå…¨ç”±å—æ•™è‚²ç¨‹åº¦å½±å“ã€‚ ä¸”æ…¢ï¼Œå…¶ä»–å˜é‡çœŸçš„éƒ½ç›¸åŒäº†å—ï¼Ÿå¯¹äºæ²¡æœ‰è§‚æµ‹åˆ°çš„å˜é‡ï¼Œæˆ–è€…ä¸èƒ½è§‚æµ‹çš„å˜é‡ï¼Œæˆ‘ä»¬æ ¹æœ¬æ²¡æœ‰åŠæ³•æ§åˆ¶ï¼Œå› ä¸ºæˆ‘ä»¬æ‰‹ä¸Šåªæœ‰ä¸€æ¡æ¡çš„æ•°æ®ã€‚ ä¸ºäº†æ›´å¥½åœ°ã€æ›´æ¸…æ™°åœ°ç ”ç©¶å˜é‡é—´çš„ç›¸å…³å…³ç³»ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®â€œå…ˆéªŒçŸ¥è¯†â€â€” ä¹Ÿå°±æ˜¯æˆ‘ä»¬å¯¹å˜é‡é—´å› æœå…³ç³»çš„ä¸»è§‚è®¤è¯†ï¼Œç»˜åˆ¶å‡ºä¸€ä¸ªå˜é‡å› æœå…³ç³»å›¾ï¼Œå¦‚ä¸‹å›¾ã€‚ï¼ˆæ³¨æ„ï¼Œç»˜åˆ¶è¯¥å›¾ï¼Œç›¸å½“å…³äºå¼•å…¥äº†ä¸€ç§å‡è®¾ï¼Œå®Œå…¨å¯ä»¥å­˜åœ¨å¦ç¾¤ç ”ç©¶äººå‘˜ï¼Œç”»å‡ºå®Œå…¨ä¸åŒçš„å˜é‡å› æœå…³ç³»å›¾ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬å¯¹å˜é‡é—´å…³ç³»æœ‰ä¸åŒçš„å‡è®¾ã€‚æ¥ä¸‹æ¥å¯¹å˜é‡ç›¸å…³æ€§çš„åˆ†æï¼Œéƒ½æ˜¯å»ºç«‹åœ¨è¯¥å‡è®¾åŸºç¡€ä¹‹ä¸Šçš„ã€‚ï¼‰ ä»ç»Ÿè®¡ä¸Šï¼Œæˆ‘ä»¬åªèƒ½é€šè¿‡æ•°æ®åˆ†æå˜é‡é—´çš„â€œç›¸å…³æ€§â€ï¼Œè€Œä¸èƒ½å¾—å‡ºâ€œå› æœæ€§â€ã€‚æ‰€ä»¥ï¼Œè¦ç ”ç©¶æ”¶å…¥ä¸å¤§å­¦æ•™è‚²çš„ï¼ˆç›´æ¥ï¼‰å…³ç³»ï¼Œæˆ‘ä»¬é¦–å…ˆè¦æ˜ç¡®ï¼Œå“ªäº›å› ç´  or å˜é‡ï¼Œä¼šå½±å“æ”¶å…¥ï¼Ÿä¹Ÿå°±æ˜¯è¯´ï¼Œå“ªäº›å˜é‡ä¸æ”¶å…¥ä¹‹é—´å­˜åœ¨ç›¸å…³æ€§ï¼Ÿ ç ”ç©¶å—æ•™è‚²ç¨‹åº¦å¯¹æ”¶å…¥çš„ç›´æ¥å½±å“ï¼Œä¹Ÿå°±æ˜¯ Dâ†’Y è¿™æ¡è¾¹ã€‚å¸Œæœ› Y çš„å˜åŒ–ï¼Œä»…ç”± Dâ†’Y çš„å½±å“æ‰€å†³å®šã€‚é‚£å°±è¦ç ”ç©¶ï¼ŒD è¿˜èƒ½é€šè¿‡å“ªäº›â€œè·¯å¾„â€å½±å“åˆ° Y å‘¢ï¼Ÿ D â†’ Y D â† I â†’ Y D â† PE â†’ I â†’ Y D â† B â†’ PE â†’ I â†’ Y ä¸Šé¢åˆ—ä¸¾äº† 4 æ¡ç”± D å‡ºå‘ï¼Œå¯èƒ½å½±å“åˆ° Y çš„â€œè·¯å¾„â€ã€‚æ³¨æ„ï¼Œè¯»è€…å¯èƒ½ä¼šç–‘æƒ‘ï¼ŒD å¯¹ Y çš„å½±å“è·¯å¾„ä¸ºä»€ä¹ˆè¿˜æœ‰é€†å‘çš„è¾¹å‘¢ï¼Ÿæœ‰å‘è¾¹ä»£è¡¨ç€å˜é‡é—´å­˜åœ¨å› æœå…³ç³»ï¼Œå¦‚æœæœ‰é€†å‘è¾¹ï¼Œå²‚ä¸æ˜¯æ„å‘³ç€â€œç»“æœä¼šå½±å“åŸå› â€ï¼Ÿ å› æœå…³ç³»ä¸Šè®²ï¼ŒåŸå› å½“ç„¶ä¸ä¼šå½±å“ç»“æœã€‚ä½†æ˜¯ï¼Œæ³¨æ„æˆ‘ä»¬æ‰€é¢ä¸´çš„å®é™…é—®é¢˜çš„æƒ…æ™¯ï¼Œæˆ‘ä»¬æ‰€é¢å¯¹çš„æ˜¯è°ƒæŸ¥å¾—åˆ°çš„æ•°æ®ã€‚ä»æ•°æ®åˆ†å¸ƒçš„è§’åº¦çœ‹ï¼Œå¦‚æœæˆ‘ä»¬å¯¹ç»“æœ X åŠ ä»¥é™åˆ¶ï¼Œä¹Ÿå°±æ˜¯é€‰æ‹©å‡º X æ»¡è¶³ä¸€å®šè¦æ±‚çš„æ•°æ®ï¼Œä¸€å®šä¼šå½±å“åŸå›  Y çš„åˆ†å¸ƒã€‚ä¸¾ä¾‹æ¥è®²ï¼Œå‡è®¾â€œä¸‹é›¨â€å’Œâ€œæ´’æ°´è½¦ç»è¿‡â€éƒ½ä¼šå¯¼è‡´â€œè‰åªå˜æ¹¿â€ï¼Œé‚£ä¹ˆï¼Œè§‚æµ‹åˆ°â€œè‰åªå˜æ¹¿â€ï¼Œä¸€å®šä¼šå½±å“æˆ‘ä»¬å¯¹â€œä¸‹é›¨â€å’Œâ€œæ´’æ°´è½¦ç»è¿‡â€å‘ç”Ÿçš„åˆ¤æ–­ï¼Œå› ä¸ºä¸¤è€…è‡³å°‘æœ‰å…¶ä¸€å‘ç”Ÿäº†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨ç»Ÿè®¡é‡Œé¢ï¼Œé™åˆ¶ç»“æœï¼Œä¸€å®šä¼šâ€œæ»¤å»â€æŸäº›åŸå› ï¼Œè¿›è€Œå¯¼è‡´åŸå› æ•°æ®åˆ†å¸ƒçš„å˜åŒ–ã€‚äºæ˜¯ï¼Œç»“æœä¼šâ€œå½±å“â€åˆ°åŸå› ã€‚ ç»“æœä¼šâ€œå½±å“â€åŸå› ï¼Œè¿™å¯å‘æˆ‘ä»¬ç ”ç©¶å˜é‡é—´çš„ç›¸å…³å…³ç³»ï¼šä»€ä¹ˆæƒ…å†µä¸‹ï¼Œå˜é‡é—´å­˜åœ¨ç›¸å…³å…³ç³»ï¼Œä»€ä¹ˆæƒ…å†µä¸‹åˆä¸å­˜åœ¨å‘¢ï¼Ÿ æˆ‘ä»¬é‡‡å–â€œé©¬å°”å¯å¤«å‡è®¾â€ï¼Œå³â€œç»“æœä»…å´å†³äºåŸå› ï¼Œåœ¨åŸå› ç»™å®šæ—¶ï¼Œç»“æœä¹‹é—´æ¡ä»¶ç‹¬ç«‹â€ï¼Œäºæ˜¯ä¸Šè¿°å› æœå…³ç³»å›¾å°±å¯ä»¥è½¬åŒ–æˆâ€œè´å¶æ–¯ç½‘ç»œæ¨¡å‹â€ã€‚ å‚è€ƒè´å¶æ–¯ç½‘ç»œæ¨¡å‹ä¸­å˜é‡é—´çš„ç‹¬ç«‹æ€§å®šç†ï¼ˆè´å¶æ–¯ç½‘ç»œçš„å…¸å‹/åŸºæœ¬ç»“æ„ï¼‰ï¼š ç»™å®šçˆ¶èŠ‚ç‚¹ï¼Œå­èŠ‚ç‚¹æ¡ä»¶ç‹¬ç«‹ï¼›çˆ¶èŠ‚ç‚¹æœªçŸ¥ï¼Œå­èŠ‚ç‚¹ç›¸å…³ã€‚ ç»™å®šå†²æ’å› å­ï¼Œçˆ¶èŠ‚ç‚¹ç›¸å…³ï¼›é‡è£…å› å­æœªçŸ¥ï¼Œçˆ¶èŠ‚ç‚¹ç‹¬ç«‹ï¼ˆæ²¡æœ‰å…¶ä»–ç›¸å…³å…³ç³»ï¼‰ã€‚ ç»™å®šä¸­é—´èŠ‚ç‚¹ï¼Œå…ˆåºèŠ‚ç‚¹ä¸ååºèŠ‚ç‚¹æ¡ä»¶ç‹¬ç«‹ï¼›ä¸­é—´èŠ‚ç‚¹æœªçŸ¥ï¼Œå…ˆåºååºç›¸å…³ã€‚ æ³¨æ„ï¼Œç›¸å…³æ€§ä¸å…·æœ‰æ–¹å‘æ€§ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ŒX ä¸ Y ç›¸å…³ï¼Œæ„å‘³ç€å˜é‡å˜åŒ–äº§ç”Ÿçš„â€œå½±å“â€ï¼Œå¯ä»¥ä» X ä¼ é€’åˆ° Yï¼Œä¹Ÿå¯ä»¥ä» Y ä¼ é€’åˆ° Xã€‚ å†æ¬¡åˆ†æ D å¯èƒ½å½±å“åˆ° Y çš„å››æ¡è·¯å¾„ï¼Œæˆ‘ä»¬å¸Œæœ› D å˜åŒ–äº§ç”Ÿçš„â€œå½±å“â€ï¼Œåªä»è·¯å¾„ 1ï¼Œä¹Ÿå°±æ˜¯ç›´æ¥è·¯å¾„ï¼Œç›´æ¥ä¼ å¯¼åˆ° Yã€‚å¦‚ä½•å°†å 3 æ¡è·¯å¾„å µä½ï¼Ÿæˆ‘ä»¬å¸Œæœ›å¯ä»¥é€šè¿‡â€œæ§åˆ¶â€æŸäº›å˜é‡ï¼Œä½¿å¾—â€œå½±å“ä¼ é€’é“¾â€ä¸­æ–­ã€‚ä¹Ÿå°±æ˜¯ç»™å®šâ€œé“¾â€ä¸­çš„æŸäº›å˜é‡ï¼Œä½¿å¾—é“¾ä¸­ä¸¤èŠ‚ç‚¹â€œç‹¬ç«‹â€ï¼Œä¹Ÿå°±ä¸­æ–­äº†â€œå½±å“â€çš„ä¼ é€’ã€‚ æ³¨æ„ï¼šå¾…ç ”ç©¶å˜é‡ï¼ˆDï¼ŒYï¼‰å’Œéšå«å˜é‡ï¼ˆBï¼‰è‚¯å®šæ˜¯ä¸èƒ½æ§åˆ¶ or æ— æ³•æ§åˆ¶çš„ æ§åˆ¶å˜é‡Iï¼š2ã€3ã€4 ä¸­æ–­ æ§åˆ¶å˜é‡PEï¼š3ã€4 ä¸­æ–­ äºæ˜¯ï¼Œæˆ‘ä»¬åªéœ€è¦æ§åˆ¶Iï¼Œå°±å¯ä»¥ä¿è¯ï¼Œæ”¶å…¥ Y çš„å˜åŒ–ä»…ç”±å—æ•™è‚²ç¨‹åº¦ D çš„å½±å“äº†ã€‚ ï¼ˆåœ¨ç»™å®šçš„å˜é‡å› æœå…³ç³»çš„å‡è®¾ä¸‹ï¼Œåœ¨é©¬å°”å¯å¤«æ¡ä»¶å‡è®¾ä¸‹ï¼‰ å‡ ç‚¹è¯´æ˜ï¼š é—®é¢˜ 1ï¼šâ€œæ§åˆ¶å˜é‡æ³•â€æœ‰é—®é¢˜å—ï¼Ÿ åšå®éªŒçš„æ§åˆ¶å˜é‡æ³•ï¼Œæ§åˆ¶äº†å¯èƒ½å¯¹ç»“æœäº§ç”Ÿå½±å“çš„å…¶ä»–åŸå› ï¼Œå¹¶å‡è®¾æ— æ³•æ§åˆ¶çš„å› ç´ éƒ½â€œæ²¡å˜â€ï¼Œåœ¨å‡æƒ³çš„ä¸–ç•Œçš„æ¦‚ç‡å›¾ä¸­ï¼Œæ‰€æœ‰å…¶ä»–å˜é‡éƒ½â€œè¢«æ§åˆ¶â€ï¼Œå› è€Œå¯ä»¥æ–­è¨€ï¼šç»“æœçš„å˜åŒ–ï¼Œä»…ç”±å¾…ç ”ç©¶çš„åŸå› çš„å˜åŒ–æ‰€å†³å®šã€‚ ä½†åœ¨å¯¹è°ƒæŸ¥æ•°æ®è¿›è¡Œç»Ÿè®¡åˆ†ææ—¶ï¼Œæˆ‘ä»¬ä»…èƒ½æ§åˆ¶è°ƒæŸ¥å¾—åˆ°çš„æ•°æ®ï¼Œå¯¹äºæ²¡æœ‰è°ƒæŸ¥çš„æ•°æ®ï¼Œæˆ‘ä»¬æ— æ³•ä¿è¯å®ƒä»¬ç›¸åŒï¼Œåœ¨æˆ‘ä»¬å‡è®¾çš„æ¦‚ç‡å›¾ä¸­ï¼Œå°±æ— æ³•ä¿è¯ç»“æœåªä¸åŸå› ç›´æ¥ç›¸å…³ã€‚ å·¥å…·å˜é‡ å‡è®¾è¦ç ”ç©¶å˜é‡ Z ä¸ Y çš„ç›´æ¥å…³ç³»ï¼Œç»˜åˆ¶å‡ºçš„å…³ç³»å›¾å¦‚æ¡†å†…æ‰€ç¤ºã€‚æˆ‘ä»¬å‘ç°æ— æ³•æ§åˆ¶æŸä¸ªå˜é‡ï¼Œä½¿å¾— Yâ† U â†’ Z è¿™æ¡è·¯å¾„è¢«ä¸­æ–­ã€‚æ€ä¹ˆåŠå‘¢ï¼Ÿ æ—¢ç„¶ä¸èƒ½ç›´æ¥ç ”ç©¶ Z ä¸ Y çš„ç›´æ¥å…³ç³»ï¼Œé‚£æˆ‘ä»¬è¯•ç€é—´æ¥ç ”ç©¶ä¸€ä¸‹ï¼šå¼•å…¥å·¥å…·å˜é‡ Xã€‚ ç ”ç©¶ Xâ†’Yâ†’Z ç ”ç©¶ Xâ†’Y å¦‚ä½•å¾—å‡º Yâ†’Zï¼Ÿ è¯æ˜ é©¬å°”å¯å¤«æ¯¯æ€§è´¨ å¦‚ä½•è¯æ˜ï¼Ÿè¯æ˜çš„ä¸€èˆ¬æ€è·¯æ˜¯æ€æ ·çš„ï¼Ÿ ç¥–å…ˆå›¾ Ancestral Graph wiki æ··åˆå›¾ï¼Ÿæœ‰å‘å›¾ æ— æœ‰å‘ç¯è·¯ - åé—¨è·¯å¾„ï¼šé™¤ç›´æ¥è·¯å¾„å¤–çš„ç›¸å…³è·¯å¾„ 1. ã€Šæœºå™¨å­¦ä¹ ã€‹-å‘¨å¿—å-æ¸…åå¤§å­¦å‡ºç‰ˆç¤¾-P156 â†© 2. Artificial Intelligence: A Morden Approach-4th â†© "},"Learn/LearnAIMA/Ch18/Ch18.html":{"url":"Learn/LearnAIMA/Ch18/Ch18.html","title":"Ch18","keywords":"","body":"ç¬¬ 18 ç«  å¤šæ™ºèƒ½ä½“å†³ç­– 18.1 å¤šæ™ºèƒ½ä½“ç¯å¢ƒçš„ç‰¹æ€§ 18.1.1 å•ä¸ªå†³ç­–è€… 18.1.2 å¤šå†³ç­–è€… 18.1.3 å¤šæ™ºèƒ½ä½“è§„åˆ’ 18.1.4 å¤šæ™ºèƒ½ä½“è§„åˆ’ï¼šåˆä½œä¸åè°ƒ 18.2 éåˆä½œåšå¼ˆè®º 18.2.1 å•æ­¥åšå¼ˆï¼šæ­£åˆ™å½¢å¼åšå¼ˆ 18.2.2 ç¤¾ä¼šç¦åˆ© 18.2.3 é‡å¤åšå¼ˆ 18.2.4 åºè´¯åšå¼ˆï¼šæ‰©å±•å½¢å¼ 18.2.5 ä¸ç¡®å®šæ”¶ç›Šä¸è¾…åŠ©åšå¼ˆ 18.3 åˆä½œåšå¼ˆè®º 18.3.1 è”ç›Ÿç»“æ„ä¸ç»“æœ 18.3.2 åˆä½œåšå¼ˆä¸­çš„ç­–ç•¥ 18.3.3 åˆä½œåšå¼ˆä¸­çš„è®¡ç®— 18.4 åšé›†ä½“å†³ç­– 18.4.1 åœ¨åˆåŒç½‘ä¸­åˆ†é…ä»»åŠ¡ 18.4.2 é€šè¿‡æ‹å–åˆ†é…ç¨€ç¼ºèµ„æº 18.4.3 æŠ•ç¥¨ 18.4.4 è®®ä»· å°ç»“ å½“ç¯å¢ƒä¸­æœ‰å…¶ä»–æ™ºèƒ½ä½“éœ€è¦åˆä½œæˆ–ç«äº‰æ—¶ï¼Œå¤šæ™ºèƒ½ä½“è§„åˆ’æ˜¯å¿…è¦çš„ã€‚æˆ‘ä»¬å¯ä»¥åˆ¶å®šè”åˆè§„åˆ’ï¼Œä½†å¦‚æœä¸¤ä¸ªæ™ºèƒ½ä½“è¦å°±æ‰§è¡Œå“ªä¸ªè”åˆè§„åˆ’è¾¾æˆä¸€è‡´ï¼Œå°±å¿…é¡»ä»¥æŸç§åè°ƒå½¢å¼åŠ ä»¥åŠ å¼ºã€‚ åšå¼ˆè®ºæè¿°çš„æ˜¯åœ¨å¤šä¸ªæ™ºèƒ½ä½“ç›¸äº’ä½œç”¨çš„æƒ…å†µä¸‹ï¼Œæ™ºèƒ½ä½“çš„ç†æ€§è¡Œä¸ºã€‚åšå¼ˆè®ºä¹‹äºå¤šæ™ºèƒ½ä½“å†³ç­–ï¼Œæ­£å¦‚å†³ç­–è®ºä¹‹äºå•æ™ºèƒ½ä½“å†³ç­–ã€‚ åšå¼ˆè®ºä¸­çš„è§£æ¦‚å¿µæ—¨åœ¨æè¿°åšå¼ˆçš„ç†æ€§ç»“æœâ€”â€”å¦‚æœæ¯ä¸ªæ™ºèƒ½ä½“éƒ½é‡‡å–ç†æ€§è¡Œä¸ºçš„æƒ…å†µä¸‹å¯èƒ½å‡ºç°çš„ç»“æœã€‚ éåˆä½œåšå¼ˆè®ºå‡è®¾æ™ºèƒ½ä½“å¿…é¡»ç‹¬ç«‹åšå‡ºå†³ç­–ã€‚çº³ä»€å‡è¡¡æ˜¯éåˆä½œåšå¼ˆè®ºä¸­æœ€é‡è¦çš„è§£æ¦‚å¿µã€‚çº³ä»€å‡è¡¡æ˜¯ä¸€ç§æ™ºèƒ½ä½“æ²¡æœ‰åŠ¨æœºåç¦»å…¶æŒ‡å®šç­–ç•¥çš„ç­–ç•¥ç»„åˆã€‚æˆ‘ä»¬æœ‰å¤„ç†é‡å¤åšå¼ˆå’Œåºè´¯åšå¼ˆçš„æŠ€å·§ã€‚ åˆä½œåšå¼ˆè®ºè€ƒè™‘çš„æ˜¯æ™ºèƒ½ä½“ä¸ºäº†åˆä½œè€Œè¾¾æˆå…·æœ‰çº¦æŸåŠ›çš„åçº¦ä»¥å½¢æˆè”ç›Ÿçš„è®¾ç½®ã€‚åˆä½œåšå¼ˆä¸­çš„è§£æ¦‚å¿µè¯•å›¾é˜æ˜å“ªäº›è”ç›Ÿæ˜¯ç¨³å®šçš„ï¼ˆæ ¸ï¼‰ï¼Œä»¥åŠå¦‚ä½•å…¬å¹³åˆ†é…è”ç›Ÿè·å¾—çš„å€¼ï¼ˆæ²™æ™®åˆ©å€¼ï¼‰ã€‚ å¯¹äºæŸäº›é‡è¦å¾—å¤šæ™ºèƒ½ä½“å†³ç­–ç±»æœ‰ä¸“é—¨çš„æŠ€æœ¯ï¼šä»»åŠ¡å…±äº«çš„åˆåŒç½‘ï¼Œè¢«ç”¨æ¥æœ‰æ•ˆåœ°åˆ†é…ç¨€ç¼ºèµ„æºçš„æ‹å–ï¼Œå°±å…±åŒåˆ©ç›Šè¿›è¡Œè®®ä»·ä»¥è¾¾æˆåçº¦ï¼Œä»¥åŠèšé›†åå¥½çš„æŠ•ç¥¨ç¨‹åºã€‚ "},"Learn/LearnCUDA/APT-CUDA.html":{"url":"Learn/LearnCUDA/APT-CUDA.html","title":"APT-CUDA","keywords":"","body":"(base) âœ sys-ycompiler git:(master) âœ— sudo apt install nvidia-cuda-dev Reading package lists... Done Building dependency tree... Done Reading state information... Done The following additional packages will be installed: dkms firmware-nvidia-gsp glx-alternative-mesa glx-alternative-nvidia glx-diversions libaccinj64-11.8 libcu++-dev libcub-dev libcublas11 libcublaslt11 libcuda1 libcudart11.0 libcufft10 libcufftw10 libcuinj64-11.8 libcupti-dev libcupti-doc libcupti11.8 libcurand10 libcusolver11 libcusolvermg11 libcusparse11 libgl-dev libglx-dev libnppc11 libnppial11 libnppicc11 libnppidei11 libnppif11 libnppig11 libnppim11 libnppist11 libnppisu11 libnppitc11 libnpps11 libnvblas11 libnvcuvid1 libnvidia-cfg1 libnvidia-ml-dev libnvidia-ml1 libnvidia-pkcs11-openssl3 libnvidia-ptxjitcompiler1 libnvjpeg11 libnvrtc-builtins11.8 libnvrtc11.2 libnvtoolsext1 libnvvm4 libthrust-dev libvdpau-dev linux-compiler-gcc-12-x86 linux-headers-6.1.0-27-amd64 linux-headers-6.1.0-27-common linux-headers-amd64 linux-kbuild-6.1 node-html5shiv nvidia-alternative nvidia-installer-cleanup nvidia-kernel-common nvidia-kernel-dkms nvidia-kernel-support nvidia-legacy-check nvidia-modprobe nvidia-persistenced nvidia-smi nvidia-support update-glx Suggested packages: menu nvidia-driver | nvidia-driver-any nvidia-cuda-mps nvidia-cuda-toolkit libvdpau-doc nodejs Recommended packages: libcuda1:i386 The following NEW packages will be installed: dkms firmware-nvidia-gsp glx-alternative-mesa glx-alternative-nvidia glx-diversions libaccinj64-11.8 libcu++-dev libcub-dev libcublas11 libcublaslt11 libcuda1 libcudart11.0 libcufft10 libcufftw10 libcuinj64-11.8 libcupti-dev libcupti-doc libcupti11.8 libcurand10 libcusolver11 libcusolvermg11 libcusparse11 libgl-dev libglx-dev libnppc11 libnppial11 libnppicc11 libnppidei11 libnppif11 libnppig11 libnppim11 libnppist11 libnppisu11 libnppitc11 libnpps11 libnvblas11 libnvcuvid1 libnvidia-cfg1 libnvidia-ml-dev libnvidia-ml1 libnvidia-pkcs11-openssl3 libnvidia-ptxjitcompiler1 libnvjpeg11 libnvrtc-builtins11.8 libnvrtc11.2 libnvtoolsext1 libnvvm4 libthrust-dev libvdpau-dev linux-compiler-gcc-12-x86 linux-headers-6.1.0-27-amd64 linux-headers-6.1.0-27-common linux-headers-amd64 linux-kbuild-6.1 node-html5shiv nvidia-alternative nvidia-cuda-dev nvidia-installer-cleanup nvidia-kernel-common nvidia-kernel-dkms nvidia-kernel-support nvidia-legacy-check nvidia-modprobe nvidia-persistenced nvidia-smi nvidia-support update-glx 0 upgraded, 67 newly installed, 0 to remove and 2 not upgraded. Need to get 1,592 MB of archives. After this operation, 5,429 MB of additional disk space will be used. Do you want to continue? [Y/n] Y Get:1 http://mirrors.ustc.edu.cn/debian bookworm/main amd64 dkms all 3.0.10-8+deb12u1 [48.7 kB] Get:2 http://mirrors.ustc.edu.cn/debian bookworm/contrib amd64 update-glx amd64 1.2.2 [5,432 B] Get:3 http://mirrors.ustc.edu.cn/debian bookworm/contrib amd64 glx-alternative-mesa amd64 1.2.2 [4,760 B] Get:4 http://mirrors.ustc.edu.cn/debian bookworm/contrib amd64 nvidia-installer-cleanup amd64 20220217+3~deb12u1 [13.3 kB] Get:5 http://mirrors.ustc.edu.cn/debian bookworm/contrib amd64 glx-diversions amd64 1.2.2 [7,408 B] Get:6 http://mirrors.ustc.edu.cn/debian bookworm/contrib amd64 glx-alternative-nvidia amd64 1.2.2 [5,776 B] Get:7 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 nvidia-legacy-check amd64 535.183.01-1~deb12u1 [156 kB] Get:8 http://mirrors.ustc.edu.cn/debian bookworm/contrib amd64 nvidia-support amd64 20220217+3~deb12u1 [14.2 kB] Get:9 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 nvidia-alternative amd64 535.183.01-1~deb12u1 [152 kB] Get:10 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnvidia-ptxjitcompiler1 amd64 535.183.01-1~deb12u1 [6,970 kB] Get:11 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnvidia-pkcs11-openssl3 amd64 535.183.01-1~deb12u1 [154 kB] Get:12 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcuda1 amd64 535.183.01-1~deb12u1 [2,999 kB] Get:13 http://mirrors.ustc.edu.cn/debian bookworm/non-free-firmware amd64 firmware-nvidia-gsp amd64 535.183.01-1~deb12u1 [38.5 MB] Get:14 http://mirrors.ustc.edu.cn/debian bookworm/contrib amd64 nvidia-kernel-common amd64 20220217+3~deb12u1 [4,488 B] Get:15 http://mirrors.ustc.edu.cn/debian bookworm/contrib amd64 nvidia-modprobe amd64 535.161.07-1~deb12u1 [21.1 kB] Get:16 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 nvidia-kernel-support amd64 535.183.01-1~deb12u1 [151 kB] Get:17 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 nvidia-kernel-dkms amd64 535.183.01-1~deb12u1 [44.9 MB] Get:18 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnvidia-cfg1 amd64 535.183.01-1~deb12u1 [240 kB] Get:19 http://mirrors.ustc.edu.cn/debian bookworm/contrib amd64 nvidia-persistenced amd64 535.171.04-1~deb12u1 [27.1 kB] Get:20 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcupti11.8 amd64 11.8.87~11.8.0-5~deb12u1 [8,039 kB] Get:21 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libaccinj64-11.8 amd64 11.8.87~11.8.0-5~deb12u1 [784 kB] Get:22 http://mirrors.ustc.edu.cn/debian bookworm/main amd64 libcu++-dev all 1.8.1-2 [554 kB] Get:23 http://mirrors.ustc.edu.cn/debian bookworm/main amd64 libcub-dev all 1.17.2-2 [245 kB] Get:24 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcublaslt11 amd64 11.11.3.6~11.8.0-5~deb12u1 [206 MB] Get:25 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcublas11 amd64 11.11.3.6~11.8.0-5~deb12u1 [44.5 MB] Get:26 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcudart11.0 amd64 11.8.89~11.8.0-5~deb12u1 [167 kB] Get:27 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcufft10 amd64 11.1.1+~10.9.0.58~11.8.0-5~deb12u1 [93.9 MB] Get:28 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcufftw10 amd64 11.1.1+~10.9.0.58~11.8.0-5~deb12u1 [393 kB] Get:29 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcuinj64-11.8 amd64 11.8.87~11.8.0-5~deb12u1 [928 kB] Get:30 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcupti-dev amd64 11.8.87~11.8.0-5~deb12u1 [7,892 kB] Get:31 http://mirrors.ustc.edu.cn/debian bookworm/main amd64 node-html5shiv all 3.7.3+dfsg-5 [13.2 kB] Get:32 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcupti-doc all 11.8.87~11.8.0-5~deb12u1 [2,463 kB] Get:33 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcurand10 amd64 11.1.1+~10.3.0.86~11.8.0-5~deb12u1 [42.2 MB] Get:34 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcusolver11 amd64 11.4.1.48~11.8.0-5~deb12u1 [32.0 MB] Get:35 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcusolvermg11 amd64 11.4.1.48~11.8.0-5~deb12u1 [20.4 MB] 37% [35 libcusolvermg11 6,765 kB/20.4 MB 33%] 89.1 kB/s 3h 16min 21s Get:36 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcusparse11 amd64 11.7.5.86~11.8.0-5~deb12u1 [116 MB] Ign:36 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcusparse11 amd64 11.7.5.86~11.8.0-5~deb12u1 Get:37 http://mirrors.ustc.edu.cn/debian bookworm/main amd64 libglx-dev amd64 1.6.0-1 [15.3 kB] Get:38 http://mirrors.ustc.edu.cn/debian bookworm/main amd64 libgl-dev amd64 1.6.0-1 [100 kB] Get:39 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnppc11 amd64 11.8.0.86~11.8.0-5~deb12u1 [391 kB] Get:40 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnppial11 amd64 11.8.0.86~11.8.0-5~deb12u1 [5,547 kB] Get:41 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnppicc11 amd64 11.8.0.86~11.8.0-5~deb12u1 [2,489 kB] Get:42 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnppidei11 amd64 11.8.0.86~11.8.0-5~deb12u1 [2,626 kB] Get:43 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnppif11 amd64 11.8.0.86~11.8.0-5~deb12u1 [48.0 MB] Get:44 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnppig11 amd64 11.8.0.86~11.8.0-5~deb12u1 [15.4 MB] Get:45 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnppim11 amd64 11.8.0.86~11.8.0-5~deb12u1 [3,195 kB] Get:46 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnppist11 amd64 11.8.0.86~11.8.0-5~deb12u1 [16.3 MB] Get:47 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnppisu11 amd64 11.8.0.86~11.8.0-5~deb12u1 [165 kB] Get:48 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnppitc11 amd64 11.8.0.86~11.8.0-5~deb12u1 [1,319 kB] Get:49 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnpps11 amd64 11.8.0.86~11.8.0-5~deb12u1 [7,502 kB] Get:50 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnvblas11 amd64 11.11.3.6~11.8.0-5~deb12u1 [176 kB] Get:51 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnvcuvid1 amd64 535.183.01-1~deb12u1 [1,501 kB] Get:52 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnvidia-ml1 amd64 535.183.01-1~deb12u1 [684 kB] Get:53 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnvidia-ml-dev amd64 11.8.86~11.8.0-5~deb12u1 [79.2 kB] Get:54 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnvjpeg11 amd64 11.9.0.86~11.8.0-5~deb12u1 [1,873 kB] Get:55 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnvrtc-builtins11.8 amd64 11.8.89~11.8.0-5~deb12u1 [130 kB] Get:56 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnvrtc11.2 amd64 11.8.89~11.8.0-5~deb12u1 [16.4 MB] Get:57 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnvtoolsext1 amd64 11.8.86~11.8.0-5~deb12u1 [31.9 kB] Get:58 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libnvvm4 amd64 11.8.89~11.8.0-5~deb12u1 [8,186 kB] Get:59 http://mirrors.ustc.edu.cn/debian bookworm/main amd64 libthrust-dev all 1.17.2-2 [445 kB] Get:60 http://mirrors.ustc.edu.cn/debian bookworm/main amd64 libvdpau-dev amd64 1.5-2 [41.5 kB] Get:61 http://mirrors.ustc.edu.cn/debian bookworm/main amd64 linux-compiler-gcc-12-x86 amd64 6.1.115-1 [920 kB] Get:62 http://mirrors.ustc.edu.cn/debian bookworm/main amd64 linux-headers-6.1.0-27-common all 6.1.115-1 [10.1 MB] Get:63 http://mirrors.ustc.edu.cn/debian bookworm/main amd64 linux-kbuild-6.1 amd64 6.1.115-1 [1,177 kB] Get:64 http://mirrors.ustc.edu.cn/debian bookworm/main amd64 linux-headers-6.1.0-27-amd64 amd64 6.1.115-1 [1,450 kB] Get:65 http://mirrors.ustc.edu.cn/debian bookworm/main amd64 linux-headers-amd64 amd64 6.1.115-1 [1,416 B] Get:66 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 nvidia-cuda-dev amd64 11.8.89~11.8.0-5~deb12u1 [774 MB] Ign:66 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 nvidia-cuda-dev amd64 11.8.89~11.8.0-5~deb12u1 Get:67 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 nvidia-smi amd64 535.183.01-1~deb12u1 [386 kB] Get:36 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 libcusparse11 amd64 11.7.5.86~11.8.0-5~deb12u1 [116 MB] Get:66 http://mirrors.ustc.edu.cn/debian bookworm/non-free amd64 nvidia-cuda-dev amd64 11.8.89~11.8.0-5~deb12u1 [774 MB] Fetched 944 MB in 21min 31s (731 kB/s) Extracting templates from packages: 100% Preconfiguring packages ... Selecting previously unselected package dkms. (Reading database ... 276371 files and directories currently installed.) Preparing to unpack .../dkms_3.0.10-8+deb12u1_all.deb ... Unpacking dkms (3.0.10-8+deb12u1) ... Selecting previously unselected package update-glx. Preparing to unpack .../update-glx_1.2.2_amd64.deb ... Unpacking update-glx (1.2.2) ... Selecting previously unselected package glx-alternative-mesa. Preparing to unpack .../glx-alternative-mesa_1.2.2_amd64.deb ... Unpacking glx-alternative-mesa (1.2.2) ... Selecting previously unselected package nvidia-installer-cleanup. Preparing to unpack .../nvidia-installer-cleanup_20220217+3~deb12u1_amd64.deb ... Unpacking nvidia-installer-cleanup (20220217+3~deb12u1) ... Setting up nvidia-installer-cleanup (20220217+3~deb12u1) ... Selecting previously unselected package glx-diversions. (Reading database ... 276535 files and directories currently installed.) Preparing to unpack .../glx-diversions_1.2.2_amd64.deb ... Unpacking glx-diversions (1.2.2) ... Selecting previously unselected package glx-alternative-nvidia. Preparing to unpack .../glx-alternative-nvidia_1.2.2_amd64.deb ... Unpacking glx-alternative-nvidia (1.2.2) ... Selecting previously unselected package nvidia-legacy-check. Preparing to unpack .../nvidia-legacy-check_535.183.01-1~deb12u1_amd64.deb ... Unpacking nvidia-legacy-check (535.183.01-1~deb12u1) ... Selecting previously unselected package nvidia-support. Preparing to unpack .../nvidia-support_20220217+3~deb12u1_amd64.deb ... Unpacking nvidia-support (20220217+3~deb12u1) ... Setting up nvidia-legacy-check (535.183.01-1~deb12u1) ... Selecting previously unselected package nvidia-alternative. (Reading database ... 276573 files and directories currently installed.) Preparing to unpack .../00-nvidia-alternative_535.183.01-1~deb12u1_amd64.deb ... Unpacking nvidia-alternative (535.183.01-1~deb12u1) ... Selecting previously unselected package libnvidia-ptxjitcompiler1:amd64. Preparing to unpack .../01-libnvidia-ptxjitcompiler1_535.183.01-1~deb12u1_amd64.deb ... Unpacking libnvidia-ptxjitcompiler1:amd64 (535.183.01-1~deb12u1) ... Selecting previously unselected package libnvidia-pkcs11-openssl3:amd64. Preparing to unpack .../02-libnvidia-pkcs11-openssl3_535.183.01-1~deb12u1_amd64.deb ... Unpacking libnvidia-pkcs11-openssl3:amd64 (535.183.01-1~deb12u1) ... Selecting previously unselected package libcuda1:amd64. Preparing to unpack .../03-libcuda1_535.183.01-1~deb12u1_amd64.deb ... Unpacking libcuda1:amd64 (535.183.01-1~deb12u1) ... Selecting previously unselected package firmware-nvidia-gsp. Preparing to unpack .../04-firmware-nvidia-gsp_535.183.01-1~deb12u1_amd64.deb ... Unpacking firmware-nvidia-gsp (535.183.01-1~deb12u1) ... Selecting previously unselected package nvidia-kernel-common. Preparing to unpack .../05-nvidia-kernel-common_20220217+3~deb12u1_amd64.deb ... Unpacking nvidia-kernel-common (20220217+3~deb12u1) ... Selecting previously unselected package nvidia-modprobe. Preparing to unpack .../06-nvidia-modprobe_535.161.07-1~deb12u1_amd64.deb ... Unpacking nvidia-modprobe (535.161.07-1~deb12u1) ... Selecting previously unselected package nvidia-kernel-support. Preparing to unpack .../07-nvidia-kernel-support_535.183.01-1~deb12u1_amd64.deb ... Unpacking nvidia-kernel-support (535.183.01-1~deb12u1) ... Selecting previously unselected package nvidia-kernel-dkms. Preparing to unpack .../08-nvidia-kernel-dkms_535.183.01-1~deb12u1_amd64.deb ... Unpacking nvidia-kernel-dkms (535.183.01-1~deb12u1) ... Selecting previously unselected package libnvidia-cfg1:amd64. Preparing to unpack .../09-libnvidia-cfg1_535.183.01-1~deb12u1_amd64.deb ... Unpacking libnvidia-cfg1:amd64 (535.183.01-1~deb12u1) ... Selecting previously unselected package nvidia-persistenced. Preparing to unpack .../10-nvidia-persistenced_535.171.04-1~deb12u1_amd64.deb ... Unpacking nvidia-persistenced (535.171.04-1~deb12u1) ... Selecting previously unselected package libcupti11.8:amd64. Preparing to unpack .../11-libcupti11.8_11.8.87~11.8.0-5~deb12u1_amd64.deb ... Unpacking libcupti11.8:amd64 (11.8.87~11.8.0-5~deb12u1) ... Selecting previously unselected package libaccinj64-11.8:amd64. Preparing to unpack .../12-libaccinj64-11.8_11.8.87~11.8.0-5~deb12u1_amd64.deb ... Unpacking libaccinj64-11.8:amd64 (11.8.87~11.8.0-5~deb12u1) ... Selecting previously unselected package libcu++-dev. Preparing to unpack .../13-libcu++-dev_1.8.1-2_all.deb ... Unpacking libcu++-dev (1.8.1-2) ... Selecting previously unselected package libcub-dev. Preparing to unpack .../14-libcub-dev_1.17.2-2_all.deb ... Unpacking libcub-dev (1.17.2-2) ... Selecting previously unselected package libcublaslt11:amd64. Preparing to unpack .../15-libcublaslt11_11.11.3.6~11.8.0-5~deb12u1_amd64.deb ... Unpacking libcublaslt11:amd64 (11.11.3.6~11.8.0-5~deb12u1) ... Selecting previously unselected package libcublas11:amd64. Preparing to unpack .../16-libcublas11_11.11.3.6~11.8.0-5~deb12u1_amd64.deb ... Unpacking libcublas11:amd64 (11.11.3.6~11.8.0-5~deb12u1) ... Selecting previously unselected package libcudart11.0:amd64. Preparing to unpack .../17-libcudart11.0_11.8.89~11.8.0-5~deb12u1_amd64.deb ... Unpacking libcudart11.0:amd64 (11.8.89~11.8.0-5~deb12u1) ... Selecting previously unselected package libcufft10:amd64. Preparing to unpack .../18-libcufft10_11.1.1+~10.9.0.58~11.8.0-5~deb12u1_amd64.deb ... Unpacking libcufft10:amd64 (11.1.1+~10.9.0.58~11.8.0-5~deb12u1) ... Selecting previously unselected package libcufftw10:amd64. Preparing to unpack .../19-libcufftw10_11.1.1+~10.9.0.58~11.8.0-5~deb12u1_amd64.deb ... Unpacking libcufftw10:amd64 (11.1.1+~10.9.0.58~11.8.0-5~deb12u1) ... Selecting previously unselected package libcuinj64-11.8:amd64. Preparing to unpack .../20-libcuinj64-11.8_11.8.87~11.8.0-5~deb12u1_amd64.deb ... Unpacking libcuinj64-11.8:amd64 (11.8.87~11.8.0-5~deb12u1) ... Selecting previously unselected package libcupti-dev:amd64. Preparing to unpack .../21-libcupti-dev_11.8.87~11.8.0-5~deb12u1_amd64.deb ... Unpacking libcupti-dev:amd64 (11.8.87~11.8.0-5~deb12u1) ... Selecting previously unselected package node-html5shiv. Preparing to unpack .../22-node-html5shiv_3.7.3+dfsg-5_all.deb ... Unpacking node-html5shiv (3.7.3+dfsg-5) ... Selecting previously unselected package libcupti-doc. Preparing to unpack .../23-libcupti-doc_11.8.87~11.8.0-5~deb12u1_all.deb ... Unpacking libcupti-doc (11.8.87~11.8.0-5~deb12u1) ... Selecting previously unselected package libcurand10:amd64. Preparing to unpack .../24-libcurand10_11.1.1+~10.3.0.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libcurand10:amd64 (11.1.1+~10.3.0.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libcusolver11:amd64. Preparing to unpack .../25-libcusolver11_11.4.1.48~11.8.0-5~deb12u1_amd64.deb ... Unpacking libcusolver11:amd64 (11.4.1.48~11.8.0-5~deb12u1) ... Selecting previously unselected package libcusolvermg11:amd64. Preparing to unpack .../26-libcusolvermg11_11.4.1.48~11.8.0-5~deb12u1_amd64.deb ... Unpacking libcusolvermg11:amd64 (11.4.1.48~11.8.0-5~deb12u1) ... Selecting previously unselected package libcusparse11:amd64. Preparing to unpack .../27-libcusparse11_11.7.5.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libcusparse11:amd64 (11.7.5.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libglx-dev:amd64. Preparing to unpack .../28-libglx-dev_1.6.0-1_amd64.deb ... Unpacking libglx-dev:amd64 (1.6.0-1) ... Selecting previously unselected package libgl-dev:amd64. Preparing to unpack .../29-libgl-dev_1.6.0-1_amd64.deb ... Unpacking libgl-dev:amd64 (1.6.0-1) ... Selecting previously unselected package libnppc11:amd64. Preparing to unpack .../30-libnppc11_11.8.0.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnppc11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libnppial11:amd64. Preparing to unpack .../31-libnppial11_11.8.0.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnppial11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libnppicc11:amd64. Preparing to unpack .../32-libnppicc11_11.8.0.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnppicc11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libnppidei11:amd64. Preparing to unpack .../33-libnppidei11_11.8.0.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnppidei11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libnppif11:amd64. Preparing to unpack .../34-libnppif11_11.8.0.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnppif11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libnppig11:amd64. Preparing to unpack .../35-libnppig11_11.8.0.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnppig11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libnppim11:amd64. Preparing to unpack .../36-libnppim11_11.8.0.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnppim11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libnppist11:amd64. Preparing to unpack .../37-libnppist11_11.8.0.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnppist11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libnppisu11:amd64. Preparing to unpack .../38-libnppisu11_11.8.0.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnppisu11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libnppitc11:amd64. Preparing to unpack .../39-libnppitc11_11.8.0.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnppitc11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libnpps11:amd64. Preparing to unpack .../40-libnpps11_11.8.0.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnpps11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libnvblas11:amd64. Preparing to unpack .../41-libnvblas11_11.11.3.6~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnvblas11:amd64 (11.11.3.6~11.8.0-5~deb12u1) ... Selecting previously unselected package libnvcuvid1:amd64. Preparing to unpack .../42-libnvcuvid1_535.183.01-1~deb12u1_amd64.deb ... Unpacking libnvcuvid1:amd64 (535.183.01-1~deb12u1) ... Selecting previously unselected package libnvidia-ml1:amd64. Preparing to unpack .../43-libnvidia-ml1_535.183.01-1~deb12u1_amd64.deb ... Unpacking libnvidia-ml1:amd64 (535.183.01-1~deb12u1) ... Selecting previously unselected package libnvidia-ml-dev:amd64. Preparing to unpack .../44-libnvidia-ml-dev_11.8.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnvidia-ml-dev:amd64 (11.8.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libnvjpeg11:amd64. Preparing to unpack .../45-libnvjpeg11_11.9.0.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnvjpeg11:amd64 (11.9.0.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libnvrtc-builtins11.8:amd64. Preparing to unpack .../46-libnvrtc-builtins11.8_11.8.89~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnvrtc-builtins11.8:amd64 (11.8.89~11.8.0-5~deb12u1) ... Selecting previously unselected package libnvrtc11.2:amd64. Preparing to unpack .../47-libnvrtc11.2_11.8.89~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnvrtc11.2:amd64 (11.8.89~11.8.0-5~deb12u1) ... Selecting previously unselected package libnvtoolsext1:amd64. Preparing to unpack .../48-libnvtoolsext1_11.8.86~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnvtoolsext1:amd64 (11.8.86~11.8.0-5~deb12u1) ... Selecting previously unselected package libnvvm4:amd64. Preparing to unpack .../49-libnvvm4_11.8.89~11.8.0-5~deb12u1_amd64.deb ... Unpacking libnvvm4:amd64 (11.8.89~11.8.0-5~deb12u1) ... Selecting previously unselected package libthrust-dev. Preparing to unpack .../50-libthrust-dev_1.17.2-2_all.deb ... Unpacking libthrust-dev (1.17.2-2) ... Selecting previously unselected package libvdpau-dev:amd64. Preparing to unpack .../51-libvdpau-dev_1.5-2_amd64.deb ... Unpacking libvdpau-dev:amd64 (1.5-2) ... Selecting previously unselected package linux-compiler-gcc-12-x86. Preparing to unpack .../52-linux-compiler-gcc-12-x86_6.1.115-1_amd64.deb ... Unpacking linux-compiler-gcc-12-x86 (6.1.115-1) ... Selecting previously unselected package linux-headers-6.1.0-27-common. Preparing to unpack .../53-linux-headers-6.1.0-27-common_6.1.115-1_all.deb ... Unpacking linux-headers-6.1.0-27-common (6.1.115-1) ... Selecting previously unselected package linux-kbuild-6.1. Preparing to unpack .../54-linux-kbuild-6.1_6.1.115-1_amd64.deb ... Unpacking linux-kbuild-6.1 (6.1.115-1) ... Selecting previously unselected package linux-headers-6.1.0-27-amd64. Preparing to unpack .../55-linux-headers-6.1.0-27-amd64_6.1.115-1_amd64.deb ... Unpacking linux-headers-6.1.0-27-amd64 (6.1.115-1) ... Selecting previously unselected package linux-headers-amd64. Preparing to unpack .../56-linux-headers-amd64_6.1.115-1_amd64.deb ... Unpacking linux-headers-amd64 (6.1.115-1) ... Selecting previously unselected package nvidia-cuda-dev:amd64. Preparing to unpack .../57-nvidia-cuda-dev_11.8.89~11.8.0-5~deb12u1_amd64.deb ... Unpacking nvidia-cuda-dev:amd64 (11.8.89~11.8.0-5~deb12u1) ... Selecting previously unselected package nvidia-smi. Preparing to unpack .../58-nvidia-smi_535.183.01-1~deb12u1_amd64.deb ... Unpacking nvidia-smi (535.183.01-1~deb12u1) ... Setting up nvidia-support (20220217+3~deb12u1) ... Setting up linux-headers-6.1.0-27-common (6.1.115-1) ... Setting up libcusparse11:amd64 (11.7.5.86~11.8.0-5~deb12u1) ... Setting up nvidia-kernel-common (20220217+3~deb12u1) ... Setting up libnppc11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Setting up libcu++-dev (1.8.1-2) ... Setting up node-html5shiv (3.7.3+dfsg-5) ... Setting up libcupti-doc (11.8.87~11.8.0-5~deb12u1) ... Setting up update-glx (1.2.2) ... Setting up libcudart11.0:amd64 (11.8.89~11.8.0-5~deb12u1) ... Setting up libnppisu11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Setting up dkms (3.0.10-8+deb12u1) ... Setting up linux-compiler-gcc-12-x86 (6.1.115-1) ... Setting up nvidia-modprobe (535.161.07-1~deb12u1) ... Setting up libnppicc11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Setting up libcupti11.8:amd64 (11.8.87~11.8.0-5~deb12u1) ... Setting up libnvjpeg11:amd64 (11.9.0.86~11.8.0-5~deb12u1) ... Setting up libcublaslt11:amd64 (11.11.3.6~11.8.0-5~deb12u1) ... Setting up libnvrtc-builtins11.8:amd64 (11.8.89~11.8.0-5~deb12u1) ... Setting up libnpps11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Setting up libnppim11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Setting up libcufft10:amd64 (11.1.1+~10.9.0.58~11.8.0-5~deb12u1) ... Setting up libnvidia-ptxjitcompiler1:amd64 (535.183.01-1~deb12u1) ... Setting up libnppitc11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Setting up libaccinj64-11.8:amd64 (11.8.87~11.8.0-5~deb12u1) ... Setting up libnppist11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Setting up firmware-nvidia-gsp (535.183.01-1~deb12u1) ... Setting up libglx-dev:amd64 (1.6.0-1) ... Setting up libnvvm4:amd64 (11.8.89~11.8.0-5~deb12u1) ... Setting up libvdpau-dev:amd64 (1.5-2) ... Setting up libnvtoolsext1:amd64 (11.8.86~11.8.0-5~deb12u1) ... Setting up libcub-dev (1.17.2-2) ... Setting up linux-kbuild-6.1 (6.1.115-1) ... Setting up libnppig11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Setting up libgl-dev:amd64 (1.6.0-1) ... Setting up libcurand10:amd64 (11.1.1+~10.3.0.86~11.8.0-5~deb12u1) ... Setting up libnppidei11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Setting up libthrust-dev (1.17.2-2) ... Setting up libnppial11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Setting up libnppif11:amd64 (11.8.0.86~11.8.0-5~deb12u1) ... Setting up libcufftw10:amd64 (11.1.1+~10.9.0.58~11.8.0-5~deb12u1) ... Setting up libcublas11:amd64 (11.11.3.6~11.8.0-5~deb12u1) ... Setting up libcupti-dev:amd64 (11.8.87~11.8.0-5~deb12u1) ... Setting up glx-alternative-mesa (1.2.2) ... Setting up libnvblas11:amd64 (11.11.3.6~11.8.0-5~deb12u1) ... Setting up glx-diversions (1.2.2) ... Removing diverted 'libGL.so' symlink with unexpected target 'libGL.so.1'. Restoring diverted 'libGL.so' symlink. update-alternatives: using /usr/lib/mesa-diverted to provide /usr/lib/glx (glx) in auto mode Setting up libcusolver11:amd64 (11.4.1.48~11.8.0-5~deb12u1) ... Setting up libnvrtc11.2:amd64 (11.8.89~11.8.0-5~deb12u1) ... Setting up linux-headers-6.1.0-27-amd64 (6.1.115-1) ... /etc/kernel/header_postinst.d/dkms: dkms: running auto installation service for kernel 6.1.0-27-amd64. dkms: autoinstall for kernel: 6.1.0-27-amd64. Setting up libcusolvermg11:amd64 (11.4.1.48~11.8.0-5~deb12u1) ... Setting up linux-headers-amd64 (6.1.115-1) ... Processing triggers for libc-bin (2.36-9+deb12u9) ... Processing triggers for man-db (2.11.2-2) ... Processing triggers for mailcap (3.70+nmu1) ... Processing triggers for desktop-file-utils (0.26-1) ... Processing triggers for initramfs-tools (0.142+deb12u1) ... update-initramfs: Generating /boot/initrd.img-6.1.0-27-amd64 Processing triggers for gnome-menus (3.36.0-1.1) ... Processing triggers for glx-alternative-mesa (1.2.2) ... update-alternatives: updating alternative /usr/lib/mesa-diverted because link group glx has changed slave links update-alternatives: using /usr/lib/mesa-diverted to provide /usr/lib/mesa-diverted/libGL.so-master (libGL.so-master) in auto mode Setting up glx-alternative-nvidia (1.2.2) ... Processing triggers for glx-alternative-nvidia (1.2.2) ... Setting up nvidia-alternative (535.183.01-1~deb12u1) ... Processing triggers for nvidia-alternative (535.183.01-1~deb12u1) ... update-alternatives: using /usr/lib/nvidia/current to provide /usr/lib/nvidia/nvidia (nvidia) in auto mode Setting up libnvidia-cfg1:amd64 (535.183.01-1~deb12u1) ... Setting up nvidia-kernel-support (535.183.01-1~deb12u1) ... Setting up libnvidia-pkcs11-openssl3:amd64 (535.183.01-1~deb12u1) ... Setting up libnvidia-ml1:amd64 (535.183.01-1~deb12u1) ... Setting up libnvidia-ml-dev:amd64 (11.8.86~11.8.0-5~deb12u1) ... Setting up nvidia-persistenced (535.171.04-1~deb12u1) ... adduser: Warning: The home dir /var/run/nvpd/ you specified can't be accessed: No such file or directory Adding system user `nvpd' (UID 117) ... Adding new group `nvpd' (GID 128) ... Adding new user `nvpd' (UID 117) with group `nvpd' ... Not creating home directory `/var/run/nvpd/'. Created symlink /etc/systemd/system/multi-user.target.wants/nvidia-persistenced.service â†’ /lib/systemd/system/nvidia-persistenced.service. Could not execute systemctl: at /usr/bin/deb-systemd-invoke line 145. Setting up libcuda1:amd64 (535.183.01-1~deb12u1) ... Setting up libcuinj64-11.8:amd64 (11.8.87~11.8.0-5~deb12u1) ... Setting up nvidia-smi (535.183.01-1~deb12u1) ... Setting up libnvcuvid1:amd64 (535.183.01-1~deb12u1) ... Setting up nvidia-cuda-dev:amd64 (11.8.89~11.8.0-5~deb12u1) ... Processing triggers for nvidia-alternative (535.183.01-1~deb12u1) ... update-alternatives: updating alternative /usr/lib/nvidia/current because link group nvidia has changed slave links Setting up nvidia-kernel-dkms (535.183.01-1~deb12u1) ... Loading new nvidia-current-535.183.01 DKMS files... Building for 6.1.0-27-amd64 Building initial module for 6.1.0-27-amd64 Done. nvidia-current.ko: Running module version sanity check. - Original module - No original module exists within this kernel - Installation - Installing to /lib/modules/6.1.0-27-amd64/updates/dkms/ nvidia-current-modeset.ko: Running module version sanity check. - Original module - No original module exists within this kernel - Installation - Installing to /lib/modules/6.1.0-27-amd64/updates/dkms/ nvidia-current-drm.ko: Running module version sanity check. - Original module - No original module exists within this kernel - Installation - Installing to /lib/modules/6.1.0-27-amd64/updates/dkms/ nvidia-current-uvm.ko: Running module version sanity check. - Original module - No original module exists within this kernel - Installation - Installing to /lib/modules/6.1.0-27-amd64/updates/dkms/ nvidia-current-peermem.ko: Running module version sanity check. - Original module - No original module exists within this kernel - Installation - Installing to /lib/modules/6.1.0-27-amd64/updates/dkms/ depmod... Processing triggers for libc-bin (2.36-9+deb12u9) ... Processing triggers for initramfs-tools (0.142+deb12u1) ... update-initramfs: Generating /boot/initrd.img-6.1.0-27-amd64 Processing triggers for update-glx (1.2.2) ... Processing triggers for glx-alternative-nvidia (1.2.2) ... update-alternatives: using /usr/lib/nvidia to provide /usr/lib/glx (glx) in auto mode Processing triggers for glx-alternative-mesa (1.2.2) ... Processing triggers for libc-bin (2.36-9+deb12u9) ... Processing triggers for initramfs-tools (0.142+deb12u1) ... update-initramfs: Generating /boot/initrd.img-6.1.0-27-amd64 "},"Learn/LearnCUDA/CUDA.html":{"url":"Learn/LearnCUDA/CUDA.html","title":"CUDA","keywords":"","body":"CUDA Learn NVIDIA CUDA documentation NVIDIA cuda-education cuda-samples CUDA Programming Course â€“ High-Performance Computing with GPUs d_what_are_some_good_resources_to_learn_cuda What-are-some-of-the-best-resources-to-learn-CUDA-C cuda-training-series even-easier-introduction-cuda demystifying-gpu-architectures-for-deep-learning numba GPU-Puzzles CUDA ç¼–ç¨‹å…¥é—¨æç®€æ•™ç¨‹ GPU ç¼–ç¨‹ nvvm-ir-spec NVIDIA CUDA (Compute Unified Device Architecture) The NVIDIAÂ® CUDAÂ® Toolkit provides a comprehensive development environment for C and C++ developers building GPU-accelerated applications. With the CUDA Toolkit, you can develop, optimize, and deploy your applications on GPU-accelerated embedded systems, desktop workstations, enterprise data centers, cloud-based platforms and HPC supercomputers. The toolkit includes GPU-accelerated libraries, debugging and optimization tools, a C/C++ compiler, and a runtime library to deploy your application. NVIDIAÂ® CUDAÂ® å·¥å…·åŒ…ä¸ºæ„å»º GPU åŠ é€Ÿåº”ç”¨ç¨‹åºçš„ C å’Œ C++ å¼€å‘äººå‘˜æä¾›äº†ä¸€ä¸ªå…¨é¢çš„å¼€å‘ç¯å¢ƒã€‚å€ŸåŠ© CUDA å·¥å…·åŒ…ï¼Œæ‚¨å¯ä»¥åœ¨ GPU åŠ é€Ÿçš„åµŒå…¥å¼ç³»ç»Ÿã€æ¡Œé¢å·¥ä½œç«™ã€ä¼ä¸šæ•°æ®ä¸­å¿ƒã€åŸºäºäº‘çš„å¹³å°å’Œ HPC è¶…çº§è®¡ç®—æœºä¸Šå¼€å‘ã€ä¼˜åŒ–å’Œéƒ¨ç½²æ‚¨çš„åº”ç”¨ç¨‹åºã€‚è¯¥å·¥å…·åŒ…åŒ…æ‹¬ GPU åŠ é€Ÿåº“ã€è°ƒè¯•å’Œä¼˜åŒ–å·¥å…·ã€C/C++ ç¼–è¯‘å™¨ä»¥åŠç”¨äºéƒ¨ç½²åº”ç”¨ç¨‹åºçš„è¿è¡Œæ—¶åº“ã€‚ Using built-in capabilities for distributing computations across multi-GPU configurations, scientists and researchers can develop applications that scale from single GPU workstations to cloud installations with thousands of GPUs. ä½¿ç”¨å†…ç½®åŠŸèƒ½åœ¨å¤š GPU é…ç½®ä¹‹é—´åˆ†é…è®¡ç®—ï¼Œç§‘å­¦å®¶å’Œç ”ç©¶äººå‘˜å¯ä»¥å¼€å‘ä»å•ä¸ª GPU å·¥ä½œç«™æ‰©å±•åˆ°å…·æœ‰æ•°åƒä¸ª GPU çš„äº‘å®‰è£…çš„åº”ç”¨ç¨‹åºã€‚ CUDA C++ Programming Guide v12.6 CUDA C++ Programming Guide CUDA ç¼–ç¨‹æ¨¡å‹çš„å…³é”®ç»„æˆéƒ¨åˆ† (GPT) CUDA ç¼–ç¨‹æ¨¡å‹ä½¿å¼€å‘è€…èƒ½å¤Ÿç¼–å†™ä»£ç ï¼Œå……åˆ†åˆ©ç”¨ NVIDIA GPU çš„å¼ºå¤§å¹¶è¡Œè®¡ç®—èƒ½åŠ›ã€‚å®ƒåŸºäºå•æŒ‡ä»¤å¤šçº¿ç¨‹ï¼ˆSIMTï¼‰æ¶æ„ï¼Œå…¶ä¸­å¤šä¸ªçº¿ç¨‹åŒæ—¶æ‰§è¡Œç›¸åŒçš„æŒ‡ä»¤ï¼Œä½†å¤„ç†ä¸åŒçš„æ•°æ®ã€‚CUDA é€šè¿‡åˆ†å±‚çš„çº¿ç¨‹ç»“æ„å’Œå†…å­˜ç®¡ç†ç³»ç»Ÿï¼Œé«˜æ•ˆç»„ç»‡è®¡ç®—ä»»åŠ¡ã€‚ çº¿ç¨‹å±‚æ¬¡ç»“æ„ï¼š çº¿ç¨‹ï¼ˆThreadï¼‰ï¼šæ‰§è¡Œç‰¹å®šä»»åŠ¡çš„æœ€å°æ‰§è¡Œå•å…ƒã€‚ çº¿ç¨‹å—ï¼ˆThread Blockï¼‰ï¼šçº¿ç¨‹çš„é›†åˆï¼Œçº¿ç¨‹å—ä¸­çš„çº¿ç¨‹å…±åŒæ‰§è¡Œä»»åŠ¡ã€‚ä¸€ä¸ªçº¿ç¨‹å—æœ€å¤šåŒ…å« 1024 ä¸ªçº¿ç¨‹ï¼ˆå…·ä½“å–å†³äº GPU æ¶æ„ï¼‰ã€‚ ç½‘æ ¼ï¼ˆGridï¼‰ï¼šçº¿ç¨‹å—çš„é›†åˆã€‚ç½‘æ ¼å¯ä»¥æ˜¯ 1Dã€2D æˆ– 3Dï¼Œä»¥ä¾¿æ›´æ–¹ä¾¿åœ°å°†çº¿ç¨‹æ˜ å°„åˆ°æ•°æ®ä¸Šã€‚ é€šè¿‡å”¯ä¸€çš„ç´¢å¼•ï¼ˆå¦‚ threadIdxã€blockIdxã€blockDim å’Œ gridDimï¼‰ï¼Œæ¯ä¸ªçº¿ç¨‹å¯ä»¥è®¿é—®ç‰¹å®šçš„æ•°æ®éƒ¨åˆ†ã€‚ å†…å­˜å±‚æ¬¡ç»“æ„ï¼š å…¨å±€å†…å­˜ï¼ˆGlobal Memoryï¼‰ï¼šæ‰€æœ‰çº¿ç¨‹éƒ½å¯ä»¥è®¿é—®ï¼Œä½†è®¿é—®å»¶è¿Ÿè¾ƒé«˜ã€‚ å…±äº«å†…å­˜ï¼ˆShared Memoryï¼‰ï¼šçº¿ç¨‹å—å†…çš„çº¿ç¨‹å…±äº«çš„ä¸€ç§å¿«é€Ÿã€ä½å»¶è¿Ÿçš„å†…å­˜ã€‚ å±€éƒ¨å†…å­˜ï¼ˆLocal Memoryï¼‰ï¼šæ¯ä¸ªçº¿ç¨‹çš„ç§æœ‰å†…å­˜ï¼Œä½†ç”±äºä½äºå…¨å±€å†…å­˜ä¸­ï¼Œè®¿é—®é€Ÿåº¦è¾ƒæ…¢ã€‚ å¯„å­˜å™¨ï¼ˆRegistersï¼‰ï¼šé€Ÿåº¦æå¿«ï¼Œä½†æ•°é‡æœ‰é™ï¼Œç”¨äºå­˜å‚¨çº¿ç¨‹çš„ä¸´æ—¶å˜é‡ã€‚ å†…æ ¸ï¼ˆKernelï¼‰ï¼š CUDA å†…æ ¸æ˜¯è¿è¡Œåœ¨ GPU ä¸Šçš„å‡½æ•°ï¼Œä½¿ç”¨ C/C++ è¯­è¨€ç¼–å†™å¹¶å¸¦æœ‰ç‰¹æ®Šçš„è¯­æ³•æ ‡è®°ã€‚å†…æ ¸ä» CPU å‘èµ·ï¼Œå¹¶ç”± GPU çš„çº¿ç¨‹å¹¶è¡Œæ‰§è¡Œã€‚ Introduction The advent of multicore CPUs and manycore GPUs means that mainstream processor chips are now parallel systems. The challenge is to develop application software that transparently scales its parallelism to leverage the increasing number of processor cores. The CUDA parallel programming model is designed to overcome this challenge while maintaing a low learning curve for programmers familiar with C. Its core is three key abstractions: a hierarchy of thread groups: å±‚çº§çº¿ç¨‹ç»„ shared memories: å…±äº«å†…å­˜ barrier synchronization: éšœç¢åŒæ­¥ These abstractions provide fine-grained data parallelism and thread parallelism, nested within coarse-grained data parallelism and task parallelism. They guide the programmer to partition the problem into coarse sub-problems that can be solved independently in parallel by blocks of threads, and each sub-problem into finer pieces that can be solved cooperatively in parallel by all threads within the block. è¿™äº›æŠ½è±¡æä¾›äº†ç»†ç²’åº¦æ•°æ®å¹¶è¡Œæ€§å’Œçº¿ç¨‹å¹¶è¡Œæ€§ï¼ŒåµŒå¥—åœ¨ç²—ç²’åº¦æ•°æ®å¹¶è¡Œæ€§å’Œä»»åŠ¡å¹¶è¡Œæ€§ä¸­ã€‚å®ƒä»¬å¼•å¯¼ç¨‹åºå‘˜å°†é—®é¢˜åˆ’åˆ†ä¸ºå¯ä»¥ç”±çº¿ç¨‹å—ç‹¬ç«‹å¹¶è¡Œè§£å†³çš„ç²—ç•¥å­é—®é¢˜ï¼Œå¹¶å°†æ¯ä¸ªå­é—®é¢˜åˆ’åˆ†ä¸ºå¯ä»¥ç”±å—å†…çš„æ‰€æœ‰çº¿ç¨‹å¹¶è¡Œåä½œè§£å†³çš„æ›´ç²¾ç»†çš„éƒ¨åˆ†ã€‚ This decomposition preserves language expressivity by allowing threads to cooperate when solving each sub-problem, and at the same time enables automatic scalability. Indeed, each block of threads can be scheduled on any of the available multiprocessors within a GPU, in any order, concurrently or sequentially, so that a compiled CUDA program can execute on any number of multiprocessors as illustrated by Figure 3, and only the runtime system needs to know the physical multiprocessor count. è¿™ç§åˆ†è§£é€šè¿‡å…è®¸çº¿ç¨‹åœ¨è§£å†³æ¯ä¸ªå­é—®é¢˜æ—¶è¿›è¡Œåˆä½œæ¥ä¿ç•™è¯­è¨€è¡¨è¾¾èƒ½åŠ›ï¼ŒåŒæ—¶å®ç°è‡ªåŠ¨å¯æ‰©å±•æ€§ã€‚äº‹å®ä¸Šï¼Œæ¯ä¸ªçº¿ç¨‹å—éƒ½å¯ä»¥ä»¥ä»»ä½•é¡ºåºï¼ˆåŒæ—¶æˆ–é¡ºåºï¼‰è°ƒåº¦åˆ° GPU å†…çš„ä»»ä½•å¯ç”¨å¤šå¤„ç†å™¨ä¸Šï¼Œä»¥ä¾¿ç¼–è¯‘åçš„ CUDA ç¨‹åºå¯ä»¥åœ¨ä»»æ„æ•°é‡çš„å¤šå¤„ç†å™¨ä¸Šæ‰§è¡Œï¼Œå¦‚å›¾ 3 æ‰€ç¤ºï¼Œå¹¶ä¸”ä»…è¿è¡Œæ—¶ç³»ç»Ÿéœ€è¦çŸ¥é“ç‰©ç†å¤šå¤„ç†å™¨æ•°é‡ã€‚ A GPU is built around an array of Streaming Multiprocessors (SMs) GPU ç”±æµå¼å¤šå¤„ç†å™¨ (SM) é˜µåˆ—æ„å»º Programming Model ç¼–ç¨‹æ¨¡å‹ Kernels: å†…æ ¸å‡½æ•° Thread Hierarachy: çº¿ç¨‹å±‚æ¬¡ç»“æ„ Memory Hierarachy: å†…å­˜å±‚æ¬¡ç»“æ„ Heteroheneous Programming: å¼‚æ„ç¼–ç¨‹ Asynchronous SIMT Programming Model: å¼‚æ­¥ SIMT ç¼–ç¨‹æ¨¡å‹ Compute Capability: è®¡ç®—èƒ½åŠ› Kernels: å†…æ ¸å‡½æ•° CUDA C++ extends C++ by allowing the programmer to define C++ functions, called kernels, that, when called, are executed N times in parallel by N different CUDA threads, as opposed to only once like regular C++ functions. CUDA C++ é€šè¿‡å…è®¸ç¨‹åºå‘˜å®šä¹‰ç§°ä¸ºå†…æ ¸çš„ C++ å‡½æ•°æ¥æ‰©å±• C++ï¼Œè¿™äº›å‡½æ•°åœ¨è°ƒç”¨æ—¶ç”± N ä¸ªä¸åŒçš„ CUDA çº¿ç¨‹å¹¶è¡Œæ‰§è¡Œ N æ¬¡ï¼Œè€Œä¸æ˜¯åƒå¸¸è§„ C++ å‡½æ•°é‚£æ ·åªèƒ½æ‰§è¡Œä¸€æ¬¡ã€‚ A kernel is defined using the __global__ declaration specifier and the number of CUDA threads that execute that kernel for a given kernel call is specified using a new >> execution configuration syntax (see C++ Language Extensions). Each thread that executes the kernel is given a unique thread ID that is accessible within the kernel through built-in variables. ä½¿ç”¨ __global__ å£°æ˜è¯´æ˜ç¬¦å®šä¹‰å†…æ ¸ï¼Œå¹¶ä½¿ç”¨æ–°çš„ >> æ‰§è¡Œé…ç½®è¯­æ³•æŒ‡å®šä¸ºç»™å®šå†…æ ¸è°ƒç”¨æ‰§è¡Œè¯¥å†…æ ¸çš„ CUDA çº¿ç¨‹æ•°ï¼ˆè¯·å‚é˜… C++è¯­è¨€æ‰©å±•ï¼‰ã€‚æ¯ä¸ªæ‰§è¡Œå†…æ ¸çš„çº¿ç¨‹éƒ½ä¼šè¢«èµ‹äºˆä¸€ä¸ªå”¯ä¸€çš„çº¿ç¨‹ ID ï¼Œè¯¥ ID å¯ä»¥åœ¨å†…æ ¸ä¸­é€šè¿‡å†…ç½®å˜é‡è¿›è¡Œè®¿é—®ã€‚ Thread Hierarachy: çº¿ç¨‹å±‚æ¬¡ç»“æ„ grids - blocks - threads å—å†…çº¿ç¨‹é©»ç•™åœ¨åŒä¸€ä¸ª core ä¸Šï¼Œå…±äº«å†…å­˜ blocks, threads ç”±ä¸‰ç»´ä¸‹æ ‡ç´¢å¼• threadIdx.x, .y, .z blockIdx.x, .y, .z block å°ºå¯¸: blockDim.x, .y, .z For convenience, threadIdx is a 3-component vector, so that threads can be identified using a one-dimensional, two-dimensional, or three-dimensional thread index, forming a one-dimensional, two-dimensional, or three-dimensional block of threads, called a thread block. This provides a natural way to invoke computation across the elements in a domain such as a vector, matrix, or volume. The index of a thread and its thread ID relate to each other in a straightforward way: For a one-dimensional block, they are the same; for a two-dimensional block of size (Dx, Dy), the thread ID of a thread of index (x, y) is (x + y Dx); for a three-dimensional block of size (Dx, Dy, Dz), the thread ID of a thread of index (x, y, z) is (x + y Dx + z Dx Dy). There is a limit to the number of threads per block, since all threads of a block are expected to reside on the same streaming multiprocessor core and must share the limited memory resources of that core. On current GPUs, a thread block may contain up to 1024 threads. æ¯ä¸ªå—çš„çº¿ç¨‹æ•°é‡æ˜¯æœ‰é™çš„ï¼Œå› ä¸ºå—çš„æ‰€æœ‰çº¿ç¨‹éƒ½åº”è¯¥é©»ç•™åœ¨åŒä¸€ä¸ªæµå¼å¤šå¤„ç†å™¨æ ¸å¿ƒä¸Šï¼Œå¹¶ä¸”å¿…é¡»å…±äº«è¯¥æ ¸å¿ƒçš„æœ‰é™å†…å­˜èµ„æºã€‚åœ¨å½“å‰çš„ GPU ä¸Šï¼Œä¸€ä¸ªçº¿ç¨‹å—æœ€å¤šå¯ä»¥åŒ…å« 1024 ä¸ªçº¿ç¨‹ã€‚ However, a kernel can be executed by multiple equally-shaped thread blocks, so that the total number of threads is equal to the number of threads per block times the number of blocks. ç„¶è€Œï¼Œä¸€ä¸ªå†…æ ¸å¯ä»¥ç”±å¤šä¸ªå½¢çŠ¶ç›¸åŒçš„çº¿ç¨‹å—æ¥æ‰§è¡Œï¼Œå› æ­¤çº¿ç¨‹æ€»æ•°ç­‰äºæ¯ä¸ªå—çš„çº¿ç¨‹æ•°ä¹˜ä»¥å—æ•°ã€‚ Blocks are organized into a one-dimensional, two-dimensional, or three-dimensional grid of thread blocks as illustrated by Figure 4. The number of thread blocks in a grid is usually dictated by the size of the data being processed, which typically exceeds the number of processors in the system. å—è¢«ç»„ç»‡æˆä¸€ç»´ã€äºŒç»´æˆ–ä¸‰ç»´çº¿ç¨‹å—ç½‘æ ¼ï¼Œå¦‚å›¾ 4 æ‰€ç¤ºã€‚ç½‘æ ¼ä¸­çº¿ç¨‹å—çš„æ•°é‡é€šå¸¸ç”±æ­£åœ¨å¤„ç†çš„æ•°æ®å¤§å°å†³å®šï¼Œè¯¥æ•°æ®é€šå¸¸è¶…è¿‡ç³»ç»Ÿä¸­å¤„ç†å™¨çš„æ•°é‡ã€‚ Extending the previous MatAdd() example to handle multiple blocks, the code becomes as follows. // Kernel definition __global__ void MatAdd(float A[N][N], float B[N][N], float C[N][N]) { int i = blockIdx.x * blockDim.x + threadIdx.x; int j = blockIdx.y * blockDim.y + threadIdx.y; if (i >>(A, B, C); ... } Threads within a block can cooperate by sharing data through some shared memory and by synchronizing their execution to coordinate memory accesses. More precisely, one can specify synchronization points in the kernel by calling the __syncthreads() intrinsic function; __syncthreads() acts as a barrier at which all threads in the block must wait before any is allowed to proceed. In addition to __syncthreads(), the Cooperative Groups API provides a rich set of thread-synchronization primitives. å—å†…çš„çº¿ç¨‹å¯ä»¥é€šè¿‡æŸäº›å…±äº«å†…å­˜å…±äº«æ•°æ®å¹¶åŒæ­¥å…¶æ‰§è¡Œæ¥åè°ƒå†…å­˜è®¿é—®æ¥è¿›è¡Œåä½œã€‚æ›´å‡†ç¡®åœ°è¯´ï¼Œå¯ä»¥é€šè¿‡è°ƒç”¨__syncthreads()å†…éƒ¨å‡½æ•°æ¥æŒ‡å®šå†…æ ¸ä¸­çš„åŒæ­¥ç‚¹ï¼› __syncthreads()å……å½“å±éšœï¼Œå—ä¸­çš„æ‰€æœ‰çº¿ç¨‹éƒ½å¿…é¡»ç­‰å¾…ï¼Œç„¶åæ‰å…è®¸ä»»ä½•çº¿ç¨‹ç»§ç»­è¿›è¡Œã€‚é™¤äº†__syncthreads()ä¹‹å¤–ï¼Œåä½œç»„ API è¿˜æä¾›äº†ä¸€ç»„ä¸°å¯Œçš„çº¿ç¨‹åŒæ­¥åŸè¯­ã€‚ For efficient cooperation, the shared memory is expected to be a low-latency memory near each processor core (much like an L1 cache) and __syncthreads() is expected to be lightweight. ä¸ºäº†é«˜æ•ˆåˆä½œï¼Œå…±äº«å†…å­˜åº”è¯¥æ˜¯æ¯ä¸ªå¤„ç†å™¨æ ¸å¿ƒé™„è¿‘çš„ä½å»¶è¿Ÿå†…å­˜ï¼ˆå¾ˆåƒ L1 ç¼“å­˜ï¼‰ï¼Œå¹¶ä¸”__syncthreads()åº”è¯¥æ˜¯è½»é‡çº§çš„ã€‚ Memory Hierarachy: å†…å­˜å±‚æ¬¡ç»“æ„ CUDA threads may access data from multiple memory spaces during their execution as illustrated by Figure 6. Each thread has private local memory. Each thread block has shared memory visible to all threads of the block and with the same lifetime as the block. Thread blocks in a thread block cluster can perform read, write, and atomics operations on each otherâ€™s shared memory. All threads have access to the same global memory. CUDA çº¿ç¨‹åœ¨æ‰§è¡ŒæœŸé—´å¯ä»¥è®¿é—®å¤šä¸ªå†…å­˜ç©ºé—´ä¸­çš„æ•°æ®ï¼Œå¦‚å›¾ 6 æ‰€ç¤ºã€‚æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ç§æœ‰æœ¬åœ°å†…å­˜ã€‚æ¯ä¸ªçº¿ç¨‹å—éƒ½æœ‰å¯¹è¯¥å—çš„æ‰€æœ‰çº¿ç¨‹å¯è§çš„å…±äº«å†…å­˜ï¼Œå¹¶ä¸”ä¸è¯¥å—å…·æœ‰ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸã€‚çº¿ç¨‹å—ç°‡ä¸­çš„çº¿ç¨‹å—å¯ä»¥å¯¹å½¼æ­¤çš„å…±äº«å†…å­˜æ‰§è¡Œè¯»ã€å†™å’ŒåŸå­æ“ä½œã€‚æ‰€æœ‰çº¿ç¨‹éƒ½å¯ä»¥è®¿é—®ç›¸åŒçš„å…¨å±€å†…å­˜ã€‚ There are also two additional read-only memory spaces accessible by all threads: the constant and texture memory spaces. The global, constant, and texture memory spaces are optimized for different memory usages (see Device Memory Accesses). Texture memory also offers different addressing modes, as well as data filtering, for some specific data formats (see Texture and Surface Memory). è¿˜æœ‰ä¸¤ä¸ªå¯ä¾›æ‰€æœ‰çº¿ç¨‹è®¿é—®çš„é™„åŠ åªè¯»å†…å­˜ç©ºé—´ï¼šå¸¸é‡å†…å­˜ç©ºé—´å’Œçº¹ç†å†…å­˜ç©ºé—´ã€‚å…¨å±€ã€å¸¸é‡å’Œçº¹ç†å†…å­˜ç©ºé—´é’ˆå¯¹ä¸åŒçš„å†…å­˜ä½¿ç”¨è¿›è¡Œäº†ä¼˜åŒ–ï¼ˆè¯·å‚é˜…è®¾å¤‡å†…å­˜è®¿é—®ï¼‰ã€‚çº¹ç†å†…å­˜è¿˜ä¸ºæŸäº›ç‰¹å®šçš„æ•°æ®æ ¼å¼æä¾›ä¸åŒçš„å¯»å€æ¨¡å¼ä»¥åŠæ•°æ®è¿‡æ»¤ï¼ˆè¯·å‚é˜…çº¹ç†å’Œè¡¨é¢å†…å­˜ï¼‰ã€‚ The global, constant, and texture memory spaces are persistent across kernel launches by the same application. å…¨å±€ã€å¸¸é‡å’Œçº¹ç†å†…å­˜ç©ºé—´åœ¨åŒä¸€åº”ç”¨ç¨‹åºçš„å†…æ ¸å¯åŠ¨è¿‡ç¨‹ä¸­æ˜¯æŒä¹…çš„ã€‚ Heteroheneous Programming: å¼‚æ„ç¼–ç¨‹ As illustrated by Figure 7, the CUDA programming model assumes that the CUDA threads execute on a physically separate device that operates as a coprocessor to the host running the C++ program. This is the case, for example, when the kernels execute on a GPU and the rest of the C++ program executes on a CPU. å¦‚å›¾ 7 æ‰€ç¤ºï¼ŒCUDA ç¼–ç¨‹æ¨¡å‹å‡è®¾ CUDA çº¿ç¨‹åœ¨ç‰©ç†ä¸Šç‹¬ç«‹çš„è®¾å¤‡ä¸Šæ‰§è¡Œï¼Œè¯¥è®¾å¤‡ä½œä¸ºè¿è¡Œ C++ ç¨‹åºçš„ä¸»æœºçš„åå¤„ç†å™¨è¿è¡Œã€‚ä¾‹å¦‚ï¼Œå½“å†…æ ¸åœ¨ GPU ä¸Šæ‰§è¡Œè€Œ C++ ç¨‹åºçš„å…¶ä½™éƒ¨åˆ†åœ¨ CPU ä¸Šæ‰§è¡Œæ—¶ï¼Œå°±ä¼šå‡ºç°è¿™ç§æƒ…å†µã€‚ The CUDA programming model also assumes that both the host and the device maintain their own separate memory spaces in DRAM, referred to as host memory and device memory, respectively. Therefore, a program manages the global, constant, and texture memory spaces visible to kernels through calls to the CUDA runtime (described in Programming Interface). This includes device memory allocation and deallocation as well as data transfer between host and device memory. CUDA ç¼–ç¨‹æ¨¡å‹è¿˜å‡è®¾ä¸»æœºå’Œè®¾å¤‡éƒ½åœ¨ DRAM ä¸­ç»´æŠ¤è‡ªå·±ç‹¬ç«‹çš„å†…å­˜ç©ºé—´ï¼Œåˆ†åˆ«ç§°ä¸ºä¸»æœºå†…å­˜å’Œè®¾å¤‡å†…å­˜ã€‚å› æ­¤ï¼Œç¨‹åºé€šè¿‡è°ƒç”¨ CUDA è¿è¡Œæ—¶ï¼ˆåœ¨ç¼–ç¨‹æ¥å£ä¸­æè¿°ï¼‰æ¥ç®¡ç†å†…æ ¸å¯è§çš„å…¨å±€ã€å¸¸é‡å’Œçº¹ç†å†…å­˜ç©ºé—´ã€‚è¿™åŒ…æ‹¬è®¾å¤‡å†…å­˜åˆ†é…å’Œé‡Šæ”¾ä»¥åŠä¸»æœºå’Œè®¾å¤‡å†…å­˜ä¹‹é—´çš„æ•°æ®ä¼ è¾“ã€‚ Unified Memory provides managed memory to bridge the host and device memory spaces. Managed memory is accessible from all CPUs and GPUs in the system as a single, coherent memory image with a common address space. This capability enables oversubscription of device memory and can greatly simplify the task of porting applications by eliminating the need to explicitly mirror data on host and device. See Unified Memory Programming for an introduction to Unified Memory. ç»Ÿä¸€å†…å­˜æä¾›æ‰˜ç®¡å†…å­˜æ¥æ¡¥æ¥ä¸»æœºå’Œè®¾å¤‡å†…å­˜ç©ºé—´ã€‚æ‰˜ç®¡å†…å­˜å¯ä½œä¸ºå…·æœ‰å…¬å…±åœ°å€ç©ºé—´çš„å•ä¸ªä¸€è‡´å†…å­˜æ˜ åƒä»ç³»ç»Ÿä¸­çš„æ‰€æœ‰ CPU å’Œ GPU è¿›è¡Œè®¿é—®ã€‚æ­¤åŠŸèƒ½å¯å®ç°è®¾å¤‡å†…å­˜çš„è¶…é¢è®¢é˜…ï¼Œå¹¶ä¸”æ— éœ€åœ¨ä¸»æœºå’Œè®¾å¤‡ä¸Šæ˜¾å¼é•œåƒæ•°æ®ï¼Œä»è€Œå¤§å¤§ç®€åŒ–ç§»æ¤åº”ç”¨ç¨‹åºçš„ä»»åŠ¡ã€‚æœ‰å…³ç»Ÿä¸€å†…å­˜çš„ä»‹ç»ï¼Œè¯·å‚é˜…ç»Ÿä¸€å†…å­˜ç¼–ç¨‹ã€‚ Serial code executes on the host while parallel code executes on the device. ä¸²è¡Œä»£ç åœ¨ä¸»æœºä¸Šæ‰§è¡Œï¼Œè€Œå¹¶è¡Œä»£ç åœ¨è®¾å¤‡ä¸Šæ‰§è¡Œã€‚ Asynchronous SIMT Programming Model: å¼‚æ­¥ SIMT ç¼–ç¨‹æ¨¡å‹ In the CUDA programming model a thread is the lowest level of abstraction for doing a computation or a memory operation. Starting with devices based on the NVIDIA Ampere GPU architecture, the CUDA programming model provides acceleration to memory operations via the asynchronous programming model. The asynchronous programming model defines the behavior of asynchronous operations with respect to CUDA threads. åœ¨ CUDA ç¼–ç¨‹æ¨¡å‹ä¸­ï¼Œçº¿ç¨‹æ˜¯æ‰§è¡Œè®¡ç®—æˆ–å†…å­˜æ“ä½œçš„æœ€ä½æŠ½è±¡çº§åˆ«ã€‚ä»åŸºäº NVIDIA Ampere GPU æ¶æ„çš„è®¾å¤‡å¼€å§‹ï¼ŒCUDA ç¼–ç¨‹æ¨¡å‹é€šè¿‡å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹æä¾›å†…å­˜æ“ä½œåŠ é€Ÿã€‚å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹å®šä¹‰äº†ä¸ CUDA çº¿ç¨‹ç›¸å…³çš„å¼‚æ­¥æ“ä½œçš„è¡Œä¸ºã€‚ The asynchronous programming model defines the behavior of Asynchronous Barrier for synchronization between CUDA threads. The model also explains and defines how cuda::memcpy_async can be used to move data asynchronously from global memory while computing in the GPU. å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹å®šä¹‰äº†ç”¨äº CUDA çº¿ç¨‹ä¹‹é—´åŒæ­¥çš„å¼‚æ­¥å±éšœçš„è¡Œä¸ºã€‚è¯¥æ¨¡å‹è¿˜è§£é‡Šå¹¶å®šä¹‰äº†å¦‚ä½•ä½¿ç”¨cuda::memcpy_asyncåœ¨ GPU ä¸­è®¡ç®—æ—¶ä»å…¨å±€å†…å­˜å¼‚æ­¥ç§»åŠ¨æ•°æ®ã€‚ 2.5.1. Asynchronous Operations 2.5.1.å¼‚æ­¥æ“ä½œ An asynchronous operation is defined as an operation that is initiated by a CUDA thread and is executed asynchronously as-if by another thread. In a well formed program one or more CUDA threads synchronize with the asynchronous operation. The CUDA thread that initiated the asynchronous operation is not required to be among the synchronizing threads. å¼‚æ­¥æ“ä½œè¢«å®šä¹‰ä¸ºç”± CUDA çº¿ç¨‹å‘èµ·å¹¶åƒç”±å¦ä¸€ä¸ªçº¿ç¨‹ä¸€æ ·å¼‚æ­¥æ‰§è¡Œçš„æ“ä½œã€‚åœ¨æ ¼å¼è‰¯å¥½çš„ç¨‹åºä¸­ï¼Œä¸€ä¸ªæˆ–å¤šä¸ª CUDA çº¿ç¨‹ä¸å¼‚æ­¥æ“ä½œåŒæ­¥ã€‚å¯åŠ¨å¼‚æ­¥æ“ä½œçš„ CUDA çº¿ç¨‹ä¸éœ€è¦ä½äºåŒæ­¥çº¿ç¨‹ä¸­ã€‚ Such an asynchronous thread (an as-if thread) is always associated with the CUDA thread that initiated the asynchronous operation. An asynchronous operation uses a synchronization object to synchronize the completion of the operation. Such a synchronization object can be explicitly managed by a user (e.g., cuda::memcpy_async) or implicitly managed within a library (e.g., cooperative_groups::memcpy_async). è¿™æ ·çš„å¼‚æ­¥çº¿ç¨‹ï¼ˆas-if çº¿ç¨‹ï¼‰å§‹ç»ˆä¸å¯åŠ¨å¼‚æ­¥æ“ä½œçš„ CUDA çº¿ç¨‹ç›¸å…³è”ã€‚å¼‚æ­¥æ“ä½œä½¿ç”¨åŒæ­¥å¯¹è±¡æ¥åŒæ­¥æ“ä½œçš„å®Œæˆã€‚è¿™æ ·çš„åŒæ­¥å¯¹è±¡å¯ä»¥ç”±ç”¨æˆ·æ˜¾å¼ç®¡ç†ï¼ˆä¾‹å¦‚ï¼Œ cuda::memcpy_async ï¼‰æˆ–åœ¨åº“ä¸­éšå¼ç®¡ç†ï¼ˆä¾‹å¦‚ï¼Œ cooperative_groups::memcpy_async ï¼‰ã€‚ A synchronization object could be a cuda::barrier or a cuda::pipeline. These objects are explained in detail in Asynchronous Barrier and Asynchronous Data Copies using cuda::pipeline. These synchronization objects can be used at different thread scopes. A scope defines the set of threads that may use the synchronization object to synchronize with the asynchronous operation. The following table defines the thread scopes available in CUDA C++ and the threads that can be synchronized with each. åŒæ­¥å¯¹è±¡å¯ä»¥æ˜¯cuda::barrieræˆ–cuda::pipeline ã€‚è¿™äº›å¯¹è±¡åœ¨ä½¿ç”¨ cuda::pipeline çš„å¼‚æ­¥å±éšœå’Œå¼‚æ­¥æ•°æ®å‰¯æœ¬ä¸­è¯¦ç»†è§£é‡Šã€‚è¿™äº›åŒæ­¥å¯¹è±¡å¯ä»¥åœ¨ä¸åŒçš„çº¿ç¨‹èŒƒå›´å†…ä½¿ç”¨ã€‚èŒƒå›´å®šä¹‰äº†å¯ä»¥ä½¿ç”¨åŒæ­¥å¯¹è±¡æ¥ä¸å¼‚æ­¥æ“ä½œåŒæ­¥çš„çº¿ç¨‹é›†ã€‚ä¸‹è¡¨å®šä¹‰äº† CUDA C++ ä¸­å¯ç”¨çš„çº¿ç¨‹èŒƒå›´ä»¥åŠå¯ä»¥ä¸æ¯ä¸ªçº¿ç¨‹åŒæ­¥çš„çº¿ç¨‹ã€‚ Compute Capability: è®¡ç®—èƒ½åŠ› Programming Interface ç¼–ç¨‹æ¥å£ Hardware Implementation ç¡¬ä»¶å®ç° Performance Guidelines æ€§èƒ½æŒ‡å— PTX Parallel Thread Execution PTX: a low-level parallel thread execution virtual machine and instruction set architecture. PTX æ˜¯ä¸€ç§ä½çº§å¹¶è¡Œçº¿ç¨‹æ‰§è¡Œè™šæ‹Ÿæœºå’ŒæŒ‡ä»¤é›†ä½“ç³»ç»“æ„ã€‚ PTX exposes the GPU as data-parallel computing device. Numba Overviewïƒ æ¦‚è¿° ïƒ Numba supports CUDA GPU programming by directly compiling a restricted subset of Python code into CUDA kernels and device functions following the CUDA execution model. Kernels written in Numba appear to have direct access to NumPy arrays. NumPy arrays are transferred between the CPU and the GPU automatically. Numba é€šè¿‡å°† Python ä»£ç çš„å—é™å­é›†ç›´æ¥ç¼–è¯‘ä¸ºéµå¾ª CUDA æ‰§è¡Œæ¨¡å‹çš„ CUDA å†…æ ¸å’Œè®¾å¤‡å‡½æ•°æ¥æ”¯æŒ CUDA GPU ç¼–ç¨‹ã€‚ç”¨ Numba ç¼–å†™çš„å†…æ ¸ä¼¼ä¹å¯ä»¥ç›´æ¥è®¿é—® NumPy æ•°ç»„ã€‚ NumPy æ•°ç»„åœ¨ CPU å’Œ GPU ä¹‹é—´è‡ªåŠ¨ä¼ è¾“ã€‚ Install CUDA CUDA Toolkit Archive NVIDIA CUDA Installation Guide for Linux Other Resources Programming Massively Parallel Processors: A Hands-on Approach Programming Massively Parallel Processors: A Hands-on Approach, Second Edition, teaches students how to program massively parallel processors. It offers a detailed discussion of various techniques for constructing parallel programs. Case studies are used to demonstrate the development process, which begins with computational thinking and ends with effective and efficient parallel programs. This guide shows both student and professional alike the basic concepts of parallel programming and GPU architecture. Topics of performance, floating-point format, parallel patterns, and dynamic parallelism are covered in depth. This revised edition contains more parallel programming examples, commonly-used libraries such as Thrust, and explanations of the latest tools. It also provides new coverage of CUDA 5.0, improved performance, enhanced development tools, increased hardware support, and more; increased coverage of related technology, OpenCL and new material on algorithm patterns, GPU clusters, host programming, and data parallelism; and two new case studies (on MRI reconstruction and molecular visualization) that explore the latest applications of CUDA and GPUs for scientific research and high-performance computing. This book should be a valuable resource for advanced students, software engineers, programmers, and hardware engineers. Programming Massively Parallel Processorsï¼š A Hands-on Approachï¼Œç¬¬äºŒç‰ˆï¼Œæ•™æˆå­¦ç”Ÿå¦‚ä½•å¯¹å¤§è§„æ¨¡å¹¶è¡Œå¤„ç†å™¨è¿›è¡Œç¼–ç¨‹ã€‚å®ƒè¯¦ç»†è®¨è®ºäº†ç”¨äºæ„å»ºå¹¶è¡Œç¨‹åºçš„å„ç§æŠ€æœ¯ã€‚æ¡ˆä¾‹ç ”ç©¶ç”¨äºæ¼”ç¤ºå¼€å‘è¿‡ç¨‹ï¼Œè¯¥è¿‡ç¨‹ä»è®¡ç®—æ€ç»´å¼€å§‹ï¼Œä»¥æœ‰æ•ˆå’Œé«˜æ•ˆçš„å¹¶è¡Œç¨‹åºç»“æŸã€‚æœ¬æŒ‡å—å‘å­¦ç”Ÿå’Œä¸“ä¸šäººå£«å±•ç¤ºäº†å¹¶è¡Œç¼–ç¨‹å’Œ GPU æ¶æ„çš„åŸºæœ¬æ¦‚å¿µã€‚æ·±å…¥ä»‹ç»äº†æ€§èƒ½ã€æµ®ç‚¹æ ¼å¼ã€å¹¶è¡Œæ¨¡å¼å’ŒåŠ¨æ€å¹¶è¡Œæ€§ç­‰ä¸»é¢˜ã€‚æ­¤ä¿®è®¢ç‰ˆåŒ…å«æ›´å¤šå¹¶è¡Œç¼–ç¨‹ç¤ºä¾‹ã€å¸¸ç”¨åº“ï¼ˆå¦‚ Thrustï¼‰ä»¥åŠæœ€æ–°å·¥å…·çš„è§£é‡Šã€‚å®ƒè¿˜æä¾›äº† CUDA 5.0 çš„æ–°è¦†ç›–èŒƒå›´ã€æ”¹è¿›çš„æ€§èƒ½ã€å¢å¼ºçš„å¼€å‘å·¥å…·ã€å¢å¼ºçš„ç¡¬ä»¶æ”¯æŒç­‰;å¢åŠ äº†ç›¸å…³æŠ€æœ¯ã€OpenCL å’Œæœ‰å…³ç®—æ³•æ¨¡å¼ã€GPU é›†ç¾¤ã€ä¸»æœºç¼–ç¨‹å’Œæ•°æ®å¹¶è¡Œæ€§çš„æ–°ææ–™çš„è¦†ç›–èŒƒå›´;ä»¥åŠä¸¤ä¸ªæ–°çš„æ¡ˆä¾‹ç ”ç©¶ï¼ˆå…³äº MRI é‡å»ºå’Œåˆ†å­å¯è§†åŒ–ï¼‰ï¼Œæ¢ç´¢ CUDA å’Œ GPU åœ¨ç§‘å­¦ç ”ç©¶å’Œé«˜æ€§èƒ½è®¡ç®—ä¸­çš„æœ€æ–°åº”ç”¨ã€‚è¿™æœ¬ä¹¦åº”è¯¥æ˜¯é«˜çº§å­¦ç”Ÿã€è½¯ä»¶å·¥ç¨‹å¸ˆã€ç¨‹åºå‘˜å’Œç¡¬ä»¶å·¥ç¨‹å¸ˆçš„å®è´µèµ„æºã€‚ CUDA Examples #include #include // CUDA kernel function for vector addition __global__ void vectorAdd(const float* A, const float* B, float* C, int N) { int i = blockIdx.x * blockDim.x + threadIdx.x; // Calculate global thread index if (i (i); h_B[i] = static_cast(i * 2); } // Allocate device memory float *d_A, *d_B, *d_C; cudaMalloc((void**)&d_A, size); cudaMalloc((void**)&d_B, size); cudaMalloc((void**)&d_C, size); // Copy data from host to device cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice); cudaMemcpy(d_B, h_B, size, cudaMemcpyHostToDevice); // Launch kernel int threadsPerBlock = 256; int blocksPerGrid = (N + threadsPerBlock - 1) / threadsPerBlock; vectorAdd>>(d_A, d_B, d_C, N); // Copy result back to host cudaMemcpy(h_C, d_C, size, cudaMemcpyDeviceToHost); // Print some results for (int i = 0; i "},"Learn/LearnCUDA/CUDA_multi.html":{"url":"Learn/LearnCUDA/CUDA_multi.html","title":"CUDA_multi","keywords":"","body":"CUDA Multi Version Installing multiple CUDA + cuDNN versions in the same machine for Tensorflow and Pytorch cuda-compatibility # add below to your env bash file. function _switch_cuda { v=$1 export PATH=$PATH:/usr/local/cuda-$v/bin export CUDADIR=/usr/local/cuda-$v export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-$v/lib64 nvcc --version } And call this function to switch to a corresponding cuda version on your bash session _switch_cuda 11.0 # change the version of your like to load bash. Multiple Version of CUDA Libraries On The Same Machine sudo sh cuda-9.1.run --silent --toolkit --toolkitpath=/usr/local/cuda-9.1 Managing Multiple CUDA Versions on a Single Machine: A Comprehensive Guide export PATH=/usr/local/cuda-11.8/bin:$PATH export LD_LIBRARY_PATH=/usr/local/cuda-11.8/lib64:$LD_LIBRARY_PATH # Activate the virtual environment echo \"export PATH=/usr/local/cuda-11.8/bin:$PATH\" >> venv/my_env/bin/activate echo \"LD_LIBRARY_PATH=/usr/local/cuda-11.8/lib64:$LD_LIBRARY_PATH\" >> venv/my_env/bin/activate "},"Learn/LearnCUDA/NCCL.html":{"url":"Learn/LearnCUDA/NCCL.html","title":"NCCL","keywords":"","body":"https://developer.nvidia.com/nccl NVIDIA Collective Communications Library (NCCL) NVIDIA NCCL è‹±ä¼Ÿè¾¾ NCCL The NVIDIA Collective Communication Library (NCCL) implements multi-GPU and multi-node communication primitives optimized for NVIDIA GPUs and Networking. NCCL provides routines such as all-gather, all-reduce, broadcast, reduce, reduce-scatter as well as point-to-point send and receive that are optimized to achieve high bandwidth and low latency over PCIe and NVLink high-speed interconnects within a node and over NVIDIA Mellanox Network across nodes. NVIDIA é›†ä½“é€šä¿¡åº“ (NCCL) å®ç°äº†é’ˆå¯¹ NVIDIA GPU å’Œç½‘ç»œè¿›è¡Œä¼˜åŒ–çš„å¤š GPU å’Œå¤šèŠ‚ç‚¹é€šä¿¡åŸè¯­ã€‚ NCCL æä¾›å…¨æ”¶é›†ã€å…¨å½’çº¦ã€å¹¿æ’­ã€å½’çº¦ã€å½’çº¦åˆ†æ•£ä»¥åŠç‚¹å¯¹ç‚¹å‘é€å’Œæ¥æ”¶ç­‰ä¾‹ç¨‹ï¼Œè¿™äº›ä¾‹ç¨‹ç»è¿‡ä¼˜åŒ–ï¼Œå¯åœ¨ PCIe å’Œ NVLink é«˜é€Ÿäº’è¿ä¸Šå®ç°é«˜å¸¦å®½å’Œä½å»¶è¿Ÿã€‚ä¸€ä¸ªèŠ‚ç‚¹ä»¥åŠè·¨èŠ‚ç‚¹çš„ NVIDIA Mellanox ç½‘ç»œã€‚ "},"Learn/LearnCUDA/TensorCores.html":{"url":"Learn/LearnCUDA/TensorCores.html","title":"TensorCores","keywords":"","body":"Tensor Cores CUDA Toolkit Documentation 12.2 (nvidia.com) NVIDIA è‹±ä¼Ÿè¾¾ Tensor Core åŸºæœ¬åŸç†(ä¸Š)ã€AI èŠ¯ç‰‡ã€‘GPU æ¶æ„ 04_å“”å“©å“”å“©_bilibili Tensor Coreï¼š ä¸“é—¨åšçŸ©é˜µä¹˜ï¼ŒçŸ©é˜µåŠ ï¼Œå¯ä»¥åœ¨ä¸€æ­¥ä¸­æ‰§è¡Œæ··åˆç²¾åº¦çš„çŸ©é˜µä¹˜æ³•å’Œç´¯ç§¯ã€‚è¿™æ„å‘³ç€å®ƒä»¬å¯ä»¥ä¹˜ä»¥ä¸¤ä¸ªçŸ©é˜µï¼Œç„¶åå°†ç¬¬ä¸‰ä¸ªçŸ©é˜µæ·»åŠ åˆ°ç»“æœä¸­ï¼Œè¿™æ˜¯æ·±åº¦å­¦ä¹ ä¸­çš„åŸºæœ¬æ“ä½œï¼Œé€Ÿåº¦éå¸¸å¿«ã€‚ GEMM é€šç”¨çŸ©é˜µä¹˜ General Matrix Multiplication FMA ä¹˜ç§¯ç´¯åŠ æŒ‡ä»¤ Fused Multiplyâ€“accumulate operation CUDA æ ¸å¿ƒå’Œ Tensor æ ¸å¿ƒ CUDA æ ¸å¿ƒå’Œ Tensor æ ¸å¿ƒéƒ½æ˜¯ NVIDIA GPU ä¸­çš„æ¶æ„ç»„ä»¶ï¼Œä½†å®ƒä»¬æ˜¯ä¸ºä¸åŒçš„ç›®çš„è®¾è®¡çš„å¹¶ä»¥ä¸åŒçš„æ–¹å¼æ“ä½œã€‚ä»¥ä¸‹æ˜¯å®ƒä»¬ä¹‹é—´çš„å·®å¼‚ï¼š 1. ç›®çš„ ï¼š CUDA æ ¸å¿ƒ ï¼šCUDA æ ¸å¿ƒæœ‰æ—¶è¢«ç§°ä¸ºâ€œæµå¼å¤šå¤„ç†å™¨â€æˆ–â€œç€è‰²å™¨æ ¸å¿ƒâ€ï¼Œå®ƒä»¬æ˜¯é€šç”¨çš„å¹¶ä¸”å¤„ç†å„ç§ä»»åŠ¡ï¼ŒåŒ…æ‹¬é¡¶ç‚¹ç€è‰²ã€åƒç´ ç€è‰²ã€å‡ ä½•ç€è‰²å’Œè®¡ç®—ä»»åŠ¡ã€‚å®ƒä»¬æ˜¯è´Ÿè´£ä¼ ç»Ÿ GPU ä»»åŠ¡çš„ä¸»è¦ç»„ä»¶ã€‚ Tensor æ ¸å¿ƒ ï¼šTensor æ ¸å¿ƒæ˜¯ NVIDIA æ¶æ„çš„è¾ƒæ–°æ·»åŠ ï¼Œä¸ Volta ä»£ä¸€èµ·å¼•å…¥ã€‚å®ƒä»¬æ˜¯ä¸“é—¨ä¸ºåŠ é€Ÿæ·±åº¦å­¦ä¹ å·¥ä½œè´Ÿè½½è€Œè®¾è®¡çš„ç¡¬ä»¶å•å…ƒï¼Œç‰¹åˆ«æ˜¯åœ¨ç¥ç»ç½‘ç»œè®­ç»ƒå’Œæ¨æ–­ä¸­å¸¸è§çš„çŸ©é˜µæ“ä½œã€‚ 2. æ“ä½œ ï¼š CUDA æ ¸å¿ƒ ï¼šCUDA æ ¸å¿ƒå¯ä»¥å¤„ç†æµ®ç‚¹ç®—æœ¯ã€æ•´æ•°ç®—æœ¯å’Œå…¶ä»–ä¼ ç»Ÿçš„ GPU ä»»åŠ¡ã€‚ Tensor æ ¸å¿ƒ ï¼šTensor æ ¸å¿ƒå¯ä»¥åœ¨ä¸€æ­¥ä¸­æ‰§è¡Œæ··åˆç²¾åº¦çš„çŸ©é˜µä¹˜æ³•å’Œç´¯ç§¯ã€‚è¿™æ„å‘³ç€å®ƒä»¬å¯ä»¥ä¹˜ä»¥ä¸¤ä¸ªçŸ©é˜µï¼Œç„¶åå°†ç¬¬ä¸‰ä¸ªçŸ©é˜µæ·»åŠ åˆ°ç»“æœä¸­ï¼Œè¿™æ˜¯æ·±åº¦å­¦ä¹ ä¸­çš„åŸºæœ¬æ“ä½œï¼Œé€Ÿåº¦éå¸¸å¿«ã€‚ 3. ç²¾åº¦ ï¼š CUDA æ ¸å¿ƒ ï¼šæ”¯æŒä»é«˜ç²¾åº¦ï¼ˆå¦‚ FP64ï¼‰åˆ°è¾ƒä½ç²¾åº¦ï¼ˆå¦‚ FP32ï¼‰çš„å¹¿æ³›ç²¾åº¦ã€‚ Tensor æ ¸å¿ƒ ï¼šä¸»è¦é’ˆå¯¹æ··åˆç²¾åº¦è®¡ç®—è¿›è¡Œäº†ä¼˜åŒ–ï¼Œé€šå¸¸ä½¿ç”¨ FP16ï¼ˆåŠç²¾åº¦ï¼‰è¿›è¡Œä¹˜æ³•å’Œ FP32ï¼ˆå•ç²¾åº¦ï¼‰è¿›è¡Œç´¯ç§¯ã€‚è¿™ç§æ··åˆç²¾åº¦æ–¹æ³•åœ¨æ·±åº¦å­¦ä¹ ä¸­æ˜¯æœ‰ç›Šçš„ï¼Œå› ä¸ºè®¸å¤šæ¨¡å‹å¯ä»¥å®¹å¿é™ä½çš„ç²¾åº¦ï¼Œè€Œä¸ä¼šå¯¹å‡†ç¡®æ€§äº§ç”Ÿé‡å¤§å½±å“ã€‚ 4. åœ¨ GPU æ¶æ„ä¸­çš„å­˜åœ¨ ï¼š CUDA æ ¸å¿ƒ ï¼šè‡ª 2007 å¹´å¼•å…¥ CUDA å¹³å°ä»¥æ¥ï¼ŒCUDA æ ¸å¿ƒä¸€ç›´æ˜¯ NVIDIA GPU çš„ä¸»è¦ç»„æˆéƒ¨åˆ†ã€‚ Tensor æ ¸å¿ƒ ï¼šå®ƒä»¬ä» Volta æ¶æ„å¼€å§‹å¼•å…¥ï¼ˆä¾‹å¦‚åœ¨ Tesla V100 ä¸­ï¼‰ï¼Œå¹¶ä¸”åœ¨éšåçš„æ¶æ„ä¸­ï¼ˆå¦‚ Turingã€Ampere ç­‰ï¼‰éƒ½å­˜åœ¨ã€‚ 5. æ€§èƒ½ ï¼š CUDA æ ¸å¿ƒ ï¼šé€šç”¨ï¼Œå¯ä»¥æœ‰æ•ˆåœ°å¤„ç†å„ç§ä»»åŠ¡ã€‚ Tensor æ ¸å¿ƒ ï¼šåœ¨ä¸æ·±åº¦å­¦ä¹ æœ‰å…³çš„ç‰¹å®šçŸ©é˜µæ“ä½œæ–¹é¢ï¼Œä¸ CUDA æ ¸å¿ƒç›¸æ¯”ï¼ŒTensor æ ¸å¿ƒæä¾›äº†æ˜æ˜¾æ›´å¿«çš„æ€§èƒ½ã€‚ æ€»ä¹‹ï¼Œè™½ç„¶ CUDA æ ¸å¿ƒå’Œ Tensor æ ¸å¿ƒéƒ½æ˜¯ NVIDIA çš„ GPU æ¶æ„çš„é‡è¦éƒ¨åˆ†ï¼Œä½† CUDA æ ¸å¿ƒæ˜¯å¤„ç†å„ç§ä»»åŠ¡çš„é€šç”¨æ ¸å¿ƒï¼Œè€Œ Tensor æ ¸å¿ƒæ˜¯é’ˆå¯¹æ·±åº¦å­¦ä¹ çŸ©é˜µæ“ä½œä¼˜åŒ–çš„ä¸“ç”¨å•å…ƒã€‚å½“è´­ä¹° NVIDIA ç¡¬ä»¶æ—¶ï¼Œåº”æ ¹æ®é¢„æœŸçš„ä¸»è¦ç”¨é€”ï¼ˆä¾‹å¦‚ï¼Œæ¸¸æˆã€å›¾å½¢ã€é€šç”¨è®¡ç®—ã€æ·±åº¦å­¦ä¹ ï¼‰è€ƒè™‘ CUDA æ ¸å¿ƒå’Œ Tensor æ ¸å¿ƒä¹‹é—´çš„å¹³è¡¡ã€‚ "},"Learn/LearnCV/ComputerVisoin.html":{"url":"Learn/LearnCV/ComputerVisoin.html","title":"ComputerVisoin","keywords":"","body":"Computer Vision Image Classification Object Detection: bounding box Image Segmentation: pixel-wise classification, cutting edges "},"Learn/LearnCV/OpenCV/OpenCV.html":{"url":"Learn/LearnCV/OpenCV/OpenCV.html","title":"OpenCV","keywords":"","body":"opencv-python haarcascade_frontalface_default.xml: Trained XML classifiers describes some features of some object we want to detect a cascade function is trained from a lot of positive(faces) and negative(non-faces) images. Image Read an image from file (using cv::imread) Display an image in an OpenCV window (using cv::imshow) Write an image to a file (using cv::imwrite) IMREAD_COLOR loads the image in the BGR 8-bit format. This is the default that is used here. IMREAD_UNCHANGED loads the image as is (including the alpha channel if present) IMREAD_GRAYSCALE loads the image as an intensity one core section, as here are defined the basic building blocks of the library imgcodecs module, which provides functions for reading and writing highgui module, as this contains the functions to show an image in a window Video VideoCapture() VideoWriter() Drawing Learn to draw different geometric shapes with OpenCV You will learn these functions : cv.line(), cv.circle() , cv.rectangle(), cv.ellipse(), cv.putText() etc. img, color, thikness, linType Mouse Learn to handle mouse events in OpenCV You will learn these functions : cv.setMouseCallback() ['EVENT_FLAG_ALTKEY', 'EVENT_FLAG_CTRLKEY', 'EVENT_FLAG_LBUTTON', 'EVENT_FLAG_MBUTTON', 'EVENT_FLAG_RBUTTON', 'EVENT_FLAG_SHIFTKEY', 'EVENT_LBUTTONDBLCLK', 'EVENT_LBUTTONDOWN', 'EVENT_LBUTTONUP', 'EVENT_MBUTTONDBLCLK', 'EVENT_MBUTTONDOWN', 'EVENT_MBUTTONUP', 'EVENT_MOUSEHWHEEL', 'EVENT_MOUSEMOVE', 'EVENT_MOUSEWHEEL', 'EVENT_RBUTTONDBLCLK', 'EVENT_RBUTTONDOWN', 'EVENT_RBUTTONUP'] Trackbar For cv.createTrackbar() function, first argument is the trackbar name, second one is the window name to which it is attached, third argument is the default value, fourth one is the maximum value and fifth one is the callback function which is executed every time trackbar value changes. The callback function always has a default argument which is the trackbar position. In our case, function does nothing, so we simply pass. Another important application of trackbar is to use it as a button or switch. OpenCV, by default, doesn't have button functionality. So you can use trackbar to get such functionality. In our application, we have created one switch in which application works only if switch is ON, otherwise screen is always black. Operations on Images Basic Operations on Images Learn to read and edit pixel values, working with image ROI and other basic operations. Arithmetic Operations on Images Perform arithmetic operations on images Performance Measurement and Improvement Techniques Getting a solution is important. But getting it in the fastest way is more important. Learn to check the speed of your code, optimize the code etc. Image Processing Feature Detection and Description Video Analysis "},"Learn/LearnConda/ChangeBaseEnv.html":{"url":"Learn/LearnConda/ChangeBaseEnv.html","title":"ChangeBaseEnv","keywords":"","body":"Change the Default Base Environment in Conda Problem: on linux (debian12), how to change the default 'base' env in conda? current 'base' env use python12, i wnat use python11 as my default base env fo conda, how to do that? Solution: To change the default base environment in Conda to use Python 3.11 instead of Python 3.12 on Debian 12, follow these steps: Step 1: Check Your Current base Environment Activate the base environment:conda activate base Check the Python version:python --version If it's showing Python 3.12, you'll need to update it. Step 2: Install Python 3.11 in the base Environment Update Conda to ensure you have the latest packages:conda update conda conda update --all Replace the Python version in the base environment:conda install python=3.11 This will resolve dependencies and replace Python 3.12 with Python 3.11 in the base environment. Step 3: Verify the Change Confirm the Python version after installation: python --version It should now show Python 3.11. Deactivate and reactivate base to ensure changes persist: conda deactivate conda activate base Step 4: Set Conda to Always Use the base Environment on Start (Optional) If you always want to activate the base environment when opening a terminal: Edit your shell initialization file (e.g., .bashrc or .zshrc):nano ~/.bashrc Add this line at the end:conda activate base Save and reload your shell:source ~/.bashrc Now, your Conda base environment will use Python 3.11 by default! "},"Learn/LearnConda/Conda.html":{"url":"Learn/LearnConda/Conda.html","title":"Conda","keywords":"","body":"pypi: https://pypi.tuna.tsinghua.edu.cn/simple https://mirrors.tuna.tsinghua.edu.cn/help/pypi/ anaconda: https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/ conda config --set custom_channels.auto https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/ "},"Learn/LearnDocker/docker.html":{"url":"Learn/LearnDocker/docker.html","title":"docker","keywords":"","body":"# Add Docker's official GPG key: sudo apt-get update sudo apt-get install ca-certificates curl sudo install -m 0755 -d /etc/apt/keyrings sudo curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc sudo chmod a+r /etc/apt/keyrings/docker.asc # Add the repository to Apt sources: echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian \\ $(. /etc/os-release && echo \"$VERSION_CODENAME\") stable\" | \\ sudo tee /etc/apt/sources.list.d/docker.list > /dev/null sudo apt-get update # Install Docker Engine: sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin https://docs.docker.com/desktop/install/debian/ docker stop $(docker ps -a -q) docker image pull name:tag docker search image_name docker pull image_name:tag docker images # list all images docker rmi image_name:tag # remove image docker run -it image_name:tag /bin/bash # run container # start docker desktop systemctl --user start docker-desktop # start on sign in systemctl --user enable docker-desktop systemctl --user stop docker-desktop https://medium.com/@SrvZ/docker-proxy-and-my-struggles-a4fd6de21861 Docker Compose Docker ç»„åˆ Docker Compose is a tool for defining and running multi-container applications. It is the key to unlocking a streamlined and efficient development and deployment experience. Docker Compose æ˜¯ä¸€ä¸ªç”¨äºå®šä¹‰å’Œè¿è¡Œå¤šå®¹å™¨åº”ç”¨ç¨‹åºçš„å·¥å…·ã€‚å®ƒæ˜¯è§£é”ç²¾ç®€é«˜æ•ˆçš„å¼€å‘å’Œéƒ¨ç½²ä½“éªŒçš„å…³é”®ã€‚ Compose simplifies the control of your entire application stack, making it easy to manage services, networks, and volumes in a single, comprehensible YAML configuration file. Then, with a single command, you create and start all the services from your configuration file. Compose ç®€åŒ–äº†å¯¹æ•´ä¸ªåº”ç”¨ç¨‹åºå †æ ˆçš„æ§åˆ¶ï¼Œä½¿æ‚¨å¯ä»¥åœ¨å•ä¸ªæ˜“äºç†è§£çš„ YAML é…ç½®æ–‡ä»¶ä¸­è½»æ¾ç®¡ç†æœåŠ¡ã€ç½‘ç»œå’Œå·ã€‚ç„¶åï¼Œä½¿ç”¨å•ä¸ªå‘½ä»¤ï¼Œæ‚¨å¯ä»¥ä»é…ç½®æ–‡ä»¶åˆ›å»ºå¹¶å¯åŠ¨æ‰€æœ‰æœåŠ¡ã€‚ Compose works in all environments; production, staging, development, testing, as well as CI workflows. It also has commands for managing the whole lifecycle of your application: Compose é€‚ç”¨äºæ‰€æœ‰ç¯å¢ƒï¼›ç”Ÿäº§ã€ç™»å°ã€å¼€å‘ã€æµ‹è¯•ä»¥åŠ CI å·¥ä½œæµç¨‹ã€‚å®ƒè¿˜å…·æœ‰ç”¨äºç®¡ç†åº”ç”¨ç¨‹åºæ•´ä¸ªç”Ÿå‘½å‘¨æœŸçš„å‘½ä»¤ï¼š Start, stop, and rebuild services å¯åŠ¨ã€åœæ­¢å’Œé‡å»ºæœåŠ¡ View the status of running services æŸ¥çœ‹æ­£åœ¨è¿è¡Œçš„æœåŠ¡çš„çŠ¶æ€ Stream the log output of running services æµå¼ä¼ è¾“æ­£åœ¨è¿è¡Œçš„æœåŠ¡çš„æ—¥å¿—è¾“å‡º Run a one-off command on a service åœ¨æœåŠ¡ä¸Šè¿è¡Œä¸€æ¬¡æ€§å‘½ä»¤ "},"Learn/LearnGPU2CPU-by-GPT/Note.html":{"url":"Learn/LearnGPU2CPU-by-GPT/Note.html","title":"Note","keywords":"","body":"å·®åˆ†é«˜æ–¯å…‰æ …åŒ– Differential Gaussian Rasterization = GPT => Differential Gaussian Rasterization: CPU Version with C Kernel "},"Learn/LearnGameDev/Note.html":{"url":"Learn/LearnGameDev/Note.html","title":"Note","keywords":"","body":"Learning Game Development links awesome-gamedev youtube: godot tutorials videos Learn GDScript From Zero app godotengine "},"Learn/LearnGameTheory/CoalitionalGames.html":{"url":"Learn/LearnGameTheory/CoalitionalGames.html","title":"CoalitionalGames","keywords":"","body":"Coalitional Games: è”ç›Ÿåšå¼ˆ A coalitional game, also known as a cooperative game, is a game theory model where players form groups to achieve a collective goal. In a coalitional game, players form coalitions, or binding agreements, to strengthen their positions and act as a single entity. Coalitional games are different from non-cooperative games, where players cannot form alliances or agreements must be self-enforced. è”ç›Ÿåšå¼ˆï¼Œä¹Ÿç§°ä¸ºåˆä½œåšå¼ˆï¼Œæ˜¯ä¸€ç§åšå¼ˆè®ºæ¨¡å‹ï¼Œå…¶ä¸­ç©å®¶ç»„æˆå›¢é˜Ÿä»¥å®ç°é›†ä½“ç›®æ ‡ã€‚ åœ¨è”ç›Ÿæ¸¸æˆä¸­ï¼Œç©å®¶ç»„æˆè”ç›Ÿæˆ–å…·æœ‰çº¦æŸåŠ›çš„åè®®ï¼Œä»¥åŠ å¼ºä»–ä»¬çš„åœ°ä½å¹¶ä½œä¸ºä¸€ä¸ªå®ä½“è¡ŒåŠ¨ã€‚ è”ç›Ÿæ¸¸æˆä¸éåˆä½œæ¸¸æˆä¸åŒï¼Œåœ¨éåˆä½œæ¸¸æˆä¸­ï¼Œç©å®¶ä¸èƒ½ç»“æˆè”ç›Ÿæˆ–åè®®å¿…é¡»è‡ªè¡Œæ‰§è¡Œã€‚ Here are some key concepts in coalitional games: Coalition: A group of players that form a binding agreement Coalition value: The worth of a coalition in a game, which is denoted by the symbol (v) The core: The set of payoff allocations that ensures no group of players has an incentive to leave their coalition Shapley value: An efficient solution concept that is recommended for games with a low number of players "},"Learn/LearnGameTheory/GameTheory.html":{"url":"Learn/LearnGameTheory/GameTheory.html","title":"GameTheory","keywords":"","body":"Game Theory Coalitional Games: è”ç›Ÿåšå¼ˆ äº«ä¹åšå¼ˆ åŒå±‚åšå¼ˆ "},"Learn/LearnJinJia2/Jinjia2.html":{"url":"Learn/LearnJinJia2/Jinjia2.html","title":"Jinjia2","keywords":"","body":"Jinjia2 from jinja2 import Template # å®šä¹‰æ¨¡æ¿ template = Template(open(\"test.jinja2\").read()) # æ¸²æŸ“æ¨¡æ¿ output = template.render(target=\"RISCV\") # æ‰“å°ç”Ÿæˆçš„ HTML print(output) "},"Learn/LearnLalrpop/Lalrpop.html":{"url":"Learn/LearnLalrpop/Lalrpop.html","title":"Lalrpop","keywords":"","body":"Lalrpop LR(1) parser generator for Rust. LALRPOP æ‹‰å°”æ³¢æ™® LALRPOP is a parser generator, similar in principle to YACC, ANTLR, Menhir, and other such programs. In general, it has the grand ambition of being the most usable parser generator ever. This ambition is most certainly not fully realized: right now, it's fairly standard, maybe even a bit subpar in some areas. But hey, it's young. For the most part, this README is intended to describe the current behavior of LALRPOP, but in some places it includes notes for planned future changes. LALRPOP æ˜¯ä¸€ä¸ªè§£æå™¨ç”Ÿæˆå™¨ï¼ŒåŸç†ç±»ä¼¼äº YACCã€ANTLRã€Menhir å’Œå…¶ä»–æ­¤ç±»ç¨‹åºã€‚æ€»çš„æ¥è¯´ï¼Œå®ƒæœ‰ä¸€ä¸ªå®ä¼Ÿçš„é›„å¿ƒå£®å¿—ï¼Œé‚£å°±æ˜¯æˆä¸ºæœ‰å²ä»¥æ¥æœ€æœ‰ç”¨çš„è§£æå™¨ç”Ÿæˆå™¨ã€‚è¿™ä¸ªé›„å¿ƒå£®å¿—è‚¯å®šæ²¡æœ‰å®Œå…¨å®ç°ï¼šç°åœ¨ï¼Œå®ƒç›¸å½“æ ‡å‡†ï¼Œç”šè‡³åœ¨æŸäº›é¢†åŸŸå¯èƒ½æœ‰ç‚¹ä½äºæ ‡å‡†ã€‚ä½†æ˜¯ï¼Œå˜¿ï¼Œå®ƒå¾ˆå¹´è½»ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæœ¬ README æ—¨åœ¨æè¿° LALRPOP çš„å½“å‰è¡Œä¸ºï¼Œä½†åœ¨æŸäº›åœ°æ–¹ï¼Œå®ƒåŒ…æ‹¬è®¡åˆ’çš„æœªæ¥æ›´æ”¹çš„è¯´æ˜ã€‚ add lalrpop to rust project define grammar in lalrpop file define asts, build ast use macros use errors and error recovery pass param to parser Tutorial : means extract the value of the expression inside the angle brackets, here is ... Macros four built-in macros: ?: Expr? get Option> *: Expr* get Vec>, minimum 0 +: Expr+ get Vec>, minimum 1 (...): short for creating an nonterminal, ( \",\")?, mean an \"optionally parse an Expr followed by a comma\" Note the angle brackets (<>) around Expr: these ensures that the value of the ( \",\")is the value of the expression, and not a tuple of the expression and the comma. get type Option> Grammar Example // Term: Num | '(' Term ')' pub Term: i32 = { => n, \"(\" \")\" => t, } // Num: r\"[0-9]+\" Num: i32 = => i32::from_str(&s).unwrap(); Precedence and associativity can be specified using attributes: pub Expr: i32 = { #[precedence(level=\"0\")] // Highest precedence Term, #[precedence(level=\"1\")] #[assoc(side=\"left\")] \"*\" => l * r, \"/\" => l / r, #[precedence(level=\"2\")] #[assoc(side=\"left\")] \"+\" => l + r, \"-\" => l - r, }; Use AST to represent the parsed tree: // ast.rs use std::fmt::{Debug, Error, Formatter}; pub enum Expr { Number(i32), Op(Box, Opcode, Box), Error, } pub enum ExprSymbol { NumSymbol(&'input str), Op(Box>, Opcode, Box>), Error, } #[derive(Copy, Clone)] pub enum Opcode { Mul, Div, Add, Sub, } impl Debug for Expr { fn fmt(&self, fmt: &mut Formatter) -> Result { use self::Expr::*; match *self { Number(n) => write!(fmt, \"{:?}\", n), Op(ref l, op, ref r) => write!(fmt, \"({:?} {:?} {:?})\", l, op, r), Error => write!(fmt, \"error\"), } } } impl Debug for ExprSymbol { fn fmt(&self, fmt: &mut Formatter) -> Result { use self::ExprSymbol::*; match *self { NumSymbol(n) => write!(fmt, \"{:?}\", n), Op(ref l, op, ref r) => write!(fmt, \"({:?} {:?} {:?})\", l, op, r), Error => write!(fmt, \"error\"), } } } impl Debug for Opcode { fn fmt(&self, fmt: &mut Formatter) -> Result { use self::Opcode::*; match *self { Mul => write!(fmt, \"*\"), Div => write!(fmt, \"/\"), Add => write!(fmt, \"+\"), Sub => write!(fmt, \"-\"), } } } // grammar.lalrpop use std::str::FromStr; use crate::ast::{Expr, Opcode}; grammar; pub Expr: Box = { // (1) Expr ExprOp Factor => Box::new(Expr::Op(<>)), // (2) Factor, }; ExprOp: Opcode = { // (3) \"+\" => Opcode::Add, \"-\" => Opcode::Sub, }; Factor: Box = { Factor FactorOp Term => Box::new(Expr::Op(<>)), Term, }; FactorOp: Opcode = { \"*\" => Opcode::Mul, \"/\" => Opcode::Div, }; Term: Box = { Num => Box::new(Expr::Number(<>)), \"(\" \")\" }; Num: i32 = { r\"[0-9]+\" => i32::from_str(<>).unwrap() }; Lexer Num: i32 = r\"[0-9]+\" => i32::from_str(<>).unwrap(); // ~~~ ~~~ ~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~ // | | | Action code // | | Symbol(s) that should match // | Return type // Name of nonterminal +-------------------+ +---------------------+ Text -> | Lexer | -> | Parser | | | | | | Applies regex to | | Consumes terminals, | | produce terminals | | executes your code | +-------------------+ | as it recognizes | | nonterminals | +---------------------+ è¯æ³•åˆ†æä¼˜å…ˆçº§é—®é¢˜ï¼šä½¿ç”¨ match æ˜¾å¼æŒ‡å®šä¼˜å…ˆçº§ã€‚ Simple match declarations ç®€å• match å£°æ˜ A match declaration lets you explicitly give the precedence between terminals. In its simplest form, it consists of just ordering regular expressions and string literals into groups, with the higher precedence items coming first. So, for example, we could resolve our conflict above by giving r\"[0-9]+\" precedence over r\"\\w+\", thus saying that if something can be lexed as a number, we'll do that, and otherwise consider it to be an identifier. match å£°æ˜å…è®¸æ‚¨æ˜¾å¼æŒ‡å®šç»ˆç«¯ä¹‹é—´çš„ä¼˜å…ˆçº§ã€‚åœ¨æœ€ç®€å•çš„å½¢å¼ä¸­ï¼Œå®ƒåªåŒ…æ‹¬å°†æ­£åˆ™è¡¨è¾¾å¼å’Œå­—ç¬¦ä¸²æ–‡æœ¬æ’åºåˆ°ç»„ä¸­ï¼Œä¼˜å…ˆçº§è¾ƒé«˜çš„é¡¹æ’åœ¨æœ€å‰é¢ã€‚å› æ­¤ï¼Œä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡èµ‹äºˆ râ€œ[0-9]+â€œä¼˜å…ˆäº râ€\\w+â€œ æ¥è§£å†³ä¸Šé¢çš„å†²çªï¼Œä»è€Œè¡¨ç¤ºå¦‚æœæŸä¸ªä¸œè¥¿å¯ä»¥è¢«è§£é‡Šä¸ºä¸€ä¸ªæ•°å­—ï¼Œæˆ‘ä»¬å°±ä¼šè¿™æ ·åšï¼Œå¦åˆ™å°±å°†å…¶è§†ä¸ºæ ‡è¯†ç¬¦ã€‚ match { r\"[0-9]+\" } else { r\"\\w+\", _ } The final _ indicates that other string literals and regular expressions that appear elsewhere in the grammar (e.g., \"(\" or \"22\") should be added into that final level of precedence (without an _, it is illegal to use a terminal that does not appear in the match declaration). ç»“å°¾çš„ _ è¡¨ç¤ºå‡ºç°åœ¨è¯­æ³•ä¸­å…¶ä»–ä½ç½®çš„å­—ç¬¦ä¸²æ–‡å­—å’Œæ­£åˆ™è¡¨è¾¾å¼ï¼ˆä¾‹å¦‚ï¼Œâ€œï¼ˆâ€ æˆ– â€œ22â€ï¼‰åº”è¯¥æ·»åŠ åˆ°æœ€ç»ˆçš„ä¼˜å…ˆçº§ä¸­ï¼ˆå¦‚æœæ²¡æœ‰ _ï¼Œä½¿ç”¨æœªå‡ºç°åœ¨ match å£°æ˜ä¸­çš„ç»ˆç»“ç¬¦æ˜¯éæ³•çš„ï¼‰ã€‚ // fixed literals get precedence over regular expressions match { r\"[0-9]+\", \"22\" } else { r\"\\w+\", _ } ä½¿ç”¨ match å£°æ˜ä¸ºæ­£åˆ™è¡¨è¾¾å¼å‘½åï¼Œè¿™æ ·æˆ‘ä»¬å°±ä¸å¿…ç›´æ¥åœ¨è¯­æ³•ä¸­è¾“å…¥å®ƒä»¬ã€‚ match { r\"[0-9]+\", \"22\" } else { r\"\\w+\" => ID, // pub Term = { Num, \"(\" \")\", \"22\" => \"Twenty-two!\".to_string(), ID => format!(\"Id({})\", <>), // Customizing skipping between tokens è‡ªå®šä¹‰åœ¨æ ‡è®°ä¹‹é—´è·³è¿‡ï¼ˆç”¨äºè·³è¿‡æ³¨é‡Šå†…å®¹ï¼‰ match { r\"\\s*\" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified r\"//[^\\n\\r]*[\\n\\r]*\" => { }, // Skip `// comments` r\"/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/\" => { }, // Skip `/* comments */` } "},"Learn/LearnMLIR/CodegenDialectOverview.html":{"url":"Learn/LearnMLIR/CodegenDialectOverview.html","title":"CodegenDialectOverview","keywords":"","body":"Codegen Dialect Overview Codegen Dialect Overview Classification åˆ†ç±» The multiple code generation-related dialects in MLIR can be roughly organized along two axes: tensor/buffer and payload/structure .MLIR ä¸­çš„å¤šä¸ªä»£ç ç”Ÿæˆç›¸å…³æ–¹è¨€å¯ä»¥å¤§è‡´æ²¿ç€ä¸¤ä¸ªè½´ç»„ç»‡ï¼šå¼ é‡/ç¼“å†²åŒºå’Œæœ‰æ•ˆè½½è·/ç»“æ„ã€‚ A dialectâ€™s position on the tensor/buffer axis indicates whether its main data abstraction is a tensor as found in ML frameworks or a memory buffer as expected by conventional lower-level compilers. Tensors are treated as immutable values that are not necessarily associated with memory, that is, operations on tensors usually donâ€™t have side effects. Data flow between such operations can be expressed using use-definition chains in traditional static single assignment (SSA) form. This is one of the aspects that makes MLIR a powerful transformation vehicle for ML programs, enabling simple rewriting of tensor operations. On the other hand, buffers are mutable and may be subject to aliasing, i.e. several objects may be pointing to the same underlying memory. Data flow can only be extracted through additional dependency and aliasing analyses. The transition between the tensor abstraction and buffer abstraction is performed by the bufferization procedure that progressively associates, and ultimately replaces, tensors with buffers. Several dialects, such as Linalg and Standard, contain operations on both tensors and buffers. Some Linalg operations can even operate on both at the same time. æ–¹è¨€åœ¨å¼ é‡/ç¼“å†²åŒºè½´ä¸Šçš„ä½ç½®è¡¨ç¤ºå…¶ä¸»è¦æ•°æ®æŠ½è±¡æ˜¯æœºå™¨å­¦ä¹ æ¡†æ¶ä¸­æ‰¾åˆ°çš„å¼ é‡ï¼Œè¿˜æ˜¯ä¼ ç»Ÿä½çº§ç¼–è¯‘å™¨æœŸæœ›çš„å†…å­˜ç¼“å†²åŒºã€‚å¼ é‡è¢«è§†ä¸ºä¸å¯å˜å€¼ï¼Œä¸ä¸€å®šä¸å†…å­˜ç›¸å…³è”ï¼Œå³å¼ é‡ä¸Šçš„æ“ä½œé€šå¸¸æ²¡æœ‰å‰¯ä½œç”¨ã€‚è¿™äº›æ“ä½œä¹‹é—´çš„æ•°æ®æµå¯ä»¥ä½¿ç”¨ä¼ ç»Ÿçš„é™æ€å•èµ‹å€¼ï¼ˆSSAï¼‰å½¢å¼ä¸­çš„ä½¿ç”¨-å®šä¹‰é“¾æ¥è¡¨ç¤ºã€‚è¿™æ˜¯ä½¿ MLIR æˆä¸ºæœºå™¨å­¦ä¹ ç¨‹åºå¼ºå¤§è½¬æ¢å·¥å…·çš„æ–¹é¢ä¹‹ä¸€ï¼Œå®ƒä½¿å¼ é‡æ“ä½œçš„ç®€å•é‡å†™æˆä¸ºå¯èƒ½ã€‚å¦ä¸€æ–¹é¢ï¼Œç¼“å†²åŒºæ˜¯å¯å˜çš„ï¼Œå¯èƒ½å—åˆ°åˆ«åçš„å½±å“ï¼Œå³å¤šä¸ªå¯¹è±¡å¯èƒ½æŒ‡å‘ç›¸åŒçš„åº•å±‚å†…å­˜ã€‚æ•°æ®æµåªèƒ½é€šè¿‡é¢å¤–çš„ä¾èµ–å’Œåˆ«ååˆ†ææ¥æå–ã€‚å¼ é‡æŠ½è±¡å’Œç¼“å†²åŒºæŠ½è±¡ä¹‹é—´çš„è½¬æ¢æ˜¯é€šè¿‡ç¼“å†²åŒ–è¿‡ç¨‹æ‰§è¡Œçš„ï¼Œè¯¥è¿‡ç¨‹é€æ­¥å…³è”ï¼Œæœ€ç»ˆç”¨ç¼“å†²åŒºæ›¿æ¢å¼ é‡ã€‚ä¸€äº›æ–¹è¨€ï¼Œå¦‚ Linalg å’Œ Standardï¼ŒåŒ…å«å¯¹å¼ é‡å’Œç¼“å†²åŒºçš„æ“ä½œã€‚ä¸€äº› Linalg æ“ä½œç”šè‡³å¯ä»¥åŒæ—¶æ“ä½œä¸¤è€…ã€‚ A dialectâ€™s position on the payload/structure axis indicates whether it describes what computation should be performed (payload) or how it should be performed (structure). For example, most mathematical operations in the Standard dialect specify the computation to be performed, e.g., the arctangent, without further detail. On the other hand, the SCF dialect defines how the contained computation is performed, e.g., repeated until some runtime condition is met, without restricting what the condition is and what computations are performed. Similarly, the Async dialect denotes the general execution model applicable at various levels of payload granularity. æ–¹è¨€åœ¨è´Ÿè½½/ç»“æ„è½´ä¸Šçš„ä½ç½®è¡¨ç¤ºå®ƒæè¿°çš„æ˜¯åº”è¯¥æ‰§è¡Œä»€ä¹ˆè®¡ç®—ï¼ˆè´Ÿè½½ï¼‰è¿˜æ˜¯å¦‚ä½•æ‰§è¡Œï¼ˆç»“æ„ï¼‰ã€‚ä¾‹å¦‚ï¼Œæ ‡å‡†æ–¹è¨€ä¸­çš„å¤§å¤šæ•°æ•°å­¦è¿ç®—æŒ‡å®šè¦æ‰§è¡Œçš„è®¡ç®—ï¼Œä¾‹å¦‚åæ­£åˆ‡ï¼Œè€Œä¸æä¾›æ›´å¤šç»†èŠ‚ã€‚å¦ä¸€æ–¹é¢ï¼ŒSCF æ–¹è¨€å®šä¹‰äº†åŒ…å«çš„è®¡ç®—å¦‚ä½•æ‰§è¡Œï¼Œä¾‹å¦‚é‡å¤æ‰§è¡Œç›´åˆ°æ»¡è¶³æŸäº›è¿è¡Œæ—¶æ¡ä»¶ï¼Œè€Œä¸é™åˆ¶æ¡ä»¶æ˜¯ä»€ä¹ˆä»¥åŠæ‰§è¡Œäº†å“ªäº›è®¡ç®—ã€‚åŒæ ·ï¼ŒAsync æ–¹è¨€è¡¨ç¤ºé€‚ç”¨äºè´Ÿè½½ç²’åº¦ä¸åŒçº§åˆ«çš„é€šç”¨æ‰§è¡Œæ¨¡å‹ã€‚ This position on this axis is non-binary, especially at higher level of abstraction. Many operations at least partially specify the structure. For example, vector dialect operations imply SIMD execution model. During the compilation process, the instructions of â€œhowâ€ tend to become more detailed and low-level. Simultaneously, lower levels of the abstraction stack tend to separate the structure operations from the payload operations for the sake of transforming only the former while keeping only an abstract understanding of the payload, e.g., the accessed data or the estimated cost. æ­¤è½´ä¸Šçš„ä½ç½®æ˜¯éäºŒå…ƒçš„ï¼Œå°¤å…¶æ˜¯åœ¨æ›´é«˜å±‚æ¬¡çš„æŠ½è±¡ä¸­ã€‚è®¸å¤šæ“ä½œè‡³å°‘éƒ¨åˆ†åœ°æŒ‡å®šäº†ç»“æ„ã€‚ä¾‹å¦‚ï¼Œå‘é‡æ–¹è¨€æ“ä½œæš—ç¤ºäº† SIMD æ‰§è¡Œæ¨¡å‹ã€‚åœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ï¼Œå…³äºâ€œå¦‚ä½•â€çš„æŒ‡ä»¤å¾€å¾€å˜å¾—æ›´åŠ è¯¦ç»†å’Œåº•å±‚ã€‚åŒæ—¶ï¼ŒæŠ½è±¡å †æ ˆçš„è¾ƒä½çº§åˆ«å€¾å‘äºå°†ç»“æ„æ“ä½œä¸æœ‰æ•ˆè´Ÿè½½æ“ä½œåˆ†å¼€ï¼Œä»¥ä¾¿ä»…è½¬æ¢å‰è€…ï¼ŒåŒæ—¶åªä¿ç•™å¯¹æœ‰æ•ˆè´Ÿè½½çš„æŠ½è±¡ç†è§£ï¼Œä¾‹å¦‚è®¿é—®çš„æ•°æ®æˆ–ä¼°è®¡çš„æˆæœ¬ã€‚ Dialects of Interest æ„Ÿå…´è¶£çš„è¯­è¨€æ–¹è¨€ An MLIR code generation pipeline goes through a sequence of intermediate steps, which are characterized by the most recently introduced dialect. Dialects can be roughly organized into a stack based on the level of abstraction they feature. Converting the representation from a higher-level abstraction to a lower-level abstraction, i.e. lowering, is usually straightforward whereas the inverse process may not be. MLIR ä»£ç ç”Ÿæˆç®¡é“ç»è¿‡ä¸€ç³»åˆ—ä¸­é—´æ­¥éª¤ï¼Œè¿™äº›æ­¥éª¤ç”±æœ€è¿‘å¼•å…¥çš„æ–¹è¨€ç‰¹å¾ã€‚æ–¹è¨€å¯ä»¥æ ¹æ®å®ƒä»¬æ‰€å…·æœ‰çš„æŠ½è±¡çº§åˆ«å¤§è‡´ç»„ç»‡æˆå †æ ˆã€‚å°†è¡¨ç¤ºä»é«˜çº§æŠ½è±¡è½¬æ¢ä¸ºä½çº§æŠ½è±¡ï¼Œå³é™çº§ï¼Œé€šå¸¸æ˜¯ç›´æ¥çš„ï¼Œè€Œé€†è¿‡ç¨‹å¯èƒ½ä¸æ˜¯ã€‚ Most pipelines enter the in-tree dialect infrastructure through the Linalg dialect, which features a versatile representation of structured computation on structured data. The dialect is specifically designed to support various transformations with minimal analysis. Operations in this dialect support both tensor and buffer operands and the bufferization process can happen without changing the operations themselves. Furthermore, Linalg provides â€œnamedâ€ operations with specific payload, such as matrix multiplication and convolution, and â€œgenericâ€ operations that only define the structure. Conversions are available between the two forms. The inherent iterative structure of Linalg dialect operations allows them to be converted into vector operations as well as (affine) loops around vector or scalar operations. å¤§å¤šæ•°ç®¡é“é€šè¿‡ Linalg æ–¹è¨€è¿›å…¥æ ‘å†…æ–¹è¨€åŸºç¡€è®¾æ–½ï¼Œè¯¥æ–¹è¨€å…·æœ‰å¯¹ç»“æ„åŒ–æ•°æ®ä¸Šç»“æ„åŒ–è®¡ç®—çš„çµæ´»è¡¨ç¤ºã€‚è¯¥æ–¹è¨€ä¸“é—¨è®¾è®¡ç”¨äºæ”¯æŒå„ç§å˜æ¢ï¼Œåˆ†ææœ€å°‘ã€‚è¯¥æ–¹è¨€ä¸­çš„æ“ä½œæ”¯æŒå¼ é‡å’Œç¼“å†²åŒºæ“ä½œæ•°ï¼Œç¼“å†²åŒºåŒ–è¿‡ç¨‹å¯ä»¥åœ¨ä¸æ”¹å˜æ“ä½œæœ¬èº«çš„æƒ…å†µä¸‹å‘ç”Ÿã€‚æ­¤å¤–ï¼ŒLinalg æä¾›äº†å…·æœ‰ç‰¹å®šæœ‰æ•ˆè½½è·çš„â€œå‘½åâ€æ“ä½œï¼Œä¾‹å¦‚çŸ©é˜µä¹˜æ³•å’Œå·ç§¯ï¼Œä»¥åŠä»…å®šä¹‰ç»“æ„çš„â€œé€šç”¨â€æ“ä½œã€‚ä¸¤ç§å½¢å¼ä¹‹é—´å¯ä»¥è¿›è¡Œè½¬æ¢ã€‚Linalg æ–¹è¨€æ“ä½œçš„å†…ç¦€è¿­ä»£ç»“æ„å…è®¸å®ƒä»¬è¢«è½¬æ¢ä¸ºå‘é‡æ“ä½œä»¥åŠå›´ç»•å‘é‡æˆ–æ ‡é‡æ“ä½œçš„ï¼ˆä»¿å°„ï¼‰å¾ªç¯ã€‚ The Async dialect captures a general asynchronous programming model and may appear at different levels: at a higher level where it is used to[organize large chunks of computation across and within devices, and at a lower level where it can wrap sequences of primitive instructions. å¼‚æ­¥æ–¹è¨€æ•è·äº†ä¸€èˆ¬çš„å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹ï¼Œå¯èƒ½å‡ºç°åœ¨ä¸åŒçš„çº§åˆ«ï¼šåœ¨è¾ƒé«˜çº§åˆ«ï¼Œå®ƒç”¨äº[ç»„ç»‡å’Œè·¨è®¾å¤‡ä»¥åŠè®¾å¤‡å†…éƒ¨çš„å¤§å—è®¡ç®—ï¼Œä»¥åŠåœ¨è¾ƒä½çº§åˆ«ï¼Œå®ƒå¯ä»¥åŒ…è£…åŸå§‹æŒ‡ä»¤çš„åºåˆ—]ã€‚ The Vector dialect (Note that the vector type belongs to the built-in dialect and can be used outside of the Vector dialect.) is a mid-level abstraction for SIMD and, potentially, SIMT execution models. It leverages MLIRâ€™s multidimensional vector type to target different platforms through dedicated lower-level dialects. An ongoing work investigates the use of vector abstraction to target GPU devices (SIMT) through explicit representation of threads. å‘é‡æ–¹è¨€ï¼ˆè¯·æ³¨æ„ï¼Œå‘é‡ç±»å‹å±äºå†…ç½®æ–¹è¨€ï¼Œå¯ä»¥åœ¨å‘é‡æ–¹è¨€ä¹‹å¤–ä½¿ç”¨ã€‚ï¼‰æ˜¯ SIMD å’Œæ½œåœ¨ SIMT æ‰§è¡Œæ¨¡å‹çš„ä¸­é—´å±‚æŠ½è±¡ã€‚å®ƒåˆ©ç”¨ MLIR çš„å¤šç»´å‘é‡ç±»å‹ï¼Œé€šè¿‡ä¸“é—¨çš„ä½çº§æ–¹è¨€é’ˆå¯¹ä¸åŒçš„å¹³å°ã€‚æ­£åœ¨è¿›è¡Œçš„å·¥ä½œæ­£åœ¨ç ”ç©¶ä½¿ç”¨å‘é‡æŠ½è±¡é€šè¿‡æ˜¾å¼è¡¨ç¤ºçº¿ç¨‹æ¥é’ˆå¯¹ GPU è®¾å¤‡ï¼ˆSIMTï¼‰ã€‚ The Affine dialect is MLIRâ€™s take on polyhedral compilation. It encapsulates the restrictions of the related programming model and defines the corresponding operations, namely control flow structures such as affine loops and conditionals and affine counterparts of memory operations. Its primary goal is to enable polyhedral transformations, such as auto-parallelization, loop fusion and tiling for locality improvement, and loop vectorization in MLIR. ä»¿å°„æ–¹è¨€æ˜¯ MLIR å¯¹å¤šé¢ä½“ç¼–è¯‘çš„è§è§£ã€‚å®ƒå°è£…äº†ç›¸å…³ç¼–ç¨‹æ¨¡å‹çš„é™åˆ¶å¹¶å®šä¹‰äº†ç›¸åº”çš„æ“ä½œï¼Œå³æ§åˆ¶æµç»“æ„ï¼Œå¦‚ä»¿å°„å¾ªç¯å’Œæ¡ä»¶ä»¥åŠå†…å­˜æ“ä½œçš„ä»¿å°„å¯¹åº”ç‰©ã€‚å…¶ä¸»è¦ç›®æ ‡æ˜¯å®ç°å¤šé¢ä½“å˜æ¢ï¼Œå¦‚è‡ªåŠ¨å¹¶è¡ŒåŒ–ã€å¾ªç¯èåˆå’Œä¸ºäº†å±€éƒ¨æ€§æ”¹è¿›çš„å¾ªç¯å¡«å……ï¼Œä»¥åŠåœ¨ MLIR ä¸­çš„å¾ªç¯å‘é‡åŒ–ã€‚ The SCF (Structured Control Flow) dialect contains the common control flow concepts expressed at a higher level than branches in a control flow graph (CFG), e.g., (parallel) â€œforâ€ and â€œwhileâ€ loops as well as conditionals. This dialect is used to represent, and sometimes transform, the structure of the computation without affecting the payload. It is a common lowering target from Affine and Linalg, which may also be used as an entry point to the MLIR code generation infrastructure from lower-level representations such as C. SCFï¼ˆç»“æ„åŒ–æ§åˆ¶æµï¼‰æ–¹è¨€åŒ…å«åœ¨æ§åˆ¶æµå›¾ï¼ˆCFGï¼‰åˆ†æ”¯ä»¥ä¸Šçš„é«˜çº§æ§åˆ¶æµæ¦‚å¿µï¼Œä¾‹å¦‚ï¼ˆå¹¶è¡Œï¼‰â€œforâ€å’Œâ€œwhileâ€å¾ªç¯ä»¥åŠæ¡ä»¶è¯­å¥ã€‚æ­¤æ–¹è¨€ç”¨äºè¡¨ç¤ºï¼Œæœ‰æ—¶ä¹Ÿç”¨äºè½¬æ¢ï¼Œè®¡ç®—ç»“æ„è€Œä¸å½±å“æœ‰æ•ˆè½½è·ã€‚å®ƒæ˜¯ä» Affine å’Œ Linalg çš„å¸¸è§é™ä½ç›®æ ‡ï¼Œä¹Ÿå¯ä»¥ç”¨ä½œä» C ç­‰åº•å±‚è¡¨ç¤ºçš„ MLIR ä»£ç ç”ŸæˆåŸºç¡€è®¾æ–½çš„å…¥å£ç‚¹ã€‚ Various programming models, namely GPU/SIMT, Async, OpenMP and OpenACC can be obtained from the SCF dialect. Each of these models is represented by a corresponding dialect, the operations in which are rarely subject to further optimizing transformations. However, these representations are an opportunity to implement transformations specific to the programming model, e.g., ones currently explored for the Async dialect. å„ç§ç¼–ç¨‹æ¨¡å‹ï¼Œå³ GPU/SIMTã€å¼‚æ­¥ã€OpenMP å’Œ OpenACCï¼Œå¯ä»¥ä» SCF æ–¹è¨€ä¸­è·å–ã€‚æ¯ä¸ªæ¨¡å‹éƒ½ç”±ç›¸åº”çš„æ–¹è¨€è¡¨ç¤ºï¼Œå…¶ä¸­çš„æ“ä½œå¾ˆå°‘å—åˆ°è¿›ä¸€æ­¥ä¼˜åŒ–è½¬æ¢çš„å½±å“ã€‚ç„¶è€Œï¼Œè¿™äº›è¡¨ç¤ºæ˜¯å®ç°ç‰¹å®šäºç¼–ç¨‹æ¨¡å‹çš„è½¬æ¢çš„æœºä¼šï¼Œä¾‹å¦‚ç›®å‰ä¸ºå¼‚æ­¥æ–¹è¨€æ¢ç´¢çš„è½¬æ¢ã€‚ SCF can also be converted to the â€œstandardâ€ CFG representation by replacing structured control flow with branches between blocks. The branch operations are currently contained in the Standard dialect, together with numerous other operations at various abstraction levels. For example, the Standard dialect also contains pointwise operations on tensors and vectors, conversions between buffers and tensors, trigonometric operations on scalars, etc. Therefore, the Standard dialect is in the process of being split into multiple well-defined dialects. SCF ä¹Ÿå¯ä»¥é€šè¿‡ç”¨å—ä¹‹é—´çš„åˆ†æ”¯æ›¿æ¢ç»“æ„åŒ–æ§åˆ¶æµæ¥è½¬æ¢ä¸ºâ€œæ ‡å‡†â€CFG è¡¨ç¤ºã€‚åˆ†æ”¯æ“ä½œç›®å‰åŒ…å«åœ¨æ ‡å‡†æ–¹è¨€ä¸­ï¼Œä»¥åŠå„ç§æŠ½è±¡çº§åˆ«ä¸Šçš„è®¸å¤šå…¶ä»–æ“ä½œã€‚ä¾‹å¦‚ï¼Œæ ‡å‡†æ–¹è¨€è¿˜åŒ…å«å¼ é‡å’Œå‘é‡çš„é€ç‚¹æ“ä½œã€ç¼“å†²åŒºå’Œå¼ é‡ä¹‹é—´çš„è½¬æ¢ã€æ ‡é‡çš„ä¸‰è§’è¿ç®—ç­‰ã€‚å› æ­¤ï¼Œæ ‡å‡†æ–¹è¨€æ­£åœ¨è¢«æ‹†åˆ†ä¸ºå¤šä¸ªå®šä¹‰è‰¯å¥½çš„æ–¹è¨€ã€‚ Ultimately, parts of the Standard dialect (operations on scalars and vectors, and branches) are converted into target-specific dialects that mostly serve as exit points from the MLIR code generation infrastructure. These include the LLVM, NVVM, ROCDL, AVX, Neon, SVE and SPIR-V dialects, all of which correspond to an external format, IR or instruction set. These dialects are not subject to transformation except for canonicalization. æœ€ç»ˆï¼Œæ ‡å‡†æ–¹è¨€ï¼ˆæ ‡é‡ä¸å‘é‡çš„æ“ä½œä»¥åŠåˆ†æ”¯ï¼‰è¢«è½¬æ¢ä¸ºç‰¹å®šç›®æ ‡çš„æ–¹è¨€ï¼Œè¿™äº›æ–¹è¨€ä¸»è¦ä½œä¸ºä» MLIR ä»£ç ç”ŸæˆåŸºç¡€è®¾æ–½çš„å‡ºå£ç‚¹ã€‚è¿™åŒ…æ‹¬ LLVMã€NVVMã€ROCDLã€AVXã€Neonã€SVE å’Œ SPIR-V æ–¹è¨€ï¼Œæ‰€æœ‰è¿™äº›éƒ½å¯¹åº”äºå¤–éƒ¨æ ¼å¼ã€IR æˆ–æŒ‡ä»¤é›†ã€‚è¿™äº›æ–¹è¨€é™¤äº†è§„èŒƒåŒ–å¤–ï¼Œä¸å—è½¬æ¢çš„å½±å“ã€‚ Finally, the Shape dialect is used to describe shapes of data independently of the payload or (mostly) structure. It appears at the entry level of the code generation pipeline and is typically lowered into address arithmetic or canonicalized away. æœ€åï¼ŒShape æ–¹è¨€ç”¨äºç‹¬ç«‹äºæœ‰æ•ˆè½½è·æˆ–ï¼ˆä¸»è¦æ˜¯ï¼‰ç»“æ„æ¥æè¿°æ•°æ®å½¢çŠ¶ã€‚å®ƒåœ¨ä»£ç ç”Ÿæˆç®¡é“çš„å…¥å£çº§åˆ«å‡ºç°ï¼Œé€šå¸¸è¢«é™ä½ä¸ºåœ°å€ç®—æœ¯æˆ–è§„èŒƒåŒ–ã€‚ PDL (Pattern Description Language) and PDLInterp dialects are used by the next-generation pattern-rewriting infrastructure for MLIR to specify transformations. As such, they never appear in the code generation pipeline, but may be necessary to describe its operation. PDLï¼ˆæ¨¡å¼æè¿°è¯­è¨€ï¼‰å’Œ PDLInterp æ–¹è¨€è¢«ä¸‹ä¸€ä»£æ¨¡å¼é‡å†™åŸºç¡€è®¾æ–½ MLIR ç”¨äºæŒ‡å®šè½¬æ¢ã€‚å› æ­¤ï¼Œå®ƒä»¬ä»æœªå‡ºç°åœ¨ä»£ç ç”Ÿæˆç®¡é“ä¸­ï¼Œä½†å¯èƒ½æ˜¯æè¿°å…¶æ“ä½œæ‰€å¿…éœ€çš„ã€‚ Some Existing Pipelines ä¸€äº›ç°æœ‰ç®¡é“ TensorFlow Kernel Generator TensorFlow å†…æ ¸ç”Ÿæˆå™¨ codegen 4 Kernel generator pipelineä»£ç ç”Ÿæˆå™¨ 4 å†…æ ¸ç”Ÿæˆå™¨ç®¡é“1170Ã—954 120 KB The Tensorflow Kernel Generator project, starting at the TensorFlow (TF) dialect, has recently switched to targeting Linalg-on-tensors from MHLO (Meta HLO, more suitable for compilation thanks to, e.g., removal of implicit broadcasting, and with support for dynamic shapes; where HLO is High-Level Optimizer representation, derived from XLA) instead of LMHLO (Late MHLO, same as MHLO but on buffers rather than tensors) and performs fusion at that level before calling bufferization on Linalg. Further loop transformations such as tiling happen at the SCF level, which is then converted into target-specific GPU dialect while the payload operations are converted to the LLVM dialect with Standard as intermediary. Now-retired prototypes have experimented with using LMHLO dialect targeting Linalg-on-Buffers and performing all transformations on SCF, where it may be more complex than on tensor abstraction. Tensorflow å†…æ ¸ç”Ÿæˆå™¨é¡¹ç›®ï¼Œä» TensorFlowï¼ˆTFï¼‰æ–¹è¨€å¼€å§‹ï¼Œæœ€è¿‘å·²åˆ‡æ¢åˆ°é’ˆå¯¹ Linalg-on-tensors ä» MHLOï¼ˆå…ƒ HLOï¼Œç”±äºä¾‹å¦‚å»é™¤éšå¼å¹¿æ’­ç­‰ï¼Œæ›´é€‚åˆç¼–è¯‘ï¼Œå¹¶æ”¯æŒåŠ¨æ€å½¢çŠ¶ï¼›å…¶ä¸­ HLO æ˜¯é«˜çº§ä¼˜åŒ–è¡¨ç¤ºï¼Œæºè‡ª XLAï¼‰è€Œä¸æ˜¯ LMHLOï¼ˆå»¶è¿Ÿ MHLOï¼Œä¸ MHLO ç›¸åŒï¼Œä½†é’ˆå¯¹ç¼“å†²åŒºè€Œä¸æ˜¯å¼ é‡ï¼‰çš„ç›®æ ‡ï¼Œå¹¶åœ¨è¯¥çº§åˆ«è¿›è¡Œèåˆï¼Œç„¶ååœ¨è°ƒç”¨ Linalg çš„ç¼“å†²åŒºä¸Šè¿›è¡Œç¼“å†²åŒ–ã€‚è¿›ä¸€æ­¥çš„å¾ªç¯è½¬æ¢ï¼Œå¦‚ tilingï¼Œå‘ç”Ÿåœ¨ SCF çº§åˆ«ï¼Œç„¶åå°†å…¶è½¬æ¢ä¸ºç‰¹å®šäºç›®æ ‡ GPU æ–¹è¨€ï¼Œè€Œæœ‰æ•ˆè´Ÿè½½æ“ä½œåˆ™è½¬æ¢ä¸º LLVM æ–¹è¨€ï¼Œä»¥æ ‡å‡†ä½œä¸ºä¸­ä»‹ã€‚ç°åœ¨å·²é€€å½¹çš„åŸå‹å·²å°è¯•ä½¿ç”¨é’ˆå¯¹ Linalg-on-Buffers çš„ LMHLO æ–¹è¨€ï¼Œå¹¶åœ¨ SCF ä¸Šæ‰§è¡Œæ‰€æœ‰è½¬æ¢ï¼Œè¿™å¯èƒ½æ¯”åœ¨å¼ é‡æŠ½è±¡ä¸Šæ›´å¤æ‚ã€‚ When producing several kernels, TensorFlow-related flows are expected to use the Async dialect to orchestrate computation. å½“ç”Ÿæˆå¤šä¸ªå†…æ ¸æ—¶ï¼ŒTensorFlow ç›¸å…³çš„æµç¨‹åº”ä½¿ç”¨å¼‚æ­¥æ–¹è¨€æ¥ç¼–æ’è®¡ç®—ã€‚ Analysis åˆ†æ Crossing Dialects è·¨è¶Šæ–¹è¨€ In hindsight, it appears that the dialects that cross axis boundaries in this classification (GPU, Linalg and Vector) have required the most discussion and iteration before being accepted as part of the core ecosystem. Even now, users of MLIR infrastructure reported that it was challenging to understand the positioning of some dialects. For example, IREE uses parts of the GPU dialect related to on-device execution, but not the parts related to managing data and kernels from the host, which are closer related to the structure than to the payload. Similarly, the discussion on bridging the tensor and memref abstraction with corresponding operations required significant effort to converge. å›é¡¾èµ·æ¥ï¼Œåœ¨è¿™ä¸ªåˆ†ç±»ï¼ˆGPUã€Linalg å’Œ Vectorï¼‰ä¸­è·¨è¶Šè½´è¾¹ç•Œçš„åœ°æ–¹ï¼Œæ–¹è¨€éœ€è¦æœ€å¤šçš„è®¨è®ºå’Œè¿­ä»£æ‰èƒ½è¢«æ¥å—ä¸ºæ ¸å¿ƒç”Ÿæ€ç³»ç»Ÿçš„ä¸€éƒ¨åˆ†ã€‚å³ä¾¿ç°åœ¨ï¼ŒMLIR åŸºç¡€è®¾æ–½çš„ç”¨æˆ·æŠ¥å‘Šç§°ï¼Œç†è§£æŸäº›æ–¹è¨€çš„ä½ç½®ä»ç„¶å…·æœ‰æŒ‘æˆ˜æ€§ã€‚ä¾‹å¦‚ï¼ŒIREE ä½¿ç”¨äº†ä¸è®¾å¤‡ä¸Šæ‰§è¡Œç›¸å…³çš„ GPU æ–¹è¨€çš„ä¸€éƒ¨åˆ†ï¼Œä½†æ²¡æœ‰ä½¿ç”¨ä¸ä»ä¸»æœºç®¡ç†æ•°æ®å’Œå†…æ ¸ç›¸å…³çš„éƒ¨åˆ†ï¼Œè¿™äº›éƒ¨åˆ†ä¸ç»“æ„æ¯”ä¸æœ‰æ•ˆè½½è·æ›´ç›¸å…³ã€‚åŒæ ·ï¼Œå…³äºå°†å¼ é‡å’Œ memref æŠ½è±¡ä¸ç›¸åº”çš„æ“ä½œæ¡¥æ¥çš„è®¨è®ºä¹Ÿè€—è´¹äº†å¤§é‡ç²¾åŠ›ä»¥è¾¾æˆå…±è¯†ã€‚ This suggests that new dialects, or smaller IR concepts, can be easier to discuss and reach consensus if they are clearly positioned with respect to other dialects and the design space. When it is necessary to cross the gap between abstractions, it may be preferable to discuss it separately and aim for generalization between dialects (e.g., bufferization process). è¿™è¡¨æ˜ï¼Œå¦‚æœæ–°æ–¹è¨€æˆ–è¾ƒå°çš„ IR æ¦‚å¿µåœ¨ä¸å…¶ä»–æ–¹è¨€å’Œè®¾è®¡ç©ºé—´çš„å…³ç³»ä¸­æ˜ç¡®å®šä½ï¼Œå®ƒä»¬å¯èƒ½æ›´å®¹æ˜“è®¨è®ºå’Œè¾¾æˆå…±è¯†ã€‚å½“éœ€è¦è·¨è¶ŠæŠ½è±¡ä¹‹é—´çš„å·®è·æ—¶ï¼Œæœ€å¥½å•ç‹¬è®¨è®ºï¼Œå¹¶æ—¨åœ¨æ–¹è¨€ä¹‹é—´å®ç°æ³›åŒ–ï¼ˆä¾‹å¦‚ï¼Œç¼“å†²è¿‡ç¨‹ï¼‰ã€‚ Linalg at the Center çº¿æ€§ä»£æ•°åœ¨ä¸­å¿ƒ The Linalg dialect is one of the main entry points to the MLIR code generation pipelines. Its most recent evolution makes it operate on both tensors and buffers, making bufferization an intra-dialect transformation. It has sufficiently high-level information about the operations to perform transformations without expensive analyses, especially when operating on tensors as values. Some transformations like fusion of element-wise operations and tiling, and combination thereof to generate imperfectly nested computations capture a sufficient amount of transformations needed to target a broad range of architectures. Furthermore, the concept of named operations enables payload-carrying operations that build on the computational patterns of Linalg. Linalg æ–¹è¨€æ˜¯ MLIR ä»£ç ç”Ÿæˆç®¡é“çš„ä¸»è¦å…¥å£ä¹‹ä¸€ã€‚å…¶æœ€æ–°çš„æ¼”å˜ä½¿å…¶èƒ½å¤Ÿåœ¨å¼ é‡å’Œç¼“å†²åŒºä¸Šè¿è¡Œï¼Œä½¿ç¼“å†²åŒºåŒ–ä¸ºæ–¹è¨€å†…éƒ¨çš„è½¬æ¢ã€‚å®ƒå¯¹è¦æ‰§è¡Œçš„æ“ä½œå…·æœ‰è¶³å¤Ÿçš„é«˜çº§ä¿¡æ¯ï¼Œå¯ä»¥åœ¨ä¸è¿›è¡Œæ˜‚è´µåˆ†æçš„æƒ…å†µä¸‹è¿›è¡Œè½¬æ¢ï¼Œå°¤å…¶æ˜¯åœ¨å°†å¼ é‡ä½œä¸ºå€¼æ“ä½œæ—¶ã€‚ä¸€äº›è½¬æ¢ï¼Œå¦‚é€å…ƒç´ æ“ä½œçš„èåˆå’Œåˆ†å—ï¼Œä»¥åŠå°†å®ƒä»¬ç»„åˆèµ·æ¥ç”Ÿæˆä¸å®Œç¾åµŒå¥—çš„è®¡ç®—ï¼Œæ•è·äº†é’ˆå¯¹å¹¿æ³›æ¶æ„æ‰€éœ€çš„å¤§é‡è½¬æ¢ã€‚æ­¤å¤–ï¼Œå‘½åæ“ä½œçš„æ¦‚å¿µä½¿å¾—åŸºäº Linalg è®¡ç®—æ¨¡å¼çš„æºå¸¦æœ‰æ•ˆè½½è·çš„æ“ä½œæˆä¸ºå¯èƒ½ã€‚ Being exercised in virtually all compilation pipelines adds maintenance pressure and stability requirements on Linalg as production users start to rely on it. The fact that it works across buffers and tensors, and may capture both the payload and the structure of the computation makes understanding Linalg to some extent a requirement for understanding any MLIR code generation pipeline. While there are benefits in having one well-defined and maintained entry point, extra care must be taken to ensure that Linalg remains composable with other dialects and that transformation algorithms are not over-designed for it. åœ¨å‡ ä¹æ‰€æœ‰ç¼–è¯‘ç®¡é“ä¸­éƒ½è¢«ä½¿ç”¨ï¼Œç»™ Linalg å¸¦æ¥äº†ç»´æŠ¤å‹åŠ›å’Œç¨³å®šæ€§è¦æ±‚ï¼Œéšç€ç”Ÿäº§ç”¨æˆ·å¼€å§‹ä¾èµ–å®ƒã€‚å®ƒèƒ½å¤Ÿåœ¨ç¼“å†²åŒºå’Œå¼ é‡ä¹‹é—´å·¥ä½œï¼Œå¹¶å¯èƒ½æ•è·è®¡ç®—çš„æœ‰æ•ˆè½½è·å’Œç»“æ„ï¼Œè¿™åœ¨ä¸€å®šç¨‹åº¦ä¸Šä½¿å¾—ç†è§£ Linalg æˆä¸ºç†è§£ä»»ä½• MLIR ä»£ç ç”Ÿæˆç®¡é“çš„å¿…è¦æ¡ä»¶ã€‚è™½ç„¶æœ‰ä¸€ä¸ªå®šä¹‰è‰¯å¥½ä¸”ç»´æŠ¤è‰¯å¥½çš„å…¥å£ç‚¹æœ‰å…¶å¥½å¤„ï¼Œä½†å¿…é¡»æ ¼å¤–å°å¿ƒï¼Œä»¥ç¡®ä¿ Linalg ä¸å…¶ä»–æ–¹è¨€ä¿æŒå¯ç»„åˆæ€§ï¼Œå¹¶ä¸”å˜æ¢ç®—æ³•ä¸è¦è¿‡åº¦è®¾è®¡ã€‚ Pipeline Differences to Complementary Transformationsç®¡é“å·®å¼‚ä¸äº’è¡¥å˜æ¢ Several parallel compilation pipelines appear to emerge in the ecosystem. The case of targeting GPUs is particularly illustrative: optimizing transformations, parallelism detection and device mapping decisions can happen in various dialects (Linalg, Affine, SCF), which may end up partially reimplementing each otherâ€™s functionality; device mapping can derive SIMT threads from explicit loops or from vectors, using the SCF or the Vector dialect. Finally, GPU libraries have support for higher-level operations such as contractions and convolutions, that could be directly targeted from the entry point of the code generation pipeline. å‡ ä¸ªå¹¶è¡Œç¼–è¯‘ç®¡é“ä¼¼ä¹åœ¨ç”Ÿæ€ç³»ç»Ÿä¸­å‡ºç°ã€‚é’ˆå¯¹ GPU çš„æƒ…å†µå°¤å…¶å…·æœ‰è¯´æ˜æ€§ï¼šä¼˜åŒ–è½¬æ¢ã€å¹¶è¡Œæ€§æ£€æµ‹å’Œè®¾å¤‡æ˜ å°„å†³ç­–å¯ä»¥åœ¨å„ç§æ–¹è¨€ï¼ˆLinalgã€Affineã€SCFï¼‰ä¸­å‘ç”Ÿï¼Œè¿™å¯èƒ½å¯¼è‡´éƒ¨åˆ†é‡æ–°å®ç°å½¼æ­¤çš„åŠŸèƒ½ï¼›è®¾å¤‡æ˜ å°„å¯ä»¥ä»æ˜¾å¼å¾ªç¯æˆ–å‘é‡ä¸­æ¨å¯¼å‡º SIMT çº¿ç¨‹ï¼Œä½¿ç”¨ SCF æˆ– Vector æ–¹è¨€ã€‚æœ€åï¼ŒGPU åº“æ”¯æŒæ›´é«˜å±‚æ¬¡çš„è¿ç®—ï¼Œå¦‚æ”¶ç¼©å’Œå·ç§¯ï¼Œè¿™äº›è¿ç®—å¯ä»¥ç›´æ¥ä»ä»£ç ç”Ÿæˆç®¡é“çš„å…¥å£ç‚¹è¿›è¡Œå®šä½ã€‚ It is more important than ever to make sure representations and transformations compose and complement each other to deliver on MLIRâ€™s promise to unify the compilation infrastructure, as opposed to building independent parallel flows. It does not necessarily mean immediately reusing all components, but avoid poorly composable patterns as much as possible. The utility of domain- and target-specific compilers is undeniable, but the project may need to invest into cross-cutting representations, using the generic mechanisms of attributes and interfaces. Circling back to targeting GPUs as an example, a device mapping strategy expressed as attributes that can be attached to different operations (e.g., Linalg generics or parallel SCF loops) that can be transformed through interfaces without needing to know the details of a specific operation. ç¡®ä¿è¡¨ç¤ºå’Œå˜æ¢ç›¸äº’ç»„åˆå’Œè¡¥å……ï¼Œä»¥å®ç° MLIR ç»Ÿä¸€ç¼–è¯‘åŸºç¡€è®¾æ–½çš„æ‰¿è¯ºï¼Œæ¯”ä»¥å¾€ä»»ä½•æ—¶å€™éƒ½æ›´åŠ é‡è¦ï¼Œè€Œä¸æ˜¯æ„å»ºç‹¬ç«‹çš„å¹¶è¡Œæµç¨‹ã€‚è¿™å¹¶ä¸æ„å‘³ç€ç«‹å³é‡ç”¨æ‰€æœ‰ç»„ä»¶ï¼Œä½†åº”å°½å¯èƒ½é¿å…ä¸è‰¯çš„å¯ç»„åˆæ¨¡å¼ã€‚é¢†åŸŸå’Œç›®æ ‡ç‰¹å®šç¼–è¯‘å™¨çš„æ•ˆç”¨æ— å¯å¦è®¤ï¼Œä½†é¡¹ç›®å¯èƒ½éœ€è¦æŠ•èµ„äºè·¨é¢†åŸŸçš„è¡¨ç¤ºï¼Œä½¿ç”¨å±æ€§å’Œæ¥å£çš„é€šç”¨æœºåˆ¶ã€‚ä»¥é’ˆå¯¹ GPU ä¸ºä¾‹ï¼Œä¸€ç§è®¾å¤‡æ˜ å°„ç­–ç•¥å¯ä»¥è¡¨ç¤ºä¸ºå¯ä»¥é™„åŠ åˆ°ä¸åŒæ“ä½œï¼ˆä¾‹å¦‚ï¼ŒLinalg æ³›å‹æˆ–å¹¶è¡Œ SCF å¾ªç¯ï¼‰çš„å±æ€§ï¼Œè¿™äº›æ“ä½œå¯ä»¥é€šè¿‡æ¥å£è¿›è¡Œè½¬æ¢ï¼Œè€Œæ— éœ€äº†è§£ç‰¹å®šæ“ä½œçš„è¯¦ç»†ä¿¡æ¯ã€‚ Build Small Reusable Abstractionsæ„å»ºå°å‹å¯é‡ç”¨æŠ½è±¡ One can observe an unsurprising tendency of performing most transformations in the higher levels of the code generation pipeline: the necessary validity information is readily available or easily extractable at these levels without the need for complex analyses. Yet, higher levels of abstraction often have more stringent restrictions of what is representable. When pursuing benefits of such abstractions, it is important to keep in mind the expressivity and the ability to perform at least some transformations at lower levels as means to quickly increase expressivity without reimplementing the top-level abstraction (dynamic shapes in HLO are a good example). ä¸€ä¸ªäººå¯ä»¥è§‚å¯Ÿåˆ°åœ¨ä»£ç ç”Ÿæˆç®¡é“çš„é«˜å±‚è¿›è¡Œå¤§å¤šæ•°è½¬æ¢çš„ä»¤äººæƒŠè®¶çš„è¶‹åŠ¿ï¼šå¿…è¦çš„æœ‰æ•ˆæ€§ä¿¡æ¯åœ¨è¿™äº›å±‚é¢ä¸Šæ˜“äºè·å–æˆ–æå–ï¼Œæ— éœ€å¤æ‚çš„åˆ†æã€‚ç„¶è€Œï¼ŒæŠ½è±¡å±‚æ¬¡è¶Šé«˜ï¼Œå¯¹å¯è¡¨ç¤ºå†…å®¹çš„é™åˆ¶é€šå¸¸è¶Šä¸¥æ ¼ã€‚åœ¨è¿½æ±‚è¿™ç§æŠ½è±¡çš„å¥½å¤„æ—¶ï¼Œé‡è¦çš„æ˜¯è¦è®°ä½è¡¨è¾¾æ€§å’Œåœ¨è¾ƒä½å±‚æ¬¡ä¸Šæ‰§è¡Œè‡³å°‘ä¸€äº›è½¬æ¢çš„èƒ½åŠ›ï¼Œä½œä¸ºå¿«é€Ÿæé«˜è¡¨è¾¾æ€§çš„æ‰‹æ®µï¼Œè€Œä¸éœ€è¦é‡æ–°å®ç°é¡¶å±‚æŠ½è±¡ï¼ˆHLO ä¸­çš„åŠ¨æ€å½¢çŠ¶æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­ï¼‰ã€‚ Need for More Structure éœ€è¦æ›´å¤šç»“æ„ Another emerging tendency is larger dialects and progressive lowering performed without leaving the dialect boundaries. Some examples include Linalg operations on tensors that get transformed into using buffers, GPU dialect block reductions that get decomposed into shuffles, and math operations in Standard that can be expanded into smaller operations or approximated using other Standard operations. We are reaching a point where a dialect contains several loosely connected subsets of operations. This has led to the proposal of splitting the Standard dialect into multiple components. However, the splitting may not always be desirable or even feasible: the same Linalg operations accept tensors and buffers so it is challenging to have separate TLinalg and BLinalg without lots of duplication. This calls for additional ways of structuring the operations within a dialect in a way that is understandable programmatically. å¦ä¸€ç§æ–°å…´è¶‹åŠ¿æ˜¯æ›´å¤§æ–¹è¨€å’Œæ¸è¿›å¼é™ä½ï¼Œè€Œæ— éœ€è·¨è¶Šæ–¹è¨€è¾¹ç•Œã€‚ä¸€äº›ä¾‹å­åŒ…æ‹¬å°†å¼ é‡æ“ä½œè½¬æ¢ä¸ºä½¿ç”¨ç¼“å†²åŒºï¼Œå°† GPU æ–¹è¨€å—å‡å°‘åˆ†è§£ä¸ºæ´—ç‰Œï¼Œä»¥åŠå¯ä»¥åœ¨æ ‡å‡†ä¸­æ‰©å±•ä¸ºè¾ƒå°æ“ä½œæˆ–ä½¿ç”¨å…¶ä»–æ ‡å‡†æ“ä½œè¿›è¡Œè¿‘ä¼¼çš„æ ‡å‡†æ•°å­¦æ“ä½œã€‚æˆ‘ä»¬æ­£è¾¾åˆ°ä¸€ä¸ªç‚¹ï¼Œå…¶ä¸­æ–¹è¨€åŒ…å«å‡ ä¸ªæ¾æ•£è¿æ¥çš„æ“ä½œå­é›†ã€‚è¿™å¯¼è‡´äº†å°†æ ‡å‡†æ–¹è¨€æ‹†åˆ†ä¸ºå¤šä¸ªç»„ä»¶çš„æè®®ã€‚ç„¶è€Œï¼Œæ‹†åˆ†å¯èƒ½å¹¶ä¸æ€»æ˜¯å¯å–æˆ–ç”šè‡³å¯è¡Œï¼šç›¸åŒçš„ Linalg æ“ä½œæ¥å—å¼ é‡å’Œç¼“å†²åŒºï¼Œå› æ­¤åœ¨æ²¡æœ‰å¤§é‡é‡å¤çš„æƒ…å†µä¸‹ï¼Œè¦åˆ†åˆ«æœ‰ TLinalg å’Œ BLinalg æ˜¯å…·æœ‰æŒ‘æˆ˜æ€§çš„ã€‚è¿™éœ€è¦ä»¥å¯ç¼–ç¨‹æ–¹å¼ç†è§£çš„æ–¹å¼åœ¨æ–¹è¨€å†…å¯¹æ“ä½œè¿›è¡Œç»“æ„åŒ–ã€‚ Host/Device Or Program/Kernel As Additional Axisä¸»æœº/è®¾å¤‡æˆ–ç¨‹åº/å†…æ ¸ä½œä¸ºé™„åŠ è½´ Finally, uses of MLIR in the scope of larger, mostly ML-related, flows prompt for cleaner separation between the aspects that pertain to the overall organization of computations (e.g., operations that reflect the mapping of a model on a distributed system and interaction with the framework that embeds MLIR, typically on a â€œhostâ€) and organization of individual computations (e.g., operations that correspond to internals of a â€œkernelâ€ or another large unit of computation, potentially offloaded to a â€œdeviceâ€). For â€œhostâ€ parts, code generation may also be necessary and often requires different transformations than for â€œkernelâ€ parts. æœ€ç»ˆï¼Œåœ¨æ›´å¤§ã€ä¸»è¦ä¸æœºå™¨å­¦ä¹ ç›¸å…³çš„æµç¨‹ä¸­ä½¿ç”¨ MLIRï¼Œä¿ƒä½¿è®¡ç®—æ•´ä½“ç»„ç»‡æ–¹é¢çš„æ–¹é¢ï¼ˆä¾‹å¦‚ï¼Œåæ˜ æ¨¡å‹åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸Šçš„æ˜ å°„ä»¥åŠä¸åµŒå…¥ MLIR çš„æ¡†æ¶äº¤äº’çš„æ“ä½œï¼Œé€šå¸¸åœ¨â€œä¸»æœºâ€ä¸Šï¼‰ä¸å•ä¸ªè®¡ç®—ç»„ç»‡ï¼ˆä¾‹å¦‚ï¼Œå¯¹åº”â€œå†…æ ¸â€æˆ–å…¶ä»–å¤§å‹è®¡ç®—å•å…ƒå†…éƒ¨çš„æ“ä½œï¼Œå¯èƒ½å¸è½½åˆ°â€œè®¾å¤‡â€ä¸Šï¼‰ä¹‹é—´çš„åˆ†ç¦»æ›´åŠ æ¸…æ™°ã€‚å¯¹äºâ€œä¸»æœºâ€éƒ¨åˆ†ï¼Œä»£ç ç”Ÿæˆå¯èƒ½ä¹Ÿæ˜¯å¿…è¦çš„ï¼Œå¹¶ä¸”é€šå¸¸éœ€è¦ä¸â€œå†…æ ¸â€éƒ¨åˆ†ä¸åŒçš„è½¬æ¢ã€‚ Specific examples of this separation include the GPU dialect that contains operations for both controlling the execution from host and operations executed on the GPU proper, which may benefit from separation into independent dialects, and the Async dialect that is being used on two levels: organizing the execution of independent â€œkernelsâ€ and parallelizing execution within a â€œkernelâ€ by targeting LLVM coroutines. å…·ä½“ç¤ºä¾‹åŒ…æ‹¬åŒ…å«æ§åˆ¶ä¸»æœºæ‰§è¡Œå’Œ GPU ä¸Šæ‰§è¡Œæ“ä½œçš„ GPU æ–¹è¨€ï¼Œè¿™å¯èƒ½ä»åˆ†ç¦»æˆç‹¬ç«‹çš„æ–¹è¨€ä¸­å—ç›Šï¼Œä»¥åŠæ­£åœ¨ä¸¤ä¸ªçº§åˆ«ä¸Šä½¿ç”¨çš„ Async æ–¹è¨€ï¼šé€šè¿‡é’ˆå¯¹ LLVM åç¨‹ç»„ç»‡ç‹¬ç«‹â€œå†…æ ¸â€çš„æ‰§è¡Œå’Œé€šè¿‡é’ˆå¯¹â€œå†…æ ¸â€å†…çš„å¹¶è¡Œæ‰§è¡Œã€‚ "},"Learn/LearnMLIR/Dialects.html":{"url":"Learn/LearnMLIR/Dialects.html","title":"Dialects","keywords":"","body":"MLIR æ–¹è¨€ï¼šæ¦‚è¿° MLIR æ–¹è¨€æ˜¯ MLIR ç”Ÿæ€ç³»ç»Ÿä¸­çš„ä¸“ä¸šå­é›†ï¼Œå®šä¹‰äº†ç‰¹å®šé¢†åŸŸçš„æ“ä½œã€ç±»å‹å’Œè½¬æ¢ã€‚æ¯ä¸ªæ–¹è¨€éƒ½é’ˆå¯¹ç‰¹å®šé¢†åŸŸæˆ–æŠ½è±¡çº§åˆ«çš„è®¡ç®—è¿›è¡Œè¡¨ç¤ºå’Œä¼˜åŒ–ã€‚è¿™ç§æ¨¡å—åŒ–å…è®¸å¼€å‘äººå‘˜é€šè¿‡ç»„åˆå’Œè½¬æ¢è¿™äº›æ–¹è¨€æ¥æ„å»ºè‡ªå®šä¹‰ç¼–è¯‘ç®¡é“ã€‚ ä»¥ä¸‹æ˜¯å¯¹å…³é”® MLIR æ–¹è¨€çš„ä»‹ç»ï¼Œå¦‚ Mathã€Linalgã€SCF å’Œ Affineï¼Œå®ƒä»¬åœ¨é«˜æ€§èƒ½å’Œé¢†åŸŸç‰¹å®šè®¡ç®—ä¸­å‘æŒ¥ç€å…³é”®ä½œç”¨ã€‚ 1. Math æ–¹è¨€ ç›®çš„ï¼š Math æ–¹è¨€æä¾›äº†ä¸€ç»„åœ¨è®¡ç®—ä»»åŠ¡ä¸­å¸¸ç”¨çš„æ•°å­¦æ“ä½œï¼Œå¦‚ä¸‰è§’å‡½æ•°ã€æŒ‡æ•°å‡½æ•°ã€å¯¹æ•°å‡½æ•°å’Œç®—æœ¯æ“ä½œã€‚å®ƒä½œä¸ºé«˜çº§æŠ½è±¡ä¸ä½çº§æ•°å€¼è®¡ç®—ä¹‹é—´çš„æ¡¥æ¢ã€‚ ç‰¹æ€§ï¼š åŒ…æ‹¬åŸºæœ¬çš„æ•°å­¦å‡½æ•°ï¼Œå¦‚ sinã€cosã€expã€log å’Œ sqrtã€‚ é€šè¿‡æŠ½è±¡å¸¸ç”¨æ•°å­¦ä¾‹ç¨‹ç®€åŒ–è®¡ç®—ã€‚ æ”¯æŒé’ˆå¯¹æ•°å­¦æ“ä½œçš„ä¼˜åŒ–ï¼Œå¦‚å¸¸é‡æŠ˜å æˆ–åŸºäºåº“çš„æ›¿æ¢ã€‚ åº”ç”¨ï¼š å¸¸ç”¨äºæœºå™¨å­¦ä¹ ã€ç§‘å­¦è®¡ç®—ä»¥åŠéœ€è¦å¤§é‡æ•°å€¼è®¡ç®—çš„é¢†åŸŸã€‚ ä¸ºè½¬æ¢ä¸ºç¡¬ä»¶ä¼˜åŒ–çš„æ•°å­¦åº“æä¾›äº†åŸºç¡€ã€‚ 2. Linalg æ–¹è¨€ ç›®çš„ï¼š Linalg æ–¹è¨€æ—¨åœ¨è¡¨ç¤ºç»“æ„åŒ–çš„çº¿æ€§ä»£æ•°è®¡ç®—ï¼Œå¦‚çŸ©é˜µä¹˜æ³•ã€å·ç§¯å’Œå½’çº¦ã€‚å®ƒæä¾›äº†ä¸å¼ é‡å’Œçº¿æ€§ä»£æ•°æ“ä½œç´§å¯†å¯¹é½çš„æŠ½è±¡ã€‚ ç‰¹æ€§ï¼š æ“ä½œåŒ…æ‹¬ï¼š linalg.matmulï¼šçŸ©é˜µ-çŸ©é˜µä¹˜æ³•ã€‚ linalg.convï¼šç”¨äºå›¾åƒå¤„ç†æˆ–ç¥ç»ç½‘ç»œçš„å·ç§¯ã€‚ linalg.genericï¼šç”¨äºç”¨æˆ·å®šä¹‰çº¿æ€§ä»£æ•°æ¨¡å¼çš„é€šç”¨å¾ªç¯ã€‚ ç»„åˆæ€§ï¼š Linalg æ“ä½œå¯ä»¥ç»„åˆå’ŒåµŒå¥—ä»¥å½¢æˆå¤æ‚çš„è®¡ç®—ã€‚ æ˜¾å¼å»ºæ¨¡è¿­ä»£å’Œå†…å­˜è®¿é—®æ¨¡å¼ã€‚ ä¼˜åŒ–ï¼š é«˜çº§è½¬æ¢ï¼ˆå¦‚åˆ†å—ã€èåˆï¼‰ã€‚ ä¸ä½çº§æ–¹è¨€ï¼ˆå¦‚ Affineï¼‰é›†æˆï¼Œä»¥è¿›è¡Œè¯¦ç»†çš„ç¡¬ä»¶æ˜ å°„ã€‚ åº”ç”¨ï¼š æœºå™¨å­¦ä¹ æ¡†æ¶ä¸­çš„å¼ é‡æ“ä½œã€‚ æ¶‰åŠå¯†é›†å’Œç¨€ç–çº¿æ€§ä»£æ•°çš„é«˜æ€§èƒ½è®¡ç®—å·¥ä½œè´Ÿè½½ã€‚ 3. SCF æ–¹è¨€ï¼ˆç»“æ„åŒ–æ§åˆ¶æµï¼‰ ç›®çš„ï¼š SCF æ–¹è¨€æä¾›äº†åŸºæœ¬çš„æ§åˆ¶æµç»“æ„ï¼Œå¦‚å¾ªç¯å’Œæ¡ä»¶è¯­å¥ã€‚è¿™äº›ç»“æ„æ˜¯é€šç”¨çš„ï¼Œå¯ä»¥ä½œä¸ºé«˜çº§æ§åˆ¶æµå’Œè¿­ä»£å»ºæ¨¡çš„æ„å»ºå—ã€‚ ç‰¹æ€§ï¼š æ“ä½œï¼š scf.forï¼šè¡¨ç¤ºå¸¦æœ‰èµ·å§‹å€¼ã€ç»“æŸå€¼å’Œæ­¥é•¿çš„æ ‡å‡† for å¾ªç¯ã€‚ scf.ifï¼šç”¨äºæ§åˆ¶æµçš„æ¡ä»¶åˆ†æ”¯ã€‚ scf.parallelï¼šç”¨äºå¤šçº¿ç¨‹æˆ– SIMD é£æ ¼æ‰§è¡Œçš„å¹¶è¡Œå¾ªç¯ã€‚ é«˜çº§æ§åˆ¶æµæŠ½è±¡ç®€åŒ–äº†åç»­çš„ä¼˜åŒ–å’Œè½¬æ¢ã€‚ åº”ç”¨ï¼š ç”¨ä½œå°†é«˜çº§å¾ªç¯è½¬æ¢ä¸ºä½çº§ç»“æ„çš„ä¸­é—´è¡¨ç¤ºã€‚ ä½œä¸ºé›†æˆå¾ªç¯ä¼˜åŒ–ï¼ˆå¦‚å¾ªç¯å±•å¼€æˆ–å‘é‡åŒ–ï¼‰çš„è·³æ¿ã€‚ 4. Affine æ–¹è¨€ ç›®çš„ï¼š Affine æ–¹è¨€æä¾›äº†ç”¨äºå»ºæ¨¡é™æ€æ§åˆ¶æµã€å†…å­˜è®¿é—®æ¨¡å¼å’Œå¾ªç¯åµŒå¥—çš„ç²¾ç¡®ä¸”å¯åˆ†æçš„ç»“æ„ã€‚å®ƒç‰¹åˆ«é€‚ç”¨äºä¼˜åŒ–æ€§èƒ½å…³é”®çš„è®¡ç®—ã€‚ ç‰¹æ€§ï¼š Affine è¡¨è¾¾å¼ï¼š ä½¿ç”¨å¸¦æœ‰æ•´æ•°ç³»æ•°çš„çº¿æ€§è¡¨è¾¾å¼æ¥è¡¨ç¤ºå¾ªç¯è¾¹ç•Œå’Œå†…å­˜è®¿é—®ã€‚ ç¤ºä¾‹ï¼šaffine.for %i = 0 to 100 step 2ã€‚ Affine æ˜ å°„ï¼š æŠ½è±¡åœ°è¡¨ç¤ºç´¢å¼•å’Œå†…å­˜åœ°å€ä¹‹é—´çš„æ˜ å°„ã€‚ é€‚ç”¨äºå¾ªç¯åˆ†å—æˆ–æ•°ç»„é‡ç´¢å¼•ç­‰è½¬æ¢ã€‚ ä¼˜åŒ–ï¼š æ”¯æŒå¾ªç¯èåˆã€äº¤æ¢å’Œåˆ†å—ç­‰è½¬æ¢ã€‚ å…è®¸ä¾èµ–æ€§åˆ†æä»¥è¿›è¡Œå¹¶è¡Œæ‰§è¡Œã€‚ åº”ç”¨ï¼š éœ€è¦æ˜¾å¼æ§åˆ¶å¾ªç¯å’Œå†…å­˜çš„é«˜æ€§èƒ½è®¡ç®—ã€‚ ä½œä¸ºé™ä½åˆ°ç¡¬ä»¶ç‰¹å®šè¡¨ç¤ºï¼ˆå¦‚ LLVM IRï¼‰çš„åŸºç¡€å±‚ã€‚ æ–¹è¨€ä¹‹é—´çš„äº¤äº’ MLIR æ–¹è¨€è®¾è®¡ä¸ºæ— ç¼äº’æ“ä½œã€‚ä¾‹å¦‚ï¼š Linalg æ–¹è¨€ä¸­çš„é«˜çº§æ“ä½œå¯ä»¥é™ä½ä¸º SCF æ–¹è¨€ä¸­çš„å¾ªç¯ï¼Œæˆ–é™ä½ä¸º Affine æ–¹è¨€ä¸­çš„é™æ€å¾ªç¯ä»¥è¿›è¡Œè¿›ä¸€æ­¥ä¼˜åŒ–ã€‚ Math æ–¹è¨€ä¸­çš„æ•°å­¦æ“ä½œå¯ä»¥åµŒå…¥åˆ° Linalg æˆ– Affine æ“ä½œä¸­è¿›è¡Œæ•°å€¼è®¡ç®—ã€‚ SCF å’Œ Affine æ–¹è¨€æä¾›äº†äº’è¡¥çš„æ§åˆ¶æµæŠ½è±¡ï¼šSCF ç”¨äºé€šç”¨å¾ªç¯ï¼ŒAffine ç”¨äºé™æ€ã€å¯åˆ†æçš„æ¨¡å¼ã€‚ ä½¿ç”¨ MLIR æ–¹è¨€çš„ä¼˜åŠ¿ æ¨¡å—åŒ–ï¼šå¼€å‘äººå‘˜å¯ä»¥é€‰æ‹©æˆ–å®šä¹‰é€‚åˆå…¶é¢†åŸŸçš„æ–¹è¨€ï¼Œä¿ƒè¿›é‡ç”¨å’Œä¸“ä¸šåŒ–ã€‚ å¯æ‰©å±•æ€§ï¼šå¯ä»¥åœ¨ä¸æ”¹å˜æ ¸å¿ƒåŸºç¡€è®¾æ–½çš„æƒ…å†µä¸‹å¼•å…¥æ–°æ–¹è¨€ã€‚ ä¼˜åŒ–ç®¡é“ï¼šæ–¹è¨€æ”¯æŒä»é«˜çº§æŠ½è±¡åˆ°ä½çº§ç¡¬ä»¶ç‰¹å®šæŒ‡ä»¤çš„åˆ†é˜¶æ®µé™ä½å’Œä¼˜åŒ–ã€‚ é¢†åŸŸç‰¹å®šæ•ˆç‡ï¼šé¢„å®šä¹‰çš„æ“ä½œå’Œæ¨¡å¼æ»¡è¶³æœºå™¨å­¦ä¹ å’Œç§‘å­¦è®¡ç®—ç­‰ç‰¹å®šé¢†åŸŸçš„éœ€æ±‚ã€‚ MLIR çš„æ–¹è¨€æ–¹æ³•ä¸ºå¼€å‘ä¼˜åŒ–çš„ã€å¯ç§»æ¤ä¸”å¯ç»´æŠ¤çš„ç¼–è¯‘å™¨åŸºç¡€è®¾æ–½æä¾›äº†å¼ºå¤§çš„æ¡†æ¶ã€‚ "},"Learn/LearnMLIR/Linalg.html":{"url":"Learn/LearnMLIR/Linalg.html","title":"Linalg","keywords":"","body":"Linalg Linalg is designed to solve the High-level Hierarchical Optimization (HHO box) in MLIR and to interoperate nicely within a Mixture Of Expert Compilers environment (i.e. the CGSel box).Linalg æ—¨åœ¨è§£å†³ MLIR ä¸­çš„é«˜çº§åˆ†å±‚ä¼˜åŒ–ï¼ˆHHO æ¡†ï¼‰é—®é¢˜ï¼Œå¹¶åœ¨æ··åˆä¸“å®¶ç¼–è¯‘å™¨ç¯å¢ƒä¸­è‰¯å¥½åœ°äº¤äº’ï¼ˆå³ CGSel æ¡†ï¼‰ã€‚ Set of Key Transformationsä¸€ç»„å…³é”®å˜æ¢ The following key transformations have been central to driving the design of Linalg. They are all implemented in terms of the properties of the linalg.generic OpInterface and avoid the pitfall of relying on hardcoded one-off op knowledge.ä»¥ä¸‹å…³é”®è½¬æ¢æ˜¯æ¨åŠ¨ Linalg è®¾è®¡çš„å…³é”®ã€‚å®ƒä»¬éƒ½åŸºäº linalg.generic OpInterface çš„æ€§è´¨å®ç°ï¼Œé¿å…äº†ä¾èµ–äºç¡¬ç¼–ç çš„å•æ¬¡æ“ä½œçŸ¥è¯†çš„é™·é˜±ã€‚ The textual form description of these transformations is left for future work. Still, it is useful to list the key transformations that are performed on the Linalg IR and that have influenced its design:è¿™äº›å˜æ¢çš„æ–‡æœ¬å½¢å¼æè¿°ç•™å¾…ä»¥åçš„å·¥ä½œã€‚å°½ç®¡å¦‚æ­¤ï¼Œåˆ—å‡ºåœ¨ Linalg IR ä¸Šæ‰§è¡Œçš„å…³é”®å˜æ¢ä»¥åŠå¯¹å…¶è®¾è®¡äº§ç”Ÿå½±å“çš„å˜æ¢æ˜¯æœ‰ç”¨çš„ï¼š Progressive Buffer Allocation.æ¸è¿›å¼ç¼“å†²åŒºåˆ†é…ã€‚ Parametric Tiling. å‚æ•°é“ºç –ã€‚ Promotion to Temporary Buffer in Fast Memory.æå‡è‡³å¿«é€Ÿå†…å­˜ä¸­çš„ä¸´æ—¶ç¼“å†²åŒºã€‚ Tiled Producer-Consumer Fusion with Parametric Tile-And-Fuse.åŸºäºå‚æ•°åŒ–åˆ†å—èåˆçš„é•¶åµŒå¼ç”Ÿäº§è€…-æ¶ˆè´¹è€…èåˆ Map to Parallel and Reduction Loops and Hardware.å¹¶è¡Œå’Œå½’çº¦å¾ªç¯åŠç¡¬ä»¶çš„æ˜ å°„ Vectorization: Rewrite in Vector Form.å‘é‡åŒ–ï¼šä»¥å‘é‡å½¢å¼é‡å†™ã€‚ Lower to Loops (Affine, Generic, and Parallel).ä¸‹åˆ°å¾ªç¯ï¼ˆä»¿å°„ã€é€šç”¨å’Œå¹¶è¡Œï¼‰ã€‚ Lower to Library Calls or Special Instructions, Intrinsics or ISA.ä¸‹è‡³åº“å‡½æ•°è°ƒç”¨æˆ–ç‰¹æ®ŠæŒ‡ä»¤ï¼Œå†…å»ºå‡½æ•°æˆ–æŒ‡ä»¤é›†æ¶æ„ã€‚ Partially Lower to Iterations Over a Finer-Grained Linalg Op.éƒ¨åˆ†é™ä½åˆ°æ›´ç»†ç²’åº¦çš„ Linalg æ“ä½œè¿­ä»£ã€‚ "},"Learn/LearnMLIR/MLIR-LanRef.html":{"url":"Learn/LearnMLIR/MLIR-LanRef.html","title":"MLIR-LanRef","keywords":"","body":"MLIR Language Reference text text text MLIR åŸºæœ¬ä¸Šæ˜¯åŸºäºä¸€ç§ç±»å›¾çš„æ•°æ®ç»“æ„ï¼Œè¿™ç§ç»“æ„ç”±ç§°ä¸ºæ“ä½œ (Operations) çš„èŠ‚ç‚¹å’Œç§°ä¸ºå€¼ (Values) çš„è¾¹ç»„æˆã€‚æ¯ä¸ªå€¼éƒ½æ˜¯ç”±ä¸€ä¸ªæ“ä½œæˆ–å—å‚æ•° (Block Argument) äº§ç”Ÿçš„ï¼Œå¹¶ä¸”å…·æœ‰ç”±ç±»å‹ç³»ç»Ÿå®šä¹‰çš„å€¼ç±»å‹ã€‚æ“ä½œåŒ…å«åœ¨å— (Blocks) ä¸­ï¼Œå—åŒ…å«åœ¨åŒºåŸŸ (Regions) ä¸­ã€‚æ“ä½œåœ¨å…¶æ‰€å±çš„å—ä¸­æ˜¯æœ‰é¡ºåºçš„ï¼Œå—åœ¨å…¶æ‰€å±çš„åŒºåŸŸä¸­ä¹Ÿæ˜¯æœ‰é¡ºåºçš„ï¼Œå°½ç®¡è¿™ç§é¡ºåºåœ¨æŸäº›ç±»å‹çš„åŒºåŸŸä¸­å¯èƒ½å…·æœ‰æˆ–ä¸å…·æœ‰è¯­ä¹‰æ„ä¹‰ã€‚æ“ä½œè¿˜å¯ä»¥åŒ…å«åŒºåŸŸï¼Œä»è€Œèƒ½å¤Ÿè¡¨ç¤ºå±‚æ¬¡ç»“æ„ã€‚ æ“ä½œå¯ä»¥è¡¨ç¤ºè®¸å¤šä¸åŒçš„æ¦‚å¿µï¼Œä»é«˜å±‚æ¦‚å¿µï¼ˆå¦‚å‡½æ•°å®šä¹‰ã€å‡½æ•°è°ƒç”¨ã€ç¼“å†²åŒºåˆ†é…ã€ç¼“å†²åŒºçš„è§†å›¾æˆ–åˆ‡ç‰‡ä»¥åŠè¿›ç¨‹åˆ›å»ºï¼‰åˆ°ä½å±‚æ¦‚å¿µï¼ˆå¦‚ä¸ç›®æ ‡æ— å…³çš„ç®—æœ¯ã€ä¸ç›®æ ‡ç›¸å…³çš„æŒ‡ä»¤ã€é…ç½®å¯„å­˜å™¨å’Œé€»è¾‘é—¨ï¼‰ã€‚è¿™äº›ä¸åŒçš„æ¦‚å¿µç”± MLIR ä¸­çš„ä¸åŒæ“ä½œè¡¨ç¤ºï¼Œå¹¶ä¸” MLIR ä¸­å¯ç”¨çš„æ“ä½œé›†å¯ä»¥ä»»æ„æ‰©å±•ã€‚ MLIR è¿˜æä¾›äº†ä¸€ä¸ªå¯æ‰©å±•çš„æ¡†æ¶ï¼Œç”¨äºå¯¹æ“ä½œè¿›è¡Œè½¬æ¢ï¼Œä½¿ç”¨äº†ç¼–è¯‘å™¨ Passes çš„å¸¸è§æ¦‚å¿µã€‚å¯¹ä»»æ„æ“ä½œé›†å¯ç”¨ä»»æ„è½¬æ¢é›†ä¼šå¸¦æ¥æ˜¾è‘—çš„æ‰©å±•æŒ‘æˆ˜ï¼Œå› ä¸ºæ¯ä¸ªè½¬æ¢éƒ½å¿…é¡»å¯èƒ½è€ƒè™‘åˆ°ä»»ä½•æ“ä½œçš„è¯­ä¹‰ã€‚MLIR é€šè¿‡å…è®¸æ“ä½œè¯­ä¹‰ä½¿ç”¨ç‰¹æ€§ (Traits) å’Œæ¥å£ (Interfaces) è¿›è¡ŒæŠ½è±¡æè¿°ï¼Œè§£å†³äº†è¿™ä¸€å¤æ‚æ€§ï¼Œä»è€Œä½¿è½¬æ¢èƒ½å¤Ÿæ›´é€šç”¨åœ°æ“ä½œè¿™äº›æ“ä½œã€‚ç‰¹æ€§é€šå¸¸æè¿°äº†å¯¹æœ‰æ•ˆä¸­é—´è¡¨ç¤º (IR) çš„éªŒè¯çº¦æŸï¼Œä»è€Œèƒ½å¤Ÿæ•è·å¹¶æ£€æŸ¥å¤æ‚çš„ä¸å˜é‡ã€‚ï¼ˆå‚è§ Op vs Operationï¼‰ MLIR çš„ä¸€ä¸ªæ˜æ˜¾åº”ç”¨æ˜¯è¡¨ç¤ºåŸºäºé™æ€å•èµ‹å€¼å½¢å¼ (SSA) çš„ä¸­é—´è¡¨ç¤º (IR)ï¼Œå¦‚ LLVM æ ¸å¿ƒ IRï¼Œä½¿ç”¨é€‚å½“çš„æ“ä½œç±»å‹æ¥å®šä¹‰æ¨¡å—ã€å‡½æ•°ã€åˆ†æ”¯ã€å†…å­˜åˆ†é…å’ŒéªŒè¯çº¦æŸï¼Œä»¥ç¡®ä¿ SSA ä¸»å¯¼æ€§ (Dominance) å±æ€§ã€‚MLIR åŒ…å«äº†ä¸€ç»„å®šä¹‰äº†è¿™äº›ç»“æ„çš„æ–¹è¨€ (Dialects)ã€‚ç„¶è€Œï¼ŒMLIR çš„è®¾è®¡è¶³å¤Ÿé€šç”¨ï¼Œä¹Ÿå¯ä»¥è¡¨ç¤ºå…¶ä»–ç±»ä¼¼ç¼–è¯‘å™¨çš„æ•°æ®ç»“æ„ï¼Œä¾‹å¦‚è¯­è¨€å‰ç«¯ä¸­çš„æŠ½è±¡è¯­æ³•æ ‘ã€ç›®æ ‡ç‰¹å®šåç«¯ä¸­ç”Ÿæˆçš„æŒ‡ä»¤æˆ–é«˜çº§ç»¼åˆå·¥å…·ä¸­çš„ç”µè·¯ã€‚ text å…³äºMLIRåŸºæœ¬æ¨¡å—å­¦ä¹ è¿‡ç¨‹å¦‚ä¸‹ï¼š Dialect, Attribute, Type, Operationï¼›æƒ³è±¡å¦‚æœè‡ªå·±å»å®ç°ï¼Œè¯¥æ€ä¹ˆè®¾è®¡ç±»ï¼› DialectConversionï¼›æƒ³è±¡åœ¨è‡ªå·±å®ç°çš„å‰å››ä¸ªæ¨¡å—ä¸Šï¼Œå¦‚ä½•å®ç°DialectConversionï¼› Interface, Constraint, Traitï¼›åŒæ ·ï¼Œæƒ³è±¡è‡ªå·±ä¼šæ€ä¹ˆå¢åŠ è¿™äº›åŠŸèƒ½ï¼› Transformation, Concalizationï¼› Region, Blockï¼šåŸºäº1. è®¾è®¡çš„Operationï¼Œä»¥åŠ4. å¢åŠ çš„Transformationï¼Œæƒ³è±¡å¦‚ä½•å¯¹Operationè¿›è¡ŒæŠ½è±¡ï¼Œæå–å‡ºRegionå’ŒBlockçš„æ¦‚å¿µï¼› Passï¼› æœ€åæ‰æ˜¯ODSå’ŒDRRã€‚ MLIRä¸­Dialectsåˆ†ç±»åŠå…³è” OpenXLA openxla An open ecosystem of performant, portable, and extensible machine learning (ML) infrastructure components that simplify ML development by defragmenting the tools between frontend frameworks and hardware backends. Built by industry leaders in AI modeling, software, and hardware. ä¸€ä¸ªç”±é«˜æ€§èƒ½ã€å¯ç§»æ¤å’Œå¯æ‰©å±•çš„æœºå™¨å­¦ä¹  (ML) åŸºç¡€è®¾æ–½ç»„ä»¶ç»„æˆçš„å¼€æ”¾ç”Ÿæ€ç³»ç»Ÿï¼Œå¯é€šè¿‡å¯¹å‰ç«¯æ¡†æ¶å’Œç¡¬ä»¶åç«¯ä¹‹é—´çš„å·¥å…·è¿›è¡Œç¢ç‰‡æ•´ç†æ¥ç®€åŒ– ML å¼€å‘ã€‚ç”± AI å»ºæ¨¡ã€è½¯ä»¶å’Œç¡¬ä»¶é¢†åŸŸçš„è¡Œä¸šé¢†å¯¼è€…æ„å»ºã€‚ XLA XLA (Accelerated Linear Algebra) is an open source compiler for machine learning. The XLA compiler takes models from popular frameworks such as PyTorch, TensorFlow, and JAX, and optimizes the models for high-performance execution across different hardware platforms including GPUs, CPUs, and ML accelerators. XLAï¼ˆåŠ é€Ÿçº¿æ€§ä»£æ•°ï¼‰æ˜¯ä¸€ä¸ªç”¨äºæœºå™¨å­¦ä¹ çš„å¼€æºç¼–è¯‘å™¨ã€‚ XLA ç¼–è¯‘å™¨é‡‡ç”¨æ¥è‡ª PyTorchã€TensorFlow å’Œ JAX ç­‰æµè¡Œæ¡†æ¶çš„æ¨¡å‹ï¼Œå¹¶ä¼˜åŒ–æ¨¡å‹ï¼Œä»¥ä¾¿åœ¨ä¸åŒçš„ç¡¬ä»¶å¹³å°ï¼ˆåŒ…æ‹¬ GPUã€CPU å’Œ ML åŠ é€Ÿå™¨ï¼‰ä¸Šå®ç°é«˜æ€§èƒ½æ‰§è¡Œã€‚ Key benefits ä¸»è¦ä¼˜ç‚¹ Build anywhere : XLA is already integrated into leading ML frameworks such as TensorFlow, PyTorch, and JAX. éšå¤„æ„å»ºï¼šXLA å·²é›†æˆåˆ°é¢†å…ˆçš„ ML æ¡†æ¶ä¸­ï¼Œä¾‹å¦‚ TensorFlowã€PyTorch å’Œ JAXã€‚ Run anywhere : It supports various backends including GPUs, CPUs, and ML accelerators, and includes a pluggable infrastructure to add support for more. éšå¤„è¿è¡Œï¼šå®ƒæ”¯æŒå„ç§åç«¯ï¼ŒåŒ…æ‹¬ GPUã€CPU å’Œ ML åŠ é€Ÿå™¨ï¼Œå¹¶åŒ…å«å¯æ’æ‹”åŸºç¡€è®¾æ–½ä»¥å¢åŠ å¯¹æ›´å¤šåç«¯çš„æ”¯æŒã€‚ Maximize and scale performance : It optimizes a model's performance with production-tested optimization passes and automated partitioning for model parallelism. æœ€å¤§åŒ–å’Œæ‰©å±•æ€§èƒ½ï¼šå®ƒé€šè¿‡ç»è¿‡ç”Ÿäº§æµ‹è¯•çš„ä¼˜åŒ–è¿‡ç¨‹å’Œæ¨¡å‹å¹¶è¡Œæ€§çš„è‡ªåŠ¨åˆ†åŒºæ¥ä¼˜åŒ–æ¨¡å‹çš„æ€§èƒ½ã€‚ Eliminate complexity : It leverages the power of MLIR to bring the best capabilities into a single compiler toolchain, so you don't have to manage a range of domain-specific compilers. æ¶ˆé™¤å¤æ‚æ€§ï¼šå®ƒåˆ©ç”¨äº† MLIRå°†æœ€ä½³åŠŸèƒ½å¼•å…¥å•ä¸ªç¼–è¯‘å™¨å·¥å…·é“¾ï¼Œå› æ­¤æ‚¨æ— éœ€ç®¡ç†ä¸€ç³»åˆ—ç‰¹å®šäºåŸŸçš„ç¼–è¯‘å™¨ã€‚ Future ready : As an open source project, built through a collaboration of leading ML hardware and software vendors, XLA is designed to operate at the cutting-edge of the ML industry. é¢å‘æœªæ¥ï¼šä½œä¸ºä¸€ä¸ªå¼€æºé¡¹ç›®ï¼Œé€šè¿‡é¢†å…ˆçš„ ML ç¡¬ä»¶å’Œè½¯ä»¶ä¾›åº”å•†çš„åˆä½œæ„å»ºï¼ŒXLA æ—¨åœ¨åœ¨ ML è¡Œä¸šçš„å‰æ²¿è¿è¡Œã€‚ StableHLO StableHLO is an operation set for high-level operations (HLO) in machine learning (ML) models. Essentially, it's a portability layer between different ML frameworks and ML compilers: ML frameworks that produce StableHLO programs are compatible with ML compilers that consume StableHLO programs. StableHLO æ˜¯æœºå™¨å­¦ä¹  (ML) æ¨¡å‹ä¸­é«˜çº§æ“ä½œ (HLO) çš„æ“ä½œé›†ã€‚æœ¬è´¨ä¸Šï¼Œå®ƒæ˜¯ä¸åŒ ML æ¡†æ¶å’Œ ML ç¼–è¯‘å™¨ä¹‹é—´çš„å¯ç§»æ¤å±‚ï¼šç”Ÿæˆ StableHLO ç¨‹åºçš„ ML æ¡†æ¶ä¸ä½¿ç”¨ StableHLO ç¨‹åºçš„ ML ç¼–è¯‘å™¨å…¼å®¹ã€‚ Shardy Shardy is an MLIR-based tensor partitioning system for all dialects. Built from the collaboration of both the GSPMD and PartIR teams, it incorporates the best of both systems, and the shared experience of both teams and users. Shardy æ˜¯ä¸€ä¸ªåŸºäº MLIR çš„å¼ é‡åˆ’åˆ†ç³»ç»Ÿï¼Œé€‚ç”¨äºæ‰€æœ‰æ–¹è¨€ã€‚å®ƒç”± GSPMD å’Œ PartIR å›¢é˜Ÿåˆä½œæ„å»ºï¼Œèåˆäº†ä¸¤ä¸ªç³»ç»Ÿçš„ä¼˜ç‚¹ä»¥åŠå›¢é˜Ÿå’Œç”¨æˆ·çš„å…±äº«ä½“éªŒã€‚ PJRT PJRT is a hardware and framework independent interface for ML compilers and runtimes. It is currently included with the XLA distribution. See the XLA GitHub and documentation for more information on how to use and integrate PJRT. PJRT æ˜¯ç”¨äº ML ç¼–è¯‘å™¨å’Œè¿è¡Œæ—¶çš„ç‹¬ç«‹äºç¡¬ä»¶å’Œæ¡†æ¶çš„æ¥å£ã€‚ç›®å‰å®ƒåŒ…å«åœ¨ XLA å‘è¡Œç‰ˆä¸­ã€‚æœ‰å…³å¦‚ä½•ä½¿ç”¨å’Œé›†æˆ PJRT çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… XLA GitHub å’Œæ–‡æ¡£ã€‚ TF(TensorFlow) Dialect This dialect maps to TensorFlow operations. è¯¥æ–¹è¨€æ˜ å°„åˆ° TensorFlow æ“ä½œã€‚ Invariants: ä¸å˜é‡ï¼š All values are of Tensor type (in particular, scalars are represented using zero-dimensional tensors); æ‰€æœ‰å€¼éƒ½æ˜¯ Tensor ç±»å‹ï¼ˆç‰¹åˆ«æ˜¯æ ‡é‡ä½¿ç”¨é›¶ç»´å¼ é‡è¡¨ç¤ºï¼‰ï¼› TODO: Make invariants more structured so that we can reference them in ops.TODOï¼š ä½¿ä¸å˜é‡æ›´åŠ ç»“æ„åŒ–ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥åœ¨æ“ä½œä¸­å¼•ç”¨å®ƒä»¬ã€‚ "},"Learn/LearnMLIR/PIR.html":{"url":"Learn/LearnMLIR/PIR.html","title":"PIR","keywords":"","body":"PIR PIR åŸºæœ¬æ¦‚å¿µå’Œå¼€å‘Â¶ åœ¨ 3.0 ç‰ˆæœ¬ä¸‹ï¼Œé£æ¡¨ç ”å‘äº†åŸºäº MLIR èŒƒå¼çš„æ–°ä¸€ä»£ä¸­é—´è¡¨ç¤ºæŠ€æœ¯ï¼Œå³ Paddle IRï¼ˆä¸‹ç®€ç§° PIRï¼‰ã€‚è¿™é¡¹æŠ€æœ¯å¯¹åº•å±‚çš„æ ¸å¿ƒæ¦‚å¿µå¦‚ Operationã€Attribute ç­‰è¿›è¡Œäº†ç³»ç»Ÿæ€§çš„æŠ½è±¡ï¼Œä¸ºå¼€å‘è€…æä¾›äº†çµæ´»çš„åŸºç¡€ç»„ä»¶ï¼›åŒæ—¶ï¼Œé€šè¿‡å¼•å…¥ Dialect è¿™ä¸€æ¦‚å¿µï¼Œé£æ¡¨èƒ½å¤Ÿå…¨é¢ã€åˆ†å±‚æ¬¡ç®¡ç†æ¡†æ¶å„æ¨¡å—å¯¹ä¸­é—´è¡¨ç¤ºçš„éœ€æ±‚ï¼Œå¹¶æ”¯æŒå¼€å‘è€…æ ¹æ®éœ€æ±‚å®šåˆ¶åŒ–æ‰©å±• Dialectï¼Œæ˜¾è‘—æå‡äº†æ¡†æ¶çš„æ‰©å±•æ€§ã€‚PIR éµå¾ª SSAï¼ˆå³ Static Single Assignmentï¼‰åŸåˆ™ï¼Œç»Ÿä¸€äº†é¡¶å±‚ç»“æ„ï¼Œå®ç°â€œç®—å­é¡ºåºæ€§â€å’Œâ€œè®¡ç®—å›¾è¯­ä¹‰â€çš„å…¼å®¹è¡¨ç¤ºã€‚æ­¤å¤–ï¼ŒPIR è¿˜æä¾›äº†æ›´åŠ ç®€æ´ã€ä½æˆæœ¬çš„ Pass å¼€å‘ä½“ç³»ï¼Œå¹¶å†…ç½®äº†ä¸€ç³»åˆ—ä¸°å¯Œä¸”åŠŸèƒ½å®Œå¤‡çš„ Pass ä¼˜åŒ–ç­–ç•¥ï¼Œä¸ºå¤§æ¨¡å‹çš„æè‡´æ€§èƒ½ä¼˜åŒ–æä¾›äº†å¼ºæœ‰åŠ›æ”¯æ’‘ã€‚ åœ¨æ·±åº¦å­¦ä¹ æ¡†æ¶ IR æ¦‚å¿µä¸­ï¼Œã€Œé¡ºåºæ€§ã€å’Œã€Œå›¾è¯­ä¹‰ã€æ˜¯ä¸¤ä¸ªéå¸¸é«˜é¢‘å¸¸ç”¨çš„æ¦‚å¿µã€‚æ—§çš„ä¸­é—´è¡¨ç¤ºä½“ç³»ç”±ã€Œé¡ºåºæ€§ã€ProgramDesc å’Œã€Œå›¾è¯­ä¹‰ã€Graph ä¸¤ä¸ªæ ¸å¿ƒç±»å…±åŒæ‰¿è½½ã€‚ç”¨æˆ·åœ¨é™æ€å›¾ API æˆ–è€…åŠ¨è½¬é™æ¨¡å—ä¸‹ï¼Œäº§ç”Ÿçš„ä¸­é—´è¡¨ç¤ºæ˜¯ Op-by-Op çš„ Programï¼Œå¦‚æœè¦åº”ç”¨æ›´é«˜å±‚é¢çš„ä¼˜åŒ–ç­–ç•¥ï¼ˆæ¯”å¦‚ç®—å­èåˆã€inplace ç­–ç•¥ã€å‰ªæç­‰ï¼‰ï¼Œæ¡†æ¶ä¼šå°†ç”± Program æ„é€ å‡º Graphï¼Œå…¶ç”±æ•°æ®èŠ‚ç‚¹ã€ç®—å­èŠ‚ç‚¹å’Œå½¼æ­¤å…³è”çš„è¾¹æ„æˆã€‚ åœ¨æ–°çš„ Paddle IR ä¸­ï¼Œé£æ¡¨åœ¨åº•å±‚æŠ½è±¡äº†ä¸€å¥—é«˜åº¦å¯æ‰©å±•çš„åŸºç¡€ç»„ä»¶ï¼ŒåŒ…æ‹¬ Typeã€Attrbuteã€Opã€Trait å’Œ Interfaceï¼Œå¹¶å¼•å…¥äº† Dialect çš„æ¦‚å¿µï¼Œæ”¯æŒå¼€å‘è€…çµæ´»æ‰©å±•ã€è‡ªç”±å®šåˆ¶ï¼Œæä¾›äº†å®Œå¤‡é²é‚¦çš„è¯­ä¹‰è¡¨è¾¾èƒ½åŠ›ï¼›åœ¨æ¨¡å‹è¡¨ç¤ºå±‚ï¼Œé€šè¿‡å¤š Dialect æ¨¡å—åŒ–ç®¡ç†ï¼Œç»Ÿä¸€å¤šç«¯è¡¨ç¤ºï¼Œå®ç°äº†è®­æ¨ä¸€ä½“çš„å…¨æ¶æ„ç»Ÿä¸€è¡¨ç¤ºï¼Œæ— ç¼è¡”æ¥ç»„åˆç®—å­å’Œç¼–è¯‘å™¨ï¼Œæ”¯æŒè‡ªåŠ¨ä¼˜åŒ–å’Œå¤šç¡¬ä»¶é€‚é…ï¼›åœ¨å›¾å˜æ¢å±‚ï¼Œé€šè¿‡ç»Ÿä¸€åº•å±‚æ¨¡å—ï¼Œç®€åŒ–åŸºç¡€æ¦‚å¿µï¼Œå‘ç”¨æˆ·æä¾›äº†ä½æˆæœ¬å¼€å‘ã€æ˜“ç”¨é«˜æ€§èƒ½ã€ä¸°å¯Œå¯æ’æ‹”çš„ Pass ä¼˜åŒ–æœºåˆ¶ã€‚ é£æ¡¨çš„æ–°ä¸€ä»£çš„ IR è¡¨ç¤ºåšæŒ SSAï¼ˆé™æ€å•èµ‹å€¼ï¼‰åŸåˆ™ï¼Œæ¨¡å‹ç­‰ä»·äºä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ã€‚å¹¶ä»¥ Valueã€Operation å¯¹è®¡ç®—å›¾è¿›è¡ŒæŠ½è±¡ï¼Œ Operation ä¸ºèŠ‚ç‚¹ï¼ŒValue ä¸ºè¾¹ã€‚ Operation è¡¨ç¤ºè®¡ç®—å›¾ä¸­çš„èŠ‚ç‚¹ï¼šä¸€ä¸ª Operation è¡¨ç¤ºä¸€ä¸ªç®—å­ï¼Œå®ƒé‡Œé¢åŒ…å«äº†é›¶ä¸ªæˆ–å¤šä¸ª Regionï¼›Region è¡¨ç¤ºä¸€ä¸ªé—­åŒ…ï¼Œå®ƒé‡Œé¢åŒ…å«äº†é›¶ä¸ªæˆ–å¤šä¸ª Blockï¼›Block è¡¨ç¤ºä¸€ä¸ªç¬¦åˆ SSA çš„åŸºæœ¬å—ï¼Œé‡Œé¢åŒ…å«äº†é›¶ä¸ªæˆ–å¤šä¸ª Operationï¼›ä¸‰è€…å¾ªç¯åµŒå¥—ï¼Œå¯ä»¥å®ç°ä»»æ„å¤æ‚çš„è¯­æ³•ç»“æ„ Value è¡¨ç¤ºè®¡ç®—å›¾ä¸­çš„æœ‰å‘è¾¹ï¼šç”¨æ¥å°†ä¸¤ä¸ª Operaton å…³è”èµ·æ¥ï¼Œæè¿°äº†ç¨‹åºä¸­çš„ UD é“¾ï¼ˆå³ Use-Define é“¾ï¼‰ï¼›OpResult è¡¨ç¤ºå®šä¹‰ç«¯ï¼Œå®šä¹‰äº†ä¸€ä¸ª Valueï¼ŒOpOperand è¡¨ç¤ºä½¿ç”¨ç«¯ï¼Œæè¿°äº†å¯¹ä¸€ä¸ª Value çš„ä½¿ç”¨ã€‚ äºŒã€è®¾è®¡åˆè¡·Â¶ è®¡ç®—å›¾ä¸­é—´è¡¨ç¤ºï¼ˆIntermediate Representationï¼Œå³ IRï¼‰æ˜¯æ·±åº¦å­¦ä¹ æ¡†æ¶æ€§èƒ½ä¼˜åŒ–ã€æ¨ç†éƒ¨ç½²ã€ç¼–è¯‘å™¨ç­‰æ–¹å‘çš„é‡è¦åŸºçŸ³ã€‚è¿‘äº›å¹´æ¥ï¼Œè¶Šæ¥è¶Šå¤šçš„æ¡†æ¶å’Œç ”ç©¶è€…å°†ç¼–è¯‘å™¨æŠ€æœ¯å¼•å…¥åˆ°æ·±åº¦å­¦ä¹ çš„ç¥ç»ç½‘ç»œæ¨¡å‹ä¼˜åŒ–ä¸­ï¼Œå¹¶åœ¨æ­¤åŸºç¡€ä¸Šå€ŸåŠ©ç¼–è¯‘å™¨çš„ç†å¿µã€æŠ€æœ¯å’Œå·¥å…·å¯¹ç¥ç»ç½‘ç»œè¿›è¡Œè‡ªåŠ¨ä¼˜åŒ–å’Œä»£ç ç”Ÿæˆã€‚é£æ¡¨å†å²ä¸Šåœ¨æ¶æ„å±‚é¢å¹¶å­˜ç€å¤šå¥—ä¸åŒçš„ä¸­é—´è¡¨ç¤ºä½“ç³»ï¼Œå…¶è¡¨è¾¾èƒ½åŠ›å„ä¸ç›¸åŒã€Pass å¼€å‘ç»´æŠ¤æˆæœ¬è¾ƒé«˜ï¼Œä»£ç å¤ç”¨æ€§è¾ƒå·®ï¼Œç¼ºä¹ç»Ÿä¸€è§„èŒƒï¼Œå­˜åœ¨ä¸¥é‡çš„æ¡†æ¶ç¨³å®šæ€§é—®é¢˜ã€‚ "},"Learn/LearnMocCUDA/CUDA-Wrap.html":{"url":"Learn/LearnMocCUDA/CUDA-Wrap.html","title":"CUDA-Wrap","keywords":"","body":"Kimi è¿™ä¸¤ä¸ªCæ–‡ä»¶ï¼ˆpassthrough.h.txt å’Œ passthrough.c.txtï¼‰æ„æˆäº†ä¸€ä¸ªåä¸º cudawrap çš„åº“ï¼Œå®ƒçš„ä½œç”¨æ˜¯æä¾›ä¸€ä¸ªå°è£…å±‚ï¼Œç”¨äºåŠ è½½å’Œè®¿é—® CUDA ç›¸å…³çš„åº“ï¼ˆå¦‚ CUDA Runtimeã€cuDNN å’Œ cuBLASï¼‰ä¸­çš„å‡½æ•°ã€‚è¿™ä¸ªå°è£…å±‚å…è®¸ç¨‹åºåœ¨è¿è¡Œæ—¶åŠ¨æ€åœ°åŠ è½½è¿™äº›åº“ï¼Œå¹¶æä¾›äº†ä¸€ç§æœºåˆ¶æ¥è°ƒç”¨è¿™äº›åº“ä¸­çš„å‡½æ•°ã€‚ä»¥ä¸‹æ˜¯å¯¹è¿™ä¸¤ä¸ªæ–‡ä»¶çš„è¯¦ç»†åˆ†æï¼š passthrough.h æ–‡ä»¶ è¿™ä¸ªå¤´æ–‡ä»¶å®šä¹‰äº† cudawrap åº“çš„æ•°æ®ç»“æ„å’Œå®ï¼Œç”¨äºå°è£…å¯¹ CUDA ç›¸å…³åº“çš„è°ƒç”¨ã€‚ æ•°æ®ç»“æ„å®šä¹‰ï¼š entry_tï¼šä¸€ä¸ªç»“æ„ä½“ï¼ŒåŒ…å«ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆ fn_ptr å’Œä¸€ä¸ªå‡½æ•°å nameï¼Œç”¨äºå­˜å‚¨åº“ä¸­å‡½æ•°çš„åœ°å€å’Œåç§°ã€‚ å®å®šä¹‰ï¼š ENTER å’Œ LEAVEï¼šç”¨äºè°ƒè¯•ç›®çš„ï¼Œè®°å½•å‡½æ•°çš„è¿›å…¥å’Œç¦»å¼€æ—¶é—´ï¼Œä»¥åŠè®¡ç®—å‡½æ•°æ‰§è¡Œæ—¶é—´ã€‚ TIME_GEMM_START å’Œ TIME_GEMM_STOPï¼šç”¨äºæ€§èƒ½åˆ†æï¼Œè®°å½•å’Œè®¡ç®— GEMMï¼ˆGeneral Matrix Multiplyï¼‰æ“ä½œçš„å¼€å§‹å’Œç»“æŸæ—¶é—´ã€‚ CUDART_ENTRY_ENUMã€CUDNN_ENTRY_ENUM å’Œ CUBLAS_ENTRY_ENUMï¼šå®ï¼Œç”¨äºç”Ÿæˆæšä¸¾å€¼ï¼Œä»£è¡¨ä¸åŒçš„åº“å‡½æ•°ã€‚ CUDART_FIND_ENTRYã€CUDNN_FIND_ENTRY å’Œ CUBLAS_FIND_ENTRYï¼šå®ï¼Œç”¨äºæŸ¥æ‰¾ç‰¹å®šå‡½æ•°çš„å…¥å£ã€‚ REAL_CUDA_RT_API_CALLã€REAL_CUDNN_CALL å’Œ REAL_CUBLAS_CALLï¼šå®ï¼Œç”¨äºå®é™…è°ƒç”¨åº“ä¸­çš„å‡½æ•°ã€‚ æšä¸¾å®šä¹‰ï¼š cudart_entry_enum_tã€cudnn_entry_enum_t å’Œ cublas_entry_enum_tï¼šæšä¸¾ç±»å‹ï¼Œåˆ—å‡ºäº†æ‰€æœ‰éœ€è¦å°è£…çš„ CUDA Runtimeã€cuDNN å’Œ cuBLAS å‡½æ•°ã€‚ passthrough.c æ–‡ä»¶ è¿™ä¸ªæºæ–‡ä»¶å®ç°äº† passthrough.h ä¸­å®šä¹‰çš„æ•°æ®ç»“æ„å’Œå‡½æ•°ã€‚ å…¨å±€å˜é‡åˆå§‹åŒ–ï¼š _cudart_inited_ã€_cudnn_inited_ å’Œ _cublas_inited_ï¼šç”¨äºæ ‡è®°å¯¹åº”çš„åº“æ˜¯å¦å·²ç»åˆå§‹åŒ–ã€‚ åº“å‡½æ•°å…¥å£æ•°ç»„ï¼š cudart_lib_entryã€cudnn_lib_entry å’Œ cublas_lib_entryï¼šæ•°ç»„ï¼Œå­˜å‚¨äº†å¯¹åº”åº“çš„æ‰€æœ‰å‡½æ•°å…¥å£ã€‚ åŠ è½½åº“å‡½æ•°ï¼š load_cudart_libã€load_cudnn_lib å’Œ load_cublas_libï¼šå‡½æ•°ï¼Œç”¨äºåŠ¨æ€åŠ è½½ CUDA Runtimeã€cuDNN å’Œ cuBLAS åº“ï¼Œå¹¶æŸ¥æ‰¾æ‰€éœ€çš„å‡½æ•°åœ°å€ã€‚ åˆå§‹åŒ–æ£€æŸ¥å‡½æ•°ï¼š cudart_lib_initedã€cudnn_lib_inited å’Œ cublas_lib_initedï¼šå‡½æ•°ï¼Œç”¨äºæ£€æŸ¥å¯¹åº”çš„åº“æ˜¯å¦å·²ç»åˆå§‹åŒ–ã€‚ æ€»ç»“ cudawrap åº“çš„ä¸»è¦ä½œç”¨æ˜¯æä¾›ä¸€ä¸ªä¸­é—´å±‚ï¼Œä½¿å¾—åº”ç”¨ç¨‹åºå¯ä»¥æ›´åŠ çµæ´»åœ°ä½¿ç”¨ CUDA ç›¸å…³çš„åº“ã€‚é€šè¿‡åŠ¨æ€åŠ è½½å’ŒæŸ¥æ‰¾å‡½æ•°ï¼Œå®ƒå…è®¸åº”ç”¨ç¨‹åºåœ¨ä¸åŒçš„ç¯å¢ƒï¼ˆå¦‚ä¸åŒçš„ CUDA ç‰ˆæœ¬æˆ–é…ç½®ï¼‰ä¸‹è¿è¡Œï¼Œè€Œæ— éœ€é‡æ–°ç¼–è¯‘ã€‚æ­¤å¤–ï¼Œå®ƒè¿˜æä¾›äº†æ€§èƒ½åˆ†æå’Œè°ƒè¯•æ”¯æŒï¼Œå¸®åŠ©å¼€å‘è€…ä¼˜åŒ–å’Œè°ƒè¯• CUDA ç›¸å…³çš„ä»£ç ã€‚ ä½¿ç”¨æ–¹æ³• è¦ä½¿ç”¨ cudawrap åº“ï¼Œä½ éœ€è¦æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤æ“ä½œï¼š åŒ…å«å¤´æ–‡ä»¶ï¼šåœ¨ä½ çš„ C æˆ– C++ æºæ–‡ä»¶ä¸­åŒ…å« passthrough.h å¤´æ–‡ä»¶ã€‚ é“¾æ¥åº“æ–‡ä»¶ï¼šåœ¨ç¼–è¯‘ä½ çš„ç¨‹åºæ—¶ï¼Œç¡®ä¿é“¾æ¥äº† cudawrap åº“ä»¥åŠå®ƒä¾èµ–çš„ CUDA ç›¸å…³åº“ï¼ˆå¦‚ libcudart.so, libcudnn.so, libcublas.soï¼‰ã€‚ åˆå§‹åŒ–åº“ï¼šåœ¨ç¨‹åºä¸­è°ƒç”¨ load_cudart_lib(), load_cudnn_lib(), å’Œ load_cublas_lib() å‡½æ•°æ¥åŠ è½½å¯¹åº”çš„ CUDA åº“ï¼Œå¹¶åˆå§‹åŒ– cudawrap åº“ã€‚ è°ƒç”¨å°è£…å‡½æ•°ï¼šä½¿ç”¨ cudawrap æä¾›çš„å®æ¥è°ƒç”¨ CUDA åº“ä¸­çš„å‡½æ•°ã€‚ ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œå±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ cudawrap åº“æ¥è°ƒç”¨ CUDA Runtime API ä¸­çš„ cudaMalloc å’Œ cudaFree å‡½æ•°ï¼š #include \"passthrough.h\" int main() { // åˆå§‹åŒ– CUDA è¿è¡Œæ—¶åº“ if (load_cudart_lib() != 0) { fprintf(stderr, \"Failed to load CUDA runtime library.\\n\"); return -1; } // åˆ†é… CUDA è®¾å¤‡å†…å­˜ void *devPtr; size_t size = 1024 * 1024; // åˆ†é… 1MB å†…å­˜ REAL_CUDA_RT_API_CALL(cudart_lib_entry, , cudaMalloc, (void**)&devPtr, size); if (devPtr == NULL) { fprintf(stderr, \"Failed to allocate device memory.\\n\"); // è¿™é‡Œåº”è¯¥è¿›è¡Œæ¸…ç†å·¥ä½œ return -1; } // ... åœ¨è¿™é‡Œè¿›è¡Œå…¶ä»– CUDA æ“ä½œ ... // é‡Šæ”¾ CUDA è®¾å¤‡å†…å­˜ REAL_CUDA_RT_API_CALL(cudart_lib_entry, , cudaFree, (devPtr)); // æ¸…ç†å·¥ä½œï¼Œå…³é—­ç¨‹åº return 0; } åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆè°ƒç”¨ load_cudart_lib() æ¥åŠ è½½ CUDA è¿è¡Œæ—¶åº“å¹¶åˆå§‹åŒ– cudawrap åº“ã€‚ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨ REAL_CUDA_RT_API_CALL å®æ¥å°è£…å¯¹ cudaMalloc å’Œ cudaFree å‡½æ•°çš„è°ƒç”¨ã€‚è¿™ä¸ªå®ä¼šæŸ¥æ‰¾å¯¹åº”çš„å‡½æ•°å…¥å£ï¼Œå¹¶æ‰§è¡Œå‡½æ•°è°ƒç”¨ã€‚ è¯·æ³¨æ„ï¼Œè¿™ä¸ªä¾‹å­å‡è®¾ cudawrap åº“å·²ç»è¢«æ­£ç¡®ç¼–è¯‘å¹¶é“¾æ¥åˆ°ä½ çš„ç¨‹åºä¸­ã€‚åœ¨å®é™…ä½¿ç”¨ä¸­ï¼Œä½ å¯èƒ½éœ€è¦æ ¹æ®ä½ çš„ç¯å¢ƒå’Œç¼–è¯‘å™¨æ¥è°ƒæ•´ç¼–è¯‘å’Œé“¾æ¥é€‰é¡¹ã€‚æ­¤å¤–ï¼Œé”™è¯¯å¤„ç†å’Œèµ„æºç®¡ç†ï¼ˆå¦‚å†…å­˜æ³„æ¼ï¼‰ä¹Ÿæ˜¯å®é™…ç¼–ç¨‹ä¸­éœ€è¦è€ƒè™‘çš„é‡è¦æ–¹é¢ã€‚ Hijack CUBLAS hijack_cublas æ˜¯ä¸€ä¸ªåº“ï¼Œå®ƒæä¾›äº†å¯¹ cuBLAS åº“å‡½æ•°çš„å°è£…å’Œå¯èƒ½çš„æ›¿ä»£å®ç°ã€‚è¿™ä¸ªåº“çš„ç›®çš„æ˜¯åœ¨ä¸åŒçš„ç¯å¢ƒä¸‹ï¼Œå¦‚æ¨¡æ‹Ÿ CUDA ç¯å¢ƒæˆ–åœ¨ä¸æ”¯æŒ CUDA çš„ç³»ç»Ÿä¸Šï¼Œæä¾› cuBLAS å‡½æ•°çš„æ¥å£ã€‚ä»¥ä¸‹æ˜¯å¯¹ hijack_cublas çš„è¿›ä¸€æ­¥åˆ†æï¼š hijack_cublas.h æ–‡ä»¶ è¿™ä¸ªå¤´æ–‡ä»¶å®šä¹‰äº† hijack_cublas åº“çš„ä¸»è¦ç»“æ„å’Œæšä¸¾ç±»å‹ï¼Œä»¥åŠå‡½æ•°åŸå‹ã€‚ æšä¸¾ç±»å‹ï¼š cublasStatus_tï¼šå®šä¹‰äº† cuBLAS API å¯èƒ½è¿”å›çš„çŠ¶æ€ç ã€‚ cublasOperation_tï¼šå®šä¹‰äº†çŸ©é˜µæ“ä½œç±»å‹ï¼Œå¦‚ CUBLAS_OP_Nï¼ˆæ— è½¬ç½®ï¼‰ã€CUBLAS_OP_Tï¼ˆè½¬ç½®ï¼‰å’Œ CUBLAS_OP_Cï¼ˆå…±è½­è½¬ç½®ï¼‰ã€‚ ç»“æ„ä½“å®šä¹‰ï¼š cublasContextï¼šå®šä¹‰äº†ä¸€ä¸ªç»“æ„ä½“ï¼ŒåŒ…å«ä¸€ä¸ªåˆå§‹åŒ–æ ‡å¿—å’Œä¸€ä¸ª CUDA æµã€‚ cublasHandle_tï¼šcublasContext ç»“æ„ä½“çš„æŒ‡é’ˆç±»å‹ï¼Œç”¨äºä½œä¸º cuBLAS åº“å‡½æ•°çš„ä¸Šä¸‹æ–‡å¥æŸ„ã€‚ å¤–éƒ¨å˜é‡å£°æ˜ï¼š cublas_entry[]ï¼šå£°æ˜äº†ä¸€ä¸ª entry_t ç±»å‹çš„æ•°ç»„ï¼Œç”¨äºå­˜å‚¨ cuBLAS åº“å‡½æ•°çš„å…¥å£ã€‚ å‡½æ•°ç±»å‹å®šä¹‰ï¼š cublas_sym_tï¼šå®šä¹‰äº†ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆç±»å‹ï¼ŒæŒ‡å‘ä¸€ä¸ªè¿”å› cublasStatus_t çš„å‡½æ•°ã€‚ hijack_cublas.c æ–‡ä»¶ è¿™ä¸ªæºæ–‡ä»¶å®ç°äº† hijack_cublas.h ä¸­å£°æ˜çš„å‡½æ•°ï¼Œæä¾›äº† cuBLAS å‡½æ•°çš„å…·ä½“å®ç°ã€‚ cuBLAS å‡½æ•°å®ç°ï¼š cublasCreate_v2ï¼šåˆ›å»ºä¸€ä¸ª cuBLAS ä¸Šä¸‹æ–‡ï¼ˆå¥æŸ„ï¼‰ã€‚ cublasDestroy_v2ï¼šé”€æ¯ä¸€ä¸ª cuBLAS ä¸Šä¸‹æ–‡ï¼ˆå¥æŸ„ï¼‰ã€‚ cublasSetStream_v2ï¼šè®¾ç½® cuBLAS ä¸Šä¸‹æ–‡çš„ CUDA æµã€‚ å¼‚æ­¥ GEMM å®ç°ï¼š cublasSgemm_async_fnï¼šä¸€ä¸ªå¼‚æ­¥æ‰§è¡Œ SGEMM æ“ä½œçš„å‡½æ•°ï¼Œå®ƒä½¿ç”¨ OpenMP è¿›è¡Œå¤šçº¿ç¨‹è®¡ç®—ã€‚ SGEMM å‡½æ•°å®ç°ï¼š cublasSgemm_v2ï¼šæ‰§è¡ŒçŸ©é˜µä¹˜æ³•æ“ä½œï¼ˆSGEMMï¼‰ã€‚è¿™ä¸ªå‡½æ•°æ ¹æ®ç¼–è¯‘æ—¶å®šä¹‰çš„æ¡ä»¶ï¼ˆå¦‚ USE_MocCUDA å’Œ USE_GCDï¼‰æ¥å†³å®šæ˜¯è°ƒç”¨çœŸå®çš„ cuBLAS å‡½æ•°è¿˜æ˜¯æ¨¡æ‹Ÿçš„å®ç°ã€‚ æ¡ä»¶ç¼–è¯‘ï¼š æ ¹æ®å®šä¹‰çš„å®ï¼ˆå¦‚ USE_MocCUDAã€USE_GCD ç­‰ï¼‰ï¼Œhijack_cublas å¯ä»¥é€‰æ‹©ä½¿ç”¨ä¸åŒçš„å®ç°ç­–ç•¥ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå®šä¹‰äº† USE_MocCUDAï¼Œåˆ™ä¼šä½¿ç”¨æ¨¡æ‹Ÿçš„ cuBLAS å®ç°ï¼Œè€Œä¸æ˜¯è°ƒç”¨çœŸå®çš„ CUDA å‡½æ•°ã€‚ è°ƒè¯•å’Œæ€§èƒ½åˆ†æï¼š æ–‡ä»¶ä¸­åŒ…å«äº† ENTER å’Œ LEAVE å®ï¼Œç”¨äºè°ƒè¯•å’Œæ€§èƒ½åˆ†æï¼Œè®°å½•å‡½æ•°çš„è¿›å…¥å’Œç¦»å¼€æ—¶é—´ã€‚ æ€»ç»“ hijack_cublas åº“çš„ä½œç”¨æ˜¯åœ¨ä¸å…·å¤‡å®Œæ•´ CUDA æ”¯æŒçš„ç¯å¢ƒä¸‹ï¼Œæä¾› cuBLAS åº“çš„æ¥å£å’Œå¯èƒ½çš„æ¨¡æ‹Ÿå®ç°ã€‚å®ƒå…è®¸å¼€å‘è€…åœ¨ç¼–å†™ä»£ç æ—¶ï¼Œä¸éœ€è¦å…³å¿ƒåç«¯æ˜¯çœŸå®çš„ CUDA ç¯å¢ƒè¿˜æ˜¯æ¨¡æ‹Ÿç¯å¢ƒï¼Œä»è€Œæé«˜äº†ä»£ç çš„å¯ç§»æ¤æ€§ã€‚æ­¤å¤–ï¼Œå®ƒè¿˜æä¾›äº†å¼‚æ­¥æ‰§è¡Œå’Œå¤šçº¿ç¨‹æ”¯æŒï¼Œä»¥ä¼˜åŒ–æ€§èƒ½ã€‚é€šè¿‡æ¡ä»¶ç¼–è¯‘ï¼Œhijack_cublas å¯ä»¥çµæ´»åœ°é€‚åº”ä¸åŒçš„ä½¿ç”¨åœºæ™¯å’Œéœ€æ±‚ã€‚ ChatGPT The provided C and header files implement a dynamic loader for CUDA libraries (libcudart, cudnn, and cublas) and a wrapper for their functionality. Here's a detailed breakdown: Purpose The main role of these files is to dynamically load CUDA libraries at runtime instead of linking them statically. This approach: Enables the use of CUDA functionalities without requiring the application to depend on specific versions of CUDA libraries during compilation. Provides a mechanism for runtime flexibility, allowing switching between different library versions. Facilitates debugging, logging, and performance tracking of library function calls. passthrough.c Analysis Key Features Dynamic Library Loading: Functions like dlopen() and dlsym() dynamically load the CUDA libraries and resolve symbols (function pointers). If the library or a specific function is not found, it emits errors and gracefully exits. Function Resolution: Arrays (cudart_lib_entry, cudnn_lib_entry, and cublas_lib_entry) store the function names and their resolved function pointers (fn_ptr). Functions like load_cudart_lib(), load_cudnn_lib(), and load_cublas_lib() populate these arrays. Initialization Flags: Static variables like _cudart_inited_, _cudnn_inited_, and _cublas_inited_ prevent redundant re-initialization. Error Handling: Robust error checking for missing libraries and functions. CUDA Libraries libcudart: Basic CUDA Runtime functionalities (e.g., cudaMalloc, cudaMemcpy). cudnn: Deep Neural Network primitives. cublas: Basic Linear Algebra operations. passthrough.h Analysis Structure Definitions entry_t: A structure for maintaining a function pointer (fn_ptr) and the corresponding function name (name). Wrapper Macros Function Wrapping: REAL_CUDA_RT_API_CALL, REAL_CUDNN_CALL, and REAL_CUBLAS_CALL resolve symbols and execute them. Example: A call to cudaMalloc() gets resolved dynamically using the corresponding function pointer. Logging and Debugging: ENTER and LEAVE macros log function entry and exit with execution timings, but only if compiled with DEBUG or FUNC_TIMINGS flags. TIME_GEMM_START and TIME_GEMM_STOP specifically measure performance of GEMM (General Matrix Multiplication) operations, crucial for BLAS and deep learning workloads. Enumerations Enumerates all supported library functions (CUDART_ENTRY_ENUM, CUDNN_ENTRY_ENUM, and CUBLAS_ENTRY_ENUM) for easy indexing in the arrays. Initialization Functions load_cudart_lib(), load_cudnn_lib(), and load_cublas_lib() are declared for library loading at runtime. Typical Workflow Initialization: A CUDA library (e.g., libcudart) is dynamically loaded when a function is called for the first time. Initialization flags ensure one-time setup. Function Execution: For example, a wrapped call to cudaMalloc() would: Resolve the function pointer via dlsym(). Execute the function through the resolved pointer. Debugging and Logging (Optional): Execution times and other statistics are logged if debugging macros are enabled. Role in CUDAWRAP These files act as the core implementation for a dynamic wrapper around CUDA libraries, suitable for environments where: Runtime Flexibility: The application can dynamically switch between different versions of CUDA libraries by setting paths via environment variables (SWITCHCUDART, SWITCHCUDNN, SWITCHCUBLAS). Debugging Support: Tracks performance and function calls without recompiling the CUDA libraries. Ease of Integration: Reduces compilation dependencies, making applications portable across systems with varying CUDA versions. Would you like to explore specific sections or use cases in more detail? How to use To use the CUDAWRAP library defined in the provided files, follow these steps. Here's a detailed explanation with an example of how to integrate it into a project and use its features. 1. Setting Up the Environment The CUDAWRAP library uses environment variables to dynamically load CUDA libraries. You need to set these variables to point to the correct library paths. For example: export SWITCHCUDART=/usr/local/cuda/lib64/libcudart.so export SWITCHCUDNN=/usr/local/cuda/lib64/libcudnn.so export SWITCHCUBLAS=/usr/local/cuda/lib64/libcublas.so If the environment variables are not set, the library defaults to paths like PATHTOCUDA_ROOT/lib64/libcudart.so. 2. Compilation You need to compile the passthrough.c and link it into your project. Use the following steps: Compile the passthrough.c: gcc -fPIC -c passthrough.c -o passthrough.o -ldl -fPIC: Generates position-independent code (necessary for shared libraries). -ldl: Links the dynamic loader library (dlopen, dlsym). Link the compiled object into your application: gcc main.c passthrough.o -o myapp -ldl 3. Example Code main.c â€“ Using CUDAWRAP to call CUDA functions. #include #include \"passthrough.h\" // Include the header int main() { // Step 1: Load the CUDA Runtime Library (libcudart) if (load_cudart_lib() != 0) { fprintf(stderr, \"Failed to load libcudart library!\\n\"); return 1; } // Step 2: Initialize CUDA int deviceCount = 0; // Dynamically call the cudaGetDeviceCount function typedef cudaError_t (*cudaGetDeviceCount_t)(int *); cudaGetDeviceCount_t cudaGetDeviceCount = (cudaGetDeviceCount_t)CUDART_FIND_ENTRY(cudart_lib_entry, cudaGetDeviceCount); if (cudaGetDeviceCount == NULL) { fprintf(stderr, \"Function cudaGetDeviceCount not found!\\n\"); return 1; } cudaError_t err = cudaGetDeviceCount(&deviceCount); if (err != cudaSuccess) { fprintf(stderr, \"CUDA Error: %s\\n\", cudaGetErrorString(err)); return 1; } printf(\"Number of CUDA devices: %d\\n\", deviceCount); // Step 3: Use another CUDA function void *devPtr; size_t size = 1024; typedef cudaError_t (*cudaMalloc_t)(void **, size_t); cudaMalloc_t cudaMalloc = (cudaMalloc_t)CUDART_FIND_ENTRY(cudart_lib_entry, cudaMalloc); if (cudaMalloc == NULL) { fprintf(stderr, \"Function cudaMalloc not found!\\n\"); return 1; } err = cudaMalloc(&devPtr, size); if (err != cudaSuccess) { fprintf(stderr, \"cudaMalloc failed: %s\\n\", cudaGetErrorString(err)); return 1; } printf(\"Successfully allocated %zu bytes on the device\\n\", size); // Cleanup (if necessary) typedef cudaError_t (*cudaFree_t)(void *); cudaFree_t cudaFree = (cudaFree_t)CUDART_FIND_ENTRY(cudart_lib_entry, cudaFree); if (cudaFree != NULL) { cudaFree(devPtr); } return 0; } 4. Explanation of Example Loading the Library: The load_cudart_lib() function dynamically loads the CUDA runtime library and populates cudart_lib_entry with function pointers. Finding a Function: Use CUDART_FIND_ENTRY macro to retrieve the pointer for the desired function (e.g., cudaGetDeviceCount, cudaMalloc). Calling the Function: Cast the function pointer to the appropriate type and call it like a regular function. Handling Errors: Check for NULL function pointers and handle errors using CUDA's error functions (cudaGetErrorString). 5. Logging and Debugging Enable logging and performance tracking by compiling with the DEBUG or FUNC_TIMINGS flags. For example: gcc -DDEBUG main.c passthrough.o -o myapp -ldl This will log entry and exit times for CUDA functions, which is helpful for debugging and profiling. 6. Benefits of Using CUDAWRAP Runtime Flexibility: Swap between CUDA library versions without recompilation. Debugging: Trace function calls and measure performance. Compatibility: Avoid hard-coding library paths, making your application portable across systems with different CUDA installations. Would you like further clarification on any part or help setting up a specific CUDA example? Hijack CUBLAS The hijack_cublas.h file builds upon the passthrough dynamic loading mechanism to provide wrappers for the cuBLAS library. Hereâ€™s how you can understand and use this extension effectively. Purpose of hijack_cublas.h This header file: Extends the CUDAWRAP framework to specifically work with the cuBLAS library. Introduces cuBLAS-specific types and enumerations (e.g., cublasStatus_t, cublasOperation_t). Implements mechanisms to hijack cuBLAS calls for logging, debugging, or dynamically replacing the cuBLAS library. Key Components 1. Enums for cuBLAS Status and Operations cublasStatus_t: Represents return statuses for cuBLAS functions (e.g., success, allocation failure, or execution errors). cublasOperation_t: Represents matrix operations (CUBLAS_OP_N for normal, CUBLAS_OP_T for transpose, etc.). 2. cublasContext Placeholder structure that mimics a cuBLAS handle (cublasHandle_t). Contains: __inited__: Indicates if the handle has been initialized. stream: CUDA stream associated with the handle. Note: This is a stub and may require proper initialization in a real-world scenario. 3. Function Wrapping cublas_sym_t: A generic type for function pointers to cuBLAS functions. cublas_entry[]: Similar to cudart_lib_entry in passthrough.h, it stores cuBLAS function names and pointers, allowing dynamic resolution. Integration into a Project To use hijack_cublas.h for cuBLAS calls: 1. Include Headers #include \"passthrough.h\" #include \"hijack_cublas.h\" 2. Initialize cuBLAS Library Call load_cublas_lib() to dynamically load the cuBLAS library and initialize the cublas_entry table: if (load_cublas_lib() != 0) { fprintf(stderr, \"Failed to load cuBLAS library!\\n\"); return -1; } 3. Use cuBLAS Functions Dynamically Retrieve and execute cuBLAS functions via CUBLAS_FIND_ENTRY macro: // Example: cublasCreate_v2 typedef cublasStatus_t (*cublasCreate_t)(cublasHandle_t *); cublasCreate_t cublasCreate = (cublasCreate_t)CUBLAS_FIND_ENTRY(cublas_lib_entry, cublasCreate_v2); cublasHandle_t handle; cublasStatus_t status = cublasCreate(&handle); if (status != CUBLAS_STATUS_SUCCESS) { fprintf(stderr, \"cublasCreate failed: %d\\n\", status); return -1; } Example Application Hereâ€™s a full example demonstrating how to use hijack_cublas.h with matrix multiplication (cublasSgemm_v2). #include #include \"hijack_cublas.h\" // Example: Matrix multiplication using cuBLAS int main() { // Step 1: Load cuBLAS library if (load_cublas_lib() != 0) { fprintf(stderr, \"Failed to load cuBLAS library!\\n\"); return -1; } // Step 2: Create cuBLAS handle typedef cublasStatus_t (*cublasCreate_t)(cublasHandle_t *); cublasCreate_t cublasCreate = (cublasCreate_t)CUBLAS_FIND_ENTRY(cublas_lib_entry, cublasCreate_v2); cublasHandle_t handle; if (cublasCreate(&handle) != CUBLAS_STATUS_SUCCESS) { fprintf(stderr, \"Failed to create cuBLAS handle!\\n\"); return -1; } // Step 3: Perform SGEMM (Single-precision General Matrix Multiply) float alpha = 1.0f, beta = 0.0f; int m = 3, n = 3, k = 3; float A[m * k] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; float B[k * n] = {9, 8, 7, 6, 5, 4, 3, 2, 1}; float C[m * n] = {0}; typedef cublasStatus_t (*cublasSgemm_t)(cublasHandle_t, cublasOperation_t, cublasOperation_t, int, int, int, const float *, const float *, int, const float *, const float *, int, float *); cublasSgemm_t cublasSgemm = (cublasSgemm_t)CUBLAS_FIND_ENTRY(cublas_lib_entry, cublasSgemm_v2); if (cublasSgemm == NULL) { fprintf(stderr, \"Function cublasSgemm_v2 not found!\\n\"); return -1; } cublasStatus_t status = cublasSgemm(handle, CUBLAS_OP_N, CUBLAS_OP_N, m, n, k, &alpha, A, m, B, k, &beta, C, m); if (status != CUBLAS_STATUS_SUCCESS) { fprintf(stderr, \"cublasSgemm failed: %d\\n\", status); return -1; } // Print result printf(\"Matrix C:\\n\"); for (int i = 0; i Key Steps in Example Loading: load_cublas_lib initializes the function pointer table. Retrieving Function Pointers: Use CUBLAS_FIND_ENTRY to locate specific cuBLAS functions. Calling Functions: Use resolved function pointers like normal cuBLAS functions. Matrix Multiplication: Performs single-precision GEMM (cublasSgemm_v2). Cleanup: Destroy cuBLAS handle using cublasDestroy_v2. Would you like a deeper dive into any specific cuBLAS function or other areas of this framework? "},"Learn/LearnMocCUDA/LibBlocksRuntime.html":{"url":"Learn/LearnMocCUDA/LibBlocksRuntime.html","title":"LibBlocksRuntime","keywords":"","body":"This script builds and installs the libblocksruntime library, a dependency for the libdispatch (also known as Grand Central Dispatch). Hereâ€™s a detailed breakdown: 1. Navigate to the Source Directory cd ${WDIR}/blocks-runtime/ Changes the working directory to ${WDIR}/blocks-runtime/. ${WDIR} is likely a variable defined earlier in the environment, pointing to the base working directory. 2. Initialize Build Tools libtoolize ; aclocal ; autoheader ; autoconf ; automake --add-missing This sequence prepares the build environment for the libblocksruntime library: libtoolize: Prepares the source tree for libtool, which helps manage the creation of shared and static libraries. aclocal: Generates aclocal.m4 by gathering macro definitions, setting up the environment for autoconf. autoheader: Creates a template for config.h, used for platform-specific configuration. autoconf: Generates the configure script from configure.ac, which customizes the build process. automake --add-missing: Generates Makefile.in and adds any missing auxiliary files (like install-sh or missing). These steps ensure the project is ready for a standard ./configure && make build process. 3. Prepare the Build Directory rm -rf build ; mkdir -p build ; cd build rm -rf build: Deletes any existing build directory, ensuring a clean slate. mkdir -p build: Creates a new build directory if it doesnâ€™t already exist. cd build: Changes into the build directory where the actual compilation will take place. 4. Configure the Build CC=\"${MocCC} ${MocCFLAGS} -fcommon\" CXX=\"${MocCXX} ${MocCXXFLAGS} -fcommon\" \\ ../configure --prefix=\"${WDIR}/install/libblocksruntime\" \\ --disable-shared --enable-static --with-pic Sets the C and C++ compiler flags: CC and CXX are set to ${MocCC} and ${MocCXX} respectively, along with their corresponding flags (${MocCFLAGS} and ${MocCXXFLAGS}), plus the -fcommon flag. -fcommon ensures variables in multiple translation units are treated as common, improving compatibility with older codebases. Runs the ../configure script with the following options: --prefix: Specifies the installation directory as ${WDIR}/install/libblocksruntime. --disable-shared: Disables building shared libraries. --enable-static: Enables building static libraries. --with-pic: Ensures position-independent code is generated, which is often required for static libraries used in shared contexts. This step customizes the build for the specific environment. 5. Build and Install make -j$(nproc) install V=1 make -j$(nproc): Compiles the source code using as many parallel jobs as there are available CPU cores ($(nproc)). install: Installs the compiled library to the directory specified by the --prefix option in the configure script. V=1: Ensures verbose output during the make process, which shows detailed compilation commands. Key Outputs The static version of the libblocksruntime library is built and installed to ${WDIR}/install/libblocksruntime. Shared libraries are explicitly disabled to focus on creating static libraries for linking. Purpose This script is part of setting up a dependency for a larger project, ensuring that libblocksruntime is built in a controlled and predictable way, customized for the environment. "},"Learn/LearnMocCUDA/LibDispatch.html":{"url":"Learn/LearnMocCUDA/LibDispatch.html","title":"LibDispatch","keywords":"","body":"https://en.wikipedia.org/wiki/Grand_Central_Dispatch text libdispatch, also known as Grand Central Dispatch (GCD), is a library designed to provide efficient, system-level support for concurrent and parallel programming. It was first introduced by Apple as part of macOS and iOS but has since been made open-source and ported to other platforms like Linux. What is libdispatch For? 1. Concurrency and Parallelism libdispatch helps developers write concurrent programs more easily by managing threads and work queues internally. Instead of explicitly creating and managing threads, libdispatch allows you to schedule tasks (blocks of code) to execute asynchronously or synchronously. 2. Efficient Resource Utilization It uses a pool of threads and intelligently distributes tasks to available system resources, optimizing CPU and memory usage. Balances workloads across cores to maximize performance. 3. Thread Safety Simplifies thread-safe programming by encapsulating tasks in dispatch queues, avoiding race conditions and the need for extensive locks. 4. Event Handling Allows for event-driven programming by integrating tasks with file descriptors, timers, or other signals. Key Features of libdispatch Dispatch Queues A queue where tasks are scheduled to execute. Types: Serial Queue: Tasks are executed one at a time in order. Concurrent Queue: Tasks are executed in parallel, as resources allow. Main Queue: A special serial queue for tasks that must run on the main thread, typically UI updates. Work Items Blocks of code that you enqueue for execution. Can be written in C, Objective-C, or Swift. Dispatch Sources Event sources that trigger the execution of tasks, such as timers, file descriptors, or custom triggers. Group Management Dispatch groups allow you to group tasks and wait for their collective completion. Timers Built-in support for creating and managing timers in a queue-based system. When to Use libdispatch Asynchronous Tasks When tasks can be performed independently of each other, allowing the program to remain responsive (e.g., downloading a file while processing user input). Parallel Processing Tasks that can run simultaneously to leverage multicore processors, such as image processing, data analysis, or sorting algorithms. Thread-Safe Code Simplifies concurrent access to shared resources without explicit locks. Event-Driven Programming Ideal for applications that need to respond to events like network requests, user input, or timers. Performance-Critical Applications Helps offload heavy computational tasks without blocking the main thread. How to Use libdispatch In C: #include void my_function() { printf(\"Task executed\\n\"); } int main() { // Create a dispatch queue dispatch_queue_t queue = dispatch_queue_create(\"com.example.myqueue\", DISPATCH_QUEUE_CONCURRENT); // Add tasks to the queue dispatch_async(queue, ^{ my_function(); }); dispatch_async(queue, ^{ printf(\"Another task executed\\n\"); }); // Wait for some time to let tasks finish sleep(1); // Clean up dispatch_release(queue); return 0; } In Swift (if using on macOS or iOS): import Dispatch let queue = DispatchQueue(label: \"com.example.myqueue\", attributes: .concurrent) // Schedule tasks queue.async { print(\"Task 1 executed\") } queue.async { print(\"Task 2 executed\") } // Dispatch to the main queue DispatchQueue.main.async { print(\"UI updates can go here\") } Advantages of libdispatch Simplifies Multithreading: Abstracts low-level threading details. Efficient: Optimizes resource use, particularly in multicore systems. Portable: Works on macOS, iOS, Linux, and more. Limitations Not a substitute for more complex threading needs like thread-local storage or thread prioritization. For very fine-grained control of threads, alternatives like POSIX threads or C++ std::thread might be better. In short, libdispatch is an essential tool for building modern, high-performance applications, especially when concurrency and responsiveness are crucial. macOS GCD - Grand Central Dispatc macOS GCD - Grand Central Dispatch Grand Central Dispatch (GCD), also known as libdispatch (libdispatch.dyld), is available in both macOS and iOS. It's a technology developed by Apple to optimize application support for concurrent (multithreaded) execution on multicore hardware. Grand Central Dispatch (GCD)ï¼Œä¹Ÿç§°ä¸ºlibdispatch ( libdispatch.dyld )ï¼Œåœ¨ macOS å’Œ iOS ä¸­å‡å¯ç”¨ã€‚å®ƒæ˜¯ Apple å¼€å‘çš„ä¸€é¡¹æŠ€æœ¯ï¼Œæ—¨åœ¨ä¼˜åŒ–å¤šæ ¸ç¡¬ä»¶ä¸Šå¹¶å‘ï¼ˆå¤šçº¿ç¨‹ï¼‰æ‰§è¡Œçš„åº”ç”¨ç¨‹åºæ”¯æŒã€‚ GCD provides and manages FIFO queues to which your application can submit tasks in the form of block objects. Blocks submitted to dispatch queues are executed on a pool of threads fully managed by the system. GCD automatically creates threads for executing the tasks in the dispatch queues and schedules those tasks to run on the available cores. GCDæä¾›å¹¶ç®¡ç†FIFO é˜Ÿåˆ—ï¼Œæ‚¨çš„åº”ç”¨ç¨‹åºå¯ä»¥å‘å…¶ä¸­ä»¥å—å¯¹è±¡çš„å½¢å¼æäº¤ä»»åŠ¡ã€‚æäº¤åˆ°è°ƒåº¦é˜Ÿåˆ—çš„å—åœ¨å®Œå…¨ç”±ç³»ç»Ÿç®¡ç†çš„çº¿ç¨‹æ± ä¸Šæ‰§è¡Œã€‚ GCD è‡ªåŠ¨åˆ›å»ºçº¿ç¨‹æ¥æ‰§è¡Œè°ƒåº¦é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼Œå¹¶å®‰æ’è¿™äº›ä»»åŠ¡åœ¨å¯ç”¨å†…æ ¸ä¸Šè¿è¡Œã€‚ In summary, to execute code in parallel, processes can send blocks of code to GCD, which will take care of their execution. Therefore, processes don't create new threads; GCD executes the given code with its own pool of threads (which might increase or decrease as necessary). æ€»ä¹‹ï¼Œè¦å¹¶è¡Œæ‰§è¡Œä»£ç ï¼Œè¿›ç¨‹å¯ä»¥å°†ä»£ç å—å‘é€åˆ° GCD ï¼ŒGCD å°†è´Ÿè´£å®ƒä»¬çš„æ‰§è¡Œã€‚å› æ­¤ï¼Œè¿›ç¨‹ä¸ä¼šåˆ›å»ºæ–°çº¿ç¨‹ï¼›è€Œæ˜¯åˆ›å»ºæ–°çº¿ç¨‹ã€‚ GCD ä½¿ç”¨è‡ªå·±çš„çº¿ç¨‹æ± æ‰§è¡Œç»™å®šçš„ä»£ç ï¼ˆå¯èƒ½ä¼šæ ¹æ®éœ€è¦å¢åŠ æˆ–å‡å°‘ï¼‰ã€‚ This is very helpful to manage parallel execution successfully, greatly reducing the number of threads processes create and optimising the parallel execution. This is ideal for tasks that require great parallelism (brute-forcing?) or for tasks that shouldn't block the main thread: For example, the main thread on iOS handles UI interactions, so any other functionality that could make the app hang (searching, accessing a web, reading a file...) is managed this way. è¿™å¯¹äºæˆåŠŸç®¡ç†å¹¶è¡Œæ‰§è¡Œéå¸¸æœ‰å¸®åŠ©ï¼Œå¤§å¤§å‡å°‘äº†è¿›ç¨‹åˆ›å»ºçš„çº¿ç¨‹æ•°é‡å¹¶ä¼˜åŒ–äº†å¹¶è¡Œæ‰§è¡Œã€‚è¿™éå¸¸é€‚åˆéœ€è¦å¤§é‡å¹¶è¡Œæ€§ï¼ˆå¼ºåˆ¶ï¼Ÿï¼‰çš„ä»»åŠ¡æˆ–ä¸åº”é˜»å¡ä¸»çº¿ç¨‹çš„ä»»åŠ¡ï¼šä¾‹å¦‚ï¼ŒiOS ä¸Šçš„ä¸»çº¿ç¨‹å¤„ç† UI äº¤äº’ï¼Œå› æ­¤ä»»ä½•å…¶ä»–å¯èƒ½å¯¼è‡´åº”ç”¨ç¨‹åºæŒ‚èµ·çš„åŠŸèƒ½ï¼ˆæœç´¢ã€è®¿é—®ç½‘ç»œã€è¯»å–æ–‡ä»¶...ï¼‰éƒ½æ˜¯ä»¥è¿™ç§æ–¹å¼è¿›è¡Œç®¡ç†çš„ã€‚ GCD Part 1: Queues and methods Grand Central Dispatch (GCD) on FreeBSD GCD Handbook "},"Learn/LearnMocCUDA/LibUnwind.html":{"url":"Learn/LearnMocCUDA/LibUnwind.html","title":"LibUnwind","keywords":"","body":"sudo apt install libunwind-dev Reading package lists... Done Building dependency tree... Done Reading state information... Done The following NEW packages will be installed: libunwind-dev 0 upgraded, 1 newly installed, 0 to remove and 2 not upgraded. Need to get 441 kB of archives. After this operation, 2,916 kB of additional disk space will be used. Get:1 http://mirrors.ustc.edu.cn/debian bookworm/main amd64 libunwind-dev amd64 1.6.2-3 [441 kB] Fetched 441 kB in 1s (775 kB/s) Selecting previously unselected package libunwind-dev:amd64. (Reading database ... 296316 files and directories currently installed.) Preparing to unpack .../libunwind-dev_1.6.2-3_amd64.deb ... Unpacking libunwind-dev:amd64 (1.6.2-3) ... Setting up libunwind-dev:amd64 (1.6.2-3) ... Processing triggers for man-db (2.11.2-2) ... "},"Learn/LearnMocCUDA/MakefileNote.html":{"url":"Learn/LearnMocCUDA/MakefileNote.html","title":"MakefileNote","keywords":"","body":"The Makefile appears to be structured to build a project with specific compiler configurations tailored for a system, potentially the Fugaku supercomputer. Here's an analysis and an organized breakdown of its components: Analysis of Key Sections in the Makefile General Description: The initial comments describe the Makefile's purpose: make depend: Generate dependencies using makedepend. make: Build the executable (presumably mycc). make clean: Remove intermediate (*.o) and executable files. Compiler Configuration: Defines the compilers: CC: Default C compiler (clang). CXX: Default C++ compiler (clang++). FC: Default Fortran compiler (flang). Compile-Time Flags: Optimizations: OPTI: Includes architecture-specific optimizations for the A64FX CPU (Fugaku) and link-time optimization. Debug flags: DEBUG: Disabled by default, can enable -DDEBUG and debugging flags (-O0, -g). CUDA handling: RedirectCUDA: Redirects CUDA functionality to a mock or alternative implementation. RedirCUDAPaths: Adds custom paths for CUDA and cuDNN. GCD: GrandCentralDispatch: Enables Grand Central Dispatch (disabled by default). Sorted Contents of the Makefile 1. Metadata and Instructions # 'make depend' uses makedepend to automatically generate dependencies # 'make' build executable file 'mycc' # 'make clean' removes all .o and executable files Instructions for the user about the purpose and usage of the Makefile. 2. Compiler Configuration # Define the C compiler to use CC ?= clang CXX ?= clang++ FC ?= flang Specifies compilers for C, C++, and Fortran. 3. Optimization and Debug Flags # Define any compile-time flags OPTI ?= -Ofast -ffast-math -mcpu=a64fx -flto=thin DEBUG ?= #-DDEBUG -O0 -g OPTI: Enables optimizations for speed, targeting the A64FX processor. DEBUG: Placeholder for debugging flags, commented out by default. 4. CUDA and Other Flags RedirectCUDA ?= -DUSE_MocCUDA=1 #=0 RedirectCUDA += #-DUSE_MocREGISTERFNs RedirCUDAPaths ?= -DPATHTOMocDeviceProp='\"$(shell pwd)\"' RedirCUDAPaths += -DPATHTOCUDA_ROOT='\"$(CUDA_TOOLKIT_ROOT_DIR)\"' -DPATHTOCUDNN_ROOT='\"$(CUDNN_ROOT)\"' GrandCentralDispatch ?= -DUSE_GCD=1 #=0 Configurations for: Redirecting CUDA calls (RedirectCUDA). Setting custom paths for CUDA and cuDNN. Enabling/disabling Grand Central Dispatch (GrandCentralDispatch). Next Steps The file likely includes build rules, dependency handling, and cleaning targets in subsequent sections. To fully analyze and organize the Makefile, I will inspect further lines and continue sorting its content into logical modules. Additional Analysis and Organization of the Makefile The content adds more configuration for building a complex project. Hereâ€™s the breakdown of the additional sections: 5. Compiler Flags CFLAGS ?= $(OPTI) $(DEBUG) $(RedirectCUDA) $(RedirCUDAPaths) $(GrandCentralDispatch) \\ -Wall -Wno-unused-label -fPIC -fopenmp CXXFLAGS ?= $(CFLAGS) -Wno-deprecated-declarations -std=c++14 CFLAGS: Includes optimization, debugging, CUDA redirection, architecture-specific flags, and OpenMP support. CXXFLAGS: Builds upon CFLAGS with C++-specific flags, including compatibility for C++14. 6. Include Directories LOCALINCL = -I$(shell pwd)/src/cudart -I$(shell pwd)/src/cudnn -I$(shell pwd)/src/cublas \\ -I$(shell pwd)/src/utils -I$(shell pwd)/src/cudawrap CINCLUDES ?= $(LOCALINCL) \\ -DFUJITSU -I$(TORCH_BUILD_ROOT)/ssl2/include \\ $(shell pkg-config --keep-system-cflags --cflags libunwind) \\ $(shell pkg-config --keep-system-cflags --cflags hwloc) \\ -I$(LIBDIS_ROOT)/include CXXINCLUDES ?= $(LOCALINCL) \\ -I$(TORCH_BUILD_ROOT)/aten/src \\ -I$(TORCH_BUILD_ROOT)/torch/include \\ -I$(CUDA_TOOLKIT_ROOT_DIR)/include FINCLUDES ?= $(LOCALINCL) LOCALINCL: Defines local include paths for CUDA, cuDNN, utilities, and CUDA wrappers. CINCLUDES, CXXINCLUDES, and FINCLUDES: Extend local includes to support Torch library paths, CUDA Toolkit, and other dependencies (e.g., libunwind, hwloc). 7. Linker Flags and Library Paths LFLAGS ?= -fuse-ld=lld \\ -L$(TORCH_BUILD_ROOT)/ssl2/lib -Wl,-rpath=$(TORCH_BUILD_ROOT)/ssl2/lib \\ $(shell pkg-config --keep-system-libs --libs-only-L libunwind) \\ $(shell pkg-config --keep-system-libs --libs-only-L hwloc) \\ -L$(LIBDIS_ROOT)/lib -L$(LIBPWQ_ROOT)/lib -L$(LIBKQU_ROOT)/lib64 -L$(LIBBRT_ROOT)/lib \\ -L$(VENV_SITEPACKAGES)/torch/lib -Wl,-rpath=$(VENV_SITEPACKAGES)/torch/lib Specifies: The linker to use (lld). Library search paths and runtime paths (e.g., Torch, libunwind, hwloc). Dependencies on additional libraries in specific paths (e.g., LIBDIS_ROOT, LIBPWQ_ROOT). 8. Libraries to Link LIBS ?= -lopenblas \\ $(shell pkg-config --keep-system-libs --libs-only-l libunwind) \\ $(shell pkg-config --keep-system-libs --libs-only-l hwloc) \\ -l:libdispatch.a -l:libpthread_workqueue.a -l:libkqueue.a -l:libBlocksRuntime.a \\ -liberty -lstdc++ -lc10 -lpthread -lm Links required libraries, including: Mathematical libraries (e.g., openblas). System utilities (libunwind, pthread). Blocks Runtime and other specific libraries for parallel and GPU operations. Next Steps The subsequent lines likely include definitions for: Source files. Build rules for object files and the final executable. Dependency generation. I will inspect the remaining lines to complete the analysis. Final Breakdown of the Makefile The remaining sections define source files, object file transformations, and build rules for the target executable. Here's an organized summary: 9. Source Files CSRCS ?= src/cudawrap/passthrough.c \\ src/cudart/hijack_cuda_runtime_api.c \\ src/cudnn/hijack_cudnn.c \\ src/cublas/hijack_cublas.c \\ src/utils/utils.c src/utils/addTensor.c src/utils/async.c CXXSRCS ?= src/torch/hijack_torch_cuda.cpp FSRCS ?= src/utils/frt_utils.f90 CSRCS: C source files for CUDA wrapping and utilities. CXXSRCS: C++ source files for Torch and CUDA handling. FSRCS: Fortran source files for utility functions. 10. Object File Definitions .SUFFIXES: .c .cpp .f90 OBJS = $(CSRCS:.c=.o) OBJS += $(CXXSRCS:.cpp=.o) OBJS += $(FSRCS:.f90=.o) Transforms the source files into object files by replacing their extensions (.c, .cpp, .f90) with .o. 11. Target Executable and Libraries # Define the executable file MAIN = lib/libMocCUDA.so CUDNN_shared = dep/install/cudnn/lib64/libcudnn.so CUDNN_static = dep/install/cudnn/lib64/libcudnn_static.a MAIN: The target output is a shared library (libMocCUDA.so). CUDNN_shared and CUDNN_static: Paths for shared and static cuDNN libraries. 12. Build Rules .PHONY: depend clean all: $(MAIN) @echo \"Our CUDA wrapper\" $(MAIN) \"has been compiled,\" @echo \"use LD_PRELOAD=$(shell pwd)/lib/libMocCUDA.so to apply it.\" $(MAIN): $(OBJS) all: Default target, builds the MAIN target and outputs instructions for using the shared library. Dependencies: Relies on compiled object files ($(OBJS)). Overall Organization of the Makefile Metadata and Instructions: Overview of Makefile usage. Compiler and Build Configurations: Compiler settings (CC, CXX, FC). Optimization (OPTI), debugging (DEBUG), and CUDA-related flags. Include Paths: Defines paths for header files and dependencies. Linker Flags and Libraries: Specifies library paths (LFLAGS) and libraries to link (LIBS). Source File Definitions: Lists source files for different languages (CSRCS, CXXSRCS, FSRCS). Object File Transformations: Generates object files using suffix replacement. Target and Build Rules: Builds the MAIN target (shared library) and provides a usage message. Would you like assistance refining or modifying this Makefile? "},"Learn/LearnMocCUDA/MocCUDA.html":{"url":"Learn/LearnMocCUDA/MocCUDA.html","title":"MocCUDA","keywords":"","body":""},"Learn/LearnMocCUDA/OpenBLAS.html":{"url":"Learn/LearnMocCUDA/OpenBLAS.html","title":"OpenBLAS","keywords":"","body":"OpenBLAS "},"Learn/LearnMocCUDA/OpenMPI.html":{"url":"Learn/LearnMocCUDA/OpenMPI.html","title":"OpenMPI","keywords":"","body":"text text "},"Learn/LearnMocCUDA/Spack.html":{"url":"Learn/LearnMocCUDA/Spack.html","title":"Spack","keywords":"","body":"https://spack.io/ https://github.com/spack/spack Welcome to Spack! Spack is a package manager for supercomputers, Linux, and macOS. It makes installing scientific software easy. Spack isnâ€™t tied to a particular language; you can build a software stack in Python or R, link to libraries written in C, C++, or Fortran, and easily swap compilers or target specific microarchitectures. Learn more here. "},"Learn/LearnMocCUDA/pytorch.needed.libs.Note.html":{"url":"Learn/LearnMocCUDA/pytorch.needed.libs.Note.html","title":"pytorch.needed.libs.Note","keywords":"","body":"This Bash script is designed to automate the generation of wrapper libraries for various CUDA-related libraries, which are commonly used in GPU-accelerated computing. These wrappers seem to integrate with Score-P, a performance analysis and tracing framework. The script processes libraries like libcudart.so, libcublas.so, and others to facilitate performance instrumentation or runtime monitoring of CUDA applications. Here's a detailed breakdown: è¯¥ Bash è„šæœ¬æ—¨åœ¨è‡ªåŠ¨ç”Ÿæˆå„ç§ CUDA ç›¸å…³åº“çš„åŒ…è£…å™¨åº“ï¼Œè¿™äº›åº“é€šå¸¸ç”¨äº GPU åŠ é€Ÿè®¡ç®—ã€‚è¿™äº›åŒ…è£…å™¨ä¼¼ä¹ä¸Score-Pï¼ˆä¸€ä¸ªæ€§èƒ½åˆ†æå’Œè·Ÿè¸ªæ¡†æ¶ï¼‰é›†æˆã€‚è¯¥è„šæœ¬å¤„ç†libcudart.so ã€ libcublas.soç­‰åº“ï¼Œä»¥ä¿ƒè¿› CUDA åº”ç”¨ç¨‹åºçš„æ€§èƒ½æ£€æµ‹æˆ–è¿è¡Œæ—¶ç›‘æ§ã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†çš„ç»†åˆ†ï¼š Purpose of the Script Wrapper Libraries Creation: Uses the scorep-libwrap-init tool to generate Score-P wrapper libraries for CUDA libraries. Enables capturing calls to CUDA libraries for debugging, profiling, or performance analysis. Custom Adjustments: Edits wrapper source files and build configurations to include specific headers and modify compilation flags (e.g., adding -fPIC for position-independent code). Instruments Specific CUDA Libraries: Covers libraries such as: libcudart.so: Runtime API for CUDA. libcublas.so: Basic Linear Algebra Subprograms (BLAS). libcufft.so: Fast Fourier Transform (FFT). libcurand.so: Random number generation. libcudnn.so: Deep neural network support. libcusparse.so: Sparse matrix operations. libnvToolsExt.so: Profiling and debugging tools. libnccl.so: Multi-GPU communication. Key Sections of the Script 1. Preparations Directory Setup: Creates a wrapper directory for holding generated wrappers. Environment Variables: Defines paths to CUDA Toolkit, cuDNN, and NCCL libraries:CUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda-10.0/targets/x86_64-linux CUDNN_ROOT_DIR=/work/opt/cuda/cudnn-10.0-linux-x64-v7.6.5.32 NCCL_ROOT_DIR=/work/opt/cuda/nccl_2.5.6-1+cuda10.0_x86_64 2. Wrapper Creation Loop For each CUDA library: Executes scorep-libwrap-init: scorep-libwrap-init --name ${LIBN} -x c++ \\ --cppflags \"-I${CUDA_TOOLKIT_ROOT_DIR}/include/\" \\ --ldflags \"-L${CUDA_TOOLKIT_ROOT_DIR}/lib/\" \\ --libs \"-l${LIBN}\" --update wrapper/wrap_${LIBN} Generates initial wrapper sources and build files for the target library. Customizes source code (libwrap.h, .filter files) and the Makefile: Includes appropriate CUDA headers like cublas_v2.h for cublas, cudnn.h for cudnn, etc. Edits filtering rules to exclude certain symbols (e.g., cuda*, curandGenerateBinomial*). Builds the wrapper: make libscorep_libwrap_${LIBN}_runtime.la 3. Special Handling Some libraries require additional modifications: For libcudart.so, it adds a custom set_launch_func to handle kernel launches. For libcufft.so, includes cufft.h and cufftXt.h. Output The script generates a series of dynamic libraries (.la files) in the wrapper directory, such as: libscorep_libwrap_cudart_runtime.la libscorep_libwrap_cublas_runtime.la libscorep_libwrap_cufft_runtime.la ... and so on. These libraries allow Score-P to monitor and trace GPU-related operations in programs that use these CUDA libraries. Potential Use Cases Performance Profiling: Developers can profile CUDA-based applications to analyze bottlenecks or resource usage. Debugging and Instrumentation: The generated wrappers enable fine-grained debugging of CUDA calls. Integration with HPC Environments: Supports performance analysis for GPU-heavy workloads in high-performance computing (HPC) clusters. Suggestions for Improvement Documentation: Add comments to clarify what specific modifications in each sed command are meant to achieve. Portability: Replace hardcoded paths (e.g., /usr/local/cuda-10.0/) with more configurable options or environment checks. Error Handling: Include error checks after key commands (mkdir, scorep-libwrap-init, make). This script is highly specialized and targets developers working with GPU performance optimization or debugging using CUDA and Score-P. è¿™æ®µ Bash è„šæœ¬æ—¨åœ¨è‡ªåŠ¨ç”Ÿæˆé’ˆå¯¹å„ç§ CUDA ç›¸å…³åº“çš„å°è£…åº“ï¼ˆwrapper librariesï¼‰ï¼Œè¿™äº›åº“é€šå¸¸ç”¨äº GPU åŠ é€Ÿè®¡ç®—ã€‚å°è£…åº“ä¼¼ä¹ä¸ Score-P é›†æˆï¼Œè¿™æ˜¯ä¸€ç§æ€§èƒ½åˆ†æå’Œè¿½è¸ªæ¡†æ¶ã€‚è„šæœ¬å¤„ç†è¯¸å¦‚ libcudart.soã€libcublas.so ç­‰åº“ï¼Œä»¥ä¾¿ä¸º CUDA åº”ç”¨ç¨‹åºæä¾›æ€§èƒ½æ£€æµ‹æˆ–è¿è¡Œæ—¶ç›‘æ§åŠŸèƒ½ã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†çš„åˆ†è§£ï¼š è„šæœ¬çš„ç›®çš„ åˆ›å»ºå°è£…åº“ï¼š ä½¿ç”¨ scorep-libwrap-init å·¥å…·ä¸º CUDA åº“ç”Ÿæˆ Score-P å°è£…åº“ã€‚ ä½¿å…¶èƒ½å¤Ÿæ•è·å¯¹ CUDA åº“çš„è°ƒç”¨ï¼Œç”¨äºè°ƒè¯•ã€æ€§èƒ½åˆ†ææˆ–è¿è¡Œæ—¶ç›‘æ§ã€‚ è‡ªå®šä¹‰è°ƒæ•´ï¼š ç¼–è¾‘å°è£…æºç æ–‡ä»¶å’Œæ„å»ºé…ç½®ï¼Œä¾‹å¦‚åŒ…å«ç‰¹å®šå¤´æ–‡ä»¶ã€ä¿®æ”¹ç¼–è¯‘æ ‡å¿—ï¼ˆå¦‚æ·»åŠ  -fPIC æ”¯æŒä½ç½®æ— å…³ä»£ç ï¼‰ã€‚ å¤„ç†ç‰¹å®šçš„ CUDA åº“ï¼š æ¶µç›–çš„åº“åŒ…æ‹¬ï¼š libcudart.soï¼šCUDA çš„è¿è¡Œæ—¶ APIã€‚ libcublas.soï¼šåŸºæœ¬çº¿æ€§ä»£æ•°å­ç¨‹åºï¼ˆBLASï¼‰ã€‚ libcufft.soï¼šå¿«é€Ÿå‚…é‡Œå¶å˜æ¢ï¼ˆFFTï¼‰ã€‚ libcurand.soï¼šéšæœºæ•°ç”Ÿæˆã€‚ libcudnn.soï¼šæ·±åº¦ç¥ç»ç½‘ç»œæ”¯æŒã€‚ libcusparse.soï¼šç¨€ç–çŸ©é˜µè¿ç®—ã€‚ libnvToolsExt.soï¼šæ€§èƒ½åˆ†æå’Œè°ƒè¯•å·¥å…·ã€‚ libnccl.soï¼šå¤š GPU é€šä¿¡ã€‚ è„šæœ¬çš„ä¸»è¦éƒ¨åˆ† 1. å‡†å¤‡é˜¶æ®µ ç›®å½•åˆ›å»ºï¼š åˆ›å»º wrapper ç›®å½•ï¼Œç”¨äºå­˜æ”¾ç”Ÿæˆçš„å°è£…åº“ã€‚ ç¯å¢ƒå˜é‡å®šä¹‰ï¼š å®šä¹‰ CUDA Toolkitã€cuDNN å’Œ NCCL åº“çš„è·¯å¾„ï¼šCUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda-10.0/targets/x86_64-linux CUDNN_ROOT_DIR=/work/opt/cuda/cudnn-10.0-linux-x64-v7.6.5.32 NCCL_ROOT_DIR=/work/opt/cuda/nccl_2.5.6-1+cuda10.0_x86_64 2. å¾ªç¯ç”Ÿæˆå°è£…åº“ å¯¹äºæ¯ä¸ª CUDA åº“ï¼š æ‰§è¡Œ scorep-libwrap-initï¼š scorep-libwrap-init --name ${LIBN} -x c++ \\ --cppflags \"-I${CUDA_TOOLKIT_ROOT_DIR}/include/\" \\ --ldflags \"-L${CUDA_TOOLKIT_ROOT_DIR}/lib/\" \\ --libs \"-l${LIBN}\" --update wrapper/wrap_${LIBN} ä¸ºç›®æ ‡åº“ç”Ÿæˆåˆå§‹çš„å°è£…æºç å’Œæ„å»ºæ–‡ä»¶ã€‚ è‡ªå®šä¹‰æºç ï¼ˆå¦‚ libwrap.h å’Œ .filter æ–‡ä»¶ï¼‰ä»¥åŠ Makefileï¼š åŒ…å«é€‚å½“çš„ CUDA å¤´æ–‡ä»¶ï¼Œä¾‹å¦‚é’ˆå¯¹ cublas çš„ cublas_v2.hï¼Œé’ˆå¯¹ cudnn çš„ cudnn.h ç­‰ã€‚ ç¼–è¾‘è¿‡æ»¤è§„åˆ™ä»¥æ’é™¤æŸäº›ç¬¦å·ï¼ˆä¾‹å¦‚ cuda*ã€curandGenerateBinomial*ï¼‰ã€‚ ç¼–è¯‘å°è£…åº“ï¼š make libscorep_libwrap_${LIBN}_runtime.la 3. ç‰¹æ®Šå¤„ç† æŸäº›åº“éœ€è¦é¢å¤–çš„ä¿®æ”¹ï¼š å¯¹äº libcudart.soï¼Œæ·»åŠ äº†è‡ªå®šä¹‰çš„ set_launch_func ä»¥å¤„ç†å†…æ ¸å¯åŠ¨ã€‚ å¯¹äº libcufft.soï¼ŒåŒ…å«äº† cufft.h å’Œ cufftXt.hã€‚ è¾“å‡º è„šæœ¬åœ¨ wrapper ç›®å½•ä¸­ç”Ÿæˆä¸€ç³»åˆ—åŠ¨æ€åº“ï¼ˆ.la æ–‡ä»¶ï¼‰ï¼Œä¾‹å¦‚ï¼š libscorep_libwrap_cudart_runtime.la libscorep_libwrap_cublas_runtime.la libscorep_libwrap_cufft_runtime.la ... ç­‰ã€‚ è¿™äº›åº“å…è®¸ Score-P ç›‘æ§å’Œè·Ÿè¸ªç¨‹åºä¸­ä¸ GPU ç›¸å…³çš„æ“ä½œã€‚ æ½œåœ¨ç”¨é€” æ€§èƒ½åˆ†æï¼š å¼€å‘è€…å¯ä»¥åˆ†æ CUDA åº”ç”¨ç¨‹åºçš„æ€§èƒ½ç“¶é¢ˆæˆ–èµ„æºä½¿ç”¨æƒ…å†µã€‚ è°ƒè¯•ä¸ç›‘æ§ï¼š ç”Ÿæˆçš„å°è£…åº“æ”¯æŒå¯¹ CUDA è°ƒç”¨çš„ç»†ç²’åº¦è°ƒè¯•ã€‚ ä¸é«˜æ€§èƒ½è®¡ç®—ç¯å¢ƒé›†æˆï¼š æ”¯æŒåœ¨é«˜æ€§èƒ½è®¡ç®—ï¼ˆHPCï¼‰é›†ç¾¤ä¸­åˆ†æ GPU å¯†é›†å‹å·¥ä½œè´Ÿè½½çš„æ€§èƒ½ã€‚ æ”¹è¿›å»ºè®® æ–‡æ¡£ï¼š æ·»åŠ æ³¨é‡Šï¼Œè¯´æ˜æ¯ä¸ª sed å‘½ä»¤çš„å…·ä½“ä¿®æ”¹ç›®çš„ã€‚ ç§»æ¤æ€§ï¼š å°†ç¡¬ç¼–ç è·¯å¾„ï¼ˆå¦‚ /usr/local/cuda-10.0/ï¼‰æ›¿æ¢ä¸ºå¯é…ç½®é€‰é¡¹æˆ–ç¯å¢ƒæ£€æŸ¥ã€‚ é”™è¯¯å¤„ç†ï¼š åœ¨å…³é”®å‘½ä»¤ï¼ˆå¦‚ mkdirã€scorep-libwrap-initã€makeï¼‰åæ·»åŠ é”™è¯¯æ£€æŸ¥ã€‚ æ­¤è„šæœ¬é«˜åº¦ä¸“ä¸šåŒ–ï¼Œé€‚ç”¨äºä½¿ç”¨ CUDA å’Œ Score-P è¿›è¡Œ GPU æ€§èƒ½ä¼˜åŒ–æˆ–è°ƒè¯•çš„å¼€å‘è€…ã€‚ "},"Learn/LearnMordenCpp/Note.html":{"url":"Learn/LearnMordenCpp/Note.html","title":"Note","keywords":"","body":"Morden Cpp Links cppreference modern-cpp hackingcpp cppweeklynews RVO and NRVO github: Mq-b/ModernCpp-ConcurrentProgramming-Tutorial awesome repositories: github: awesome-cpp cli arg parse: github.com: p-ranav/argparse Misc Smart Pointers All programming languages must answer: how to allocate the resources? how to get the read only access to the resource? how to get the mut/write access to the resource? how to pass or move the access of the resource? when to give up the access to the resource? when to release the resources? ~~ practical answer: resource ownership with lifetime Back to Basics: Smart Pointers and RAII - Inbal Levi - CppCon 2021 hacking cpp: unique_ownership The ownership model in C++ syntax and design of smart pointers and RAII ownership events: moving an object passing an object as a function parameter returning an object from a function smart pointers unique_ptr: single ownership shared_ptr: multiple ownership weak_ptr: non ownership RESOURCE MANAGEMENT-RAII Standard library classes using RAll std:string, std::vector - free memory on DTOR std::jthread - rejoin on DTOR Standard library utilities std::unique_lock - exclusive mutex wrapper (C++11) std::shared_lock - shared mutex wrapper (C++14) std:lock_guard - ownership of a mutex in a scope (C++11) std::scoped_lock - ownership of multiple mutexes (avoids deadlock) (C++11) experimental:scope_exit - general purpose scope guard Guidelines Support Library (github: Microsoft GSL) gsl::owner - a wrapper which prevents multiple ownership to an object unique_ptr hacking cpp: unique_ptr shared_ptr hacking cpp: shared_ownership. "},"Learn/LearnPest/ParsingExpressionGrammar.html":{"url":"Learn/LearnPest/ParsingExpressionGrammar.html","title":"ParsingExpressionGrammar","keywords":"","body":"PEG: Parsing Expression Grammar è§£æè¡¨è¾¾å¼è¯­æ³• Parsing_expression_grammar awesome-pest In computer science, a parsing expression grammar (PEG) is a type of analytic formal grammar, i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language. The formalism was introduced by Bryan Ford in 2004[1] and is closely related to the family of top-down parsing languages introduced in the early 1970s. Syntactically, PEGs also look similar to context-free grammars (CFGs), but they have a different interpretation: the choice operator selects the first match in PEG, while it is ambiguous in CFG. This is closer to how string recognition tends to be done in practice, e.g. by a recursive descent parser. åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼Œè§£æè¡¨è¾¾å¼è¯­æ³•ï¼ˆ PEG ï¼‰æ˜¯ä¸€ç§åˆ†æå½¢å¼è¯­æ³•ï¼Œå³å®ƒæ ¹æ®ä¸€ç»„ç”¨äºè¯†åˆ«è¯­è¨€ä¸­å­—ç¬¦ä¸²çš„è§„åˆ™æ¥æè¿°å½¢å¼è¯­è¨€ã€‚è¯¥å½¢å¼ä¸»ä¹‰ç”± Bryan Ford äº 20041 å¹´æå‡ºï¼Œä¸ 20 ä¸–çºª 70 å¹´ä»£åˆæ¨å‡ºçš„è‡ªé¡¶å‘ä¸‹è§£æè¯­è¨€ç³»åˆ—å¯†åˆ‡ç›¸å…³ã€‚ä»è¯­æ³•ä¸Šè®²ï¼ŒPEG çœ‹èµ·æ¥ä¹Ÿä¸ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•ï¼ˆCFGï¼‰ç±»ä¼¼ï¼Œä½†å®ƒä»¬æœ‰ä¸åŒçš„è§£é‡Šï¼šé€‰æ‹©è¿ç®—ç¬¦é€‰æ‹© PEG ä¸­çš„ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹ï¼Œè€Œåœ¨ CFG ä¸­å®ƒæ˜¯ä¸æ˜ç¡®çš„ã€‚è¿™æ›´æ¥è¿‘äºå®è·µä¸­å­—ç¬¦ä¸²è¯†åˆ«çš„æ–¹å¼ï¼Œä¾‹å¦‚é€šè¿‡é€’å½’ä¸‹é™è§£æå™¨ã€‚ Unlike CFGs, PEGs cannot be ambiguous; a string has exactly one valid parse tree or none. It is conjectured that there exist context-free languages that cannot be recognized by a PEG, but this is not yet proven.[1] PEGs are well-suited to parsing computer languages (and artificial human languages such as Lojban) where multiple interpretation alternatives can be disambiguated locally, but are less likely to be useful for parsing natural languages where disambiguation may have to be global.[2] ä¸ CFG ä¸åŒï¼ŒPEG ä¸èƒ½å«ç³Šä¸æ¸…ï¼›ä¸€ä¸ªå­—ç¬¦ä¸²åªæœ‰ä¸€ä¸ªæœ‰æ•ˆçš„è§£ææ ‘ï¼Œæˆ–è€…æ²¡æœ‰ã€‚æ®æ¨æµ‹ï¼Œå­˜åœ¨ PEG æ— æ³•è¯†åˆ«çš„ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼Œä½†è¿™å°šæœªå¾—åˆ°è¯å®ã€‚1 PEG éå¸¸é€‚åˆè§£æè®¡ç®—æœºè¯­è¨€ï¼ˆä»¥åŠLojbanç­‰äººå·¥äººç±»è¯­è¨€ï¼‰ï¼Œå…¶ä¸­å¯ä»¥æœ‰å¤šç§è§£é‡Šæ›¿ä»£æ–¹æ¡ˆã€‚åœ¨æœ¬åœ°æ¶ˆé™¤æ­§ä¹‰ï¼Œä½†å¯¹äºè§£æå¯èƒ½å¿…é¡»æ˜¯å…¨å±€æ¶ˆæ­§çš„è‡ªç„¶è¯­è¨€ä¸å¤ªæœ‰ç”¨ã€‚ "},"Learn/LearnPest/pest.html":{"url":"Learn/LearnPest/pest.html","title":"pest","keywords":"","body":"pest. The Elegant Parser pest.rs pest.docs.rs pest.book pest is a general purpose parser written in Rust with a focus on accessibility , correctness , and performance . It uses parsing expression grammars (or PEG) as input, which are similar in spirit to regular expressions, but which offer the enhanced expressivity needed to parse complex languages. pest æ˜¯ä¸€ä¸ªç”¨ Rust ç¼–å†™çš„é€šç”¨è§£æå™¨ï¼Œé‡ç‚¹å…³æ³¨å¯è®¿é—®æ€§ã€æ­£ç¡®æ€§å’Œæ€§èƒ½ã€‚å®ƒä½¿ç”¨è§£æè¡¨è¾¾å¼è¯­æ³•ï¼ˆæˆ– PEGï¼‰ä½œä¸ºè¾“å…¥ï¼Œå…¶æœ¬è´¨ä¸Šä¸æ­£åˆ™è¡¨è¾¾å¼ç±»ä¼¼ï¼Œä½†æä¾›äº†è§£æå¤æ‚è¯­è¨€æ‰€éœ€çš„å¢å¼ºè¡¨è¾¾èƒ½åŠ›ã€‚ alpha = { 'a'..'z' | 'A'..'Z' } digit = { '0'..'9' } ident = { (alpha | digit)+ } ident_list = _{ !digit ~ ident ~ (\" \" ~ ident)+ } // ^ // ident_list rule is silent (produces no tokens or error reports) int main() { return 5; } - FuncDecl - int_t: \"int \" - Identifier: \"main\" - FormalParams: \"\" - Block > Stmt > Return > Expr > Integer: \"5\" "},"Learn/LearnPolygeist/2021_Polygeist-Raising C to Polyhedral MLIR-translated_only.html":{"url":"Learn/LearnPolygeist/2021_Polygeist-Raising C to Polyhedral MLIR-translated_only.html","title":"2021_Polygeist-Raising C to Polyhedral MLIR-translated_only","keywords":"","body":"GPT-Academic Report Title: Polygeist: Raising C to Polyhedral MLIR Abstract: We present Polygeist, a new compilation flow that connects the MLIR compiler infrastructure to cutting edge polyhedral optimization tools. It consists of a C and C++ frontend capable of converting a broad range of existing codes into MLIR suitable for polyhedral transformation and a bi-directional conversion between MLIR and OpenScop exchange format. The Polygeist/MLIR intermediate representation featuring high-level (affine) loop constructs and n-D arrays embedded into a single static assignment (SSA) substrate enables an unprecedented combination of SSA-based and polyhedral optimizations. We illustrate this by proposing and implementing two extra transformations: statement splitting and reduction parallelization. Our evaluation demonstrates that Polygeist outperforms on average both an LLVM IR-level optimizer (Polly) and a source-to-source state-of-the-art polyhedral compiler (Pluto) when exercised on the Polybench/C benchmark suite in sequential (2.53x vs 1.41x, 2.34x) and parallel mode (9.47x vs 3.26x, 7.54x) thanks to the new representation and transformations. Meta Translation æ ‡é¢˜ï¼šPolygeist: å°†Cæå‡åˆ°å¤šé¢ä½“MLIR æ‘˜è¦ï¼šæˆ‘ä»¬æå‡ºäº†Polygeistï¼Œè¿™æ˜¯ä¸€ç§æ–°çš„ç¼–è¯‘æµç¨‹ï¼Œæ—¨åœ¨å°†MLIRç¼–è¯‘åŸºç¡€è®¾æ–½ä¸å‰æ²¿çš„å¤šé¢ä½“ä¼˜åŒ–å·¥å…·è¿æ¥èµ·æ¥ã€‚å®ƒåŒ…æ‹¬ä¸€ä¸ªCå’ŒC++å‰ç«¯ï¼Œèƒ½å¤Ÿå°†å¹¿æ³›çš„ç°æœ‰ä»£ç è½¬æ¢ä¸ºé€‚åˆå¤šé¢ä½“å˜æ¢çš„MLIRï¼Œå¹¶å®ç°MLIRä¸OpenScopäº¤æ¢æ ¼å¼ä¹‹é—´çš„åŒå‘è½¬æ¢ã€‚Polygeist/MLIRä¸­é—´è¡¨ç¤ºå…·å¤‡é«˜å±‚ï¼ˆä»¿å°„ï¼‰å¾ªç¯æ„é€ å’ŒåµŒå…¥åˆ°å•ä¸€é™æ€èµ‹å€¼ï¼ˆSSAï¼‰åŸºç¡€ç»“æ„ä¸­çš„nç»´æ•°ç»„ï¼Œèƒ½å¤Ÿå®ç°å‰æ‰€æœªæœ‰çš„SSAåŸºç¡€å’Œå¤šé¢ä½“ä¼˜åŒ–çš„ç»“åˆã€‚æˆ‘ä»¬é€šè¿‡æå‡ºå’Œå®ç°ä¸¤ä¸ªé¢å¤–å˜æ¢ï¼šè¯­å¥åˆ†å‰²å’Œå½’çº¦å¹¶è¡ŒåŒ–ï¼Œæ¥è¯æ˜è¿™ä¸€ç‚¹ã€‚æˆ‘ä»¬çš„è¯„ä¼°è¡¨æ˜ï¼ŒPolygeiståœ¨Polybench/CåŸºå‡†å¥—ä»¶çš„é¡ºåºæ¨¡å¼ï¼ˆ2.53xå¯¹æ¯”1.41xï¼Œ2.34xï¼‰å’Œå¹¶è¡Œæ¨¡å¼ï¼ˆ9.47xå¯¹æ¯”3.26xï¼Œ7.54xï¼‰ä¸Šçš„è¡¨ç°å¹³å‡ä¼˜äºLLVM IRçº§åˆ«ä¼˜åŒ–å™¨ï¼ˆPollyï¼‰å’Œå…ˆè¿›çš„æºåˆ°æºå¤šé¢ä½“ç¼–è¯‘å™¨ï¼ˆPlutoï¼‰ï¼Œè¿™å¾—ç›Šäºæ–°çš„è¡¨ç¤ºå’Œå˜æ¢ã€‚ I. INTRODUCTION I. å¼•è¨€ æé«˜è®¡ç®—æ•ˆç‡ä¸€ç›´æ˜¯è®¡ç®—é¢†åŸŸçš„ä¸»è¦ç›®æ ‡ä¹‹ä¸€ã€‚é€šè¿‡åˆ©ç”¨å¹¶è¡Œæ€§ã€æ—¶é—´å’Œç©ºé—´å±€éƒ¨æ€§ä»¥åŠå…¶ä»–æ€§èƒ½æ¥æºï¼Œå¯ä»¥æ˜¾è‘—æé«˜ç¨‹åºæ€§èƒ½ã€‚å½“é’ˆå¯¹ç°ä»£å¤šæ ¸ CPU å’Œ GPU è¿›è¡Œç›¸å…³ç¨‹åºå˜æ¢æ—¶ï¼Œè¿™äº›å˜æ¢å°¤å…¶ç¹çä¸”å…·æœ‰æŒ‘æˆ˜æ€§ï¼Œå› ä¸ºç°ä»£æ¶æ„å…·æœ‰æ·±åº¦å†…å­˜å±‚æ¬¡å’Œå¹¶è¡Œæ€§ï¼Œé€šå¸¸ç”±ä¼˜åŒ–ç¼–è¯‘å™¨è‡ªåŠ¨æ‰§è¡Œã€‚ å¤šé¢ä½“æ¨¡å‹èƒ½å¤Ÿå®ç°ç²¾ç¡®åˆ†æå’Œç›¸å¯¹ç®€å•çš„å˜æ¢è§„èŒƒï¼ˆå¦‚å¾ªç¯é‡æ„ã€è‡ªåŠ¨å¹¶è¡ŒåŒ–ç­‰ï¼‰ï¼Œä»¥åˆ©ç”¨ç¡¬ä»¶æ€§èƒ½æ¥æºã€‚å› æ­¤ï¼Œæœ‰è¶Šæ¥è¶Šå¤šçš„è¯æ®è¡¨æ˜ï¼Œå¤šé¢ä½“æ¨¡å‹æ˜¯é«˜æ•ˆè½¬åŒ–è®¡ç®—å¯†é›†å‹ç¨‹åº [1]ã€[2]ã€[3] å’Œç¼–ç¨‹åŠ é€Ÿå™¨æ¶æ„ [4]ã€[5]ã€[6] çš„æœ€ä½³æ¡†æ¶ä¹‹ä¸€ã€‚å› æ­¤ï¼Œç¼–è¯‘å™¨ç¤¾åŒºä¸“æ³¨äºæ„å»ºå·¥å…·ï¼Œä»¥è¯†åˆ«å’Œä¼˜åŒ–å¯ä»¥åœ¨å¤šé¢ä½“æ¨¡å‹ä¸­è¡¨ç¤ºçš„ç¨‹åºéƒ¨åˆ†ï¼ˆé€šå¸¸ç§°ä¸ºé™æ€æ§åˆ¶éƒ¨åˆ†æˆ– SCoPï¼‰ã€‚è¿™äº›å·¥å…·å¾€å¾€åˆ†ä¸ºä¸¤ç±»ã€‚ åŸºäºç¼–è¯‘å™¨çš„å·¥å…·ï¼Œå¦‚ Polly [7] å’Œ Graphite [8]ï¼Œåœ¨ç¼–è¯‘å™¨ä¸­é—´è¡¨ç¤ºï¼ˆIRï¼‰ä¸­æ£€æµ‹å’Œè½¬æ¢ SCoPã€‚å°½ç®¡è¿™ä¸ç¼–è¯‘å™¨çš„å…¶ä½™éƒ¨åˆ†æ— ç¼é›†æˆï¼Œä½†ç¼ºä¹é«˜å±‚æ¬¡ç»“æ„å’Œä¿¡æ¯é™åˆ¶äº†è¿™äº›å·¥å…·è¿›è¡Œåˆ†æå’Œå˜æ¢çš„èƒ½åŠ›ã€‚è¿™ç§ç»“æ„é€šå¸¸éœ€è¦é€šè¿‡ä¼˜åŒ–åçš„ IR æ¢å¤ï¼Œå¾€å¾€æ˜¯ä»¥ä¸å®Œå…¨æˆ–é«˜æˆæœ¬çš„æ–¹å¼å®ç° [9]ã€‚æ­¤å¤–ï¼Œè¯¸å¦‚ LICM çš„å¸¸è§ç¼–è¯‘å™¨ä¼˜åŒ–å¯èƒ½ä¼šå¹²æ‰°è¿™ä¸€è¿‡ç¨‹ [10]ã€‚æœ€åï¼Œä½çº§ IR é€šå¸¸ç¼ºä¹ç”±å˜æ¢ç”Ÿæˆçš„å¹¶è¡Œæ€§æˆ–å½’çº¦çš„æ„é€ ï¼Œä»è€Œä½¿æµç¨‹æ›´åŠ å¤æ‚ã€‚ æºåˆ°æºç¼–è¯‘å™¨ï¼Œå¦‚ Pluto [11]ã€POCC [12] å’Œ PPCG [5]ï¼Œç›´æ¥åœ¨ C æˆ– C++ ä»£ç ä¸Šæ“ä½œã€‚è™½ç„¶è¿™å¯ä»¥æœ‰æ•ˆåœ°åˆ©ç”¨æºä»£ç ä¸­çš„é«˜å±‚ä¿¡æ¯ï¼Œä½†è¿™äº›å·¥å…·çš„æœ‰æ•ˆæ€§å¾€å¾€å› ç¼ºä¹å¯ç”¨ä¼˜åŒ–è€Œé™ä½ï¼Œä¾‹å¦‚å°†å±é™©çš„å†…å­˜åŠ è½½è½¬æ¢ä¸ºå•èµ‹å€¼è™šæ‹Ÿå¯„å­˜å™¨ã€‚æ­¤å¤–ï¼Œå˜æ¢ç»“æœå¿…é¡»ç”¨ C è¡¨è¾¾ï¼Œè€Œ C è¯­è¨€æœ¬èº«çš„å¤æ‚æ€§ä¼—æ‰€å‘¨çŸ¥ [13]ã€[14]ï¼Œè€Œä¸”ä¹Ÿç¼ºä¹ä¾‹å¦‚å½’çº¦å¾ªç¯æˆ–æœªè¢«å†…å­˜å­˜å‚¨æ”¯æŒçš„å¯„å­˜å™¨å€¼çš„æ„é€ ã€‚ æœ¬æ–‡æå‡ºå¹¶è¯„ä¼°äº†ä¸€ç§å¤šé¢ä½“ç¼–è¯‘æµç¨‹ Polygeistï¼ˆå›¾ 1ï¼‰çš„å¥½å¤„ï¼Œè¯¥æµç¨‹å¯ä»¥åˆ©ç”¨æºä»£ç ä¸­å¯ç”¨çš„é«˜å±‚ç»“æ„ä»¥åŠç”±ä½çº§ IR æä¾›çš„ç¼–è¯‘å™¨ä¼˜åŒ–çš„ç»†ç²’åº¦æ§åˆ¶ã€‚å®ƒæ„å»ºåœ¨æœ€è¿‘çš„ MLIR ç¼–è¯‘å™¨åŸºç¡€è®¾æ–½ä¹‹ä¸Šï¼Œè¯¥åŸºç¡€è®¾æ–½å…è®¸åœ¨åŒä¸€è¡¨ç¤ºä¸­ã€åœ¨åŒä¸€å˜æ¢è¿‡ç¨‹ä¸­æ··åˆå¤šä¸ªæŠ½è±¡å±‚æ¬¡ [15]ã€‚å¯äº’æ¢çš„ MLIR æŠ½è±¡æˆ–æ–¹è¨€åŒ…æ‹¬é«˜å±‚æ„é€ ï¼Œå¦‚å¾ªç¯ã€å¹¶è¡Œå’Œå½’çº¦æ¨¡å¼ï¼›å®Œæ•´è¦†ç›– LLVM IR çš„ä½å±‚è¡¨ç¤º [16]ï¼›ä»¥åŠä¸€ç§å—åˆ°å¤šé¢ä½“å¯å‘çš„è¡¨ç¤ºï¼Œå…·æœ‰å¸¦æœ‰ä»¿å°„è¡¨è¾¾å¼æ³¨é‡Šçš„å¾ªç¯å’Œå†…å­˜è®¿é—®ã€‚æ­¤å¤–ï¼Œé€šè¿‡å°†æºçº§å’Œ IR çº§å·¥å…·çš„ä¼˜åŠ¿ç»“åˆåœ¨ä¸€ä¸ªç«¯åˆ°ç«¯çš„å¤šé¢ä½“æµç¨‹ä¸­ï¼ŒPolygeist ä¿ç•™äº†é«˜å±‚ä¿¡æ¯å¹¶åˆ©ç”¨è¿™äº›ä¿¡æ¯åœ¨è¾ƒä½çº§åˆ«æŠ½è±¡ä¸Šæ‰§è¡Œæ–°çš„æˆ–æ”¹è¿›çš„ä¼˜åŒ–ï¼Œå¦‚è¯­å¥æ‹†åˆ†å’Œå¾ªç¯æºå¸¦å€¼æ£€æµ‹ï¼ŒåŒæ—¶å½±å“åç»­ä¼˜åŒ–ã€‚ æˆ‘ä»¬çš„è´¡çŒ®å¦‚ä¸‹ï¼š â€¢ ä¸€ä¸ª C å’Œ C++ çš„ MLIR å‰ç«¯ï¼Œä¿ç•™åŸå§‹æºä»£ç ä¸­çš„é«˜å±‚å¾ªç¯ç»“æ„ï¼› â€¢ ä¸€ä¸ªç«¯åˆ°ç«¯çš„æµç¨‹ï¼Œå®ç°å‘å¤šé¢ä½“æ¨¡å‹çš„æå‡å’Œé™ä½ï¼Œåˆ©ç”¨æˆ‘ä»¬çš„æŠ½è±¡æ‰§è¡Œæ¯”æºçº§å’Œ IR çº§å·¥å…·æ›´å¤šçš„ä¼˜åŒ–ï¼ŒåŒ…æ‹¬å½’çº¦å¹¶è¡ŒåŒ–ï¼› â€¢ æ¢ç´¢ Polygeist åˆ›å»ºçš„æ–°å˜æ¢æœºä¼šï¼Œå°¤å…¶æ˜¯è¯­å¥æ‹†åˆ†ï¼› â€¢ ä»¥åŠ Polygeist ä¸æœ€å…ˆè¿›çš„åŸºäºæºå’Œ IR çš„å·¥å…·ï¼ˆPluto [11] å’Œ Polly [14]ï¼‰ä¹‹é—´çš„ç«¯åˆ°ç«¯æ¯”è¾ƒï¼Œä»¥åŠä¼˜åŒ–æ¡ˆä¾‹ç ”ç©¶ã€‚ A. Overview A. æ¦‚è¿° MLIRæ˜¯ä¸€ç§ä¼˜åŒ–ç¼–è¯‘å™¨åŸºç¡€è®¾æ–½ï¼Œå—åˆ°LLVMçš„å¯å‘ï¼Œé‡ç‚¹å…³æ³¨æ‰©å±•æ€§å’Œæ¨¡å—åŒ–ã€‚å…¶ä¸»è¦åˆ›æ–°åœ¨äºæ”¯æŒå®Œå…¨å¯æ‰©å±•çš„ä¸€ç»„æŒ‡ä»¤ï¼ˆç§°ä¸ºæ“ä½œï¼‰å’Œç±»å‹çš„ä¸­é—´è¡¨ç¤ºï¼ˆIRï¼‰ã€‚å®é™…ä¸Šï¼ŒMLIRå°†é™æ€å•èµ‹å€¼ï¼ˆSSAï¼‰ä¸åµŒå¥—åŒºåŸŸç›¸ç»“åˆï¼Œä½¿å¾—èƒ½å¤Ÿå°†ä¸€ç³»åˆ—æ¦‚å¿µè¡¨ç¤ºä¸ºä¸€ç±»ä¸€æµçš„æ“ä½œï¼ŒåŒ…æ‹¬æœºå™¨æŒ‡ä»¤ï¼Œä¾‹å¦‚æµ®ç‚¹åŠ æ³•ã€ç»“æ„åŒ–æ§åˆ¶æµï¼Œä¾‹å¦‚å¾ªç¯ã€ç¡¬ä»¶ç”µè·¯ï¼Œä»¥åŠå¤§å‹æœºå™¨å­¦ä¹ å›¾ã€‚æ“ä½œå®šä¹‰äº†ç¨‹åºçš„è¿è¡Œæ—¶è¯­ä¹‰ï¼Œå¹¶å¤„ç†ä¸å¯å˜å€¼ã€‚æœ‰å…³å€¼çš„ç¼–è¯‘æ—¶ä¿¡æ¯ç”¨ç±»å‹è¡¨ç¤ºï¼Œè€Œæœ‰å…³æ“ä½œçš„ä¿¡æ¯ç”¨å±æ€§è¡¨ç¤ºã€‚æ“ä½œå¯ä»¥é™„å¸¦åŒºåŸŸï¼Œè€Œè¿™äº›åŒºåŸŸå†…éƒ¨åˆåŒ…å«å…¶ä»–æ“ä½œçš„ï¼ˆåŸºæœ¬ï¼‰å—ã€‚æ‰€æœ‰æ“ä½œæ¥å—çš„é€šç”¨è¯­æ³•åœ¨å›¾2ä¸­å±•ç¤ºäº†MLIRçš„ç»“æ„ã€‚æ­¤å¤–ï¼ŒMLIRæ”¯æŒç”¨æˆ·è‡ªå®šä¹‰çš„è‡ªå®šä¹‰è¯­æ³•ã€‚ å±æ€§ã€æ“ä½œå’Œç±»å‹è¢«ç»„ç»‡åœ¨æ–¹è¨€ä¸­ï¼Œå¯ä»¥è§†ä¸ºæ¨¡å—åŒ–åº“ã€‚MLIRæä¾›äº†å°‘é‡æ–¹è¨€ï¼Œä»¥å®šä¹‰å¸¸è§æ“ä½œï¼Œå¦‚æ¨¡å—ã€å‡½æ•°ã€å¾ªç¯ã€å†…å­˜æˆ–ç®—æœ¯æŒ‡ä»¤ï¼Œä»¥åŠåƒæ•´æ•°å’Œæµ®ç‚¹æ•°è¿™æ ·çš„é€šç”¨ç±»å‹ã€‚æˆ‘ä»¬å°†åœ¨æ¥ä¸‹æ¥çš„ç« èŠ‚ä¸­è®¨è®ºä¸Polygeistç›¸å…³çš„æ–¹è¨€ã€‚ B. Affine and MemRef Dialects B. ä»¿å°„å’Œå†…å­˜å¼•ç”¨æ–¹è¨€ ä»¿å°„æ–¹è¨€ [18] æ—¨åœ¨è¡¨ç¤ºå…·æœ‰æ˜¾å¼é€‚åˆå¤šé¢ä½“çš„å¾ªç¯å’Œæ¡ä»¶æ„é€ çš„é™æ€è®¡ç®—ç¨‹åºï¼ˆSCoPï¼‰ã€‚å…¶è¡¨ç¤ºçš„æ ¸å¿ƒæ˜¯ä»¥ä¸‹å€¼ç±»åˆ«çš„åˆ†ç±»ï¼š ç¬¦å·â€”â€”å·²çŸ¥ä¸ºå¾ªç¯ä¸å˜ä½†åœ¨ç¼–è¯‘æ—¶æœªçŸ¥çš„æ•´æ•°å€¼ï¼Œåœ¨å¤šé¢ä½“æ–‡çŒ®ä¸­ä¹Ÿç§°ä¸ºç¨‹åºå‚æ•°ï¼Œé€šå¸¸æ˜¯æ•°ç»„ç»´åº¦æˆ–å‡½æ•°å‚æ•°ã€‚åœ¨ MLIR ä¸­ï¼Œç¬¦å·æ˜¯åœ¨å…·æœ‰â€œä»¿å°„èŒƒå›´â€è¯­ä¹‰çš„æ“ä½œçš„é¡¶çº§åŒºåŸŸä¸­å®šä¹‰çš„å€¼ï¼Œä¾‹å¦‚å‡½æ•°ï¼›æˆ–è€…æ•°ç»„ç»´åº¦ã€å¸¸é‡å’Œä»¿å°„æ˜ å°„ï¼ˆè§ä¸‹æ–‡ï¼‰åº”ç”¨ç»“æœï¼Œæ— è®ºå®ƒä»¬çš„å®šä¹‰ç‚¹åœ¨å“ªé‡Œã€‚ ç»´åº¦â€”â€”æ˜¯ç¬¦å·çš„æ‰©å±•ï¼Œæ¥å—ä»¿å°„å¾ªç¯çš„å½’çº³å˜é‡ã€‚ éä»¿å°„â€”â€”ä»»ä½•å…¶ä»–å€¼ã€‚ç¬¦å·å’Œç»´åº¦å…·æœ‰ç´¢å¼•ç±»å‹ï¼Œå³å¹³å°ç‰¹å®šçš„æ•´æ•°ï¼Œé€‚åˆæŒ‡é’ˆï¼ˆåœ¨ C ä¸­ä¸º intptr_tï¼‰ã€‚ MLIR æä¾›äº†ä¸¤ä¸ªä¸ä»¿å°„æ–¹è¨€ç›¸å…³çš„å±æ€§ï¼š ä»¿å°„æ˜ å°„æ˜¯å¤šç»´çš„ï¼ˆå‡†ï¼‰çº¿æ€§å‡½æ•°ï¼Œå®ƒå°†ä¸€ç»„ç»´åº¦å’Œç¬¦å·å‚æ•°æ˜ å°„åˆ°ä¸€ç»„ç»“æœã€‚ä¾‹å¦‚ï¼Œ ( (d_0, d_1, d_2, s_0) \\rightarrow (d_0 + d_1, s_0 \\cdot d_2) ) æ˜¯ä¸€ä¸ªäºŒç»´å‡†ä»¿å°„æ˜ å°„ï¼Œå¯ä»¥åœ¨ MLIR ä¸­è¡¨ç¤ºä¸º affine_map (d0+d1, s0 * d2)>ã€‚ç»´åº¦ï¼ˆå·¦ä¾§çš„æ‹¬å·å†…ï¼‰å’Œç¬¦å·ï¼ˆå·¦ä¾§çš„æ–¹æ‹¬å·å†…ï¼‰è¢«åˆ†éš”å¼€ï¼Œä»¥å…è®¸å‡†çº¿æ€§è¡¨è¾¾å¼ï¼šç¬¦å·è¢«è§†ä¸ºå¸¸é‡ï¼Œå› æ­¤å¯ä»¥ä¸ç»´åº¦ç›¸ä¹˜ï¼Œè€Œä¸¤ä¸ªç»´åº¦çš„ä¹˜ç§¯æ˜¯æ— æ•ˆçš„ã€‚ æ•´æ•°é›†æ˜¯è¢«ï¼ˆå‡†ï¼‰çº¿æ€§è¡¨è¾¾å¼çš„åˆå–é™åˆ¶çš„æ•´æ•°å…ƒç»„é›†åˆã€‚ä¾‹å¦‚ï¼Œâ€œä¸‰è§’å½¢â€é›†åˆ ({(d_0, d_1) : 0 \\leq d_0 affine_set= 0, s0-d0-1 >= 0, d1 >= 0, d0-d1 >= 0)>ã€‚ ä»¿å°„æ–¹è¨€åˆ©ç”¨ä¸Šè¿°æ¦‚å¿µå®šä¹‰äº†ä¸€ç»„æ“ä½œã€‚affine.for æ˜¯ä¸€ä¸ªâ€œforâ€å¾ªç¯ï¼Œå…¶å¾ªç¯ä¸å˜çš„ä¸‹ç•Œå’Œä¸Šç•Œè¡¨ç¤ºä¸ºå¸¦æœ‰å¸¸é‡æ­¥é•¿çš„ä»¿å°„æ˜ å°„ã€‚affine.parallel æ˜¯ä¸€ä¸ªâ€œå¤šé‡forâ€å¾ªç¯åµŒå¥—ï¼Œå…¶è¿­ä»£å¯ä»¥å¹¶å‘æ‰§è¡Œã€‚è¿™ä¸¤ç§å¾ªç¯éƒ½æ”¯æŒé€šè¿‡å¾ªç¯ä¼ é€’å€¼è¿›è¡Œå½’çº¦ï¼Œä»¥åŠ max(min) è¡¨è¾¾å¼çš„ä¸‹ï¼ˆä¸Šï¼‰ç•Œã€‚affine.if æ˜¯ä¸€ä¸ªæ¡ä»¶æ„é€ ï¼Œå¸¦æœ‰ä¸€ä¸ªå¯é€‰çš„ else åŒºåŸŸï¼Œæ¡ä»¶è¢«å®šä¹‰ä¸ºç»™å®šå€¼åŒ…å«åœ¨ä¸€ä¸ªæ•´æ•°é›†ä¸­ã€‚æœ€åï¼Œaffine.load å’Œ affine.store è¡¨ç¤ºå†…å­˜è®¿é—®ï¼Œå…¶ä¸­åœ°å€è®¡ç®—è¡¨ç¤ºä¸ºä»¿å°„æ˜ å°„ã€‚æ ¸å¿ƒçš„ MLIR ç±»å‹â€”â€”å†…å­˜å¼•ç”¨ï¼ˆmemrefï¼‰ï¼Œä»¥åŠç›¸åº”çš„ memref æ–¹è¨€ä¹Ÿåœ¨å›¾ 3 ä¸­å±•ç¤ºã€‚memref ç±»å‹æè¿°äº†æŒ‡å‘å†…å­˜çš„ç»“æ„åŒ–å¤šç´¢å¼•æŒ‡é’ˆï¼Œä¾‹å¦‚ï¼Œmemref è¡¨ç¤ºä¸€ä¸ªæµ®ç‚¹å…ƒç´ çš„ä¸€ç»´æ•°ç»„ï¼›è€Œ memref æ–¹è¨€æä¾›äº†å†…å­˜å’Œç±»å‹æ“ä½œï¼Œä¾‹å¦‚ memref.dim æ£€ç´¢ memref å¯¹è±¡çš„ç»´åº¦ã€‚memref ä¸å…è®¸å†…éƒ¨åˆ«åï¼Œå³ä¸åŒçš„ä¸‹æ ‡å§‹ç»ˆæŒ‡å‘ä¸åŒçš„åœ°å€ã€‚è¿™æœ‰æ•ˆåœ°è§£å†³äº†é™åˆ¶å¤šé¢ä½“æŠ€æœ¯åœ¨ LLVM IR çº§åˆ«åº”ç”¨çš„å»çº¿æ€§åŒ–é—®é¢˜ [9]ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬åªè€ƒè™‘ä¸å…¼å®¹ C ABIï¼ˆåº”ç”¨ç¨‹åºäºŒè¿›åˆ¶æ¥å£ï¼‰çš„è¿ç»­è¡Œä¸»å­˜å‚¨å¯¹åº”çš„é»˜è®¤å¸ƒå±€çš„ memrefsã€‚å®é™…ä¸Šï¼Œmemrefs æ”¯æŒå¯ä½œä¸ºä»¿å°„æ˜ å°„è¡¨è¾¾çš„ä»»æ„å¸ƒå±€ï¼Œä½†åœ¨ Polygeist çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œè¿™äº›å¹¶ä¸æ˜¯å¿…éœ€çš„ã€‚ C. Other Relevant Core Dialects MLIRæä¾›äº†å‡ åç§æ–¹è¨€ã€‚åœ¨è¿™äº›æ–¹è¨€ä¸­ï¼Œåªæœ‰å°‘æ•°å‡ ç§ä¸æˆ‘ä»¬çš„è®¨è®ºç›¸å…³ï¼š ç»“æ„åŒ–æ§åˆ¶æµï¼ˆscfï¼‰æ–¹è¨€å®šä¹‰äº†æ§åˆ¶æµæ“ä½œï¼Œä¾‹å¦‚å¾ªç¯å’Œæ¡ä»¶è¯­å¥ï¼Œè¿™äº›æ“ä½œä¸å—ä»¿å°„åˆ†ç±»è§„åˆ™çš„é™åˆ¶ã€‚ä¾‹å¦‚ï¼Œscf.for å¾ªç¯å¯ä»¥æ¥å—ä»»ä½•æ•´æ•°å€¼ä½œä¸ºå¾ªç¯è¾¹ç•Œï¼Œè¿™äº›è¾¹ç•Œä¸ä¸€å®šæ˜¯ä»¿å°„è¡¨è¾¾å¼ã€‚ æ ‡å‡†ï¼ˆstdï¼‰æ–¹è¨€åŒ…å«å¸¸è§çš„æ“ä½œï¼Œä¾‹å¦‚æ•´æ•°å’Œæµ®ç‚¹ç®—æœ¯ï¼Œè¿™è¢«ç”¨ä½œä»æ›´é«˜çº§åˆ«æ–¹è¨€åˆ°å¤šä¸ªç›®æ ‡æ–¹è¨€çš„å…±åŒé™ä½ç‚¹ï¼Œå¯ä»¥è§†ä¸ºLLVM IRçš„æ¦‚æ‹¬[16]ã€‚ LLVMæ–¹è¨€ç›´æ¥å°†LLVM IRæŒ‡ä»¤å’Œç±»å‹æ˜ å°„åˆ°MLIRï¼Œä¸»è¦æ˜¯ä¸ºäº†ç®€åŒ–å®ƒä»¬ä¹‹é—´çš„è½¬æ¢ã€‚ OpenMPæ–¹è¨€æä¾›äº†ä¸€ç§ä¸æ–¹è¨€å’Œå¹³å°æ— å…³çš„OpenMPæŒ‡ä»¤è¡¨ç¤ºï¼Œä¾‹å¦‚â€œparallelâ€å’Œâ€œworkshare loopâ€ï¼Œå¯ç”¨äºè½¬æ¢OpenMPæ„é€ æˆ–ç”Ÿæˆä¸OpenMPè¿è¡Œæ—¶äº¤äº’çš„LLVM IRã€‚ æ•°å­¦æ–¹è¨€å°†æ•´æ•°å’Œæµ®ç‚¹ç±»å‹ä¸Šçš„æ•°å­¦æ“ä½œï¼ˆè¶…å‡ºç®€å•ç®—æœ¯ï¼‰å½’ä¸ºä¸€ç»„ï¼Œä¾‹å¦‚ï¼Œmath.powæˆ–math.sqrtã€‚ III. AN (AFFINE) MLIR COMPILATION PIPELINE III. ä¸€ä¸ªï¼ˆä»¿å°„ï¼‰MLIRç¼–è¯‘æµç¨‹ Polygeistç¼–è¯‘æµç¨‹ç”±4ä¸ªç»„ä»¶ç»„æˆï¼ˆè§å›¾1ï¼‰ã€‚è¿™ä½¿å¾—Polygeistèƒ½å¤Ÿä¿ç•™åŸå§‹ç¨‹åºä¸­å¯ç”¨çš„æ›´å¤šç»“æ„ï¼ˆä¾‹å¦‚ï¼Œå¤šç»´æ•°ç»„ï¼‰ï¼Œå¹¶èƒ½å¤Ÿä¸MLIRçš„é«˜çº§å†…å­˜æ“ä½œè¿›è¡Œäº¤äº’ã€‚è¿™ä¸ä»»ä½•å…·æœ‰æŒ‡é’ˆå‚æ•°çš„C ABIä¸åŒï¼Œå¹¶ä¸”ä¸Cå‡½æ•°çš„æ¥å£ä¸ä¸€è‡´ã€‚Polygeisté€šè¿‡ä¸ºå‡½æ•°å‚æ•°å’Œåˆ†é…æä¾›ä¸€ä¸ªå±æ€§ï¼Œä½¿å…¶ä½¿ç”¨ä¸Cå…¼å®¹çš„æŒ‡é’ˆç±»å‹ï¼Œè€Œä¸æ˜¯memrefï¼Œé»˜è®¤é€‚ç”¨äºå¤–éƒ¨å‡½æ•°ï¼Œå¦‚strcmpå’Œscanfã€‚å½“ä½¿ç”¨memref ABIå‚æ•°è°ƒç”¨æŒ‡é’ˆ ABIå‡½æ•°æ—¶ï¼ŒPolygeistç”ŸæˆåŒ…è£…ä»£ç ï¼Œä»memrefä¸­æ¢å¤ä¸C ABIå…¼å®¹çš„æŒ‡é’ˆï¼Œå¹¶ç¡®ä¿ç»“æœæ­£ç¡®ã€‚å›¾5å±•ç¤ºäº†ä¸€ä¸ªç¤ºä¾‹ï¼Œæ¼”ç¤ºäº†Polygeistä¸C ABIåœ¨ä¸€ä¸ªå°ç¨‹åºä¸­çš„äº’åŠ¨ã€‚ åœ¨åˆ†é…å’Œé‡Šæ”¾å†…å­˜æ—¶ï¼Œè¿™ç§ABIçš„å·®å¼‚æ˜¾å¾—å°¤ä¸ºé‡è¦ã€‚è¿™æ˜¯å› ä¸ºä½¿ç”¨mallocåˆ†é…æ•°ç»„çš„å‡ ä¸ªå­—èŠ‚åï¼Œå†å°†å…¶è½¬æ¢ä¸ºmemrefå°†ä¸ä¼šäº§ç”Ÿåˆæ³•ä»£ç ï¼ˆå› ä¸ºmemrefæœ¬èº«å¯èƒ½ä¸æ˜¯ç”¨åŸå§‹æŒ‡é’ˆå®ç°çš„ï¼‰ã€‚å› æ­¤ï¼ŒPolygeistè¯†åˆ«å¯¹åˆ†é…å’Œé‡Šæ”¾å‡½æ•°çš„è°ƒç”¨ï¼Œå¹¶å°†å…¶æ›¿æ¢ä¸ºmemrefçš„åˆæ³•ç­‰æ•ˆå‡½æ•°ã€‚ å‡½æ•°å’Œå…¨å±€å˜é‡ä½¿ç”¨Cæˆ–C++ ABIä¸­ä½¿ç”¨çš„ç›¸åŒåç§°å‘å‡ºã€‚è¿™ç¡®ä¿æ‰€æœ‰å¤–éƒ¨å€¼éƒ½è¢«æ­£ç¡®åŠ è½½ï¼Œå¹¶ä¸”å¤šç‰ˆæœ¬å‡½æ•°ï¼ˆå¦‚C++æ¨¡æ¿æˆ–é‡è½½ç”Ÿæˆçš„å‡½æ•°ï¼‰æ‹¥æœ‰ä¸åŒçš„åç§°å’Œå®šä¹‰ã€‚ c) æŒ‡ä»¤ç”Ÿæˆï¼šå¯¹äºå¤§å¤šæ•°æŒ‡ä»¤ï¼ŒPolygeistç›´æ¥å‘å‡ºä¸ç­‰æ•ˆCæ“ä½œç›¸å¯¹åº”çš„MLIRæ“ä½œï¼ˆå¦‚æ•´æ•°åŠ æ³•çš„addiï¼Œå‡½æ•°è°ƒç”¨çš„callç­‰ï¼‰ã€‚å¯¹äºæŸäº›ç‰¹æ®ŠæŒ‡ä»¤ï¼Œå¦‚å¯¹powçš„è°ƒç”¨ï¼ŒPolygeisté€‰æ‹©å‘å‡ºMathæ–¹è¨€ä¸­ç‰¹å®šçš„MLIRæ“ä½œï¼Œè€Œä¸æ˜¯è°ƒç”¨å¤–éƒ¨å‡½æ•°ï¼ˆåœ¨libmä¸­å®šä¹‰ï¼‰ã€‚è¿™ä½¿å¾—è¿™äº›æŒ‡ä»¤èƒ½å¤Ÿåœ¨MLIRä¸­æ›´å¥½åœ°è¿›è¡Œåˆ†æå’Œä¼˜åŒ–ã€‚ æ¶‰åŠå†…å­˜æˆ–æŒ‡é’ˆç®—æœ¯çš„æ“ä½œéœ€è¦é¢å¤–å¤„ç†ã€‚MLIRæ²¡æœ‰é€šç”¨çš„æŒ‡é’ˆç®—æœ¯æŒ‡ä»¤ï¼›ç›¸åï¼Œå®ƒè¦æ±‚loadå’Œstoreæ“ä½œåŒ…å«æ‰€æœ‰è¢«æŸ¥æ‰¾çš„ç´¢å¼•ã€‚è¿™ä¸ºæ‰§è¡ŒæŒ‡é’ˆç®—æœ¯çš„æ“ä½œå¸¦æ¥äº†é—®é¢˜ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¼•å…¥äº†ä¸€ä¸ªä¸´æ—¶å­ç´¢å¼•æ“ä½œï¼Œç”¨äºmemrefï¼Œä»¥è·Ÿè¸ªé™„åŠ çš„åœ°å€åç§»ã€‚åœ¨Polygeistä¸­çš„åç»­ä¼˜åŒ–è¿‡ç¨‹ä¸­ï¼Œå°†å­ç´¢å¼•ä¸­çš„åç§»é‡è½¬å‘ç»™ä»»ä½•ä½¿ç”¨å®ƒä»¬çš„loadæˆ–storeã€‚ d) å±€éƒ¨å˜é‡ï¼šå±€éƒ¨å˜é‡é€šè¿‡åœ¨å‡½æ•°é¡¶éƒ¨åˆ†é…ä¸€ä¸ªmemrefåœ¨æ ˆä¸Šè¿›è¡Œå¤„ç†ã€‚è¿™ä½¿å¾—Cæˆ–C++çš„æ‰€éœ€è¯­ä¹‰èƒ½å¤Ÿç›¸å¯¹å®¹æ˜“åœ°å®ç°ã€‚ç„¶è€Œï¼Œç”±äºè®¸å¤šå±€éƒ¨å˜é‡å’Œå‚æ•°åŒ…å«memrefç±»å‹ï¼Œè¿™ç«‹å³å¯¼è‡´äº†memrefçš„memref-è¿™å¯¹å¤§å¤šæ•°MLIRä¼˜åŒ–æ¥è¯´æ˜¯ä¸€ä¸ªéšœç¢ï¼Œå› ä¸ºåœ¨Polygeistä¹‹å¤–è¿™æ˜¯ä¸åˆæ³•çš„ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å®ç°äº†ä¸€ä¸ªé‡é‡çº§çš„å†…å­˜åˆ°å¯„å­˜å™¨ï¼ˆmem2regï¼‰è½¬æ¢è¿‡ç¨‹ï¼Œè¯¥è¿‡ç¨‹æ¶ˆé™¤äº†MLIRæ„é€ ä¸­çš„ä¸å¿…è¦çš„åŠ è½½ã€å­˜å‚¨å’Œåˆ†é…ã€‚æ ¹æ®ç»éªŒï¼Œè¿™æ¶ˆé™¤äº†Polybenchå¥—ä»¶ä¸­æ‰€æœ‰memrefçš„memrefã€‚ B. Raising to Affine å°†Cæˆ–C++ç›´æ¥ç¿»è¯‘ä¸ºMLIRèƒ½å¤Ÿä¿ç•™å…³äºå¾ªç¯ç»“æ„å’Œnç»´æ•°ç»„çš„é«˜çº§ä¿¡æ¯ï¼Œä½†ä¸ä¼šç”Ÿæˆå…¶ä»–çš„ä»¿å°„æ“ä½œã€‚ä¹‹åï¼ŒPolygeistå°†å†…å­˜ã€æ¡ä»¶å’Œå¾ªç¯æ“ä½œæå‡è‡³å…¶ä»¿å°„æ–¹è¨€å¯¹åº”ç‰©ï¼Œå¦‚æœå®ƒèƒ½å¤Ÿè¯æ˜è¿™äº›æ“ä½œæ˜¯åˆæ³•çš„ä»¿å°„æ“ä½œã€‚å¦‚æœç›¸åº”çš„å‰ç«¯ä»£ç è¢«åŒ…è£¹åœ¨#pragma scopä¸­ï¼ŒPolygeistå‡è®¾åœ¨è¯¥åŒºåŸŸå†…æå‡æ‰€æœ‰æ“ä½œæ˜¯å§‹ç»ˆåˆæ³•çš„ï¼Œä¸”æ— éœ€é¢å¤–æ£€æŸ¥ã€‚å¯¹äºä»»ä½•æœªè¢«è¯æ˜æˆ–å‡è®¾ä¸ºä»¿å°„çš„æ“ä½œï¼Œåˆ™ä¿æŒä¸å˜ã€‚æˆ‘ä»¬å¯¹ä»¿å°„æ˜ å°„è¿›è¡Œç®€åŒ–ï¼Œä»¥å»é™¤å…·æœ‰é›¶æ¬¡æˆ–ä¸€æ¬¡è¿­ä»£çš„å¾ªç¯ï¼Œå¹¶åˆ é™¤åœ¨ç¼–è¯‘æ—¶å·²çŸ¥æ¡ä»¶çš„æ¡ä»¶è¯­å¥çš„åˆ†æ”¯ã€‚ a) Memory operations and loop bounds: a) å†…å­˜æ“ä½œå’Œå¾ªç¯è¾¹ç•Œï¼šä¸ºäº†è½¬æ¢ä¸€ä¸ªæ“ä½œï¼ŒPolygeist ç”¨æ’ç­‰ä»¿å°„æ˜ å°„ï¼ˆaffine_map(s0)>[%bound]ï¼‰æ›¿æ¢å…¶è¾¹ç•Œå’Œä¸‹æ ‡æ“ä½œæ•°ã€‚å®ƒç„¶åå°†è®¡ç®—æ˜ å°„æ“ä½œæ•°çš„æ“ä½œï¼Œä¾‹å¦‚åŠ æ³•ï¼ˆaddiï¼‰ã€ä¹˜æ³•ï¼ˆmuliï¼‰ï¼ŒæŠ˜å åˆ°æ˜ å°„æœ¬èº«ä¸­ã€‚ä»å¾ªç¯å½’çº³å˜é‡ä¼ é€’å¾—å‡ºçš„å€¼å˜æˆäº†æ˜ å°„ç»´åº¦ï¼Œå…¶ä»–å€¼åˆ™å˜æˆç¬¦å·ã€‚ä¾‹å¦‚ï¼Œaffine_map(s0)> [%bound] åœ¨ %bound = addi %N, %i çš„æƒ…å†µä¸‹ï¼Œå…¶ä¸­ %i æ˜¯ä¸€ä¸ªå½’çº³å˜é‡ï¼Œè¢«æŠ˜å ä¸º affine_map(s0 + d0)>(%i)[%N]ã€‚è¯¥è¿‡ç¨‹åœ¨æ— æ³•å†æŠ˜å æ“ä½œæˆ–æ»¡è¶³ä»¿å°„å€¼åˆ†ç±»è§„åˆ™æ—¶ç»ˆæ­¢ã€‚ b) æ¡ä»¶è¯­å¥ï¼šå‰ç«¯ä¸ºä¸¤ç§è¾“å…¥ä»£ç æ¨¡å¼ï¼ˆif æ¡ä»¶å’Œä¸‰å…ƒè¡¨è¾¾å¼ï¼‰ç”Ÿæˆæ¡ä»¶æ“ä½œã€‚æ¡ä»¶é€šè¿‡å¼•å…¥æ•´æ•°é›†åˆå¹¶å°†æ“ä½œæ•°æŠ˜å åˆ°å…¶ä¸­è¿›è¡Œè½¬æ¢ï¼Œç±»ä¼¼äºä»¿å°„æ˜ å°„ï¼Œæ­¤å¤–ï¼Œæ“ä½œä¹‹é—´çš„åŠ æ³•å’Œè¿ç®—åˆ†éš”é›†åˆçº¦æŸï¼Œè€Œéè¿ç®—åˆ™å¯¹å…¶è¿›è¡Œåè½¬ï¼ˆaffine.if ä»…æ¥å— â‰¥ 0 å’Œ = 0 çš„çº¦æŸï¼‰ã€‚Polygeist å¤„ç†åµŒå¥—æ¡ä»¶æ—¶éµå¾ª C é£æ ¼çš„çŸ­è·¯è¯­ä¹‰ï¼Œå…¶ä¸­åç»­æ¡ä»¶åœ¨å‰é¢æ¡ä»¶çš„ä¸»ä½“å†…è¿›è¡Œæ£€æŸ¥ï¼Œå½“æ³•å¾‹å…è®¸æ—¶ï¼Œå°†æ¡ä»¶æå‡åˆ°æœ€å¤–å±‚æ¡ä»¶ä¹‹å¤–ï¼Œå¹¶ç”¨å¸ƒå°”æ“ä½œæˆ–é€‰æ‹©æ“ä½œæ›¿æ¢å®ƒä»¬ã€‚åœ¨ #pragma scop å†…ï¼Œè¿™æ€»æ˜¯åˆæ³•çš„ã€‚ ä¸ºä¸‰å…ƒè¡¨è¾¾å¼ç”Ÿæˆçš„æ¡ä»¶è¯­å¥é€šå¸¸æ¶‰åŠå…¶åŒºåŸŸå†…çš„å†…å­˜åŠ è½½ï¼Œç”±äºå‰¯ä½œç”¨ï¼Œå¯¼è‡´æ— æ³•æå‡ã€‚æˆ‘ä»¬é‡ç”¨ mem2reg é€šé“ï¼Œåœ¨å¯èƒ½çš„æƒ…å†µä¸‹å°†å…¶æ›¿æ¢ä¸ºç­‰æ•ˆçš„æ—©æœŸåŠ è½½ï¼Œä»¥å®ç°æå‡ã€‚ä»ç»éªŒä¸Šçœ‹ï¼Œè¿™è¶³ä»¥å¤„ç† Polybench/C å¥—ä»¶ä¸­çš„æ‰€æœ‰ä¸‰å…ƒè¡¨è¾¾å¼ [19]ã€‚å¦åˆ™ï¼Œä¸‰å…ƒè¡¨è¾¾å¼å°†éœ€è¦è¢«ä¸‹æ¸¸å¤šé¢ä½“é€šé“æ‰“åŒ…æˆå•ä¸ªè¯­å¥ã€‚ C. Connecting MLIR to Polyhedral Tools è¾“å…¥ç¨‹åºä¸­ä½¿ç”¨ MLIR Affine æ–¹è¨€è¡¨è¾¾çš„åŒºåŸŸé€‚ç”¨äºå¤šé¢ä½“æ¨¡å‹ã€‚ç„¶è€Œï¼Œç°æœ‰å·¥å…·æ— æ³•ç›´æ¥ä½¿ç”¨ MLIRã€‚å› æ­¤ï¼Œæˆ‘ä»¬é€‰æ‹©å®ç°ä¸ OpenScop [20] çš„åŒå‘è½¬æ¢ï¼Œè¿™æ˜¯ä¸€ç§å¯è¢«ä¼—å¤šå¤šé¢ä½“å·¥å…·ç›´æ¥ä½¿ç”¨çš„äº¤æ¢æ ¼å¼ï¼ŒåŒ…æ‹¬ Pluto [11]ï¼Œå¹¶ä¸”è¿›ä¸€æ­¥å¯è½¬æ¢ä¸º isl [21] è¡¨ç¤ºã€‚è¿™ä½¿å¾— Polygeist èƒ½å¤Ÿä¸åœ¨å¤šé¢ä½“ç¼–è¯‘ç ”ç©¶ä¸­åˆ›å»ºçš„å·¥å…·æ— ç¼è¿æ¥ï¼Œè€Œæ— éœ€ä¿®æ”¹è¿™äº›å·¥å…·ä»¥æ”¯æŒ MLIRã€‚ å¤§å¤šæ•°å¤šé¢ä½“å·¥å…·è®¾è®¡ç”¨äºå¤„ç†ä»¥è¯­å¥ä¸ºåŸºç¡€çš„ C æˆ– FORTRAN è¾“å…¥ï¼Œè€Œå®ƒä»¬åœ¨ MLIR ä¸­å¹¶æ²¡æœ‰ç›´æ¥å¯¹åº”çš„ç­‰ä»·ç‰©ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ç§æœºåˆ¶ï¼Œä»ä¸€ç³»åˆ— MLIR æ“ä½œåˆ›å»ºç±»ä¼¼è¯­å¥çš„ç»“æ„ã€‚ä¾‹å¦‚ï¼š void setArray(int N, double val, double * array) {...} int main(int argc, char ** argv) { ... cmp = strcmp(str1, str2) ... double array [10]; setArray(10, 42.0, array) } å¯è½¬æ¢ä¸ºï¼š func @setArray(%N: i32, %val: f64, %array: memref) { %0 = index_cast %N : i32 to index affine.for %i = 0 to %0 { affine.store %val, %array[%i] : memref } return } func @main(%argc: i32, %argv: !llvm.ptr>) -> i32 { ... %cmp = llvm.call @strcmp(%str1, %str2) : (!llvm.ptr, !llvm.ptr) -> !llvm.i32 ... %array = memref.alloca() : memref %arraycst = memref.cast %array : memref to memref %val = constant 42.0 : f64 call @setArray(%N, %val, %arraycst) : (i32, f64, memref) -> () } å›¾ 5. ç¤ºä¾‹æ¼”ç¤ºäº† Polygeist çš„ ABIã€‚å¯¹äºé¢„æœŸè¦ç”± Polygeist ç¼–è¯‘çš„å‡½æ•°ï¼ˆå¦‚ setArrayï¼‰ï¼ŒæŒ‡é’ˆå‚æ•°è¢«æ›¿æ¢ä¸º memrefã€‚å¯¹äºéœ€è¦å¤–éƒ¨è°ƒç”¨çº¦å®šï¼ˆå¦‚ main/strcmpï¼‰çš„å‡½æ•°ï¼ŒPolygeist é€€å›åˆ°å‘å‡º llvm.ptr å¹¶ç”Ÿæˆè½¬æ¢ä»£ç çš„æ–¹å¼ã€‚ æˆ‘ä»¬è¿›ä¸€æ­¥è¯æ˜ï¼Œè¿™ä½¿å¾— Polygeist èƒ½å¤Ÿé€šè¿‡æ§åˆ¶è¯­å¥ç²’åº¦ï¼Œç§¯æå½±å“å¤šé¢ä½“è°ƒåº¦å™¨çš„è¡Œä¸ºï¼ˆè¯¦è§ç¬¬ III-D èŠ‚ï¼‰ã€‚ a) ç®€å•è¯­å¥å½¢æˆï¼šè§‚å¯Ÿåˆ°ç¬¦åˆå¤šé¢ä½“æ¨¡å‹çš„Cè¯­å¥ä¸»è¦æ˜¯å˜é‡èµ‹å€¼ï¼Œæˆ‘ä»¬å¯ä»¥æ¨å¯¼å‡ºä¸€ç§æœºåˆ¶ï¼Œä»MLIRæ“ä½œé“¾ä¸­è¯†åˆ«è¯­å¥ã€‚å­˜å‚¨åˆ°å†…å­˜ä¸­çš„æ“ä½œæ˜¯è¯¥è¯­å¥çš„æœ€åä¸€ä¸ªæ“ä½œã€‚è¯¥æ“ä½œçš„é€†å‘åˆ‡ç‰‡ï¼Œå³ä¼ é€’è®¡ç®—å…¶æ“ä½œæ•°çš„æ“ä½œï¼Œå±äºè¯¥è¯­å¥ã€‚åˆ‡ç‰‡æ‰©å±•åœ¨ç”Ÿæˆè¢«åˆ†ç±»ä¸ºä»¿å°„ç»´åº¦æˆ–ç¬¦å·çš„å€¼çš„æ“ä½œå¤„åœæ­¢ï¼Œè¿™äº›å€¼å¯ä»¥ç›´æ¥ç”¨äºä»¿å°„è¡¨è¾¾å¼ã€‚æ­¤ç±»å€¼åŒ…æ‹¬å¾ªç¯å½’çº³å˜é‡æˆ–å¾ªç¯ä¸å˜å¸¸é‡ã€‚ä¸€äº›æ“ä½œå¯èƒ½å‡ºç°åœ¨å¤šä¸ªè¯­å¥ä¸­ï¼Œå¦‚æœè¯¥å€¼è¢«å¤šæ¬¡ä½¿ç”¨ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬éœ€è¦æ“ä½œä¸è¯­å¥ä¹‹é—´çš„æ˜ å°„æ˜¯åŒå‘çš„ï¼Œä»¥ä¾¿åœ¨è°ƒåº¦å™¨é‡æ–°ç»“æ„åŒ–ç¨‹åºåå‘å‡ºMLIRï¼Œè€Œä¸è€ƒè™‘SSAå€¼çš„å¯è§æ€§è§„åˆ™ã€‚å¦‚æœä¸€ä¸ªå¤šæ¬¡ä½¿ç”¨çš„æ“ä½œæ²¡æœ‰å‰¯ä½œç”¨ï¼ŒPolygeistä¼šç®€å•åœ°å¤åˆ¶å®ƒã€‚å¯¹äºé‡å¤æ“ä½œçš„å¤åˆ¶ä¸åˆæ³•çš„æƒ…å†µï¼ŒPolygeistå°†å…¶ç»“æœå­˜å‚¨åœ¨å †æ ˆåˆ†é…çš„å†…å­˜å¼•ç”¨ä¸­ï¼Œå¹¶å°†æ‰€æœ‰åç»­ä½¿ç”¨æ›¿æ¢ä¸ºå†…å­˜åŠ è½½ã€‚å›¾6å±•ç¤ºäº†åœ¨æ“ä½œ%20ä¸­ä½¿ç”¨çš„å€¼%0çš„è½¬æ¢ã€‚è¿™åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„è¯­å¥ã€‚ b) è·¨åŒºåŸŸä¾èµ–å…³ç³»ï¼šåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä¸€ä¸ªè¯­å¥å¯èƒ½ç”±ä¸åŒï¼ˆåµŒå¥—ï¼‰å¾ªç¯ä¸­çš„MLIRæ“ä½œç»„æˆï¼Œä¾‹å¦‚ï¼Œä»å†…å­˜åŠ è½½åˆ°SSAå¯„å­˜å™¨çš„æ“ä½œå‘ç”Ÿåœ¨å¤–éƒ¨å¾ªç¯ä¸­ï¼Œè€Œå®ƒåœ¨å†…éƒ¨å¾ªç¯ä¸­è¢«ä½¿ç”¨ã€‚è¯¥è¯­å¥åœ¨å¾ªç¯å±‚æ¬¡ç»“æ„ä¸­çš„ä½ç½®å¹¶ä¸æ˜ç¡®ã€‚æ›´é‡è¦çš„æ˜¯ï¼Œæ— æ³•å°†å…¶ä¼ è¾¾ç»™å¤šé¢ä½“è°ƒåº¦å™¨ã€‚Polygeisté€šè¿‡åœ¨å®šä¹‰åŒºåŸŸä¸­å°†å€¼å­˜å‚¨åœ¨å †æ ˆåˆ†é…çš„å†…å­˜å¼•ç”¨ä¸­ï¼Œå¹¶åœ¨ä½¿ç”¨åŒºåŸŸä¸­å°†å…¶åŠ è½½å›å»ï¼Œä»è€Œè§£å†³äº†è¿™ä¸€é—®é¢˜ã€‚å›¾6å±•ç¤ºäº†åœ¨æ“ä½œ%10ä¸­ä½¿ç”¨çš„å€¼%0çš„è¿™ç§è½¬æ¢ã€‚ä¸åŸºæœ¬æƒ…å†µç±»ä¼¼ï¼Œè¿™åœ¨å¤–éƒ¨å¾ªç¯ä¸­åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„è¯­å¥ï¼Œå¯ä»¥ç‹¬ç«‹è°ƒåº¦ã€‚è¯¥æ–¹æ³•å¯ä»¥è§†ä¸ºreg2memè½¬æ¢ï¼Œè¿™æ˜¯åœ¨å‰ç«¯æ‰§è¡Œçš„mem2regçš„åå‘æ“ä½œã€‚å®ƒä»…é€‚ç”¨äºä¸€éƒ¨åˆ†å€¼ï¼Œå¹¶ä¸”åœ¨å¤šé¢ä½“è°ƒåº¦å®Œæˆåå¯ä»¥æ’¤é”€ã€‚æ­¤å¤–ï¼Œä¸ºäº†å‡å°‘ä¾èµ–å…³ç³»å’Œå†…å­˜å ç”¨ï¼ŒPolygeistæ‰§è¡Œç®€å•çš„å€¼åˆ†æï¼Œå¹¶åœ¨åŒä¸€å€¼åœ¨å¦ä¸€ä¸ªå†…å­˜ä½ç½®å¯ç”¨å¹¶èƒ½å¤Ÿä»é‚£é‡Œè¯»å–æ—¶ï¼Œé¿å…åˆ›å»ºå †æ ˆåˆ†é…çš„ç¼“å†²åŒºã€‚ c) SCoP å½¢æˆï¼šä¸ºäº†å®šä¹‰ä¸€ä¸ª SCoPï¼Œæˆ‘ä»¬å°†å•ç‹¬çš„è¯­å¥åˆ’åˆ†ä¸ºå‡½æ•°ï¼Œè¿™æ ·å®ƒä»¬å°±å¯ä»¥è¢«è¡¨ç¤ºä¸ºå…·æœ‰å·²çŸ¥å†…å­˜å ç”¨çš„é€æ˜è°ƒç”¨ï¼Œç±»ä¼¼äº Pencil [22]ã€‚è¿™ä¸ªè¿‡ç¨‹ä¹Ÿä½¿å¾—è¯­å¥é—´çš„ SSA ä¾èµ–å…³ç³»å˜å¾—æ¸…æ™°ã€‚è¿™äº›ä¾èµ–å…³ç³»å­˜åœ¨äºä½¿ç”¨ç›¸åŒ SSA å€¼çš„è°ƒç”¨ä¹‹é—´ï¼Œä½†è¿™äº›è°ƒç”¨æ²¡æœ‰å®šä¹‰ä»»ä½•å€¼ã€‚æˆ‘ä»¬æå‡æ‰€æœ‰å±€éƒ¨æ ˆåˆ†é…ï¼Œå¹¶å°†å®ƒä»¬æ”¾ç½®åœ¨å‘¨å›´å‡½æ•°çš„å…¥å£å—ä¸­ï¼Œä»¥ä¿æŒå®ƒä»¬åœ¨å¾ªç¯é‡æ„åä»ç„¶å¯è§ã€‚å›¾ 7 å±•ç¤ºäº†å¾—åˆ°çš„ IRã€‚ å¤šé¢ä½“è¡¨ç¤ºçš„å…¶ä½™ç»„ä»¶å¦‚ä¸‹æ´¾ç”Ÿï¼šè¯­å¥çš„åŸŸè¢«å®šä¹‰ä¸ºå…¶æ‰€åŒ…å«å¾ªç¯çš„è¿­ä»£ç©ºé—´ï¼Œç”±å„è‡ªçš„ä¸‹ç•Œå’Œä¸Šç•Œçº¦æŸï¼Œå¹¶ä¸ä»»ä½•â€œifâ€æ¡ä»¶ç›¸äº¤ã€‚è¿™ä¸ªè¿‡ç¨‹åˆ©ç”¨äº† MLIR ç›´æ¥å°†è¾¹ç•Œå’Œæ¡ä»¶è¡¨ç¤ºä¸ºä»¿å°„æ„é€ çš„ç‰¹æ€§ã€‚æ¯ä¸ªè¯­å¥çš„è®¿é—®å…³ç³»ä½œä¸º affine.loadï¼ˆè¯»å–ï¼‰å’Œ affine.storeï¼ˆå¿…é¡»å†™å…¥ï¼‰æ“ä½œçš„ä»¿å°„æ˜ å°„çš„å¹¶é›†è·å¾—ï¼Œå…³ç³»çš„å³ä¾§è¢«æ³¨é‡Šä¸ºä¸è¢«è®¿é—®çš„ memref å¯¹åº”çš„â€œæ•°ç»„â€ï¼Œè¿™å¯¹åº”äº SSA å€¼ã€‚åˆå§‹è°ƒåº¦æ˜¯ä½¿ç”¨ (2d + 1) å½¢å¼åˆ†é…çš„ï¼Œå¥‡æ•°ç»´åº¦è¡¨ç¤ºè¾“å…¥ç¨‹åºä¸­å¾ªç¯çš„è¯æ³•é¡ºåºï¼Œè€Œå¶æ•°ç»´åº¦ç­‰äºå¾ªç¯å¼•å¯¼å˜é‡ã€‚OpenScop ä¸­çš„ä»¿å°„æ„é€ è¡¨ç¤ºä¸ºçº¿æ€§ç­‰å¼ (= 0) æˆ–ä¸ç­‰å¼ (â‰¥ 0) ç³»æ•°çš„åˆ—è¡¨ï¼Œè¿™æ­£å¥½ä¸ MLIR ä¸­çš„å†…éƒ¨è¡¨ç¤ºç›¸åŒ¹é…ï¼Œä½¿è½¬æ¢å˜å¾—ç®€å•æ˜äº†ã€‚ d) ä»£ç ç”Ÿæˆå› MLIRï¼šPluto è°ƒåº¦å™¨å› æ­¤ç”Ÿæˆäº† OpenScop ä¸­çš„æ–°è°ƒåº¦ã€‚ä»ä»¿å°„è°ƒåº¦ç”Ÿæˆå¾ªç¯ç»“æ„æ˜¯ä¸€ä¸ªå·²è§£å†³ä½†ç›¸å½“å¤æ‚çš„é—®é¢˜ [13]ï¼Œ[14]ã€‚Polygeist ä¾èµ–äº CLooG [13] æ¥ç”Ÿæˆåˆå§‹çš„å¾ªç¯çº§ ASTï¼Œç„¶åå°†å…¶è½¬æ¢ä¸ºä»¿å°„æ–¹è¨€çš„å¾ªç¯å’Œæ¡ä»¶ã€‚åœ¨ä»£ç ç”Ÿæˆæ—¶æ— éœ€ç®€åŒ–ä»¿å°„è¡¨è¾¾å¼ï¼Œå› ä¸º MLIR å¯ä»¥ç›´æ¥æ¥å—å®ƒä»¬ï¼Œå¹¶èƒ½å¤Ÿåœ¨åç»­é˜¶æ®µè¿›è¡Œç®€åŒ–ã€‚è¯­å¥ä½œä¸ºå…·æœ‰é‡å†™æ“ä½œæ•°çš„å‡½æ•°è°ƒç”¨å¼•å…¥ï¼Œç„¶åè¿›è¡Œå†…è”ã€‚ D. Controlling Statement Granularity D. æ§åˆ¶è¯­å¥ç²’åº¦ å›æƒ³ä¸€ä¸‹ï¼ŒPolygeist æ˜¯é€šè¿‡åŸå§‹æ“ä½œçš„åºåˆ—é‡å»ºâ€œè¯­å¥â€çš„ï¼ˆè§ç¬¬ä¸‰èŠ‚Cï¼‰ã€‚æˆ‘ä»¬æœ€åˆè®¾è®¡äº†ä¸€ç§æ¢å¤ä¸ C è¾“å…¥ä¸­ç›¸ä¼¼çš„è¯­å¥ç»“æ„çš„æ–¹æ³•ï¼Œä½†è¿™å¹¶ä¸æ˜¯å¿…éœ€çš„ã€‚å®é™…ä¸Šï¼Œåªè¦å¯ä»¥å°†è¯­å¥ç»„ç»‡æˆå¾ªç¯å¹¶è¿›è¡Œæ‹“æ‰‘æ’åºï¼ˆå³è¯­å¥ä¹‹é—´æ²¡æœ‰ä½¿ç”¨-å®šä¹‰å¾ªç¯ï¼‰ï¼Œè¯­å¥å¯ä»¥ç”±ä»»ä½•å­é›†çš„ MLIR æ“ä½œå½¢æˆã€‚ä¸ºäº†å‘ä»¿å°„è°ƒåº¦å™¨æš´éœ²è¿™äº›è¯­å¥ä¹‹é—´çš„ä¾èµ–å…³ç³»ï¼Œæˆ‘ä»¬é‡ç”¨äº†é€šè¿‡ä¸´æ—¶å­˜å‚¨å™¨çš„æ€æƒ³ï¼šæ¯ä¸ªè¯­å¥å°†å…¶ä»–è¯­å¥æ‰€éœ€çš„å€¼å†™å…¥ä¸“ç”¨å†…å­˜ä½ç½®ï¼Œéšåè¯­å¥ä»è¿™äº›ä½ç½®è¯»å–ã€‚ä¸´æ—¶å­˜å‚¨å™¨å—åˆ°éƒ¨åˆ†æ•°ç»„æ‰©å±•çš„é™åˆ¶[23]ï¼Œä»¥æœ€å°åŒ–å®ƒä»¬å¯¹ä»¿å°„è°ƒåº¦å™¨çš„å½±å“ï¼Œå› ä¸ºå•å…ƒç´ çš„ä¸´æ—¶å­˜å‚¨å™¨æ•°ç»„ä¼šäº§ç”Ÿäººä¸ºçš„æ ‡é‡ä¾èµ–å…³ç³»ã€‚è¿™ç§è¯­å¥ç²’åº¦çš„å˜åŒ–ä¸ºä»¿å°„è°ƒåº¦å™¨æä¾›äº†å‰æ‰€æœªæœ‰çš„çµæ´»æ€§ï¼Œä½¿å…¶èƒ½å¤Ÿä¸ºåŒä¸€ C è¯­å¥çš„ä¸åŒéƒ¨åˆ†é€‰æ‹©ä¸åŒçš„è°ƒåº¦ã€‚ä»¥å›¾8ï¼ˆé¡¶éƒ¨ï¼‰ä¸­çš„è¯­å¥ S ä¸ºä¾‹ï¼Œè¯¥è¯­å¥è¢«ä¸‰ä¸ªé’ˆå¯¹ iã€j å’Œ k çš„å¾ªç¯åŒ…å›´ã€‚è¿™ç§æ”¶ç¼©æ¨¡å¼åœ¨è®¡ç®—ç¨‹åºä¸­å¾ˆå¸¸è§ï¼ˆæ­¤ç‰¹å®šç¤ºä¾‹å¯ä»¥åœ¨ç›¸å…³åŸºå‡†ä¸­æ‰¾åˆ°ï¼ŒBâ‰¡Cï¼Œè§ç¬¬äº”èŠ‚Eï¼‰ã€‚æœ€ä½³åˆ©ç”¨å±€éƒ¨æ€§çš„å¾ªç¯é¡ºåºæ˜¯ (k, i, j)ï¼Œè¿™å¯¹ä» B çš„è¯»å–äº§ç”Ÿæ—¶æ•ˆå±€éƒ¨æ€§ï¼ˆè¯¥å€¼åœ¨ç°åœ¨æœ€å†…å±‚çš„ j å¾ªç¯çš„æ‰€æœ‰è¿­ä»£ä¸­è¢«é‡ç”¨ï¼‰å¹¶å¯¹ä» C çš„è¯»å–äº§ç”Ÿç©ºé—´å±€éƒ¨æ€§ï¼ˆè¿ç»­çš„å€¼è¢«è¿ç»­çš„è¿­ä»£è¯»å–ï¼Œä»è€Œå¢åŠ äº† L1 ç¼“å­˜å‘½ä¸­ç‡çš„å¯èƒ½æ€§ï¼‰ã€‚ç„¶è€Œï¼ŒPluto ä»æœªæå‡ºè¿™æ ·çš„é¡ºåºï¼Œå› ä¸ºåœ¨ k ç»´åº¦ä¸Šç”±äºå¯¹ A[i][j] çš„é‡å¤è¯»/å†™è®¿é—®è€Œå­˜åœ¨å‡å°‘ä¾èµ–å…³ç³»ï¼ŒPluto è¶‹å‘äºé€‰æ‹©ä¾èµ–å…³ç³»è¾ƒå°‘çš„å¾ªç¯ä½œä¸ºæœ€å¤–å±‚ã€‚è™½ç„¶è¿™ç§ä¾èµ–å…³ç³»æœ¬èº«æ˜¯ä¸å¯é¿å…çš„ï¼Œä½†å®ƒå¯ä»¥è½¬ç§»åˆ°å›¾8ï¼ˆåº•éƒ¨å·¦ä¾§ï¼‰çš„å•ç‹¬è¯­å¥ T ä¸­ã€‚è¿™ç§æ–¹æ³•ä¸ºè°ƒåº¦å™¨æä¾›äº†æ›´å¤šçš„é€‰æ‹©è‡ªç”±åº¦ï¼Œå†…å­˜æˆæœ¬ç›¸å¯¹è¾ƒä½ï¼Œè€Œä¸æ˜¯æ‰©å±•æ•´ä¸ª A æ•°ç»„ã€‚å®ƒè¿˜å°†å‡å°‘é—®é¢˜åˆ†è§£ä¸ºä¸€ä¸ªâ€œè§„èŒƒâ€è¯­å¥ï¼Œä½¿å¾—ä¸‹æ¸¸å¤„ç†ï¼ˆä¾‹å¦‚å‘é‡åŒ–ï¼‰æ›´å®¹æ˜“è¿›è¡Œã€‚ åœ¨ C çº§åˆ«å®ç°è¿™ä¸€è½¬æ¢å°†éœ€è¦æ“ä½œ C æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰å¹¶æ¨ç† Cï¼ˆç”šè‡³ C++ï¼‰çš„è¯­ä¹‰ã€‚è¿™é€šå¸¸è¶…å‡ºäº†è¯¸å¦‚ Pluto è¿™æ ·çš„æºåˆ°æºå¤šé¢ä½“ä¼˜åŒ–å™¨çš„èƒ½åŠ›ï¼Œå› ä¸ºè¿™äº›ä¼˜åŒ–å™¨å°†è¯­å¥è§†ä¸ºé»‘ç®±ã€‚è™½ç„¶åœ¨ LLVM IR çº§åˆ«å®ç°è¿™ä¸€è½¬æ¢ä¹Ÿæ˜¯å¯èƒ½çš„ï¼Œä¾‹å¦‚åœ¨ Polly ä¸­ï¼Œåœ¨é‚£é‡Œè¯­å¥ä¹Ÿè¢«é‡å»ºä¸”æš‚æ—¶åˆ†é…çš„æ³¨å…¥è¾ƒä¸ºå®¹æ˜“ï¼Œä½†é©±åŠ¨è½¬æ¢çš„å¯å‘å¼æ˜¯åŸºäºå¾ªç¯ç»“æ„å’Œå¤šç»´è®¿é—®æ¨¡å¼çš„ï¼Œè€Œåœ¨å¦‚æ­¤ä½çš„çº§åˆ«æ¢å¤è¿™äº›ä¿¡æ¯æ˜¯å›°éš¾çš„[9]ã€‚ æ½œåœ¨åˆ†å‰²çš„ç©ºé—´æ˜¯å·¨å¤§çš„â€”â€”æ¯ä¸ª MLIR æ“ä½œéƒ½æœ‰å¯èƒ½æˆä¸ºä¸€ä¸ªè¯­å¥ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ç§å¯å‘å¼æ–¹æ³•æ¥å¤„ç†ç±»ä¼¼äºå›¾8çš„æ”¶ç¼©æƒ…å†µã€‚å‡å°‘è¯­å¥åˆ†å‰²é€‚ç”¨äºä»¥ä¸‹è¯­å¥ï¼š â€¢ è‡³å°‘è¢« 3 ä¸ªå¾ªç¯åŒ…å›´ï¼› â€¢ å·¦ä¾§ = å³ä¾§ï¼Œå¹¶ä¸”ä½¿ç”¨æ‰€æœ‰å¾ªç¯ï¼Œé™¤äº†æœ€å†…å±‚çš„ï¼› â€¢ å³ä¾§å…·æœ‰ä¸¤ä¸ªæˆ–æ›´å¤šä¸åŒçš„è®¿é—®æ¨¡å¼ã€‚è¿™æ¶µç›–äº†é‚£äº›å¯èƒ½é€šè¿‡ä¸åŒå¾ªç¯é¡ºåºæ”¹å–„å±€éƒ¨æ€§çš„è¯­å¥ï¼Œå¹¶ä¸”é£é™©è¾ƒä½ï¼Œä¸ä¼šäº§ç”Ÿä¸å¸Œæœ›çš„åˆ†è£‚ã€‚è¿™ä¸ªå¯å‘å¼æ–¹æ³•ä»…ä½œä¸º Polygeist èƒ½å¤Ÿå¯ç”¨çš„æ–°è½¬æ¢ç±»å‹çš„ç¤ºä¾‹ã€‚ E. Post-Transformations and Backend E. åå˜æ¢åŠåç«¯ Polygeist ä½¿å¾—åœ¨ quasi-syntactic å’Œ SSA å±‚é¢ä¸Šæ“ä½œæˆä¸ºå¯èƒ½ï¼Œä»è€Œå®ç°äº†åœ¨ä»»ä½•ä¸€ä¸ªå±‚é¢ä¸Šå•ç‹¬è¿›è¡Œåˆ†æå’Œä¼˜åŒ–æ—¶æå…¶å›°éš¾ï¼ˆç”šè‡³ä¸å¯èƒ½ï¼‰çš„ä»»åŠ¡ã€‚é™¤äº†è¯­å¥æ‹†åˆ†ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸¤ç§å±•ç¤º Polygeist æ½œåŠ›çš„æŠ€æœ¯ã€‚ a) è½¬æ¢å¸¦æœ‰å»¶ç»­å€¼çš„å¾ªç¯ï¼ˆå½’çº¦ï¼‰ï¼šPolygeist åˆ©ç”¨ MLIR å¯¹å¾ªç¯æºå¸¦å€¼çš„ä¸€çº§æ”¯æŒï¼Œæ¥æ£€æµ‹ã€è¡¨è¾¾å’Œè½¬æ¢ç±»ä¼¼å½’çº¦çš„å¾ªç¯ã€‚è¿™ç§æ”¯æŒä¸éœ€è¦æºä»£ç æ³¨é‡Šï¼Œè€Œä¸ä½¿ç”¨æ³¨é‡Šä»¥å¯ç”¨æ£€æµ‹çš„æºçº§å·¥å…· [24] ä¸åŒï¼Œä¹Ÿä¸éœ€è¦å¤æ‚çš„ä¿®æ”¹æ¥è¿›è¡Œå¹¶è¡Œä»£ç çš„ç”Ÿæˆï¼Œä¸ Polly [25] ä¸åŒï¼Œåè€…å—åˆ° LLVM ç¼ºå¤±ä¸€çº§å¹¶è¡Œæ„é€ çš„é™åˆ¶ã€‚æˆ‘ä»¬ä¹Ÿæœªå¯¹å¤šé¢ä½“è°ƒåº¦å™¨è¿›è¡Œä¿®æ”¹ï¼Œè€Œæ˜¯ä¾èµ–åå¤„ç†æ¥è¿›è¡Œå½’çº¦å¹¶è¡ŒåŒ–ï¼ŒåŒ…æ‹¬æœ€å¤–å±‚çš„å¹¶è¡Œå½’çº¦å¾ªç¯ã€‚ æ€»ä½“æ–¹æ³•éµå¾ªäº† [26] ä¸­æå‡ºçš„å®šä¹‰ï¼Œé’ˆå¯¹ MLIR çš„åŸºäºåŒºåŸŸçš„ä¸­é—´è¡¨ç¤ºè¿›è¡Œäº†è°ƒæ•´ï¼Œå¦‚å›¾ 9 æ‰€ç¤ºã€‚Polygeist é€šè¿‡æ‰«æå¾ªç¯çš„å•å—ä¸»ä½“ï¼Œè¯†åˆ«æ¯æ¬¡è¿­ä»£ä¸­è¢«ä¿®æ”¹çš„å†…å­˜ä½ç½®ï¼Œå³å…·æœ‰å¾ªç¯ä¸å˜ä¸‹æ ‡ä¸”æ²¡æœ‰äº¤é”™åˆ«åå­˜å‚¨çš„åŠ è½½/å­˜å‚¨å¯¹ã€‚è¿™äº›è¢«è½¬æ¢ä¸ºå¾ªç¯æºå¸¦å€¼æˆ–äºŒæ¬¡å½’çº³å˜é‡ï¼ŒåŠ è½½/å­˜å‚¨å¯¹è¢«æå‡åˆ°å¾ªç¯å¤–å¹¶é‡æ–°ç”¨äºè¯»å–åˆå§‹å€¼å’Œå­˜å‚¨æœ€ç»ˆå€¼ã€‚åœ¨å¾ªç¯ä¸»ä½“ä¸­ï¼Œå¾ªç¯æºå¸¦å€¼å¯ä»¥é€šè¿‡ä¸€ç³»åˆ—æ— å‰¯ä½œç”¨æ“ä½œè¿›è¡Œæ›´æ–°ã€‚å¦‚æœè¿™ä¸ªé“¾è¢«è®¤ä¸ºæ˜¯ç»“åˆçš„å’Œäº¤æ¢çš„ï¼Œé‚£ä¹ˆè¯¥å¾ªç¯å³ä¸ºå½’çº¦ã€‚å³ä½¿åœ¨æ²¡æœ‰åˆé€‚çš„å½’çº¦æ“ä½œçš„æƒ…å†µä¸‹ï¼Œå¾ªç¯æºå¸¦å€¼ä¹Ÿèƒ½è¢«æ£€æµ‹åˆ°ã€‚å…·æœ‰æ­¤ç±»å€¼çš„å¾ªç¯å°†å¯¹ mem2reg äº§ç”Ÿè´¡çŒ®ï¼Œé™ä½å†…å­˜å ç”¨ï¼Œä½†ä¸é€‚åˆè¿›è¡Œå¹¶è¡ŒåŒ–ã€‚ b) å»¶è¿Ÿå¹¶è¡ŒåŒ–ï¼šPolygeist å¹¶ä¸ä¾èµ–äºé€šè¿‡ä»¿å°„è°ƒåº¦å™¨è·å–çš„ä¾èµ–è·ç¦»ä¿¡æ¯ï¼Œè€Œæ˜¯å¯¹ç”Ÿæˆçš„ä»£ç è¿›è¡Œå•ç‹¬çš„å¤šé¢ä½“åˆ†æä»¥æ£€æµ‹å¾ªç¯å¹¶è¡Œæ€§ã€‚è¯¥åˆ†ææœ¬èº«æ˜¯ä¸€ç§ç»å…¸çš„å¤šé¢ä½“ä¾èµ–åˆ†æ [27]ã€[28]ï¼Œåœ¨ MLIR åŒºåŸŸç»“æ„ä¹‹ä¸Šå®ç°ã€‚åœ¨è¿›è¡Œ SSA åŸºäºä¼˜åŒ–ä¹‹åæ‰§è¡Œè¿™ä¸€æ­¥ï¼Œç‰¹åˆ«æ˜¯ mem2reg å’Œå½’çº¦æ£€æµ‹ï¼Œèƒ½å¤Ÿå¹¶è¡ŒåŒ–æ›´å¤šçš„å¾ªç¯ã€‚ç‰¹åˆ«æ˜¯ï¼Œå½’çº¦å¾ªç¯å’Œé‚£äº›å˜é‡å€¼ä»…åœ¨å•æ¬¡è¿­ä»£å†…ç›¸å…³çš„å¾ªç¯ï¼ˆç±»ä¼¼äºæ´»è·ƒèŒƒå›´é‡æ’åº [29]ï¼Œä½†æ²¡æœ‰æ˜‚è´µçš„é¢å¤–å¤šé¢ä½“åˆ†æï¼‰éƒ½å¾—åˆ°å¤„ç†ï¼ˆåœ¨å¾ªç¯ä¸­å®šä¹‰çš„ SSA å€¼çš„æ´»è·ƒèŒƒå›´ä»ä¸è¶…å‡ºå¾ªç¯ï¼‰ã€‚ IV. EVALUATION æˆ‘ä»¬çš„è¯„ä¼°æœ‰ä¸¤ä¸ªç›®æ ‡ã€‚1ï¼‰æˆ‘ä»¬å¸Œæœ›è¯æ˜ï¼ŒPolygeist ç”Ÿæˆçš„ä»£ç åœ¨æ²¡æœ‰é¢å¤–ä¼˜åŒ–çš„æƒ…å†µä¸‹ï¼Œå…¶æ€§èƒ½ä¸åƒ Clang è¿™æ ·çš„ç°ä»£ç¼–è¯‘å™¨æ²¡æœ‰ä»»ä½•ä¸å¯è§£é‡Šçš„å·®å¼‚ã€‚2ï¼‰æˆ‘ä»¬æ¢è®¨ Polygeist çš„å†…éƒ¨è¡¨ç¤ºå¦‚ä½•åœ¨åŒä¸€ç¼–è¯‘æµç¨‹ä¸­æ”¯æŒç»“åˆä½¿ç”¨ä»¿å°„å˜æ¢å’ŒåŸºäº SSA çš„å˜æ¢ï¼Œå¹¶è¯„ä¼°ä¸ç°æœ‰çš„æºä»£ç å’Œç¼–è¯‘å™¨åŸºç¡€ä¸Šçš„å¤šé¢ä½“å·¥å…·ç›¸æ¯”çš„æ½œåœ¨ä¼˜åŠ¿ã€‚ A. Experimental Setup æˆ‘ä»¬åœ¨ä¸€å° AWS c5.metal å®ä¾‹ä¸Šè¿›è¡Œå®éªŒï¼Œè¯¥å®ä¾‹ç¦ç”¨äº†è¶…çº¿ç¨‹å’Œ Turbo Boostã€‚ç³»ç»Ÿä¸º Ubuntu 20.04ï¼Œè¿è¡ŒäºåŒæ’æ§½ Intel Xeon Platinum 8275CL CPUï¼Œä¸»é¢‘ä¸º 3.0 GHzï¼Œæ¯ä¸ªæ’æ§½æœ‰ 24 ä¸ªæ ¸å¿ƒï¼ŒL1ã€L2 å’Œ L3 ç¼“å­˜åˆ†åˆ«ä¸º 0.75 MBã€35 MB å’Œ 35.75 MBï¼Œå¹¶é…å¤‡ 256 GB RAMã€‚æˆ‘ä»¬ä½¿ç”¨â€œEXTRALARGEâ€æ•°æ®é›†è¿è¡Œ Poly-Bench [19] ä¸­çš„æ‰€æœ‰ 30 ä¸ªåŸºå‡†æµ‹è¯•ã€‚Pluto æ— æ³•ä» adi åŸºå‡†æµ‹è¯•ä¸­æå– SCoPã€‚æˆ‘ä»¬å¯¹æ¯ä¸ªåŸºå‡†æµ‹è¯•è¿›è¡Œäº†æ€»å…± 5 æ¬¡è¯•éªŒï¼Œé‡‡ç”¨ PolyBench æŠ¥å‘Šçš„æ‰§è¡Œæ—¶é—´ï¼›é™¤éå¦æœ‰è¯´æ˜ï¼Œç»“æœä»¥ä¸­ä½æ•°çš„å½¢å¼ç»™å‡ºã€‚ä»¥ä¸‹å„èŠ‚ä¸­æŠ¥å‘Šçš„æ¯ä¸ªæµ‹é‡æˆ–ç»“æœå‡ä¸åŒç²¾åº¦æ•°æ®ç›¸å…³ã€‚æ‰€æœ‰å®éªŒå‡åœ¨æ ¸å¿ƒ 1-8 ä¸Šè¿è¡Œï¼Œä»¥ç¡®ä¿æ‰€æœ‰çº¿ç¨‹ä½äºåŒä¸€æ’æ§½ï¼Œå¹¶ä¸”ä¸ä¼šä¸è°ƒåº¦åœ¨æ ¸å¿ƒ 0 ä¸Šçš„è¿›ç¨‹å‘ç”Ÿæ½œåœ¨å†²çªã€‚ åœ¨æ‰€æœ‰æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬é‡‡ç”¨ä¸¤é˜¶æ®µç¼–è¯‘ï¼š(i) ä½¿ç”¨ clang ä»¥ -O3 çº§åˆ«ç¼–è¯‘ï¼Œä¸åŒ…æ‹¬å±•å¼€å’Œå‘é‡åŒ–ï¼›æˆ–ä½¿ç”¨ Polygeist ä» C å‘å‡º LLVM IRï¼›(ii) ä½¿ç”¨ clang ä»¥ -O3 çº§åˆ«å‘å‡ºæœ€ç»ˆäºŒè¿›åˆ¶æ–‡ä»¶ã€‚ç”±äºæŸäº›ä¼˜åŒ–å¹¶éå¹‚ç­‰çš„ï¼Œå› æ­¤ç¬¬äºŒè½®ä¼˜åŒ–å¯èƒ½ä¼šæ˜¾è‘—æå‡ï¼ˆè€Œå¾ˆå°‘æƒ…å†µä¼šæŠ‘åˆ¶ï¼‰æ€§èƒ½ã€‚è¿™å°±æ˜¯æˆ‘ä»¬é€‰æ‹©ä»…åœ¨æœ€åä¼˜åŒ–é˜¶æ®µè¿›è¡Œå‘é‡åŒ–å’Œå±•å¼€çš„åŸå› ã€‚ç”±äº Polygeist åœ¨ MLIR çº§åˆ«åº”ç”¨äº†ä¸€äº›ä¼˜åŒ–ï¼ˆä¾‹å¦‚ï¼Œmem2regï¼‰ï¼Œæˆ‘ä»¬å°†å…¶ä¸ä¸¤é˜¶æ®µç¼–è¯‘æµç¨‹ï¼ˆCLANGï¼‰è¿›è¡Œæ¯”è¾ƒï¼Œä½œä¸ºæ›´å…¬å¹³çš„åŸºçº¿ã€‚æˆ‘ä»¬è¿˜è¯„ä¼°äº†å•é˜¶æ®µç¼–è¯‘ï¼Œä»¥è¯„ä¼°ä¸¤é˜¶æ®µæµç¨‹çš„æ•ˆæœï¼ˆCLANGSINGï¼‰ã€‚ B. Baseline Performance B. åŸºçº¿æ€§èƒ½ Polygeistå¿…é¡»ç”Ÿæˆå°½å¯èƒ½æ¥è¿‘ç°æœ‰ç¼–è¯‘æµç¨‹çš„è¿è¡Œæ—¶ä»£ç ï¼Œä»¥å»ºç«‹ä¸€ä¸ªç¨³å›ºçš„åŸºçº¿ã€‚æ¢å¥è¯è¯´ï¼ŒPolygeistä¸åº”è¯¥å¼•å…¥å¼€é”€æˆ–åŠ é€Ÿï¼Œé™¤éæ˜ç¡®æŒ‡ç¤ºï¼Œä»¥ä¾¿èƒ½å¤Ÿæµ‹é‡é¢å¤–ä¼˜åŒ–çš„æ•ˆæœã€‚æˆ‘ä»¬é€šè¿‡æ¯”è¾ƒPolygeistç”Ÿæˆçš„ç¨‹åºä¸åŒä¸€æäº¤ç‰ˆæœ¬ï¼ˆ2021å¹´4æœˆï¼‰ä¸‹Clangç”Ÿæˆçš„ç¨‹åºçš„è¿è¡Œæ—¶æ¥è¯„ä¼°è¿™ä¸€ç‚¹ã€‚å›¾10æ€»ç»“äº†ä»¥ä¸‹å‡ ç§æµç¨‹çš„ç»“æœï¼š â€¢ CLANGï¼šä½¿ç”¨Clangç¼–è¯‘ç¨‹åºï¼Œè¿è¡Œä¸¤é˜¶æ®µä¼˜åŒ–çš„è¿‡ç¨‹ï¼› â€¢ CLANGSINGï¼šä½¿ç”¨Clangç¼–è¯‘ç¨‹åºï¼Œè¿è¡Œä¸€é˜¶æ®µä¼˜åŒ–çš„è¿‡ç¨‹ï¼› â€¢ MLIR-CLANGï¼šä½¿ç”¨Polygeistå‰ç«¯çš„ç¼–è¯‘æµç¨‹ï¼Œåœ¨MLIRå†…è¿›è¡Œé¢„å¤„ç†ä¼˜åŒ–ï¼Œä½†ä¸æ‰§è¡Œå¤šé¢ä½“è°ƒåº¦æˆ–åå¤„ç†ã€‚ C. Compilation Flows æˆ‘ä»¬å°†Polygeistä¸æºä»£ç çº§å’Œä¸­é—´è¡¨ç¤ºçº§ä¼˜åŒ–å™¨ï¼ˆPlutoå’ŒPollyï¼‰è¿›è¡Œæ¯”è¾ƒï¼Œé…ç½®å¦‚ä¸‹ï¼š PLUTOï¼šä½¿ç”¨-polycc 3åŠ-noparallelå’Œ-tileæ ‡å¿—çš„Plutoç¼–è¯‘å™¨è‡ªåŠ¨è½¬æ¢ï¼› PLUTOPARï¼šä¸ä¸Šè¿°ç›¸åŒï¼Œä½†ä½¿ç”¨-parallelæ ‡å¿—ï¼› POLLYï¼šPolly [7]çš„LLVMé€šé“ï¼Œå…·æœ‰ä»¿å°„è°ƒåº¦å’Œåˆ‡ç‰‡ï¼Œæ²¡æœ‰åŸºäºæ¨¡å¼çš„ä¼˜åŒ– [30]ï¼› POLLYPARï¼šä¸ä¸Šè¿°ç›¸åŒï¼Œä½†è¿›è¡Œäº†è‡ªåŠ¨å¹¶è¡ŒåŒ–ï¼› POLYGEISTï¼šæˆ‘ä»¬çš„å·¥ä½œæµï¼Œç»“åˆäº†Plutoå’Œé¢å¤–çš„å˜æ¢ï¼› POLYGEISTPARï¼šä¸ä¸Šè¿°ç›¸åŒï¼Œä½†ä½¿ç”¨-parallelçš„Plutoè°ƒåº¦ï¼ŒPolygeistå¹¶è¡ŒåŒ–å’Œå½’çº¦ã€‚ åœ¨æºä»£ç å’ŒLLVM IRçº§åˆ«ä¹‹é—´è¿è¡Œæ—¶ï¼Œæˆ‘ä»¬æœŸæœ›Polygeistèƒ½å¤Ÿä»è¿™ä¸¤è€…çš„ä¼˜ç‚¹ä¸­å—ç›Šï¼Œä»è€Œç”Ÿæˆçš„ä»£ç èƒ½å¤Ÿä¸ç«äº‰å¯¹æ‰‹ç›¸åª²ç¾æˆ–æ›´ä¼˜ã€‚åœ¨ä½¿ç”¨Plutoæ—¶ï¼Œæ— è®ºæ˜¯ç‹¬ç«‹åœ°è¿˜æ˜¯åœ¨Polygeistä¸­ï¼Œæˆ‘ä»¬éƒ½ä¼šç¦ç”¨å‘é‡åŒ–æç¤ºå’Œå¾ªç¯å±•å¼€çš„å‘å‡ºï¼Œä»¥ç¡®ä¿è¿™ä¸¤ç§å˜æ¢éƒ½å®Œå…¨ç”±LLVMä¼˜åŒ–å™¨æ§åˆ¶ï¼Œè¯¥ä¼˜åŒ–å™¨ä¹Ÿåœ¨Pollyæµç¨‹ä¸­è¿è¡Œã€‚æˆ‘ä»¬åœ¨Clangç¼–è¯‘çš„æœ€æ–°é˜¶æ®µè¿è¡ŒPollyï¼Œä½¿ç”¨-mllvm -pollyåŠå…¶ä»–æ ‡å¿—ä»¥å¯ç”¨ä»¿å°„è°ƒåº¦ã€åˆ‡ç‰‡å’Œå¹¶è¡ŒåŒ–ã€‚Pollyä¸Clangä½¿ç”¨ç›¸åŒçš„LLVMæäº¤ç‰ˆæœ¬ã€‚æˆ‘ä»¬ç¦ç”¨åœ¨å…¶ä»–åœ°æ–¹ä¸å¯ç”¨çš„åŸºäºæ¨¡å¼çš„ä¼˜åŒ– [30]ã€‚å›¾11å’Œå›¾12åˆ†åˆ«æ€»ç»“äº†é¡ºåºå’Œå¹¶è¡Œæµç¨‹çš„ç»“æœã€‚ A. Benchmarking é™ä½å¾ªç¯çš„è½¬æ¢ï¼Œç‰¹åˆ«æ˜¯å¹¶è¡ŒåŒ–ï¼Œå¯èƒ½ä¼šå¯¼è‡´éƒ¨åˆ†ç»“æœç´¯ç§¯çš„é¡ºåºå‘ç”Ÿå˜åŒ–ã€‚è¿™åœ¨ IEEE 754 è¯­ä¹‰ä¸‹æ˜¯ä¸å…è®¸çš„ï¼Œä½†ä½¿ç”¨ -ffast-math é€‰é¡¹çš„ç¼–è¯‘å™¨æ”¯æŒè¿™ç§æƒ…å†µã€‚æˆ‘ä»¬å‘ç°ï¼ŒPolybench çš„åˆ†é…å‡½æ•°ä¼šå¦¨ç¢ Clang/LLVM çš„åˆ«ååˆ†æï¼Œä»è€Œå¯¹æ€§èƒ½äº§ç”Ÿè´Ÿé¢å½±å“ 2 LLVM æäº¤ 20d5c42e0ef5d252b434bcb610b04f1cb79fe771 3 Pluto æäº¤ dae26e77b94b2624a540c08ec7128f20cd7b7985ï¼Œä¸¾ä¾‹æ¥è¯´ï¼Œåœ¨ adi ä¸­ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¿®æ”¹äº†æ‰€æœ‰åŸºå‡†æµ‹è¯•ï¼Œä½¿ç”¨å·²çŸ¥ä¼šäº§ç”Ÿéåˆ«åæŒ‡é’ˆçš„ mallocã€‚ B. Baseline Comparison æˆ‘ä»¬æ²¡æœ‰è§‚å¯Ÿåˆ°CLANGå’ŒCLANGSINGé…ç½®ä¹‹é—´çš„è¿è¡Œæ—¶é—´å­˜åœ¨æ˜¾è‘—å·®å¼‚ï¼Œåœ¨åŸºå‡†æµ‹è¯•ä¸­ï¼Œå®ƒä»¬çš„å‡ ä½•å¹³å‡å¯¹ç§°å·®ä¸º0.43%ã€‚å› æ­¤ï¼Œåœ¨æœ¬æ–‡çš„å…¶ä½™éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬ä»…è€ƒè™‘CLANGä½œä¸ºåŸºçº¿ã€‚åŒæ ·ï¼Œæˆ‘ä»¬ä¹Ÿæ²¡æœ‰è§‚å¯Ÿåˆ°CLANGå’ŒMLIR-CLANGé…ç½®ä¹‹é—´çš„è¿è¡Œæ—¶é—´å­˜åœ¨æ˜¾è‘—å·®å¼‚ï¼Œå…¶å‡ ä½•å¹³å‡å¯¹ç§°å·®ä¸º0.24%ã€‚ æˆ‘ä»¬å‘ç°çŸ­è¿è¡ŒåŸºå‡†çš„è¿è¡Œæ—¶é—´å­˜åœ¨å˜åŠ¨ï¼Œç‰¹åˆ«æ˜¯åœ¨jacobi-1dä¸Šã€‚è¿™å¯ä»¥å½’å› äºæ•°æ®åˆå§‹åŒ–å’ŒåŸºå‡†æµ‹è¯•ä»£ç ä¹‹é—´çš„ç›¸äº’ä½œç”¨ï¼Œä»¥åŠå…¶ä»–æ“ä½œç³»ç»Ÿè¿›ç¨‹çš„å½±å“ã€‚ä»åˆ†æä¸­æ’é™¤è¿è¡Œæ—¶é—´å°‘äº0.05ç§’çš„åŸºå‡†ï¼ˆå¦‚jacobi-1dã€gesummvã€ataxã€bicgï¼‰ï¼Œæˆ‘ä»¬åˆ†åˆ«è·å¾—ä¸Šè¿°ä¸¤ä¸ªæ¯”è¾ƒçš„å‡ ä½•å¹³å‡å¯¹ç§°å·®ä¸º0.32%å’Œ0.17%ã€‚è¿™äº›ç»“æœè¡¨æ˜ï¼Œæˆ‘ä»¬çš„æµç¨‹åœ¨åŸºçº¿ä¹‹ä¸Šæ²¡æœ‰æœªè§£é‡Šçš„ï¼ˆä¸ï¼‰ä¼˜åŠ¿ã€‚ C. Performance Differences in Sequential Code æ•´ä½“è€Œè¨€ï¼ŒPolygeist ç›¸è¾ƒäº Plutoï¼ˆ2.34Ã—ï¼‰å’Œ Pollyï¼ˆ1.41Ã—ï¼‰æä¾›äº†æ›´å¤§çš„åŠ é€Ÿï¼Œå‡ ä½•å¹³å‡å€¼ä¸º 2.53Ã—ï¼Œå°½ç®¡æ”¹è¿›å¹¶ä¸æ˜¯ç³»ç»Ÿæ€§çš„ã€‚Polygeist å’Œ Polly ä¹‹é—´çš„ä¸€äº›å·®å¼‚æ˜¯ç”±äºæ‰€é‡‡ç”¨çš„å¤šé¢ä½“è°ƒåº¦å™¨ï¼Œä¾‹å¦‚åœ¨ lu å’Œ mvt ä¸­ã€‚å¾—ç›Šäºè¯­å¥åˆ†å‰²ï¼ŒPolygeist åœ¨ 2mmã€3mm åŠå…¶ä»–æŸäº›æƒ…å†µä¸‹ç”Ÿæˆçš„ä»£ç é€Ÿåº¦è¶…è¿‡äº† Pluto å’Œ Pollyï¼Œè¯¦è§ç¬¬ V-E èŠ‚ã€‚ åœ¨ç»™å®šç›¸åŒè¯­å¥å’Œè°ƒåº¦çš„æƒ…å†µä¸‹ï¼Œä»£ç ç”Ÿæˆå±‚é¢çš„ä¼˜åŒ–æ˜¯é€ æˆå…¶ä»–æ€§èƒ½å·®å¼‚çš„åŸå› ã€‚seidel-2d æ˜¯æœ€æ˜æ˜¾çš„ä¾‹å­ï¼šPluto æ‰§è¡Œçš„æ•´æ•°æŒ‡ä»¤æ¯” Polygeist å¤šå‡º 2.7â€¢10^11 æ¬¡ã€‚å‡è®¾è¿™äº›æŒ‡ä»¤éƒ½æ˜¯ç´¢å¼•/åœ°å€è®¡ç®—ï¼Œæ··åˆäº† addï¼ˆååé‡ä¸º 1/2 æˆ– 1/4ï¼‰å’Œ imul/shlï¼ˆååé‡ä¸º 1ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥é¢„è®¡åœ¨ 3GHz ä¸‹ä¼šæœ‰ â‰ˆ 59 ç§’çš„å·®å¼‚ï¼Œè¿™ä¸å®éªŒè§‚å¯Ÿç»“æœä¸€è‡´ã€‚Polygeist åœ¨å…¶åä¼˜åŒ–é˜¶æ®µä¼˜åŒ–æ‰äº†ä¸€éƒ¨åˆ†æŒ‡ä»¤ï¼Œå¹¶ä» memref å‘å‡ºé€‚å½“æœºå™¨å¤§å°ç±»å‹çš„å‡åŒ€åœ°å€è®¡ç®—ï¼Œä½¿ä¸‹æ¸¸ç¼–è¯‘å™¨èƒ½å¤Ÿè¿›è¡Œæ›´æ¿€è¿›çš„ç•Œé™åˆ†æå’Œç®€åŒ–ã€‚ç›¸åï¼Œç”±äº Polygeist ä¸ºäº†ç¼–è¯‘å™¨æ€§èƒ½åŸå› æ”¾å¼ƒäº†å¯¹ CLooG ä»£ç çš„ç®€åŒ–ï¼Œjacobi-2d çš„æ€§èƒ½è¾ƒå·®ï¼Œåœ¨ 40 ä¸ªåˆ†æ”¯ä¸­æœ‰å¤šè¾¾ 75 ä¸ªè¯­å¥å‰¯æœ¬ï¼Œè€Œ Clang å¤„ç†è¿™äº›ä»£ç éœ€è€—æ—¶å¤šè¾¾ 5 ç§’ï¼Œä½†å…¶ç»“æœå´å®ç°äº†æ›´å¥½çš„å‘é‡åŒ–ã€‚éœ€è¦è¿›ä¸€æ­¥çš„å·¥ä½œæ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œé€šè¿‡ç›´æ¥ä» Polygeist å‘å‡ºå‘é‡æŒ‡ä»¤ã€‚ D. Performance Differences In Parallel Code åŒæ ·ï¼Œå¯¹äºå¹¶è¡Œä»£ç ï¼ŒæŸäº›æ€§èƒ½å·®å¼‚æ˜¯ç”±äºä¸åŒçš„è°ƒåº¦å™¨ã€‚ä¾‹å¦‚ï¼Œåœ¨ cholesky å’Œ lu ä¸­ï¼ŒPluto å’Œ Polygeist çš„æ€§èƒ½éƒ½ä¼˜äº Pollyï¼Œå‰©ä½™çš„å·®è·å¯ä»¥å½’å› äºä»£ç ç”Ÿæˆçº§åˆ«çš„å·®å¼‚ã€‚ç›¸åï¼Œåœ¨ gemver å’Œ mvt ä¸­ï¼ŒPolly ç›¸è¾ƒäºä¸¤è€…çš†æœ‰ä¼˜åŠ¿ã€‚ å›¾ 10 æ˜¾ç¤ºäº†åœ¨ CLANGã€CLANGSING å’Œ MLIR-CLANG é…ç½®ä¸‹ï¼ŒPolybench çš„äº”æ¬¡è¿è¡Œä¸­ç¨‹åºè¿è¡Œæ—¶é—´çš„å‡å€¼å’Œ 95% ç½®ä¿¡åŒºé—´ï¼ˆå¯¹æ•°å°ºåº¦ï¼‰ï¼Œå€¼è¶Šä½è¶Šå¥½ã€‚ç”± Polygeist äº§ç”Ÿçš„æœªä¼˜åŒ–ä»£ç çš„è¿è¡Œæ—¶é—´ä¸ Clang çš„è¿è¡Œæ—¶é—´ç›¸å½“ã€‚ä¸åŒç¨‹åº¦çš„å•é‡å’ŒåŒé‡ä¼˜åŒ–ä¹‹é—´æ²¡æœ‰è§‚å¯Ÿåˆ°æ˜¾è‘—å·®å¼‚ã€‚è¿è¡Œæ—¶é—´è¾ƒçŸ­çš„ jacobi-1d æ˜¾ç¤ºå‡ºé«˜çš„ç»„å†…å˜å¼‚æ€§ã€‚ å›¾ 11 æ˜¾ç¤ºäº†åœ¨é¡ºåºé…ç½®ä¸‹ç›¸å¯¹äº CLANG çš„ä¸­ä½æ•°åŠ é€Ÿæ¯”ï¼ˆå¯¹æ•°å°ºåº¦ï¼‰ï¼Œå€¼è¶Šé«˜è¶Šå¥½ã€‚Polygeist åœ¨å¹³å‡æƒ…å†µä¸‹çš„åŠ é€Ÿæ¯”ï¼ˆå‡ ä½•å‡å€¼åŠ é€Ÿæ¯”ä¸º 2.53Ã—ï¼‰ä¼˜äº Plutoï¼ˆ2.34Ã—ï¼‰å’Œ Pollyï¼ˆ1.41Ã—ï¼‰ã€‚Pluto æ— æ³•å¤„ç† adiï¼Œå› æ­¤è¯¥æ¡ˆä¾‹è¢«æ’é™¤åœ¨æ€»ç»“ç»Ÿè®¡ä¹‹å¤–ã€‚ å›¾ 12 æ˜¾ç¤ºäº†åœ¨å¹¶è¡Œé…ç½®ä¸‹ç›¸å¯¹äº CLANG çš„ä¸­ä½æ•°åŠ é€Ÿæ¯”ï¼ˆå¯¹æ•°å°ºåº¦ï¼‰ï¼Œå€¼è¶Šé«˜è¶Šå¥½ã€‚Polygeist åœ¨å¹³å‡æƒ…å†µä¸‹çš„åŠ é€Ÿæ¯”ï¼ˆå‡ ä½•å‡å€¼åŠ é€Ÿæ¯”ä¸º 9.47Ã—ï¼‰ä¼˜äº Plutoï¼ˆ7.54Ã—ï¼‰å’Œ Pollyï¼ˆ3.26Ã—ï¼‰ã€‚Pluto æ— æ³•å¤„ç† adiï¼Œå› æ­¤è¯¥æ¡ˆä¾‹ä¹Ÿè¢«æ’é™¤åœ¨æ€»ç»“ç»Ÿè®¡ä¹‹å¤–ã€‚ åœ¨ ludcmp å’Œ syr(2)k ä¸­ï¼ŒSSA çº§åˆ«çš„ä¼˜åŒ–ä½¿å¾— Polygeist ç”Ÿæˆçš„ä»£ç æ¯” Pluto æ›´å¿«ï¼Œå¹¶ä¸”è‡³å°‘ä¸ Polly åŒæ ·å¿«ã€‚è¿™äº›ç»“æœè¡¨æ˜ï¼ŒPolygeist ç¡®å®åˆ©ç”¨äº†ä»¿å°„ä¼˜åŒ–å’Œ SSA åŸºç¡€ä¼˜åŒ–çš„ä¼˜ç‚¹ã€‚ Polygeist æ˜¯å”¯ä¸€åœ¨ dericheï¼ˆåŠ é€Ÿæ¯” 6.9Ã—ï¼‰å’Œ symmï¼ˆåŠ é€Ÿæ¯” 7.7Ã—ï¼‰ä¸Šå®ç°åŠ é€Ÿçš„ç¼–è¯‘æµç¨‹ã€‚é€šè¿‡æ£€æŸ¥è¾“å‡ºä»£ç ï¼Œæˆ‘ä»¬è§‚å¯Ÿåˆ°åªæœ‰ Polygeist æˆåŠŸåœ°å¯¹è¿™ä¸¤ä¸ªåŸºå‡†è¿›è¡Œäº†å¹¶è¡ŒåŒ–ã€‚è€ƒè™‘åˆ°å›¾ 13 ä¸­çš„è¾“å…¥ä»£ç ï¼Œå¯ä»¥è§‚å¯Ÿåˆ° i å¾ªç¯é‡ç”¨äº† ym1 å˜é‡ï¼Œè¿™è¢«ä»¿å°„è°ƒåº¦å™¨è§£é‡Šä¸ºå¦¨ç¢å¹¶è¡ŒåŒ–çš„å¾ªç¯æºå¸¦ä¾èµ–ã€‚Polygeist åœ¨å°† ym1 æå‡ä¸ºä¸€ä¸ªç”± j å¾ªç¯æºå¸¦çš„ SSA å¯„å­˜å™¨åï¼Œè¿›è¡Œè‡ªå·±çš„å¹¶è¡Œæ€§åˆ†æï¼Œå…¶ä½¿ç”¨å®šä¹‰èŒƒå›´ä¸å¦¨ç¢å¹¶è¡ŒåŒ–ã€‚ ç±»ä¼¼åœ°ï¼ŒPolygeist çš„å¹¶è¡ŒåŒ–å™¨è¯†åˆ«å‡ºä¸¤ä¸ªå…·æœ‰å¹¶è¡Œå½’çº¦å¾ªç¯çš„åŸºå‡†ï¼Œè¿™äº›å¾ªç¯ä¸åŒ…å«åœ¨å…¶ä»–å¹¶è¡Œå¾ªç¯ä¸­ï¼šgramschmidt å’Œ durbinã€‚ç›¸æ¯”äº Polly çš„ 34Ã— å’Œ Pluto çš„ 54Ã—ï¼Œgramschmidt åœ¨ Polygeist çš„å¸®åŠ©ä¸‹è·å¾—äº† 56Ã— çš„åŠ é€Ÿã€‚durbin åˆ™å‡ºç°äº† 6Ã— çš„å‡é€Ÿï¼Œå› ä¸ºæ–°çš„å¹¶è¡Œå¾ªç¯è¿­ä»£æ¬¡æ•°ç›¸å¯¹è¾ƒå°‘ï¼Œå¹¶ä¸”åµŒå¥—åœ¨ä¸€ä¸ªé¡ºåºå¾ªç¯å†…ï¼Œå¯¼è‡´åŒæ­¥æˆæœ¬è¶…è¿‡äº†å¹¶è¡ŒåŒ–å¸¦æ¥çš„å¥½å¤„ã€‚ç¬¬ V-F èŠ‚å°†æ›´è¯¦ç»†åœ°æ¢è®¨ durbin åŸºå‡†ã€‚ Polybench æ˜¯ä¸€ç»„ï¼ˆå¤§å¤šæ•°å·²çŸ¥ï¼‰å…·æœ‰å¹¶è¡Œç‰¹æ€§çš„ä»£ç ï¼Œå› æ­¤åœ¨ CPU ä¸Šè¿›è¡Œå½’çº¦å¹¶è¡ŒåŒ–çš„éœ€æ±‚ä¸å¤§ï¼Œå› ä¸ºåªæœ‰ä¸€åº¦çš„å¹¶è¡Œæ€§å°±å·²è¶³å¤Ÿã€‚ç„¶è€Œï¼Œå½“é’ˆå¯¹å›ºæœ‰çš„ç›®æ ‡æ¶æ„å¦‚ GPU æ—¶ï¼Œåˆ©ç”¨å½’çº¦å¹¶è¡Œæ€§å¯èƒ½å¯¹äºå®ç°å³°å€¼æ€§èƒ½è‡³å…³é‡è¦ [31], [24]ã€‚ E. Case Study: Statement Splitting E. æ¡ˆä¾‹ç ”ç©¶ï¼šè¯­å¥æ‹†åˆ† æˆ‘ä»¬ç¡®å®šäº† 5 ä¸ªåŸºå‡†æµ‹è¯•ï¼Œå…¶ä¸­åº”ç”¨äº†è¯­å¥æ‹†åˆ†å¯å‘å¼æ–¹æ³•ï¼š2mmã€3mmã€ç›¸å…³æ€§ã€åæ–¹å·®å’Œ trmmã€‚ä¸ºäº†è¯„ä¼°å˜æ¢çš„æ•ˆæœï¼Œæˆ‘ä»¬æ‰§è¡Œäº†è¿™äº›åŸºå‡†æµ‹è¯•ï¼Œå¹¶ç¦ç”¨äº†è¯­å¥æ‹†åˆ†ï¼Œç”¨ -nosplit åç¼€æ ‡è®°ï¼Œå¦‚å›¾ 14 æ‰€ç¤ºã€‚åœ¨é¡ºåºç‰ˆæœ¬ä¸­ï¼Œ2mm çš„é€Ÿåº¦æ…¢äº† 4.1%ï¼ˆ3.13 ç§’å¯¹æ¯” 3.26 ç§’ï¼‰ï¼Œä½†å…¶ä»–åŸºå‡†æµ‹è¯•åˆ†åˆ«çœ‹åˆ°äº† 25%ã€50%ã€51% å’Œ 27% çš„åŠ é€Ÿã€‚å¯¹äºå¹¶è¡Œç‰ˆæœ¬ï¼Œé€Ÿåº¦æå‡åˆ†åˆ«ä¸º 36%ã€20%ã€44%ã€40% å’Œ -9%ã€‚ å¯¹å¤šé¢ä½“è°ƒåº¦å™¨è¾“å‡ºçš„æ£€æŸ¥è¡¨æ˜ï¼Œå®ƒç¡®å®ç”Ÿæˆäº†é¢„æœŸçš„è°ƒåº¦ã€‚ä¾‹å¦‚ï¼Œåœ¨ç›¸å…³æ€§åŸºå‡†ä¸­ï¼Œè¯­å¥ A[i][j] += B[k][i] * B[k][j] Polygeist èƒ½å¤Ÿåœ¨æ‹†åˆ†åæ‰¾åˆ° (k, i, j) çš„å¾ªç¯é¡ºåºã€‚é€šè¿‡åœ¨é¡ºåºä»£ç ä¸Šä½¿ç”¨ç¡¬ä»¶æ€§èƒ½è®¡æ•°å™¨ï¼Œæˆ‘ä»¬ç¡®è®¤æ•´ä½“ç¼“å­˜ç¼ºå¤±ç‡ç¡®å®åˆ†åˆ«é™ä½äº† 75%ã€50%ã€20%ã€27% å’Œ -26%ã€‚ç„¶è€Œï¼Œç”±æ€»åŒ£å‘¨æœŸä¼°ç®—çš„å†…å­˜æµé‡åœ¨ 2mm ä¸­å¢åŠ äº† 9%ï¼Œè€Œå…¶ä»–åŸºå‡†æµ‹è¯•åˆ™åˆ†åˆ«å‡å°‘äº† 18%ã€32%ã€32% å’Œ 21%ã€‚è¯¥æŒ‡æ ‡ä¸åŒä¸€è¿è¡Œä¸­è§‚å¯Ÿåˆ°çš„æ€§èƒ½å·®å¼‚å¼ºç›¸å…³ï¼ˆr = 0.99ï¼Œp = 3 â€¢ 10 -11ï¼‰ã€‚è¿™ç§è¡Œä¸ºå¯èƒ½æ˜¯ç”±äºè°ƒåº¦å™¨äº§ç”Ÿäº†ä¸åŒçš„èåˆç»“æ„ï¼Œä¾‹å¦‚ï¼Œåœ¨ 2mm ä¸­æ²¡æœ‰èåˆæœ€å¤–å±‚çš„å¾ªç¯ï¼Œè¿™ä¹Ÿå½±å“äº†å±€éƒ¨æ€§ã€‚å¹¶è¡Œä»£ç ä¸­ä¹Ÿå¯ä»¥è§‚å¯Ÿåˆ°ç±»ä¼¼çš„ç»“æœã€‚è¿›ä¸€æ­¥çš„ç ”ç©¶æœ‰å¿…è¦åˆ©ç”¨ Polygeist åˆ›é€ çš„è¯­å¥æ‹†åˆ†æœºä¼šï¼Œå¹¶ä¸èåˆè¿›è¡Œç›¸äº’ä½œç”¨ã€‚ F. Case Study: Reduction Parallelization in durbin F. æ¡ˆä¾‹ç ”ç©¶ï¼šDurbinä¸­çš„å½’çº¦å¹¶è¡ŒåŒ– åœ¨è¿™ä¸ªåŸºå‡†æµ‹è¯•ä¸­ï¼ŒPolygeiståˆ©ç”¨å…¶å½’çº¦ä¼˜åŒ–åˆ›å»ºäº†ä¸€ä¸ªå…¶ä»–å·¥å…·æ— æ³•å®ç°çš„å¹¶è¡Œå¾ªç¯ã€‚å¯¹äºé»˜è®¤è¿è¡Œçš„ç›¸å¯¹è¾ƒå°çš„è¾“å…¥ï¼ŒN = 4000çš„è¿­ä»£åµŒå¥—åœ¨å¦ä¸€ä¸ªå…·æœ‰Næ¬¡è¿­ä»£çš„é¡ºåºå¾ªç¯ä¸­ï¼Œæ•´ä½“æ€§èƒ½å‡ºç°ä¸‹é™ã€‚æˆ‘ä»¬å‡è®¾åˆ›å»ºå¹¶è¡Œçº¿ç¨‹å’ŒåŒæ­¥å®ƒä»¬çš„æˆæœ¬è¶…è¿‡äº†é¢å¤–å¹¶è¡Œæ€§å¸¦æ¥çš„æ”¶ç›Šï¼Œå¹¶é€šè¿‡å¢åŠ Næ¥éªŒè¯æˆ‘ä»¬çš„å‡è®¾ã€‚æ ¹æ®å›¾15ä¸­çš„ç»“æœï¼Œå¯ä»¥è§‚å¯Ÿåˆ°ï¼ŒPolygeiståœ¨N â‰¥ 16000æ—¶å¼€å§‹äº§ç”ŸåŠ é€Ÿæ•ˆæœï¼ˆ> 1ï¼‰ï¼Œè€ŒPollyä»…åœ¨N â‰¥ 224000æ—¶æ‰ä¼šå¦‚æ­¤ï¼Œå¹¶ä¸”å¹…åº¦è¦å°å¾—å¤šï¼š6.62Ã—å¯¹æ¯”1.01Ã—ã€‚åœ¨æ²¡æœ‰å½’çº¦å¹¶è¡ŒåŒ–çš„æƒ…å†µä¸‹ï¼ŒPolygeistçš„è¡¨ç°ä¸Pollyç›¸åŒã€‚Plutoæœªèƒ½å¯¹ä»»ä½•æœ€å†…å±‚å¾ªç¯è¿›è¡Œå¹¶è¡ŒåŒ–ï¼Œå¹¶ä¸”æ˜¾ç¤ºæ²¡æœ‰åŠ é€Ÿã€‚è¿™æ”¯æŒäº†æˆ‘ä»¬çš„å‡è®¾ï¼Œå¹¶å¼ºè°ƒäº†èƒ½å¤Ÿå¹¶è¡ŒåŒ–å½’çº¦çš„é‡è¦æ€§ã€‚ VI. RELATED WORK VI. ç›¸å…³å·¥ä½œ a) MLIRå‰ç«¯ï¼šè‡ªä»MLIRè¢«çº³å…¥LLVMæ¡†æ¶åï¼Œå·²ç»åˆ›å»ºäº†å¤šä¸ªå‰ç«¯ç”¨äºä»ç‰¹å®šé¢†åŸŸè¯­è¨€ç”ŸæˆMLIRã€‚Teckyl [2] å°†é¢å‘ç”Ÿäº§åŠ›çš„å¼ é‡ç†è§£ [1] ç¬¦å·è¿æ¥åˆ°MLIRçš„Linalgæ–¹è¨€ã€‚Flangï¼ŒLLVMçš„Fortranå‰ç«¯ï¼Œä½¿ç”¨FIRæ–¹è¨€å»ºæ¨¡Fortranç‰¹å®šçš„æ„é€  [32]ã€‚COMETï¼Œä¸€ä¸ªé’ˆå¯¹åŒ–å­¦é¢†åŸŸçš„ç‰¹å®šé¢†åŸŸç¼–è¯‘å™¨ï¼Œå¼•å…¥äº†ä¸€ä¸ªä»åŸºäºå¼ é‡çš„è¯­è¨€åˆ°MLIRçš„ç‰¹å®šé¢†åŸŸå‰ç«¯ [33]ã€‚NPCompæ—¨åœ¨æä¾›å¿…è¦çš„åŸºç¡€è®¾æ–½ä»¥ä¾¿ç¼–è¯‘æ•°å€¼Pythonå’ŒPyTorchç¨‹åºï¼Œä»è€Œåˆ©ç”¨MLIRåŸºç¡€è®¾æ–½ [34]ã€‚PET-to-MLIRé€šè¿‡è§£æpetçš„å†…éƒ¨è¡¨ç¤ºï¼Œå°†ä¸€éƒ¨åˆ†å¤šé¢ä½“Cä»£ç è½¬æ¢ä¸ºMLIRçš„Affineæ–¹è¨€ã€‚é™¤äº†å½“å‰ä¸å¤„ç†ç‰¹å®šæ„é€ ï¼ˆå¦‚ifè¯­å¥ã€ç¬¦å·è¾¹ç•Œå’Œå¤–éƒ¨å‡½æ•°è°ƒç”¨ï¼‰å¤–ï¼Œè§£æpetçš„è¡¨ç¤ºé™åˆ¶äº†å‰ç«¯çš„å¯ç”¨æ€§ï¼Œå› ä¸ºå®ƒæ— æ³•ä¸éå¤šé¢ä½“ä»£ç ï¼ˆå¦‚åˆå§‹åŒ–ã€éªŒè¯æˆ–æ‰“å°ä¾‹ç¨‹ï¼‰æ¥å£ [35]ã€‚ç›¸å¯¹è€Œè¨€ï¼ŒPolygeistèƒ½å¤Ÿä»éå¤šé¢ä½“ä»£ç ç”ŸæˆMLIRï¼ˆå°½ç®¡ä¸ä¸€å®šåœ¨Affineæ–¹è¨€ä¸­ï¼‰ã€‚CIRCTæ˜¯ä¸€ä¸ªæ–°çš„é¡¹ç›®ï¼Œæ—¨åœ¨å°†MLIRå¼€å‘æ–¹æ³•åº”ç”¨äºç”µå­è®¾è®¡è‡ªåŠ¨åŒ–è¡Œä¸šï¼Œéš¶å±äºLLVMæ¡†æ¶ [17]ã€‚Stripeä½¿ç”¨MLIRçš„Affineæ–¹è¨€ä½œä¸ºæœºå™¨å­¦ä¹ æ¨¡å‹ä¸­çš„å¾ªç¯å˜æ¢çš„åŸºç¡€ï¼ŒåŒ…æ‹¬æ‹†åˆ†å’Œå‘é‡åŒ–ï¼Œå¹¶æ¥å—è‡ªå®šä¹‰DSLä½œä¸ºè¾“å…¥ [36]ã€‚ b) Compilers Leveraging Multiple Representations: b) åˆ©ç”¨å¤šç§è¡¨ç¤ºçš„ç¼–è¯‘å™¨ï¼šSUIFç¼–è¯‘å™¨åŸºç¡€è®¾æ–½å¼€åˆ›äº†ä¸€ç§ç»„åˆå†…éƒ¨è¡¨ç¤ºï¼Œæ”¯æŒæ›´é«˜çº§çš„è½¬æ¢ï¼ŒåŒ…æ‹¬å¾ªç¯ä¼˜åŒ–å’Œå¹¶è¡ŒåŒ– [37]ï¼Œå°¤å…¶æ˜¯å½’çº¦å¹¶è¡ŒåŒ– [38]ã€‚Polygeiståˆ©ç”¨SUIFä¸­ä¸å¯ç”¨çš„MLIRæŠ½è±¡ï¼šå¸¸è§„å’Œä»¿å°„å¾ªç¯ï¼ŒOpenMPå½’çº¦æ„é€ ç­‰ã€‚å®ƒè¿˜å—ç›Šäºä»…ä½œä¸ºå¤–éƒ¨æ‰©å±•å­˜åœ¨äºSUIFä¸­çš„SSA+åŒºåŸŸå½¢å¼ [39]ï¼Œå¯ä»¥ç”¨äºä¸­é—´è¡¨ç¤ºçš„ç®€åŒ–ã€‚PIPSåœ¨é’ˆå¯¹OpenMPæ—¶æ”¯æŒå¾ªç¯è½¬æ¢å’Œè¿‡ç¨‹é—´ä¼˜åŒ– [40]ï¼Œ[41]ã€‚Polygeistä¸è¿™ä¸¤è€…çš„ä¸åŒä¹‹å¤„åœ¨äºå®ƒå‘å‡ºæœºå™¨ä»£ç è€Œä¸æ˜¯æºä»£ç ï¼Œä»è€Œèƒ½å¤Ÿå‘å‡ºå¹¶è¡Œè¿è¡Œæ—¶å’Œå…¶ä»–åœ¨æºè¯­è¨€ï¼ˆå¦‚Cï¼‰ä¸­æ²¡æœ‰è¡¨ç¤ºçš„æŒ‡ä»¤ã€‚ c) ç»“åˆâ€œç»å…¸â€å’Œå¤šé¢ä½“æµç¨‹ï¼šå°‘æ•°è®ºæ–‡å…³æ³¨äºå°†â€œç»å…¸â€çš„ã€å¤§å¤šæ•°æ˜¯ASTçº§åˆ«çš„è½¬åŒ–ä¸å¤šé¢ä½“è½¬åŒ–ç»“åˆèµ·æ¥ã€‚PolyASTé€šè¿‡ç»“åˆä»¿å°„è°ƒåº¦å™¨ä¸ASTçº§åˆ«çš„å¯å‘å¼æ–¹æ³•è¿›è¡Œèåˆå’Œåˆ‡ç‰‡ [42]ï¼Œå¼€åˆ›äº†è¿™ç§æ–¹æ³•ï¼Œå°½ç®¡ä»…ä½¿ç”¨å¤šé¢ä½“è½¬åŒ–ä¹Ÿå±•ç¤ºäº†ç±»ä¼¼çš„ç»“æœ [43]ã€‚CUDA-CHiLL [44] ä¹Ÿå®éªŒäº†ä¸€ç§ç±»ä¼¼çš„æ–¹æ³•ã€‚å¯ä»¥è¯´ï¼Œè®¸å¤šè‡ªåŠ¨åŒ–çš„å¤šé¢ä½“æµç¨‹å°†å¾ªç¯èåˆå’Œ/æˆ–åˆ‡ç‰‡ä½œä¸ºä¸€ä¸ªç‹¬ç«‹æ­¥éª¤æ¥æ‰§è¡Œï¼Œè¿™å¯ä»¥è¢«è®¤ä¸ºæ˜¯ä¸€ç§ç»å…¸è½¬åŒ–ã€‚Pluto [11] ä½¿ç”¨å‡ ä¸ªâ€œè¯­æ³•â€åå¤„ç†è¿‡ç¨‹æ¥åˆ©ç”¨æ¨¡æ¿ä¸­çš„ç©ºé—´å±€éƒ¨æ€§å’Œå¹¶è¡Œæ€§ [45]ã€‚å·²æå‡ºå¤šä¸ªå·¥å…·ï¼Œä»¥ç»å…¸å¾ªç¯è½¬åŒ–å¦‚èåˆå’Œæ’åˆ—ä½œä¸ºæ“ä½œï¼Œé©±åŠ¨å¤šé¢ä½“å¾ªç¯è½¬åŒ–ï¼ŒåŒ…æ‹¬URUK [46]ã€CHiLL [47] å’ŒClay [48]ã€‚Polygeistä¸è¿™äº›å·¥å…·çš„ä¸åŒä¹‹å¤„åœ¨äºå®ƒåœ¨å…¶IRä¸­ä¿ç•™äº†æ­¤ç±»è½¬åŒ–çš„ç»“æœï¼Œå¹¶ä¸”ä¸å¤šé¢ä½“æ„é€ ä¸€èµ·ï¼Œå…è®¸ä¸åŒæŠ½è±¡å±‚æ¬¡ä¹‹é—´çš„äº¤äº’ã€‚ d) é¢å¤–çš„ï¼ˆåï¼‰å¤šé¢ä½“è½¬åŒ–ï¼šPolly [25] æå‡ºäº†å¤„ç†å½’çº¦å¾ªç¯çš„æ”¯æŒï¼Œä½†å¹¶æœªå®ç°ä»£ç ç”Ÿæˆã€‚åœ¨è¯­æ³•å±‚é¢ï¼Œé€šè¿‡æ‰‹åŠ¨æ³¨é‡Šä½¿ç”¨PENCILæŒ‡ä»¤å‘PETæ·»åŠ äº†å½’çº¦æ”¯æŒ [24]ã€‚æ®æŠ¥é“ï¼ŒR-Streamä½¿ç”¨äº†ä¸€ç§å˜ä½“çš„è¯­å¥æ‹†åˆ†ä»¥å½±å“è°ƒåº¦å™¨çš„è¡Œä¸ºå¹¶ä¼˜åŒ–å†…å­˜æ¶ˆè€— [49]ã€‚POLYSIMDåœ¨PPCGå¤šé¢ä½“æµç¨‹å‘¨å›´ä½¿ç”¨å˜é‡é‡å‘½åä»¥æ”¹å–„å‘é‡åŒ– [50]ã€‚Polygeiståˆ©ç”¨SSAå’Œå¤šé¢ä½“ä¿¡æ¯è‡ªåŠ¨åŒ–è¿™äº›æ“ä½œã€‚ e) Integration of Polyhedral Optimizers into Compilers: e) èšåˆä¼˜åŒ–å™¨ä¸ç¼–è¯‘å™¨çš„é›†æˆ: èšåˆä¼˜åŒ–ä¼ é€’åœ¨ç”Ÿäº§ï¼ˆGCC [8]ï¼ŒLLVM [7]ï¼ŒIBM XL [51]ï¼‰å’Œç ”ç©¶ï¼ˆR-Stream [49]ï¼ŒROSE [52]ï¼‰ç¼–è¯‘å™¨ä¸­å¯ç”¨ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå¿…é¡»ä»ä½çº§è¡¨ç¤ºä¸­æå–èšåˆæŠ½è±¡ï¼Œç„¶ååœ¨ä¸“é—¨çš„ä»£ç ç”Ÿæˆæ­¥éª¤ä¸­è¿›è¡Œè½¬æ¢å’Œé™çº§ [13]ï¼Œ[14]ã€‚è¿™ä¸ªæå–è¿‡ç¨‹å¹¶ä¸æ˜¯ä¿è¯æˆåŠŸçš„ï¼Œå¯èƒ½æ— æ³•æ¢å¤æºçº§åˆ«ä¸Šå¯ç”¨çš„é«˜çº§ä¿¡æ¯ [9]ã€‚æ­¤å¤–ï¼Œå¸¸è§çš„ç¼–è¯‘å™¨ä¼˜åŒ–ï¼Œä¾‹å¦‚LICMï¼Œå·²çŸ¥ä¼šå¯¹æ­¤äº§ç”Ÿå¹²æ‰° [10]ã€‚Polygeist é€šè¿‡è®¾è®¡ç»´æŠ¤è¶³å¤Ÿçš„é«˜çº§ä¿¡æ¯ï¼Œå°¤å…¶æ˜¯å¾ªç¯å’Œå¤šç»´æ•°ç»„ç»“æ„ï¼Œä»¥è§„é¿è¿™äº›é—®é¢˜ã€‚ æºåˆ°æºçš„èšåˆç¼–è¯‘å™¨ï¼Œå¦‚Pluto [11] å’ŒPPCG [5]ï¼Œåœ¨Cæˆ–C++çº§åˆ«ä¸Šè¿è¡Œã€‚å®ƒä»¬ç¼ºä¹ä¸å…¶ä»–ç¼–è¯‘å™¨ä¼˜åŒ–çš„äº¤äº’ï¼Œä»¥åŠå¯¹ä»£ç çš„å…¨å±€è§†è§’ï¼Œè¿™é˜»ç¢äº†ä¾‹å¦‚å¸¸é‡ä¼ æ’­å’Œå†…è”ç­‰å¯èƒ½æ”¹å–„èšåˆä¼˜åŒ–ç»“æœçš„è¿‡ç¨‹ã€‚Polygeistä½äºASTå’ŒLLVM IRçº§åˆ«ä¹‹é—´ï¼Œä½¿å¾—æ›´é«˜çº§åˆ«å’Œä½çº§åˆ«æŠ½è±¡ä¹‹é—´çš„äº¤äº’æˆä¸ºå¯èƒ½ï¼Œè€Œè¿™ç§äº¤äº’åœ¨å…¶ä»–æƒ…å†µä¸‹ä»…é™äºç¼–è¯‘å™¨æŒ‡ç¤ºï¼Œå³ä»…ä»…æ˜¯ä¼˜åŒ–æç¤ºã€‚æ­¤å¤–ï¼ŒPolygeistå¯ä»¥ä¾é MLIRçš„é€æ­¥æå‡ [53]ï¼Œä»¥æ¯”èšåˆæ¡†æ¶ [54] æ›´å°‘çš„åŠªåŠ›ï¼Œé’ˆå¯¹æ›´é«˜äºCä»£ç çš„æŠ½è±¡ã€‚ VII. DISCUSSION VII. è®¨è®º A. é™åˆ¶a) å‰ç«¯ï¼šå°½ç®¡PolygeistæŠ€æœ¯ä¸Šå¯ä»¥æ¥å—ä»»ä½•æœ‰æ•ˆçš„Cæˆ–C++ä»£ç ï¼Œå› ä¸ºå®ƒæ˜¯åŸºäºClangæ„å»ºçš„ï¼Œä½†ä»ç„¶å­˜åœ¨ä»¥ä¸‹é™åˆ¶ã€‚ç”±äºé«˜å±‚æ¬¡MLIRæ–¹è¨€ä¸­ç¼ºä¹ç»“æ„ç±»å‹ï¼Œä»…æ”¯æŒå€¼ç±»å‹ç›¸åŒçš„ç»“æ„ä½“ï¼Œæˆ–åœ¨ç‰¹å®šå‡½æ•°å†…ï¼ˆå¦‚fprintfä¸­çš„FILEï¼‰ä½¿ç”¨çš„ç»“æ„ä½“ã€‚æ‰€æœ‰åˆ†é…å†…å­˜çš„å‡½æ•°å¿…é¡»ä½¿ç”¨Polygeistç¼–è¯‘ï¼Œè€Œä¸æ˜¯ä½¿ç”¨C++ç¼–è¯‘å™¨ï¼Œè¿™æ ·æ‰èƒ½ç¡®ä¿ç”Ÿæˆçš„æ˜¯memrefè€ŒéæŒ‡é’ˆã€‚b) ä¼˜åŒ–å™¨ï¼šä¼˜åŒ–å™¨çš„é™åˆ¶æºè‡ªäºæ‰€æ¶‰åŠå·¥å…·çš„é™åˆ¶ã€‚ç‰¹åˆ«æ˜¯ï¼ŒMLIRçš„ä»¿å°„å€¼åˆ†ç±»å¯¼è‡´äº†å…¨æœ‰æˆ–å…¨æ— çš„å»ºæ¨¡ï¼Œå¦‚æœä»»ä½•å¾ªç¯ä¸­åŒ…å«ä¸€ä¸ªéä»¿å°„è®¿é—®æˆ–è´Ÿæ­¥é•¿ï¼Œå°±ä¼šå°†è¯¥å¾ªç¯é™çº§ä¸ºéä»¿å°„ã€‚å¯¹ä¸æ˜¯ç”±Polygeistå‰ç«¯ç”Ÿæˆçš„ä»£ç ä½¿ç”¨Polygeistçš„åç«¯è¿è¡Œæ—¶ï¼Œå°†é™åˆ¶åœ¨å…·æœ‰æ­£ç´¢å¼•çš„å¾ªç¯ä¸Šã€‚æœ€åï¼ŒMLIRç›®å‰å°šæœªæä¾›å¯¹éå‡¸é›†åˆçš„å¹¿æ³›æ”¯æŒï¼ˆé€šå¸¸ä»¥å¹¶é›†çš„å½¢å¼è¡¨ç¤ºï¼‰ã€‚MLIRå†…éƒ¨æ­£åœ¨è¿›è¡Œç›¸å…³å·¥ä½œä»¥è§£å†³æ­¤ç±»é—®é¢˜ã€‚c) å®éªŒï¼šå°½ç®¡æˆ‘ä»¬çš„å®éªŒæ¸…æ¥šåœ°å±•ç¤ºäº†åœ¨Polygeistä¸­å®ç°çš„æŠ€æœ¯çš„å¥½å¤„â€”â€”è¯­å¥æ‹†åˆ†å’ŒåæœŸï¼ˆå½’çº¦ï¼‰å¹¶è¡ŒåŒ–â€”â€”ä½†ä»æœ‰ä¸å®¹å¿½è§†çš„æ•ˆæœæ˜¯ç”±äºè°ƒåº¦å™¨çš„å·®å¼‚ï¼šPolygeistä¸­çš„Plutoå’ŒPollyä¸­çš„islã€‚ä½¿ç”¨Pluto 5çš„Pollyç‰ˆæœ¬ä¸ç°ä»£LLVMä¸å…¼å®¹ï¼Œè€Œåè€…åˆæ˜¯åˆ©ç”¨MLIRæ‰€å¿…éœ€çš„ã€‚å°†islè°ƒåº¦å™¨è¿æ¥åˆ°Polygeistå¯èƒ½ä¼šä½¿ç»“æœæ›´æ¥è¿‘Pollyï¼Œä½†ä»ç„¶æ— æ³•æ›´ç›´æ¥åœ°è¿›è¡Œæ¯”è¾ƒï¼Œå› ä¸ºSCoPæ£€æµ‹ã€è¯­å¥å½¢æˆå’Œä»¿å°„è°ƒåº¦ä¹‹é—´çš„ç›¸äº’ä½œç”¨ã€‚ B. Opportunities and Future Work å°†MLIRä¸ç°æœ‰çš„å¤šé¢ä½“æµç¨‹è¿æ¥èµ·æ¥ï¼Œä¸ºç¼–è¯‘å™¨ä¼˜åŒ–ç ”ç©¶å¼€è¾Ÿäº†è®¸å¤šæ–°é€”å¾„ï¼Œè¿æ¥äº†å¤šé¢ä½“å’Œä¼ ç»Ÿçš„åŸºäºSSAçš„ç¼–è¯‘å™¨è½¬æ¢ã€‚è¿™ä½¿å¾—å¤šé¢ä½“è°ƒåº¦å™¨å¯ä»¥è®¿é—®ä¸€äº›é‡è¦çš„åˆ†æä¿¡æ¯ï¼Œå¦‚åˆ«ååˆ†æä»¥åŠç²¾ç¡®çš„æ•°æ®å¸ƒå±€å’Œç›®æ ‡æœºå™¨æè¿°ç­‰æœ‰ç”¨ä¿¡æ¯ã€‚å¯ä»¥è¯´ï¼Œè¿™äº›ä¿¡æ¯å·²ç»è¢«Pollyåˆ©ç”¨ï¼Œä½†LLVM IRå’Œä»¿å°„å¾ªç¯ä¹‹é—´çš„è¡¨ç¤ºä¸åŒ¹é…ä½¿å¾—é«˜æ•ˆåˆ©ç”¨è¿™äº›ä¿¡æ¯å˜å¾—å›°éš¾ã€‚MLIRä»¥è¶³å¤Ÿé«˜çš„æŠ½è±¡å±‚çº§æš´éœ²äº†ç±»ä¼¼çš„ä¿¡æ¯ï¼Œä½¿å…¶å¯ç”¨äºä»¿å°„å˜æ¢ã€‚ é€šè¿‡åœ¨å•ä¸ªæ¨¡å—ä¸­æ··åˆä¸åŒçš„æŠ½è±¡ï¼ŒMLIRå¯¹æ•´ä¸ªè½¬æ¢è¿‡ç¨‹æä¾›äº†æ›´ç»†ç²’åº¦çš„æ§åˆ¶ã€‚Polygeistçš„æ‰©å±•å¯ä»¥ç¡®ä¿é€šè¿‡ç›´æ¥å‘å‡ºå‘é‡æŒ‡ä»¤æ¥å®ç°å¾ªç¯å‘é‡åŒ–ï¼Œè€Œä¸æ˜¯ä¾èµ–äºå¸¸å¸¸åªæ˜¯ç¼–è¯‘å™¨å»ºè®®çš„pragmaæŒ‡ä»¤ã€‚è¯¥æµç¨‹è¿˜å¯ä»¥æ§åˆ¶æ›´ä½å±‚æ¬¡çš„æœºåˆ¶ï¼Œå¦‚é¢„å–æˆ–å‘å‡ºä¸“ç”¨çš„ç¡¬ä»¶æŒ‡ä»¤ã€‚åä¹‹ï¼Œå¤šé¢ä½“åˆ†æå¯ä»¥ç¡®ä¿ä¸‹æ¸¸çš„å¤„ç†è¿‡ç¨‹ï¼Œä¾‹å¦‚ï¼Œåœ°å€è®¡ç®—æ°¸è¿œä¸ä¼šå¯¼è‡´è¶Šç•Œè®¿é—®ï¼Œä»¥åŠå…¶ä»–ä¿¡æ¯ã€‚ åœ¨Polygeistçš„æ”¯æŒä¸‹ï¼Œæ§åˆ¶è¯­å¥ç²’åº¦çš„æœªæ¥å·¥ä½œæ˜¯å¿…è¦çš„ã€‚é™¤äº†å½±å“ä»¿å°„è°ƒåº¦å¤–ï¼Œè¯¥æŠ€æœ¯è¿˜ä½¿å¾—è½»æ¾çš„é‡æ–°ç‰©åŒ–å’Œå±€éƒ¨è½¬ç½®ç¼“å†²æˆä¸ºå¯èƒ½ï¼Œè¿™åœ¨GPUä¸Šæ˜¯è‡³å…³é‡è¦çš„[55]ï¼Œä»¥åŠè½¯ä»¶æµæ°´çº¿åŒ–ï¼›æ‰€æœ‰è¿™äº›éƒ½ä¸éœ€è¦ç”Ÿæˆå·²çŸ¥å¤æ‚çš„Cæºä»£ç [56]ã€‚å¦ä¸€æ–¹é¢ï¼Œè¯­å¥æ•°é‡å¯èƒ½ä¼šå¯¹ç¼–è¯‘æ—¶é—´äº§ç”Ÿå½±å“ï¼Œå› ä¸ºè¯­å¥æ•°é‡æ˜¯ä¾èµ–åˆ†æå’Œè°ƒåº¦ç®—æ³•å¤æ‚æ€§è¾¹ç•Œçš„é‡è¦å› ç´ ã€‚ C. Alternatives æ›¿ä»£æ–¹æ¡ˆ ä¸å…¶è®©å¤šé¢ä½“å·¥å…·è§£æå¹¶ç”ŸæˆMLIRï¼Œä¸å¦‚ç›´æ¥ä»MLIRå‘å‡ºCï¼ˆæˆ–C++ï¼‰ä»£ç ï¼Œå¹¶åœ¨Cæºä»£ç ä¸Šä½¿ç”¨åŸºäºCçš„å¤šé¢ä½“å·¥å…·ï¼Œä½†è¿™ç§æ–¹æ³•é™ä½äº†ç¼–è¯‘æµç¨‹çš„è¡¨è¾¾èƒ½åŠ›ã€‚ä¸€äº›MLIRæ„é€ ï¼Œä¾‹å¦‚å¹¶è¡Œå½’çº¦å¾ªç¯ï¼Œå¯ä»¥ç›´æ¥åœ¨å¤šé¢ä½“æ¨¡å‹ä¸­è¡¨è¾¾ï¼Œè€Œåœ¨Cä¸­å´éœ€è¦ä¸€ä¸ªå¤æ‚ä¸”ä¸ä¿è¯å¯è¡Œçš„æå‡æ­¥éª¤ã€‚å¦ä¸€äº›æ„é€ ï¼Œä¾‹å¦‚é¢„å‘é‡åŒ–çš„ä»¿å°„å†…å­˜æ“ä½œï¼Œåˆ™æ ¹æœ¬æ— æ³•åœ¨Cä¸­è¡¨è¾¾ã€‚Polygeistæ”¯æŒåœ¨MLIRåˆ°MLIRçš„æµç¨‹ä¸­é€æ˜åœ°å¤„ç†è¿™äº›æ„é€ ï¼Œä½†æˆ‘ä»¬å°†æ­¤ç±»å¤„ç†çš„ç»†èŠ‚ç•™å¾…æœªæ¥ç ”ç©¶ã€‚ Polygeistæµç¨‹ä¹Ÿå¯ä»¥ä¸å…¶ä»–å¤šé¢ä½“æ ¼å¼ç›¸è¿æ¥ï¼Œç‰¹åˆ«æ˜¯ä¸islç›¸è¿ã€‚æˆ‘ä»¬é€‰æ‹©OpenScopä½œä¸ºæœ¬ç ”ç©¶çš„å¯¹è±¡ï¼Œå› ä¸ºå®ƒå¾—åˆ°æ›´å¤šå·¥å…·çš„æ”¯æŒã€‚islä½¿ç”¨è°ƒåº¦æ ‘æ¥è¡¨ç¤ºåˆå§‹å’Œè½¬åŒ–åçš„ç¨‹åºè°ƒåº¦ã€‚è°ƒåº¦æ ‘ä¸åµŒå¥—æ“ä½œçš„IRæ¨¡å‹éå¸¸æ¥è¿‘ï¼Œä½¿å¾—è½¬æ¢å˜å¾—ç®€å•ï¼šforå¾ªç¯å¯¹åº”äºå¸¦èŠ‚ç‚¹ï¼ˆæ¯ä¸ªå¸¦ç»´åº¦ä¸€ä¸ªå¾ªç¯ï¼‰ï¼Œifæ¡ä»¶å¯¹åº”äºè¿‡æ»¤èŠ‚ç‚¹ï¼Œå‡½æ•°çº§å¸¸é‡å¯ä»¥åŒ…å«åœ¨ä¸Šä¸‹æ–‡èŠ‚ç‚¹ä¸­ã€‚æ ‘ç»“æ„ä¸MLIRåŒºåŸŸä¿æŒä¸€è‡´ã€‚é€†å‘è½¬æ¢å¯ä»¥é€šè¿‡islçš„ASTç”Ÿæˆå·¥å…·è·å¾—ã€‚ VIII. CONCLUSION æˆ‘ä»¬æå‡ºäº†Polygeistï¼Œä¸€ç§å°†ç°æœ‰Cæˆ–C++ä»£ç å¯¼å…¥MLIRçš„ç¼–è¯‘å·¥ä½œæµç¨‹ï¼Œå¹¶å…è®¸å¤šé¢ä½“å·¥å…·ï¼ˆå¦‚Plutoï¼‰å¯¹MLIRç¨‹åºè¿›è¡Œä¼˜åŒ–ã€‚è¿™ä½¿å¾—MLIRèƒ½å¤Ÿå—ç›Šäºæ•°åå¹´æ¥åœ¨å¤šé¢ä½“ç¼–è¯‘æ–¹é¢çš„ç ”ç©¶ã€‚æˆ‘ä»¬è¯æ˜äº†Polygeistç”Ÿæˆçš„ä»£ç åœ¨æ€§èƒ½ä¸Šä¸Clangç›¸å½“ï¼Œä»è€Œå®ç°äº†é’ˆå¯¹MLIRæ„å»ºçš„å˜æ¢ä¸ç°æœ‰å¤šé¢ä½“æ¡†æ¶ä¹‹é—´çš„å…¬æ­£æ¯”è¾ƒã€‚æœ€åï¼Œæˆ‘ä»¬å±•ç¤ºäº†Polygeistæ‰€å¸¦æ¥çš„ä¼˜åŒ–æœºä¼šï¼Œè€ƒè™‘äº†ä¸¤ç§äº’è¡¥çš„å˜æ¢ï¼šè¯­å¥æ‹†åˆ†å’Œå½’çº¦å¹¶è¡ŒåŒ–ã€‚åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼ŒPolygeistçš„æ€§èƒ½å‡ä¼˜äºæœ€å…ˆè¿›çš„å¤šé¢ä½“ç¼–è¯‘å™¨å’Œæºåˆ°æºä¼˜åŒ–å™¨ã€‚ å…³äºå¦‚ä½•åœ¨ç¡¬ä»¶æˆ–è½¯ä»¶é…ç½®ä¸æˆ‘ä»¬æ‰€ä½¿ç”¨çš„ä¸åŒçš„ç³»ç»Ÿä¸Šè¿è¡Œï¼Œè¿™å¯èƒ½éœ€è¦ä¿®æ”¹çš„è¯„è®ºã€‚å¦‚é¢„æœŸçš„é‚£æ ·ï¼Œå‘½ä»¤æè¿°ä¸dockeræ–‡ä»¶çš„å†…å®¹ç›¸ä¼¼ã€‚è™½ç„¶dockeræ–‡ä»¶æ— ç–‘æ›´æ–¹ä¾¿ï¼Œæ˜¯è®¾ç½®ç¼–è¯‘å™¨çš„å¥½æ–¹æ³•ï¼Œä½†å³ä¾¿ä½¿ç”¨Dockerï¼Œå¯¹äºè¯„ä¼°ç³»ç»Ÿçš„æ ¸å¿ƒæ•°é‡çš„æœŸæœ›ä¹Ÿéœ€è¦ç±»ä¼¼çš„æ›´æ”¹ã€‚ è¦ç¼–è¯‘Polygeistï¼Œé¦–å…ˆéœ€è¦ç¼–è¯‘å…¶è‹¥å¹²ä¾èµ–é¡¹ã€‚æˆ‘ä»¬åœ¨åŸºäºUbuntu 20.04çš„AWS c5.metalå®ä¾‹ä¸Šè¿è¡Œäº†å®éªŒã€‚æˆ‘ä»¬æ ¹æ®è¯¥ç³»ç»Ÿè°ƒæ•´äº†æ„å»ºè¯´æ˜ã€‚è™½ç„¶è®¸å¤šè¯´æ˜æ˜¯é€šç”¨çš„ï¼Œä¸æœºå™¨æˆ–æ“ä½œç³»ç»Ÿæ— å…³ï¼Œä½†æŸäº›æ­¥éª¤å¯èƒ½å¹¶éå¦‚æ­¤ï¼ˆæˆ‘ä»¬å°†åœ¨ä¸‹æ–‡ä¸­æè¿°å®ƒä»¬å¯èƒ½å‡ºç°çš„ä½ç½®ï¼‰ã€‚ $ sudo apt update $ sudo apt install apt-utils $ sudo apt install tzdata build-essential \\ libtool autoconf pkg-config flex bison \\ libgmp-dev clang-9 libclang-9-dev texinfo \\ cmake ninja-build git texlive-full numactl # æ›´æ”¹é»˜è®¤ç¼–è¯‘å™¨ä»¥ä½¿Plutoæ­£å¸¸å·¥ä½œ $ sudo update-alternatives --install \\ /usr/bin/llvm-config llvm-config \\ /usr/bin/llvm-config-9 100 $ sudo update-alternatives --install \\ /usr/bin/FileCheck FileCheck-9 \\ /usr/bin/FileCheck 100 $ sudo update-alternatives --install \\ /usr/bin/clang clang \\ /usr/bin/clang-9 100 $ sudo update-alternatives --install \\ /usr/bin/clang++ clang++ \\ /usr/bin/clang++-9 100 é¦–å…ˆï¼Œè®©æˆ‘ä»¬ä¸‹è½½ä¸€ä¸ªå®ç”¨å·¥å…·åº“ï¼Œå…¶ä¸­å°†åŒ…å«ä¸€äº›ç¼–è¯‘å’ŒåŸºå‡†æµ‹è¯•æ‰€éœ€çš„è„šæœ¬å’Œå…¶ä»–æ–‡ä»¶ï¼š $ cd $ git clone \\ https://github.com/wsmoses/Polygeist-Script\\ scripts ç°åœ¨å¯ä»¥æŒ‰ç…§ä¸‹é¢çš„æ­¥éª¤ç¼–è¯‘å’Œæ„å»ºPlutoï¼š $ cd $ git clone \\ https://github.com/bondhugula/pluto $ cd pluto/ $ git checkout e5a039096547e0a3d34686295c $ git submodule init $ git submodule update $ ./autogen.sh $ ./configure $ make -jnproc æ¥ä¸‹æ¥ï¼Œå¯ä»¥é€šè¿‡æ‰§è¡Œä»¥ä¸‹æ“ä½œæ¥æ„å»ºLLVMã€MLIRå’Œå‰ç«¯ï¼š ä»è¿™é‡Œå¼€å§‹ï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡å¤åˆ¶è„šæœ¬åº“ä¸­çš„ç‰ˆæœ¬å¹¶æ›¿æ¢æˆ‘ä»¬åˆšåˆšæ„å»ºçš„ç‰ˆæœ¬æ¥ä¿®æ”¹omp.hã€‚ $ cd $ export OMP_FILE=find \\ $HOME/mlir-clang/build -iname omp.h $ cp $HOME/scripts/omp.h $OMP_FILE ç°åœ¨è®©æˆ‘ä»¬æ„å»ºMLIRå¤šé¢ä½“åˆ†æï¼Œä»¥åŠå®ƒæ‰€éœ€çš„ç‰¹å®šç‰ˆæœ¬çš„LLVMã€‚æˆ‘ä»¬å°†å¼€å§‹ä¸‹è½½æ‰€éœ€çš„ä»£ç å¹¶æ„å»ºå…¶ä¾èµ–é¡¹ã€‚ $ cd $ git clone --recursive \\ https://github.com/kumasento/polymer -b pact $ cd polymer/ $ cd llvm/ $ mkdir build $ cd build/ $ cmake ../llvm \\ -DLLVM_ENABLE_PROJECTS=\"llvm;clang;mlir\" \\ -DLLVM_TARGETS_TO_BUILD=\"host\" \\ -DLLVM_ENABLE_ASSERTIONS=ON \\ -DCMAKE_BUILD_TYPE=Release \\ -DLLVM_INSTALL_UTILS=ON \\ -G Ninja $ ninja -jnproc $ ninja check-mlir ç°åœ¨æˆ‘ä»¬å¯ä»¥æ„å»ºMLIRå¤šé¢ä½“åˆ†æå¹¶å¯¼å‡ºç›¸åº”çš„æ„å»ºäº§ç‰©ã€‚ $ cd ~/polymer $ mkdir build $ cd build $ export BUILD=$PWD/../llvm/build $ cmake .. \\ -DCMAKE_BUILD_TYPE=DEBUG \\ -DMLIR_DIR=$BUILD/lib/cmake/mlir \\ -DLLVM_DIR=$BUILD/lib/cmake/llvm \\ -DLLVM_ENABLE_ASSERTIONS=ON \\ -DLLVM_EXTERNAL_LIT=$BUILD/bin/llvm-lit \\ -G Ninja $ ninja -jnproc $ export LD_LIBRARY_PATH= \\ pwd/pluto/lib:$LD_LIBRARY_PATH $ ninja check-polymer æœ€åï¼Œæˆ‘ä»¬å‡†å¤‡å¼€å§‹åŸºå‡†æµ‹è¯•ã€‚æˆ‘ä»¬é¦–å…ˆè¿è¡Œä¸€ä¸ªè„šæœ¬ï¼Œç¦ç”¨æ¶¡è½®æå‡å’Œè¶…çº¿ç¨‹ï¼Œå¹¶å…³é—­æœºå™¨ä¸Šä»ç„¶ä¸å¿…è¦çš„æœåŠ¡ã€‚è¯¥è„šæœ¬ç‰¹å®šäºAWSå®ä¾‹ä¸Šçš„æ ¸å¿ƒæ•°é‡ï¼ˆæ‰€æœ‰æ ¸å¿ƒä¸­é™¤ç¬¬ä¸€ä¸ªæ’æ§½ä¸Šçš„éè¶…çº¿ç¨‹æ ¸å¿ƒå¤–å‡è¢«ç¦ç”¨ï¼‰ï¼Œä»¥åŠä½¿ç”¨çš„é•œåƒï¼ˆé•œåƒä¸Šä»å­˜åœ¨çš„æ‰€æœ‰ä¸å¿…è¦æœåŠ¡è¢«ç¦ç”¨ï¼‰ï¼Œå› æ­¤å¦‚æœæ‰“ç®—åœ¨å…¶ä»–æœºå™¨ä¸Šä½¿ç”¨ï¼Œå¯èƒ½éœ€è¦è¿›è¡Œä¿®æ”¹ã€‚ $ cd ~/scripts/ $ sudo bash ./hyper.sh æˆ‘ä»¬ç°åœ¨å¯ä»¥è¿è¡ŒåŸºå‡†æµ‹è¯•è„šæœ¬ã€‚è¯¥è„šæœ¬æœ¬èº«å¯¹æ ¸å¿ƒå’Œå¸ƒå±€æœ‰ä¸€äº›å‡è®¾ï¼ˆä¾‹å¦‚ï¼Œè®¾ç½® taskset -c 1-8 numactl -i allï¼‰ã€‚å¦‚æœä½¿ç”¨ä¸åŒçš„æœºå™¨ï¼Œå¯èƒ½éœ€è¦æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´è¿™äº›è®¾ç½®ã€‚ cd ~/scripts/ $ cd polybench-c-4.2.1-beta/ $ ./run.sh # è¾“å‡ºé€šè¿‡æ ‡å‡†è¾“å‡ºç”Ÿæˆ è¯¥è„šæœ¬çš„è¾“å‡ºå°†åŒ…å«æ¯æ¬¡è¯•éªŒçš„è¿è¡Œæ—¶é—´ï¼Œæè¿°æ‰€ä½¿ç”¨çš„ç¼–è¯‘è®¾ç½®ä»¥åŠè¿è¡Œäº†å“ªä¸ªåŸºå‡†æµ‹è¯•ã€‚ æœ¬æ–‡ä»¶ä¸­åŒ…å«çš„è§‚ç‚¹å’Œç»“è®ºæ˜¯ä½œè€…çš„è§‚ç‚¹ï¼Œä¸åº”è¢«è§£è¯»ä¸ºä»£è¡¨ç¾å›½ç©ºå†›æˆ–ç¾å›½æ”¿åºœçš„å®˜æ–¹æ”¿ç­–ï¼Œæ— è®ºæ˜¯æ˜ç¤ºè¿˜æ˜¯æš—ç¤ºã€‚ç¾å›½æ”¿åºœè¢«æˆæƒä¸ºäº†æ”¿åºœç›®çš„å¤å°å’Œåˆ†å‘è¯¥æ–‡ä»¶çš„å°åˆ·æœ¬ï¼Œå°½ç®¡è¿™é‡Œæœ‰ä»»ä½•ç‰ˆæƒè¯´æ˜ã€‚ APPENDIX åœ¨æœ¬é™„å½•ä¸­ï¼Œæˆ‘ä»¬æè¿°äº†å¦‚ä½•æ„å»ºPolygeistå¹¶è¯„ä¼°å…¶åœ¨PolybenchåŸºå‡†æµ‹è¯•å¥—ä»¶ä¸Šçš„æ€§èƒ½ï¼ˆä»¥åŠåŸºå‡†ç¼–è¯‘å™¨ï¼‰ã€‚æˆ‘ä»¬æä¾›äº†ä¸¤ç§è‰ºæœ¯å“è¯„ä¼°æœºåˆ¶ï¼šä¸€ä¸ªDockerå®¹å™¨ä»¥åŠé€æ­¥å‘½ä»¤æè¿°çš„å®‰è£…è¿‡ç¨‹ï¼Œè¿åŒ "},"Learn/LearnPolygeist/2021_Polygeist-Raising C to Polyhedral MLIRtranslated_and_original.html":{"url":"Learn/LearnPolygeist/2021_Polygeist-Raising C to Polyhedral MLIRtranslated_and_original.html","title":"2021_Polygeist-Raising C to Polyhedral MLIRtranslated_and_original","keywords":"","body":"GPT-Academic Report # Title: Polygeist: Raising C to Polyhedral MLIR # Abstract: We present Polygeist, a new compilation flow that connects the MLIR compiler infrastructure to cutting edge polyhedral optimization tools. It consists of a C and C++ frontend capable of converting a broad range of existing codes into MLIR suitable for polyhedral transformation and a bi-directional conversion between MLIR and OpenScop exchange format. The Polygeist/MLIR intermediate representation featuring high-level (affine) loop constructs and n-D arrays embedded into a single static assignment (SSA) substrate enables an unprecedented combination of SSA-based and polyhedral optimizations. We illustrate this by proposing and implementing two extra transformations: statement splitting and reduction parallelization. Our evaluation demonstrates that Polygeist outperforms on average both an LLVM IR-level optimizer (Polly) and a source-to-source state-of-the-art polyhedral compiler (Pluto) when exercised on the Polybench/C benchmark suite in sequential (2.53x vs 1.41x, 2.34x) and parallel mode (9.47x vs 3.26x, 7.54x) thanks to the new representation and transformations. # Meta Translation æ ‡é¢˜ï¼šPolygeist: å°†Cæå‡åˆ°å¤šé¢ä½“MLIR æ‘˜è¦ï¼šæˆ‘ä»¬æå‡ºäº†Polygeistï¼Œè¿™æ˜¯ä¸€ç§æ–°çš„ç¼–è¯‘æµç¨‹ï¼Œæ—¨åœ¨å°†MLIRç¼–è¯‘åŸºç¡€è®¾æ–½ä¸å‰æ²¿çš„å¤šé¢ä½“ä¼˜åŒ–å·¥å…·è¿æ¥èµ·æ¥ã€‚å®ƒåŒ…æ‹¬ä¸€ä¸ªCå’ŒC++å‰ç«¯ï¼Œèƒ½å¤Ÿå°†å¹¿æ³›çš„ç°æœ‰ä»£ç è½¬æ¢ä¸ºé€‚åˆå¤šé¢ä½“å˜æ¢çš„MLIRï¼Œå¹¶å®ç°MLIRä¸OpenScopäº¤æ¢æ ¼å¼ä¹‹é—´çš„åŒå‘è½¬æ¢ã€‚Polygeist/MLIRä¸­é—´è¡¨ç¤ºå…·å¤‡é«˜å±‚ï¼ˆä»¿å°„ï¼‰å¾ªç¯æ„é€ å’ŒåµŒå…¥åˆ°å•ä¸€é™æ€èµ‹å€¼ï¼ˆSSAï¼‰åŸºç¡€ç»“æ„ä¸­çš„nç»´æ•°ç»„ï¼Œèƒ½å¤Ÿå®ç°å‰æ‰€æœªæœ‰çš„SSAåŸºç¡€å’Œå¤šé¢ä½“ä¼˜åŒ–çš„ç»“åˆã€‚æˆ‘ä»¬é€šè¿‡æå‡ºå’Œå®ç°ä¸¤ä¸ªé¢å¤–å˜æ¢ï¼šè¯­å¥åˆ†å‰²å’Œå½’çº¦å¹¶è¡ŒåŒ–ï¼Œæ¥è¯æ˜è¿™ä¸€ç‚¹ã€‚æˆ‘ä»¬çš„è¯„ä¼°è¡¨æ˜ï¼ŒPolygeiståœ¨Polybench/CåŸºå‡†å¥—ä»¶çš„é¡ºåºæ¨¡å¼ï¼ˆ2.53xå¯¹æ¯”1.41xï¼Œ2.34xï¼‰å’Œå¹¶è¡Œæ¨¡å¼ï¼ˆ9.47xå¯¹æ¯”3.26xï¼Œ7.54xï¼‰ä¸Šçš„è¡¨ç°å¹³å‡ä¼˜äºLLVM IRçº§åˆ«ä¼˜åŒ–å™¨ï¼ˆPollyï¼‰å’Œå…ˆè¿›çš„æºåˆ°æºå¤šé¢ä½“ç¼–è¯‘å™¨ï¼ˆPlutoï¼‰ï¼Œè¿™å¾—ç›Šäºæ–°çš„è¡¨ç¤ºå’Œå˜æ¢ã€‚ # I. INTRODUCTION Improving the efficiency of computation has always been one of the prime goals of computing. Program performance can be improved significantly by reaping the benefits of parallelism, temporal and spatial locality, and other performance sources. Relevant program transformations are particularly tedious and challenging when targeting modern multicore CPUs and GPUs with deep memory hierarchies and parallelism, and are often performed automatically by optimizing compilers. The polyhedral model enables precise analyses and a relatively easy specification of transformations (loop restructuring, automatic parallelization, etc.) that take advantage of hardware performance sources. As a result, there is growing evidence that the polyhedral model is one of the best frameworks for efficient transformation of compute-intensive programs [1], [2], [3], and for programming accelerator architectures [4], [5], [6]. Consequently, the compiler community has focused on building tools that identify and optimize parts of the program that can be represented within the polyhedral model (commonly referred to as static-control parts, or SCoP's). Such tools tend to fall into two categories. Compiler-based tools like Polly [7] and Graphite [8] detect and transform SCoPs in compiler intermediate representations (IRs). While this offers seamless integration with rest of the compiler, the lack of high-level structure and information hinders the tools' ability to perform analyses and transformations. This structure needs to be recovered from optimized IR, often Fig. 1. The Polygeist compilation flow consists of 4 stages. The frontend traverses Clang AST to emit MLIR SCF dialect (Section III-A), which is raised to the Affine dialect and pre-optimized (Section III-B). The IR is then processed by a polyhedral scheduler (Sections III-C,III-D) before postoptimization and parallelization (Section III-E). Finally, it is translated to LLVM IR for further optimization and binary generation by LLVM. imperfectly or at a significant cost [9]. Moreover, common compiler optimizations such as LICM may interfere with the process [10]. Finally, low-level IRs often lack constructs for, e.g., parallelism or reductions, produced by the transformation, which makes the flow more complex. Source-to-source compilers such as Pluto [11], POCC [12] and PPCG [5] operate directly on C or C++ code. While this can effectively leverage the high-level information from source code, the effectiveness of such tools is often reduced by the lack of enabling optimizations such as those converting hazardous memory loads into single-assignment virtual registers. Furthermore, the transformation results must be expressed in C, which is known to be complex [13], [14] and is also missing constructs for, e.g., reduction loops or register values not backed by memory storage. This paper proposes and evaluates the benefits of a polyhedral compilation flow, Polygeist (Figure 1), that can leverage both the high-level structure available in source code and the fine-grained control of compiler optimization provided by lowlevel IRs. It builds on the recent MLIR compiler infrastructure that allows the interplay of multiple abstraction levels within the same representation, during the same transformations [15]. Intermixable MLIR abstractions, or dialects, include highlevel constructs such as loops, parallel and reduction patterns; low-level representations fully covering LLVM IR [16]; and a polyhedral-inspired representation featuring loops and memory accesses annotated with affine expressions. Moreover, by combining the best of source-level and IR-level tools in an end-to-end polyhedral flow, Polygeist preserves high-level information and leverages them to perform new or improved %result = \"dialect.operation\"(%operand, %operand) {attribute = #dialect} ({ // Inside a nested region. ^basic_block(%block_argument: !dialect.type): \"another.operation\"() : () -> () }) : (!dialect.type) -> !dialect.result_type Fig. 2. Generic MLIR syntax for an operation with two operands, one result, one attribute and a single-block region. optimizations, such as statement splitting and loop-carried value detection, on a lower-level abstraction as well as to influence downstream optimizations. We make the following contributions: â€¢ a C and C++ frontend for MLIR that preserves high-level loop structure from the original source code; â€¢ an end-to-end flow with raising to and lowering from the polyhedral model, leveraging our abstraction to perform more optimizations than both source-and IR-level tools, including reduction parallelization; â€¢ an exploration of new transformation opportunities created by Polygeist, in particular, statement splitting; â€¢ and an end-to-end comparison between Polygeist and state-of-the-art source-and IR-based tools (Pluto [11] and Polly [14]) along with optimization case studies. I. å¼•è¨€ æé«˜è®¡ç®—æ•ˆç‡ä¸€ç›´æ˜¯è®¡ç®—é¢†åŸŸçš„ä¸»è¦ç›®æ ‡ä¹‹ä¸€ã€‚é€šè¿‡åˆ©ç”¨å¹¶è¡Œæ€§ã€æ—¶é—´å’Œç©ºé—´å±€éƒ¨æ€§ä»¥åŠå…¶ä»–æ€§èƒ½æ¥æºï¼Œå¯ä»¥æ˜¾è‘—æé«˜ç¨‹åºæ€§èƒ½ã€‚å½“é’ˆå¯¹ç°ä»£å¤šæ ¸ CPU å’Œ GPU è¿›è¡Œç›¸å…³ç¨‹åºå˜æ¢æ—¶ï¼Œè¿™äº›å˜æ¢å°¤å…¶ç¹çä¸”å…·æœ‰æŒ‘æˆ˜æ€§ï¼Œå› ä¸ºç°ä»£æ¶æ„å…·æœ‰æ·±åº¦å†…å­˜å±‚æ¬¡å’Œå¹¶è¡Œæ€§ï¼Œé€šå¸¸ç”±ä¼˜åŒ–ç¼–è¯‘å™¨è‡ªåŠ¨æ‰§è¡Œã€‚ å¤šé¢ä½“æ¨¡å‹èƒ½å¤Ÿå®ç°ç²¾ç¡®åˆ†æå’Œç›¸å¯¹ç®€å•çš„å˜æ¢è§„èŒƒï¼ˆå¦‚å¾ªç¯é‡æ„ã€è‡ªåŠ¨å¹¶è¡ŒåŒ–ç­‰ï¼‰ï¼Œä»¥åˆ©ç”¨ç¡¬ä»¶æ€§èƒ½æ¥æºã€‚å› æ­¤ï¼Œæœ‰è¶Šæ¥è¶Šå¤šçš„è¯æ®è¡¨æ˜ï¼Œå¤šé¢ä½“æ¨¡å‹æ˜¯é«˜æ•ˆè½¬åŒ–è®¡ç®—å¯†é›†å‹ç¨‹åº [1]ã€[2]ã€[3] å’Œç¼–ç¨‹åŠ é€Ÿå™¨æ¶æ„ [4]ã€[5]ã€[6] çš„æœ€ä½³æ¡†æ¶ä¹‹ä¸€ã€‚å› æ­¤ï¼Œç¼–è¯‘å™¨ç¤¾åŒºä¸“æ³¨äºæ„å»ºå·¥å…·ï¼Œä»¥è¯†åˆ«å’Œä¼˜åŒ–å¯ä»¥åœ¨å¤šé¢ä½“æ¨¡å‹ä¸­è¡¨ç¤ºçš„ç¨‹åºéƒ¨åˆ†ï¼ˆé€šå¸¸ç§°ä¸ºé™æ€æ§åˆ¶éƒ¨åˆ†æˆ– SCoPï¼‰ã€‚è¿™äº›å·¥å…·å¾€å¾€åˆ†ä¸ºä¸¤ç±»ã€‚ åŸºäºç¼–è¯‘å™¨çš„å·¥å…·ï¼Œå¦‚ Polly [7] å’Œ Graphite [8]ï¼Œåœ¨ç¼–è¯‘å™¨ä¸­é—´è¡¨ç¤ºï¼ˆIRï¼‰ä¸­æ£€æµ‹å’Œè½¬æ¢ SCoPã€‚å°½ç®¡è¿™ä¸ç¼–è¯‘å™¨çš„å…¶ä½™éƒ¨åˆ†æ— ç¼é›†æˆï¼Œä½†ç¼ºä¹é«˜å±‚æ¬¡ç»“æ„å’Œä¿¡æ¯é™åˆ¶äº†è¿™äº›å·¥å…·è¿›è¡Œåˆ†æå’Œå˜æ¢çš„èƒ½åŠ›ã€‚è¿™ç§ç»“æ„é€šå¸¸éœ€è¦é€šè¿‡ä¼˜åŒ–åçš„ IR æ¢å¤ï¼Œå¾€å¾€æ˜¯ä»¥ä¸å®Œå…¨æˆ–é«˜æˆæœ¬çš„æ–¹å¼å®ç° [9]ã€‚æ­¤å¤–ï¼Œè¯¸å¦‚ LICM çš„å¸¸è§ç¼–è¯‘å™¨ä¼˜åŒ–å¯èƒ½ä¼šå¹²æ‰°è¿™ä¸€è¿‡ç¨‹ [10]ã€‚æœ€åï¼Œä½çº§ IR é€šå¸¸ç¼ºä¹ç”±å˜æ¢ç”Ÿæˆçš„å¹¶è¡Œæ€§æˆ–å½’çº¦çš„æ„é€ ï¼Œä»è€Œä½¿æµç¨‹æ›´åŠ å¤æ‚ã€‚ æºåˆ°æºç¼–è¯‘å™¨ï¼Œå¦‚ Pluto [11]ã€POCC [12] å’Œ PPCG [5]ï¼Œç›´æ¥åœ¨ C æˆ– C++ ä»£ç ä¸Šæ“ä½œã€‚è™½ç„¶è¿™å¯ä»¥æœ‰æ•ˆåœ°åˆ©ç”¨æºä»£ç ä¸­çš„é«˜å±‚ä¿¡æ¯ï¼Œä½†è¿™äº›å·¥å…·çš„æœ‰æ•ˆæ€§å¾€å¾€å› ç¼ºä¹å¯ç”¨ä¼˜åŒ–è€Œé™ä½ï¼Œä¾‹å¦‚å°†å±é™©çš„å†…å­˜åŠ è½½è½¬æ¢ä¸ºå•èµ‹å€¼è™šæ‹Ÿå¯„å­˜å™¨ã€‚æ­¤å¤–ï¼Œå˜æ¢ç»“æœå¿…é¡»ç”¨ C è¡¨è¾¾ï¼Œè€Œ C è¯­è¨€æœ¬èº«çš„å¤æ‚æ€§ä¼—æ‰€å‘¨çŸ¥ [13]ã€[14]ï¼Œè€Œä¸”ä¹Ÿç¼ºä¹ä¾‹å¦‚å½’çº¦å¾ªç¯æˆ–æœªè¢«å†…å­˜å­˜å‚¨æ”¯æŒçš„å¯„å­˜å™¨å€¼çš„æ„é€ ã€‚ æœ¬æ–‡æå‡ºå¹¶è¯„ä¼°äº†ä¸€ç§å¤šé¢ä½“ç¼–è¯‘æµç¨‹ Polygeistï¼ˆå›¾ 1ï¼‰çš„å¥½å¤„ï¼Œè¯¥æµç¨‹å¯ä»¥åˆ©ç”¨æºä»£ç ä¸­å¯ç”¨çš„é«˜å±‚ç»“æ„ä»¥åŠç”±ä½çº§ IR æä¾›çš„ç¼–è¯‘å™¨ä¼˜åŒ–çš„ç»†ç²’åº¦æ§åˆ¶ã€‚å®ƒæ„å»ºåœ¨æœ€è¿‘çš„ MLIR ç¼–è¯‘å™¨åŸºç¡€è®¾æ–½ä¹‹ä¸Šï¼Œè¯¥åŸºç¡€è®¾æ–½å…è®¸åœ¨åŒä¸€è¡¨ç¤ºä¸­ã€åœ¨åŒä¸€å˜æ¢è¿‡ç¨‹ä¸­æ··åˆå¤šä¸ªæŠ½è±¡å±‚æ¬¡ [15]ã€‚å¯äº’æ¢çš„ MLIR æŠ½è±¡æˆ–æ–¹è¨€åŒ…æ‹¬é«˜å±‚æ„é€ ï¼Œå¦‚å¾ªç¯ã€å¹¶è¡Œå’Œå½’çº¦æ¨¡å¼ï¼›å®Œæ•´è¦†ç›– LLVM IR çš„ä½å±‚è¡¨ç¤º [16]ï¼›ä»¥åŠä¸€ç§å—åˆ°å¤šé¢ä½“å¯å‘çš„è¡¨ç¤ºï¼Œå…·æœ‰å¸¦æœ‰ä»¿å°„è¡¨è¾¾å¼æ³¨é‡Šçš„å¾ªç¯å’Œå†…å­˜è®¿é—®ã€‚æ­¤å¤–ï¼Œé€šè¿‡å°†æºçº§å’Œ IR çº§å·¥å…·çš„ä¼˜åŠ¿ç»“åˆåœ¨ä¸€ä¸ªç«¯åˆ°ç«¯çš„å¤šé¢ä½“æµç¨‹ä¸­ï¼ŒPolygeist ä¿ç•™äº†é«˜å±‚ä¿¡æ¯å¹¶åˆ©ç”¨è¿™äº›ä¿¡æ¯åœ¨è¾ƒä½çº§åˆ«æŠ½è±¡ä¸Šæ‰§è¡Œæ–°çš„æˆ–æ”¹è¿›çš„ä¼˜åŒ–ï¼Œå¦‚è¯­å¥æ‹†åˆ†å’Œå¾ªç¯æºå¸¦å€¼æ£€æµ‹ï¼ŒåŒæ—¶å½±å“åç»­ä¼˜åŒ–ã€‚ æˆ‘ä»¬çš„è´¡çŒ®å¦‚ä¸‹ï¼š â€¢ ä¸€ä¸ª C å’Œ C++ çš„ MLIR å‰ç«¯ï¼Œä¿ç•™åŸå§‹æºä»£ç ä¸­çš„é«˜å±‚å¾ªç¯ç»“æ„ï¼› â€¢ ä¸€ä¸ªç«¯åˆ°ç«¯çš„æµç¨‹ï¼Œå®ç°å‘å¤šé¢ä½“æ¨¡å‹çš„æå‡å’Œé™ä½ï¼Œåˆ©ç”¨æˆ‘ä»¬çš„æŠ½è±¡æ‰§è¡Œæ¯”æºçº§å’Œ IR çº§å·¥å…·æ›´å¤šçš„ä¼˜åŒ–ï¼ŒåŒ…æ‹¬å½’çº¦å¹¶è¡ŒåŒ–ï¼› â€¢ æ¢ç´¢ Polygeist åˆ›å»ºçš„æ–°å˜æ¢æœºä¼šï¼Œå°¤å…¶æ˜¯è¯­å¥æ‹†åˆ†ï¼› â€¢ ä»¥åŠ Polygeist ä¸æœ€å…ˆè¿›çš„åŸºäºæºå’Œ IR çš„å·¥å…·ï¼ˆPluto [11] å’Œ Polly [14]ï¼‰ä¹‹é—´çš„ç«¯åˆ°ç«¯æ¯”è¾ƒï¼Œä»¥åŠä¼˜åŒ–æ¡ˆä¾‹ç ”ç©¶ã€‚ # A. Overview MLIR is an optimizing compiler infrastructure inspired by LLVM [16] with a focus on extensibility and modularity [15]. Its main novelty is the IR supporting a fully extensible set of instructions (called operations) and types. Practically, MLIR combines SSA with nested regions, allowing one to express a range of concepts as first-class operations including machine instructions such as floating-point addition, structured control flow such as loops, hardware circuitry [17], and large machine learning graphs. Operations define the runtime semantics of a program and process immutable values. Compile-time information about values is expressed in types, and information about operations is expressed in attributes. Operations can have attached regions, which in turn contain (basic) blocks of further operations. The generic syntax, accepted by all operations, illustrates the structure of MLIR in Figure 2. Additionally, MLIR supports user-defined custom syntax. Attributes, operations, and types are organized in dialects, which can be thought of as modular libraries. MLIR provides a handful of dialects that define common operations such as modules, functions, loops, memory or arithmetic instructions, and ubiquitous types such as integers and floats. We discuss the dialects relevant to Polygeist in the following sections. A. æ¦‚è¿° MLIRæ˜¯ä¸€ç§ä¼˜åŒ–ç¼–è¯‘å™¨åŸºç¡€è®¾æ–½ï¼Œå—åˆ°LLVMçš„å¯å‘ï¼Œé‡ç‚¹å…³æ³¨æ‰©å±•æ€§å’Œæ¨¡å—åŒ–ã€‚å…¶ä¸»è¦åˆ›æ–°åœ¨äºæ”¯æŒå®Œå…¨å¯æ‰©å±•çš„ä¸€ç»„æŒ‡ä»¤ï¼ˆç§°ä¸ºæ“ä½œï¼‰å’Œç±»å‹çš„ä¸­é—´è¡¨ç¤ºï¼ˆIRï¼‰ã€‚å®é™…ä¸Šï¼ŒMLIRå°†é™æ€å•èµ‹å€¼ï¼ˆSSAï¼‰ä¸åµŒå¥—åŒºåŸŸç›¸ç»“åˆï¼Œä½¿å¾—èƒ½å¤Ÿå°†ä¸€ç³»åˆ—æ¦‚å¿µè¡¨ç¤ºä¸ºä¸€ç±»ä¸€æµçš„æ“ä½œï¼ŒåŒ…æ‹¬æœºå™¨æŒ‡ä»¤ï¼Œä¾‹å¦‚æµ®ç‚¹åŠ æ³•ã€ç»“æ„åŒ–æ§åˆ¶æµï¼Œä¾‹å¦‚å¾ªç¯ã€ç¡¬ä»¶ç”µè·¯ï¼Œä»¥åŠå¤§å‹æœºå™¨å­¦ä¹ å›¾ã€‚æ“ä½œå®šä¹‰äº†ç¨‹åºçš„è¿è¡Œæ—¶è¯­ä¹‰ï¼Œå¹¶å¤„ç†ä¸å¯å˜å€¼ã€‚æœ‰å…³å€¼çš„ç¼–è¯‘æ—¶ä¿¡æ¯ç”¨ç±»å‹è¡¨ç¤ºï¼Œè€Œæœ‰å…³æ“ä½œçš„ä¿¡æ¯ç”¨å±æ€§è¡¨ç¤ºã€‚æ“ä½œå¯ä»¥é™„å¸¦åŒºåŸŸï¼Œè€Œè¿™äº›åŒºåŸŸå†…éƒ¨åˆåŒ…å«å…¶ä»–æ“ä½œçš„ï¼ˆåŸºæœ¬ï¼‰å—ã€‚æ‰€æœ‰æ“ä½œæ¥å—çš„é€šç”¨è¯­æ³•åœ¨å›¾2ä¸­å±•ç¤ºäº†MLIRçš„ç»“æ„ã€‚æ­¤å¤–ï¼ŒMLIRæ”¯æŒç”¨æˆ·è‡ªå®šä¹‰çš„è‡ªå®šä¹‰è¯­æ³•ã€‚ å±æ€§ã€æ“ä½œå’Œç±»å‹è¢«ç»„ç»‡åœ¨æ–¹è¨€ä¸­ï¼Œå¯ä»¥è§†ä¸ºæ¨¡å—åŒ–åº“ã€‚MLIRæä¾›äº†å°‘é‡æ–¹è¨€ï¼Œä»¥å®šä¹‰å¸¸è§æ“ä½œï¼Œå¦‚æ¨¡å—ã€å‡½æ•°ã€å¾ªç¯ã€å†…å­˜æˆ–ç®—æœ¯æŒ‡ä»¤ï¼Œä»¥åŠåƒæ•´æ•°å’Œæµ®ç‚¹æ•°è¿™æ ·çš„é€šç”¨ç±»å‹ã€‚æˆ‘ä»¬å°†åœ¨æ¥ä¸‹æ¥çš„ç« èŠ‚ä¸­è®¨è®ºä¸Polygeistç›¸å…³çš„æ–¹è¨€ã€‚ # B. Affine and MemRef Dialects The Affine dialect [18] aims at representing SCoP's with explicit polyhedral-friendly loop and conditional constructs. The core of its representation is the following classification of value categories: â€¢ Symbols-integer values that are known to be loopinvariant but unknown at compile-time, also referred to as program parameters in polyhedral literature, typically array dimensions or function arguments. In MLIR, symbols are values defined in the top-level region of an operation with \"affine scope\" semantics, e.g., functions; or array dimensions, constants, and affine map (see below) application results regardless of their definition point. â€¢ Dimensions-are an extension of symbols that also accepts induction variables of affine loops. â€¢ Non-affine-any other values. Symbols and dimensions have index type, which is a platform-specific integer that fits a pointer (intptr_t in C). MLIR provides two attributes relevant for the Affine dialect: â€¢ Affine maps are multi-dimensional (quasi-)linear functions that map a list of dimension and symbol arguments to a list of results. For example, (d 0 , d 1 , d 2 , s 0 ) â†’ (d 0 + d 1 , s 0 â€¢ d 2 ) is a two-dimensional quasi-affine map, which can be expressed in MLIR as affine_map (d0+d1, s0 * d2)>. Dimensions (in parentheses on the left) and symbols (in brackets on the left) are separated to allow quasi-linear expressions: symbols are treated as constants, which can therefore be multiplied with dimensions, whereas a product of two dimensions is invalid. â€¢ Integer sets are collections of integer tuples constrained by conjunctions of (quasi-)linear expressions. For example, a \"triangular\" set {(d 0 , d 1 ) : 0 â‰¤ d 0 = 0, s0-d0-1 >= 0, d1 >= 0, d0-d1 >= 0)>. The Affine dialect makes use of the concepts above to define a set of operations. An affine.for is a \"for\" loop with loop-invariant lower and upper bounds expressed as affine maps with a constant step. An affine.parallel is a \"multifor\" loop nest, iterations of which may be executed concurrently. Both kinds of loops support reductions via loopcarried values as well as max(min) expression lower(upper) bounds. An affine.if is a conditional construct, with an optional else region, and a condition defined as inclusion of the given values into an integer set. Finally, affine.load and affine.store express memory accesses where the address computation is expressed as an affine map. A core MLIR type-memref, which stands for memory reference-and the corresponding memref dialect are also featured in Figure 3. The memref type describes a structured multi-index pointer into memory, e.g., memref denotes a 1-d array of floating-point elements; and the memref dialect provides memory and type manipulation operations, e.g., memref.dim retrieves the dimensionality of a memref object. memref does not allow internal aliasing, i.e., different subscripts always point to different addresses. This effectively defines away the delinearization problem that hinders the application of polyhedral techniques at the LLVM IR level [9]. Throughout this paper, we only consider memrefs with the default layout that corresponds to contiguous row-major storage compatible with C ABI (Application Binary Interface). In practice, memrefs support arbitrary layouts expressible as affine maps, but these are not necessary in Polygeist context. B. ä»¿å°„å’Œå†…å­˜å¼•ç”¨æ–¹è¨€ ä»¿å°„æ–¹è¨€ [18] æ—¨åœ¨è¡¨ç¤ºå…·æœ‰æ˜¾å¼é€‚åˆå¤šé¢ä½“çš„å¾ªç¯å’Œæ¡ä»¶æ„é€ çš„é™æ€è®¡ç®—ç¨‹åºï¼ˆSCoPï¼‰ã€‚å…¶è¡¨ç¤ºçš„æ ¸å¿ƒæ˜¯ä»¥ä¸‹å€¼ç±»åˆ«çš„åˆ†ç±»ï¼š ç¬¦å·â€”â€”å·²çŸ¥ä¸ºå¾ªç¯ä¸å˜ä½†åœ¨ç¼–è¯‘æ—¶æœªçŸ¥çš„æ•´æ•°å€¼ï¼Œåœ¨å¤šé¢ä½“æ–‡çŒ®ä¸­ä¹Ÿç§°ä¸ºç¨‹åºå‚æ•°ï¼Œé€šå¸¸æ˜¯æ•°ç»„ç»´åº¦æˆ–å‡½æ•°å‚æ•°ã€‚åœ¨ MLIR ä¸­ï¼Œç¬¦å·æ˜¯åœ¨å…·æœ‰â€œä»¿å°„èŒƒå›´â€è¯­ä¹‰çš„æ“ä½œçš„é¡¶çº§åŒºåŸŸä¸­å®šä¹‰çš„å€¼ï¼Œä¾‹å¦‚å‡½æ•°ï¼›æˆ–è€…æ•°ç»„ç»´åº¦ã€å¸¸é‡å’Œä»¿å°„æ˜ å°„ï¼ˆè§ä¸‹æ–‡ï¼‰åº”ç”¨ç»“æœï¼Œæ— è®ºå®ƒä»¬çš„å®šä¹‰ç‚¹åœ¨å“ªé‡Œã€‚ ç»´åº¦â€”â€”æ˜¯ç¬¦å·çš„æ‰©å±•ï¼Œæ¥å—ä»¿å°„å¾ªç¯çš„å½’çº³å˜é‡ã€‚ éä»¿å°„â€”â€”ä»»ä½•å…¶ä»–å€¼ã€‚ç¬¦å·å’Œç»´åº¦å…·æœ‰ç´¢å¼•ç±»å‹ï¼Œå³å¹³å°ç‰¹å®šçš„æ•´æ•°ï¼Œé€‚åˆæŒ‡é’ˆï¼ˆåœ¨ C ä¸­ä¸º intptr_tï¼‰ã€‚ MLIR æä¾›äº†ä¸¤ä¸ªä¸ä»¿å°„æ–¹è¨€ç›¸å…³çš„å±æ€§ï¼š ä»¿å°„æ˜ å°„æ˜¯å¤šç»´çš„ï¼ˆå‡†ï¼‰çº¿æ€§å‡½æ•°ï¼Œå®ƒå°†ä¸€ç»„ç»´åº¦å’Œç¬¦å·å‚æ•°æ˜ å°„åˆ°ä¸€ç»„ç»“æœã€‚ä¾‹å¦‚ï¼Œ ( (d_0, d_1, d_2, s_0) \\rightarrow (d_0 + d_1, s_0 \\cdot d_2) ) æ˜¯ä¸€ä¸ªäºŒç»´å‡†ä»¿å°„æ˜ å°„ï¼Œå¯ä»¥åœ¨ MLIR ä¸­è¡¨ç¤ºä¸º affine_map (d0+d1, s0 * d2)>ã€‚ç»´åº¦ï¼ˆå·¦ä¾§çš„æ‹¬å·å†…ï¼‰å’Œç¬¦å·ï¼ˆå·¦ä¾§çš„æ–¹æ‹¬å·å†…ï¼‰è¢«åˆ†éš”å¼€ï¼Œä»¥å…è®¸å‡†çº¿æ€§è¡¨è¾¾å¼ï¼šç¬¦å·è¢«è§†ä¸ºå¸¸é‡ï¼Œå› æ­¤å¯ä»¥ä¸ç»´åº¦ç›¸ä¹˜ï¼Œè€Œä¸¤ä¸ªç»´åº¦çš„ä¹˜ç§¯æ˜¯æ— æ•ˆçš„ã€‚ æ•´æ•°é›†æ˜¯è¢«ï¼ˆå‡†ï¼‰çº¿æ€§è¡¨è¾¾å¼çš„åˆå–é™åˆ¶çš„æ•´æ•°å…ƒç»„é›†åˆã€‚ä¾‹å¦‚ï¼Œâ€œä¸‰è§’å½¢â€é›†åˆ ({(d_0, d_1) : 0 \\leq d_0 affine_set= 0, s0-d0-1 >= 0, d1 >= 0, d0-d1 >= 0)>ã€‚ ä»¿å°„æ–¹è¨€åˆ©ç”¨ä¸Šè¿°æ¦‚å¿µå®šä¹‰äº†ä¸€ç»„æ“ä½œã€‚affine.for æ˜¯ä¸€ä¸ªâ€œforâ€å¾ªç¯ï¼Œå…¶å¾ªç¯ä¸å˜çš„ä¸‹ç•Œå’Œä¸Šç•Œè¡¨ç¤ºä¸ºå¸¦æœ‰å¸¸é‡æ­¥é•¿çš„ä»¿å°„æ˜ å°„ã€‚affine.parallel æ˜¯ä¸€ä¸ªâ€œå¤šé‡forâ€å¾ªç¯åµŒå¥—ï¼Œå…¶è¿­ä»£å¯ä»¥å¹¶å‘æ‰§è¡Œã€‚è¿™ä¸¤ç§å¾ªç¯éƒ½æ”¯æŒé€šè¿‡å¾ªç¯ä¼ é€’å€¼è¿›è¡Œå½’çº¦ï¼Œä»¥åŠ max(min) è¡¨è¾¾å¼çš„ä¸‹ï¼ˆä¸Šï¼‰ç•Œã€‚affine.if æ˜¯ä¸€ä¸ªæ¡ä»¶æ„é€ ï¼Œå¸¦æœ‰ä¸€ä¸ªå¯é€‰çš„ else åŒºåŸŸï¼Œæ¡ä»¶è¢«å®šä¹‰ä¸ºç»™å®šå€¼åŒ…å«åœ¨ä¸€ä¸ªæ•´æ•°é›†ä¸­ã€‚æœ€åï¼Œaffine.load å’Œ affine.store è¡¨ç¤ºå†…å­˜è®¿é—®ï¼Œå…¶ä¸­åœ°å€è®¡ç®—è¡¨ç¤ºä¸ºä»¿å°„æ˜ å°„ã€‚æ ¸å¿ƒçš„ MLIR ç±»å‹â€”â€”å†…å­˜å¼•ç”¨ï¼ˆmemrefï¼‰ï¼Œä»¥åŠç›¸åº”çš„ memref æ–¹è¨€ä¹Ÿåœ¨å›¾ 3 ä¸­å±•ç¤ºã€‚memref ç±»å‹æè¿°äº†æŒ‡å‘å†…å­˜çš„ç»“æ„åŒ–å¤šç´¢å¼•æŒ‡é’ˆï¼Œä¾‹å¦‚ï¼Œmemref è¡¨ç¤ºä¸€ä¸ªæµ®ç‚¹å…ƒç´ çš„ä¸€ç»´æ•°ç»„ï¼›è€Œ memref æ–¹è¨€æä¾›äº†å†…å­˜å’Œç±»å‹æ“ä½œï¼Œä¾‹å¦‚ memref.dim æ£€ç´¢ memref å¯¹è±¡çš„ç»´åº¦ã€‚memref ä¸å…è®¸å†…éƒ¨åˆ«åï¼Œå³ä¸åŒçš„ä¸‹æ ‡å§‹ç»ˆæŒ‡å‘ä¸åŒçš„åœ°å€ã€‚è¿™æœ‰æ•ˆåœ°è§£å†³äº†é™åˆ¶å¤šé¢ä½“æŠ€æœ¯åœ¨ LLVM IR çº§åˆ«åº”ç”¨çš„å»çº¿æ€§åŒ–é—®é¢˜ [9]ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬åªè€ƒè™‘ä¸å…¼å®¹ C ABIï¼ˆåº”ç”¨ç¨‹åºäºŒè¿›åˆ¶æ¥å£ï¼‰çš„è¿ç»­è¡Œä¸»å­˜å‚¨å¯¹åº”çš„é»˜è®¤å¸ƒå±€çš„ memrefsã€‚å®é™…ä¸Šï¼Œmemrefs æ”¯æŒå¯ä½œä¸ºä»¿å°„æ˜ å°„è¡¨è¾¾çš„ä»»æ„å¸ƒå±€ï¼Œä½†åœ¨ Polygeist çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œè¿™äº›å¹¶ä¸æ˜¯å¿…éœ€çš„ã€‚ # C. Other Relevant Core Dialects MLIR provides several dozen dialects. Out of those, only a handful are relevant for our discussion: â€¢ The Structured Control Flow (scf) dialect defines the control flow operations such as loops and conditionals that are not constrained by affine categorization rules. For example, the scf.for loop accepts any integer value as loop bounds, which are not necessarily affine expressions. â€¢ The Standard (std) dialect contains common operations such as integer and float arithmetic, which is used as a common lowering point from higher-level dialects before fanning out into multiple target dialects and can be seen as a generalization of LLVM IR [16]. â€¢ The LLVM dialect directly maps from LLVM IR instructions and types to MLIR, primarily to simplify the translation between them. â€¢ The OpenMP dialect provides a dialect-and platformagnostic representation of OpenMP directives such as \"parallel\" and \"workshare loop\", which can be used to transform OpenMP constructs or emit LLVM IR that interacts with the OpenMP runtime. â€¢ The Math dialect groups together mathematical operations on integer and floating type beyond simple arithmetic, e.g., math.pow or math.sqrt. MLIRæä¾›äº†å‡ åç§æ–¹è¨€ã€‚åœ¨è¿™äº›æ–¹è¨€ä¸­ï¼Œåªæœ‰å°‘æ•°å‡ ç§ä¸æˆ‘ä»¬çš„è®¨è®ºç›¸å…³ï¼š ç»“æ„åŒ–æ§åˆ¶æµï¼ˆscfï¼‰æ–¹è¨€å®šä¹‰äº†æ§åˆ¶æµæ“ä½œï¼Œä¾‹å¦‚å¾ªç¯å’Œæ¡ä»¶è¯­å¥ï¼Œè¿™äº›æ“ä½œä¸å—ä»¿å°„åˆ†ç±»è§„åˆ™çš„é™åˆ¶ã€‚ä¾‹å¦‚ï¼Œscf.for å¾ªç¯å¯ä»¥æ¥å—ä»»ä½•æ•´æ•°å€¼ä½œä¸ºå¾ªç¯è¾¹ç•Œï¼Œè¿™äº›è¾¹ç•Œä¸ä¸€å®šæ˜¯ä»¿å°„è¡¨è¾¾å¼ã€‚ æ ‡å‡†ï¼ˆstdï¼‰æ–¹è¨€åŒ…å«å¸¸è§çš„æ“ä½œï¼Œä¾‹å¦‚æ•´æ•°å’Œæµ®ç‚¹ç®—æœ¯ï¼Œè¿™è¢«ç”¨ä½œä»æ›´é«˜çº§åˆ«æ–¹è¨€åˆ°å¤šä¸ªç›®æ ‡æ–¹è¨€çš„å…±åŒé™ä½ç‚¹ï¼Œå¯ä»¥è§†ä¸ºLLVM IRçš„æ¦‚æ‹¬[16]ã€‚ LLVMæ–¹è¨€ç›´æ¥å°†LLVM IRæŒ‡ä»¤å’Œç±»å‹æ˜ å°„åˆ°MLIRï¼Œä¸»è¦æ˜¯ä¸ºäº†ç®€åŒ–å®ƒä»¬ä¹‹é—´çš„è½¬æ¢ã€‚ OpenMPæ–¹è¨€æä¾›äº†ä¸€ç§ä¸æ–¹è¨€å’Œå¹³å°æ— å…³çš„OpenMPæŒ‡ä»¤è¡¨ç¤ºï¼Œä¾‹å¦‚â€œparallelâ€å’Œâ€œworkshare loopâ€ï¼Œå¯ç”¨äºè½¬æ¢OpenMPæ„é€ æˆ–ç”Ÿæˆä¸OpenMPè¿è¡Œæ—¶äº¤äº’çš„LLVM IRã€‚ æ•°å­¦æ–¹è¨€å°†æ•´æ•°å’Œæµ®ç‚¹ç±»å‹ä¸Šçš„æ•°å­¦æ“ä½œï¼ˆè¶…å‡ºç®€å•ç®—æœ¯ï¼‰å½’ä¸ºä¸€ç»„ï¼Œä¾‹å¦‚ï¼Œmath.powæˆ–math.sqrtã€‚ # III. AN (AFFINE) MLIR COMPILATION PIPELINE The Polygeist pipeline consists of 4 components (Figure 1): 4). This allows Polygeist to preserve more of the structure available within the original program (e.g., multi-dimensional arrays) and enables interaction with MLIR's high-level memory operations. This diverges from the C ABI for any functions with pointer arguments and wouldn't interface correctly with C functions. Polygeist addresses this by providing an attribute for function arguments and allocations to use a C-compatible pointer type rather than memref, applied by default to external functions such as strcmp and scanf. When calling a pointer-ABI function with a memref-ABI argument, Polygeist generates wrapper code that recovers the C ABI-compatible pointer from memref and ensures the correct result. Figure 5 shows an example demonstrating how the Polygeist and C ABI may interact for a small program. When allocating and deallocating memory, this difference in ABI becomes significant. This is because allocating several bytes of an array with malloc then casting to a memref will not result in legal code (as memref itself may not be implemented with a raw pointer). Thus, Polygeist identifies calls to allocation and deallocation functions and replaces them with legal equivalents for memref. Functions and global variables are emitted using the same name used by the C or C++ ABI. This ensures that all external values are loaded correctly, and multi-versioned functions (such as those generated by C++ templates or overloading) have distinct names and definitions. c) Instruction Generation: For most instructions, Polygeist directly emits an MLIR operation corresponding to the equivalent C operation (addi for integer add, call for function call, etc.). For some special instructions such as a call to pow, Polygeist chooses to emit a specific MLIR operation in the Math dialect, instead of a call to an external function (defined in libm). This permits such instructions to be better analyzed and optimized within MLIR. Operations that involve memory or pointer arithmetic require additional handling. MLIR does not have a generic pointer arithmetic instruction; instead, it requires that load and store operations contain all of the indices being looked up. This presents issues for operations that perform pointer arithmetic. To remedy this, we introduce a temporary subindex operation for memref's keeps track of the additional address offsets. A subsequent optimization pass within Polygeist, forwards the offsets in a subindex to any load or store which uses them. d) Local Variables: Local variables are handled by allocating a memref on stack at the top of a function. This permits the desired semantics of C or C++ to be implemented with relative ease. However, as many local variables and arguments contain memref types, this immediately results in a memref of a memref-a hindrance for most MLIR optimizations as it is illegal outside of Polygeist. As a remedy, we implement a heavyweight memory-to-register (mem2reg) transformation pass that eliminates unnecessary loads, stores, and allocations within MLIR constructs. Empirically this eliminates all memrefs of memref in the Polybench suite. III. ä¸€ä¸ªï¼ˆä»¿å°„ï¼‰MLIRç¼–è¯‘æµç¨‹ Polygeistç¼–è¯‘æµç¨‹ç”±4ä¸ªç»„ä»¶ç»„æˆï¼ˆè§å›¾1ï¼‰ã€‚è¿™ä½¿å¾—Polygeistèƒ½å¤Ÿä¿ç•™åŸå§‹ç¨‹åºä¸­å¯ç”¨çš„æ›´å¤šç»“æ„ï¼ˆä¾‹å¦‚ï¼Œå¤šç»´æ•°ç»„ï¼‰ï¼Œå¹¶èƒ½å¤Ÿä¸MLIRçš„é«˜çº§å†…å­˜æ“ä½œè¿›è¡Œäº¤äº’ã€‚è¿™ä¸ä»»ä½•å…·æœ‰æŒ‡é’ˆå‚æ•°çš„C ABIä¸åŒï¼Œå¹¶ä¸”ä¸Cå‡½æ•°çš„æ¥å£ä¸ä¸€è‡´ã€‚Polygeisté€šè¿‡ä¸ºå‡½æ•°å‚æ•°å’Œåˆ†é…æä¾›ä¸€ä¸ªå±æ€§ï¼Œä½¿å…¶ä½¿ç”¨ä¸Cå…¼å®¹çš„æŒ‡é’ˆç±»å‹ï¼Œè€Œä¸æ˜¯memrefï¼Œé»˜è®¤é€‚ç”¨äºå¤–éƒ¨å‡½æ•°ï¼Œå¦‚strcmpå’Œscanfã€‚å½“ä½¿ç”¨memref ABIå‚æ•°è°ƒç”¨æŒ‡é’ˆ ABIå‡½æ•°æ—¶ï¼ŒPolygeistç”ŸæˆåŒ…è£…ä»£ç ï¼Œä»memrefä¸­æ¢å¤ä¸C ABIå…¼å®¹çš„æŒ‡é’ˆï¼Œå¹¶ç¡®ä¿ç»“æœæ­£ç¡®ã€‚å›¾5å±•ç¤ºäº†ä¸€ä¸ªç¤ºä¾‹ï¼Œæ¼”ç¤ºäº†Polygeistä¸C ABIåœ¨ä¸€ä¸ªå°ç¨‹åºä¸­çš„äº’åŠ¨ã€‚ åœ¨åˆ†é…å’Œé‡Šæ”¾å†…å­˜æ—¶ï¼Œè¿™ç§ABIçš„å·®å¼‚æ˜¾å¾—å°¤ä¸ºé‡è¦ã€‚è¿™æ˜¯å› ä¸ºä½¿ç”¨mallocåˆ†é…æ•°ç»„çš„å‡ ä¸ªå­—èŠ‚åï¼Œå†å°†å…¶è½¬æ¢ä¸ºmemrefå°†ä¸ä¼šäº§ç”Ÿåˆæ³•ä»£ç ï¼ˆå› ä¸ºmemrefæœ¬èº«å¯èƒ½ä¸æ˜¯ç”¨åŸå§‹æŒ‡é’ˆå®ç°çš„ï¼‰ã€‚å› æ­¤ï¼ŒPolygeistè¯†åˆ«å¯¹åˆ†é…å’Œé‡Šæ”¾å‡½æ•°çš„è°ƒç”¨ï¼Œå¹¶å°†å…¶æ›¿æ¢ä¸ºmemrefçš„åˆæ³•ç­‰æ•ˆå‡½æ•°ã€‚ å‡½æ•°å’Œå…¨å±€å˜é‡ä½¿ç”¨Cæˆ–C++ ABIä¸­ä½¿ç”¨çš„ç›¸åŒåç§°å‘å‡ºã€‚è¿™ç¡®ä¿æ‰€æœ‰å¤–éƒ¨å€¼éƒ½è¢«æ­£ç¡®åŠ è½½ï¼Œå¹¶ä¸”å¤šç‰ˆæœ¬å‡½æ•°ï¼ˆå¦‚C++æ¨¡æ¿æˆ–é‡è½½ç”Ÿæˆçš„å‡½æ•°ï¼‰æ‹¥æœ‰ä¸åŒçš„åç§°å’Œå®šä¹‰ã€‚ c) æŒ‡ä»¤ç”Ÿæˆï¼šå¯¹äºå¤§å¤šæ•°æŒ‡ä»¤ï¼ŒPolygeistç›´æ¥å‘å‡ºä¸ç­‰æ•ˆCæ“ä½œç›¸å¯¹åº”çš„MLIRæ“ä½œï¼ˆå¦‚æ•´æ•°åŠ æ³•çš„addiï¼Œå‡½æ•°è°ƒç”¨çš„callç­‰ï¼‰ã€‚å¯¹äºæŸäº›ç‰¹æ®ŠæŒ‡ä»¤ï¼Œå¦‚å¯¹powçš„è°ƒç”¨ï¼ŒPolygeisté€‰æ‹©å‘å‡ºMathæ–¹è¨€ä¸­ç‰¹å®šçš„MLIRæ“ä½œï¼Œè€Œä¸æ˜¯è°ƒç”¨å¤–éƒ¨å‡½æ•°ï¼ˆåœ¨libmä¸­å®šä¹‰ï¼‰ã€‚è¿™ä½¿å¾—è¿™äº›æŒ‡ä»¤èƒ½å¤Ÿåœ¨MLIRä¸­æ›´å¥½åœ°è¿›è¡Œåˆ†æå’Œä¼˜åŒ–ã€‚ æ¶‰åŠå†…å­˜æˆ–æŒ‡é’ˆç®—æœ¯çš„æ“ä½œéœ€è¦é¢å¤–å¤„ç†ã€‚MLIRæ²¡æœ‰é€šç”¨çš„æŒ‡é’ˆç®—æœ¯æŒ‡ä»¤ï¼›ç›¸åï¼Œå®ƒè¦æ±‚loadå’Œstoreæ“ä½œåŒ…å«æ‰€æœ‰è¢«æŸ¥æ‰¾çš„ç´¢å¼•ã€‚è¿™ä¸ºæ‰§è¡ŒæŒ‡é’ˆç®—æœ¯çš„æ“ä½œå¸¦æ¥äº†é—®é¢˜ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¼•å…¥äº†ä¸€ä¸ªä¸´æ—¶å­ç´¢å¼•æ“ä½œï¼Œç”¨äºmemrefï¼Œä»¥è·Ÿè¸ªé™„åŠ çš„åœ°å€åç§»ã€‚åœ¨Polygeistä¸­çš„åç»­ä¼˜åŒ–è¿‡ç¨‹ä¸­ï¼Œå°†å­ç´¢å¼•ä¸­çš„åç§»é‡è½¬å‘ç»™ä»»ä½•ä½¿ç”¨å®ƒä»¬çš„loadæˆ–storeã€‚ d) å±€éƒ¨å˜é‡ï¼šå±€éƒ¨å˜é‡é€šè¿‡åœ¨å‡½æ•°é¡¶éƒ¨åˆ†é…ä¸€ä¸ªmemrefåœ¨æ ˆä¸Šè¿›è¡Œå¤„ç†ã€‚è¿™ä½¿å¾—Cæˆ–C++çš„æ‰€éœ€è¯­ä¹‰èƒ½å¤Ÿç›¸å¯¹å®¹æ˜“åœ°å®ç°ã€‚ç„¶è€Œï¼Œç”±äºè®¸å¤šå±€éƒ¨å˜é‡å’Œå‚æ•°åŒ…å«memrefç±»å‹ï¼Œè¿™ç«‹å³å¯¼è‡´äº†memrefçš„memref-è¿™å¯¹å¤§å¤šæ•°MLIRä¼˜åŒ–æ¥è¯´æ˜¯ä¸€ä¸ªéšœç¢ï¼Œå› ä¸ºåœ¨Polygeistä¹‹å¤–è¿™æ˜¯ä¸åˆæ³•çš„ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å®ç°äº†ä¸€ä¸ªé‡é‡çº§çš„å†…å­˜åˆ°å¯„å­˜å™¨ï¼ˆmem2regï¼‰è½¬æ¢è¿‡ç¨‹ï¼Œè¯¥è¿‡ç¨‹æ¶ˆé™¤äº†MLIRæ„é€ ä¸­çš„ä¸å¿…è¦çš„åŠ è½½ã€å­˜å‚¨å’Œåˆ†é…ã€‚æ ¹æ®ç»éªŒï¼Œè¿™æ¶ˆé™¤äº†Polybenchå¥—ä»¶ä¸­æ‰€æœ‰memrefçš„memrefã€‚ # B. Raising to Affine The translation from C or C++ to MLIR directly preserves high-level information about loop structure and n-D arrays, but does not generate other Affine operations. Polygeist subsequently raises memory, conditional, and looping operations into their Affine dialect counterparts if it can prove them to be legal affine operations. If the corresponding frontend code was enclosed within #pragma scop, Polygeist assumes it is always legal to raise all operations within that region without additional checks. 1 Any operations which are not proven or assumed to be affine remain untouched. We perform simplifications on affine maps to remove loops with zero or one iteration and drop branches of a conditional with a condition known at compile time. å°†Cæˆ–C++ç›´æ¥ç¿»è¯‘ä¸ºMLIRèƒ½å¤Ÿä¿ç•™å…³äºå¾ªç¯ç»“æ„å’Œnç»´æ•°ç»„çš„é«˜çº§ä¿¡æ¯ï¼Œä½†ä¸ä¼šç”Ÿæˆå…¶ä»–çš„ä»¿å°„æ“ä½œã€‚ä¹‹åï¼ŒPolygeistå°†å†…å­˜ã€æ¡ä»¶å’Œå¾ªç¯æ“ä½œæå‡è‡³å…¶ä»¿å°„æ–¹è¨€å¯¹åº”ç‰©ï¼Œå¦‚æœå®ƒèƒ½å¤Ÿè¯æ˜è¿™äº›æ“ä½œæ˜¯åˆæ³•çš„ä»¿å°„æ“ä½œã€‚å¦‚æœç›¸åº”çš„å‰ç«¯ä»£ç è¢«åŒ…è£¹åœ¨#pragma scopä¸­ï¼ŒPolygeistå‡è®¾åœ¨è¯¥åŒºåŸŸå†…æå‡æ‰€æœ‰æ“ä½œæ˜¯å§‹ç»ˆåˆæ³•çš„ï¼Œä¸”æ— éœ€é¢å¤–æ£€æŸ¥ã€‚å¯¹äºä»»ä½•æœªè¢«è¯æ˜æˆ–å‡è®¾ä¸ºä»¿å°„çš„æ“ä½œï¼Œåˆ™ä¿æŒä¸å˜ã€‚æˆ‘ä»¬å¯¹ä»¿å°„æ˜ å°„è¿›è¡Œç®€åŒ–ï¼Œä»¥å»é™¤å…·æœ‰é›¶æ¬¡æˆ–ä¸€æ¬¡è¿­ä»£çš„å¾ªç¯ï¼Œå¹¶åˆ é™¤åœ¨ç¼–è¯‘æ—¶å·²çŸ¥æ¡ä»¶çš„æ¡ä»¶è¯­å¥çš„åˆ†æ”¯ã€‚ # a) Memory operations and loop bounds: To convert an operation, Polygeist replaces its bound and subscript operands with identity affine maps (affine_map(s0)>[%bound]). It then folds the operations computing the map operands, e.g., addi, muli, into the map itself. Values that are transitively derived from loop induction variables become map dimensions and other values become symbols. For example, affine_map(s0)> [%bound] with %bound = addi %N, %i, where %i is an induction variable, is folded into affine_map(s0 + d0)>(%i)[%N]. The process terminates when no operations can be folded or when Affine value categorization rules are satisfied. b) Conditionals: Conditional operations are emitted by the frontend for two input code patterns: if conditions and ternary expressions. The condition is transformed by introducing an integer set and by folding the operands into it similarly to the affine maps, with in addition and operations separating set constraints and not operations inverting them (affine.if only accepts â‰¥ 0 and = 0 constraints). Polygeist processes nested conditionals with C-style shortcircuit semantics, in which the subsequent conditions are checked within the body of the preceding conditionals, by hoisting conditions outside the outermost conditional when legal and replacing them with a boolean operation or a select. This is always legal within #pragma scop. Conditionals emitted for ternary expressions often involve memory loads in their regions, which prevent hoisting due to side effects. We reuse our mem2reg pass to replace those to equivalent earlier loads when possible to enable hoisting. Empirically, this is sufficient to process all ternary expressions in the Polybench/C suite [19]. Otherwise, ternary expressions would need to be packed into a single statement by the downstream polyhedral pass. a) å†…å­˜æ“ä½œå’Œå¾ªç¯è¾¹ç•Œï¼šä¸ºäº†è½¬æ¢ä¸€ä¸ªæ“ä½œï¼ŒPolygeist ç”¨æ’ç­‰ä»¿å°„æ˜ å°„ï¼ˆaffine_map(s0)>[%bound]ï¼‰æ›¿æ¢å…¶è¾¹ç•Œå’Œä¸‹æ ‡æ“ä½œæ•°ã€‚å®ƒç„¶åå°†è®¡ç®—æ˜ å°„æ“ä½œæ•°çš„æ“ä½œï¼Œä¾‹å¦‚åŠ æ³•ï¼ˆaddiï¼‰ã€ä¹˜æ³•ï¼ˆmuliï¼‰ï¼ŒæŠ˜å åˆ°æ˜ å°„æœ¬èº«ä¸­ã€‚ä»å¾ªç¯å½’çº³å˜é‡ä¼ é€’å¾—å‡ºçš„å€¼å˜æˆäº†æ˜ å°„ç»´åº¦ï¼Œå…¶ä»–å€¼åˆ™å˜æˆç¬¦å·ã€‚ä¾‹å¦‚ï¼Œaffine_map(s0)> [%bound] åœ¨ %bound = addi %N, %i çš„æƒ…å†µä¸‹ï¼Œå…¶ä¸­ %i æ˜¯ä¸€ä¸ªå½’çº³å˜é‡ï¼Œè¢«æŠ˜å ä¸º affine_map(s0 + d0)>(%i)[%N]ã€‚è¯¥è¿‡ç¨‹åœ¨æ— æ³•å†æŠ˜å æ“ä½œæˆ–æ»¡è¶³ä»¿å°„å€¼åˆ†ç±»è§„åˆ™æ—¶ç»ˆæ­¢ã€‚ b) æ¡ä»¶è¯­å¥ï¼šå‰ç«¯ä¸ºä¸¤ç§è¾“å…¥ä»£ç æ¨¡å¼ï¼ˆif æ¡ä»¶å’Œä¸‰å…ƒè¡¨è¾¾å¼ï¼‰ç”Ÿæˆæ¡ä»¶æ“ä½œã€‚æ¡ä»¶é€šè¿‡å¼•å…¥æ•´æ•°é›†åˆå¹¶å°†æ“ä½œæ•°æŠ˜å åˆ°å…¶ä¸­è¿›è¡Œè½¬æ¢ï¼Œç±»ä¼¼äºä»¿å°„æ˜ å°„ï¼Œæ­¤å¤–ï¼Œæ“ä½œä¹‹é—´çš„åŠ æ³•å’Œè¿ç®—åˆ†éš”é›†åˆçº¦æŸï¼Œè€Œéè¿ç®—åˆ™å¯¹å…¶è¿›è¡Œåè½¬ï¼ˆaffine.if ä»…æ¥å— â‰¥ 0 å’Œ = 0 çš„çº¦æŸï¼‰ã€‚Polygeist å¤„ç†åµŒå¥—æ¡ä»¶æ—¶éµå¾ª C é£æ ¼çš„çŸ­è·¯è¯­ä¹‰ï¼Œå…¶ä¸­åç»­æ¡ä»¶åœ¨å‰é¢æ¡ä»¶çš„ä¸»ä½“å†…è¿›è¡Œæ£€æŸ¥ï¼Œå½“æ³•å¾‹å…è®¸æ—¶ï¼Œå°†æ¡ä»¶æå‡åˆ°æœ€å¤–å±‚æ¡ä»¶ä¹‹å¤–ï¼Œå¹¶ç”¨å¸ƒå°”æ“ä½œæˆ–é€‰æ‹©æ“ä½œæ›¿æ¢å®ƒä»¬ã€‚åœ¨ #pragma scop å†…ï¼Œè¿™æ€»æ˜¯åˆæ³•çš„ã€‚ ä¸ºä¸‰å…ƒè¡¨è¾¾å¼ç”Ÿæˆçš„æ¡ä»¶è¯­å¥é€šå¸¸æ¶‰åŠå…¶åŒºåŸŸå†…çš„å†…å­˜åŠ è½½ï¼Œç”±äºå‰¯ä½œç”¨ï¼Œå¯¼è‡´æ— æ³•æå‡ã€‚æˆ‘ä»¬é‡ç”¨ mem2reg é€šé“ï¼Œåœ¨å¯èƒ½çš„æƒ…å†µä¸‹å°†å…¶æ›¿æ¢ä¸ºç­‰æ•ˆçš„æ—©æœŸåŠ è½½ï¼Œä»¥å®ç°æå‡ã€‚ä»ç»éªŒä¸Šçœ‹ï¼Œè¿™è¶³ä»¥å¤„ç† Polybench/C å¥—ä»¶ä¸­çš„æ‰€æœ‰ä¸‰å…ƒè¡¨è¾¾å¼ [19]ã€‚å¦åˆ™ï¼Œä¸‰å…ƒè¡¨è¾¾å¼å°†éœ€è¦è¢«ä¸‹æ¸¸å¤šé¢ä½“é€šé“æ‰“åŒ…æˆå•ä¸ªè¯­å¥ã€‚ # C. Connecting MLIR to Polyhedral Tools Part-1 Regions of the input program expressed using MLIR Affine dialect are amenable to the polyhedral model. Existing tools, however, cannot directly consume MLIR. We chose to implement a bi-directional conversion to and from OpenScop [20], an exchange format readily consumable by numerous polyhedral tools, including Pluto [11], and further convertible to isl [21] representation. This allows Polygeist to seamlessly connect with tools created in polyhedral compilation research without having to amend those tools to support MLIR. Most polyhedral tools are designed to operate on C or FORTRAN inputs build around statements, which do not have a direct equivalent in MLIR. Therefore, we design a mechanism to create statement-like structure from chains of MLIR void setArray(int N, double val, double array) {...} int main(int argc, char * argv) { ... cmp = strcmp(str1, str2) ... double array [10]; setArray(10, 42.0, array) } â‡“ func @setArray(%N: i32, %val: f64, %array: memref) { %0 = index_cast %N : i32 to index affine.for %i = 0 to %0 { affine.store %val, %array[%i] : memref } return } func @main(%argc: i32, %argv: !llvm.ptr>) -> i32 { ... %cmp = llvm.call @strcmp(%str1, %str2) : (!llvm.ptr, !llvm.ptr) -> !llvm.i32 ... %array = memref.alloca() : memref %arraycst = memref.cast %array : memref to memref %val = constant 42.0 : f64 call @setArray(%N, %val, %arraycst) : (i32, f64, memref) -> () } Fig. 5. Example demonstrating Polygeist ABI. For functions expected to be compiled with Polygeist such as setArray, pointer arguments are replaced with memref's. For functions that require external calling conventions (such as main/strcmp), Polygeist falls back to emitting llvm.ptr and generates conversion code. operations. We further demonstrate that this gives Polygeist an ability to favorably affect the behavior of the polyhedral scheduler by controlling statement granularity (Section III-D). è¾“å…¥ç¨‹åºä¸­ä½¿ç”¨ MLIR Affine æ–¹è¨€è¡¨è¾¾çš„åŒºåŸŸé€‚ç”¨äºå¤šé¢ä½“æ¨¡å‹ã€‚ç„¶è€Œï¼Œç°æœ‰å·¥å…·æ— æ³•ç›´æ¥ä½¿ç”¨ MLIRã€‚å› æ­¤ï¼Œæˆ‘ä»¬é€‰æ‹©å®ç°ä¸ OpenScop [20] çš„åŒå‘è½¬æ¢ï¼Œè¿™æ˜¯ä¸€ç§å¯è¢«ä¼—å¤šå¤šé¢ä½“å·¥å…·ç›´æ¥ä½¿ç”¨çš„äº¤æ¢æ ¼å¼ï¼ŒåŒ…æ‹¬ Pluto [11]ï¼Œå¹¶ä¸”è¿›ä¸€æ­¥å¯è½¬æ¢ä¸º isl [21] è¡¨ç¤ºã€‚è¿™ä½¿å¾— Polygeist èƒ½å¤Ÿä¸åœ¨å¤šé¢ä½“ç¼–è¯‘ç ”ç©¶ä¸­åˆ›å»ºçš„å·¥å…·æ— ç¼è¿æ¥ï¼Œè€Œæ— éœ€ä¿®æ”¹è¿™äº›å·¥å…·ä»¥æ”¯æŒ MLIRã€‚ å¤§å¤šæ•°å¤šé¢ä½“å·¥å…·è®¾è®¡ç”¨äºå¤„ç†ä»¥è¯­å¥ä¸ºåŸºç¡€çš„ C æˆ– FORTRAN è¾“å…¥ï¼Œè€Œå®ƒä»¬åœ¨ MLIR ä¸­å¹¶æ²¡æœ‰ç›´æ¥å¯¹åº”çš„ç­‰ä»·ç‰©ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ç§æœºåˆ¶ï¼Œä»ä¸€ç³»åˆ— MLIR æ“ä½œåˆ›å»ºç±»ä¼¼è¯­å¥çš„ç»“æ„ã€‚ä¾‹å¦‚ï¼š void setArray(int N, double val, double * array) {...} int main(int argc, char ** argv) { ... cmp = strcmp(str1, str2) ... double array [10]; setArray(10, 42.0, array) } å¯è½¬æ¢ä¸ºï¼š func @setArray(%N: i32, %val: f64, %array: memref) { %0 = index_cast %N : i32 to index affine.for %i = 0 to %0 { affine.store %val, %array[%i] : memref } return } func @main(%argc: i32, %argv: !llvm.ptr>) -> i32 { ... %cmp = llvm.call @strcmp(%str1, %str2) : (!llvm.ptr, !llvm.ptr) -> !llvm.i32 ... %array = memref.alloca() : memref %arraycst = memref.cast %array : memref to memref %val = constant 42.0 : f64 call @setArray(%N, %val, %arraycst) : (i32, f64, memref) -> () } å›¾ 5. ç¤ºä¾‹æ¼”ç¤ºäº† Polygeist çš„ ABIã€‚å¯¹äºé¢„æœŸè¦ç”± Polygeist ç¼–è¯‘çš„å‡½æ•°ï¼ˆå¦‚ setArrayï¼‰ï¼ŒæŒ‡é’ˆå‚æ•°è¢«æ›¿æ¢ä¸º memrefã€‚å¯¹äºéœ€è¦å¤–éƒ¨è°ƒç”¨çº¦å®šï¼ˆå¦‚ main/strcmpï¼‰çš„å‡½æ•°ï¼ŒPolygeist é€€å›åˆ°å‘å‡º llvm.ptr å¹¶ç”Ÿæˆè½¬æ¢ä»£ç çš„æ–¹å¼ã€‚ æˆ‘ä»¬è¿›ä¸€æ­¥è¯æ˜ï¼Œè¿™ä½¿å¾— Polygeist èƒ½å¤Ÿé€šè¿‡æ§åˆ¶è¯­å¥ç²’åº¦ï¼Œç§¯æå½±å“å¤šé¢ä½“è°ƒåº¦å™¨çš„è¡Œä¸ºï¼ˆè¯¦è§ç¬¬ III-D èŠ‚ï¼‰ã€‚ # C. Connecting MLIR to Polyhedral Tools Part-2 a) Simple Statement Formation: Observing that C statements amenable to the polyhedral model are (mostly) variable assignments, we can derive a mechanism to identify statements from chains of MLIR operations. A store into memory is the last operation of the statement. The backward slice of this operation, i.e., the operations transitively computing its operands, belong to the statement. The slice extension stops at operations producing a value categorized as affine dimension or symbol, directly usable in affine expressions. Such values are loop induction variables or loop-invariant constants. Some operations may end up in multiple statements if the value is used more than once. However, we need the mapping between operations and statements to be bidirectional in order to emit MLIR after the scheduler has restructured the program without considering SSA value visibility rules. If an operation with multiple uses is side effect free, Polygeist simply duplicates it. For operations whose duplication is illegal, Polygeist stores their results in stack-allocated memref's and replaces all further uses with memory loads. Figure 6 illustrates the transformation for value %0 used in operation %20. This creates a new statement. b) Region-Spanning Dependencies: In some cases, a statement may consist of MLIR operations across different (nested) loops, e.g., a load from memory into an SSA register happens in an outer loop while it is used in inner loops. The location of such a statement in the loop hierarchy is unclear. More importantly, it cannot be communicated to the polyhedral scheduler. Polygeist resolves this by storing the value in a stack-allocated memref in the defining region and loading it back in the user regions. Figure 6 illustrates this transformation for value %0 used in operation %10. Similarly to the basic case, this creates a new statement in the outer loop that can be scheduled independently. This approach can be seen as a reg2mem conversion, the inverse of mem2reg performed in the frontend. It only applies to a subset of values, and may be undone after polyhedral scheduling has completed. Furthermore, to decrease the number of dependencies and memory footprint, Polygeist performs a simple value analysis and avoids creating stack-allocated buffers if the same value is already available in another memory location and can be read from there. a) ç®€å•è¯­å¥å½¢æˆï¼šè§‚å¯Ÿåˆ°ç¬¦åˆå¤šé¢ä½“æ¨¡å‹çš„Cè¯­å¥ä¸»è¦æ˜¯å˜é‡èµ‹å€¼ï¼Œæˆ‘ä»¬å¯ä»¥æ¨å¯¼å‡ºä¸€ç§æœºåˆ¶ï¼Œä»MLIRæ“ä½œé“¾ä¸­è¯†åˆ«è¯­å¥ã€‚å­˜å‚¨åˆ°å†…å­˜ä¸­çš„æ“ä½œæ˜¯è¯¥è¯­å¥çš„æœ€åä¸€ä¸ªæ“ä½œã€‚è¯¥æ“ä½œçš„é€†å‘åˆ‡ç‰‡ï¼Œå³ä¼ é€’è®¡ç®—å…¶æ“ä½œæ•°çš„æ“ä½œï¼Œå±äºè¯¥è¯­å¥ã€‚åˆ‡ç‰‡æ‰©å±•åœ¨ç”Ÿæˆè¢«åˆ†ç±»ä¸ºä»¿å°„ç»´åº¦æˆ–ç¬¦å·çš„å€¼çš„æ“ä½œå¤„åœæ­¢ï¼Œè¿™äº›å€¼å¯ä»¥ç›´æ¥ç”¨äºä»¿å°„è¡¨è¾¾å¼ã€‚æ­¤ç±»å€¼åŒ…æ‹¬å¾ªç¯å½’çº³å˜é‡æˆ–å¾ªç¯ä¸å˜å¸¸é‡ã€‚ä¸€äº›æ“ä½œå¯èƒ½å‡ºç°åœ¨å¤šä¸ªè¯­å¥ä¸­ï¼Œå¦‚æœè¯¥å€¼è¢«å¤šæ¬¡ä½¿ç”¨ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬éœ€è¦æ“ä½œä¸è¯­å¥ä¹‹é—´çš„æ˜ å°„æ˜¯åŒå‘çš„ï¼Œä»¥ä¾¿åœ¨è°ƒåº¦å™¨é‡æ–°ç»“æ„åŒ–ç¨‹åºåå‘å‡ºMLIRï¼Œè€Œä¸è€ƒè™‘SSAå€¼çš„å¯è§æ€§è§„åˆ™ã€‚å¦‚æœä¸€ä¸ªå¤šæ¬¡ä½¿ç”¨çš„æ“ä½œæ²¡æœ‰å‰¯ä½œç”¨ï¼ŒPolygeistä¼šç®€å•åœ°å¤åˆ¶å®ƒã€‚å¯¹äºé‡å¤æ“ä½œçš„å¤åˆ¶ä¸åˆæ³•çš„æƒ…å†µï¼ŒPolygeistå°†å…¶ç»“æœå­˜å‚¨åœ¨å †æ ˆåˆ†é…çš„å†…å­˜å¼•ç”¨ä¸­ï¼Œå¹¶å°†æ‰€æœ‰åç»­ä½¿ç”¨æ›¿æ¢ä¸ºå†…å­˜åŠ è½½ã€‚å›¾6å±•ç¤ºäº†åœ¨æ“ä½œ%20ä¸­ä½¿ç”¨çš„å€¼%0çš„è½¬æ¢ã€‚è¿™åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„è¯­å¥ã€‚ b) è·¨åŒºåŸŸä¾èµ–å…³ç³»ï¼šåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä¸€ä¸ªè¯­å¥å¯èƒ½ç”±ä¸åŒï¼ˆåµŒå¥—ï¼‰å¾ªç¯ä¸­çš„MLIRæ“ä½œç»„æˆï¼Œä¾‹å¦‚ï¼Œä»å†…å­˜åŠ è½½åˆ°SSAå¯„å­˜å™¨çš„æ“ä½œå‘ç”Ÿåœ¨å¤–éƒ¨å¾ªç¯ä¸­ï¼Œè€Œå®ƒåœ¨å†…éƒ¨å¾ªç¯ä¸­è¢«ä½¿ç”¨ã€‚è¯¥è¯­å¥åœ¨å¾ªç¯å±‚æ¬¡ç»“æ„ä¸­çš„ä½ç½®å¹¶ä¸æ˜ç¡®ã€‚æ›´é‡è¦çš„æ˜¯ï¼Œæ— æ³•å°†å…¶ä¼ è¾¾ç»™å¤šé¢ä½“è°ƒåº¦å™¨ã€‚Polygeisté€šè¿‡åœ¨å®šä¹‰åŒºåŸŸä¸­å°†å€¼å­˜å‚¨åœ¨å †æ ˆåˆ†é…çš„å†…å­˜å¼•ç”¨ä¸­ï¼Œå¹¶åœ¨ä½¿ç”¨åŒºåŸŸä¸­å°†å…¶åŠ è½½å›å»ï¼Œä»è€Œè§£å†³äº†è¿™ä¸€é—®é¢˜ã€‚å›¾6å±•ç¤ºäº†åœ¨æ“ä½œ%10ä¸­ä½¿ç”¨çš„å€¼%0çš„è¿™ç§è½¬æ¢ã€‚ä¸åŸºæœ¬æƒ…å†µç±»ä¼¼ï¼Œè¿™åœ¨å¤–éƒ¨å¾ªç¯ä¸­åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„è¯­å¥ï¼Œå¯ä»¥ç‹¬ç«‹è°ƒåº¦ã€‚è¯¥æ–¹æ³•å¯ä»¥è§†ä¸ºreg2memè½¬æ¢ï¼Œè¿™æ˜¯åœ¨å‰ç«¯æ‰§è¡Œçš„mem2regçš„åå‘æ“ä½œã€‚å®ƒä»…é€‚ç”¨äºä¸€éƒ¨åˆ†å€¼ï¼Œå¹¶ä¸”åœ¨å¤šé¢ä½“è°ƒåº¦å®Œæˆåå¯ä»¥æ’¤é”€ã€‚æ­¤å¤–ï¼Œä¸ºäº†å‡å°‘ä¾èµ–å…³ç³»å’Œå†…å­˜å ç”¨ï¼ŒPolygeistæ‰§è¡Œç®€å•çš„å€¼åˆ†æï¼Œå¹¶åœ¨åŒä¸€å€¼åœ¨å¦ä¸€ä¸ªå†…å­˜ä½ç½®å¯ç”¨å¹¶èƒ½å¤Ÿä»é‚£é‡Œè¯»å–æ—¶ï¼Œé¿å…åˆ›å»ºå †æ ˆåˆ†é…çš„ç¼“å†²åŒºã€‚ # C. Connecting MLIR to Polyhedral Tools Part-3 c) SCoP Formation: To define a SCoP, we outline individual statements into functions so that they can be represented as opaque calls with known memory footprints, similarly to Pencil [22]. This process also makes the inter-statement SSA dependencies clear. These dependencies exist between calls that use the same SSA value, but there are no values defined by these calls. We lift all local stack allocations and place them at the entry block of the surrounding function in order to keep them visible after loop restructuring. Figure 7 demonstrates the resulting IR. The remaining components of the polyhedral representation are derived as follows: the domain of the statement is defined to be the iteration space of its enclosing loops, constrained by their respective lower and upper bounds, and intersected with any \"if\" conditions. This process leverages the fact that MLIR expresses bounds and conditions directly as affine constructs. The access relations for each statement are obtained as unions of affine maps of the affine.load (read) and affine.store (must-write) operations, with RHS of the relation annotated by an \"array\" that corresponds to the SSA value of the accessed memref. Initial schedules are assigned using the (2d + 1) formalism, with odd dimensions representing the lexical order of loops in the input program and even dimensions being equal to loop induction variables. Affine constructs in OpenScop are represented as lists of linear equality (= 0) or inequality (â‰¥ 0) coefficients, which matches exactly the internal representation in MLIR, making the conversion straightforward. d) Code Generation Back to MLIR: The Pluto scheduler produces new schedules in OpenScop as a result. Generating loop structure back from affine schedules is a solved, albeit daunting, problem [13], [14]. Polygeist relies on CLooG [13] to generate an initial loop-level AST, which it then converts to Affine dialect loops and conditionals. There is no need to simplify affine expressions at code generation since MLIR accepts them directly and can simplify them at a later stage. Statements are introduced as function calls with rewritten operands and then inlined. c) SCoP å½¢æˆï¼šä¸ºäº†å®šä¹‰ä¸€ä¸ª SCoPï¼Œæˆ‘ä»¬å°†å•ç‹¬çš„è¯­å¥åˆ’åˆ†ä¸ºå‡½æ•°ï¼Œè¿™æ ·å®ƒä»¬å°±å¯ä»¥è¢«è¡¨ç¤ºä¸ºå…·æœ‰å·²çŸ¥å†…å­˜å ç”¨çš„é€æ˜è°ƒç”¨ï¼Œç±»ä¼¼äº Pencil [22]ã€‚è¿™ä¸ªè¿‡ç¨‹ä¹Ÿä½¿å¾—è¯­å¥é—´çš„ SSA ä¾èµ–å…³ç³»å˜å¾—æ¸…æ™°ã€‚è¿™äº›ä¾èµ–å…³ç³»å­˜åœ¨äºä½¿ç”¨ç›¸åŒ SSA å€¼çš„è°ƒç”¨ä¹‹é—´ï¼Œä½†è¿™äº›è°ƒç”¨æ²¡æœ‰å®šä¹‰ä»»ä½•å€¼ã€‚æˆ‘ä»¬æå‡æ‰€æœ‰å±€éƒ¨æ ˆåˆ†é…ï¼Œå¹¶å°†å®ƒä»¬æ”¾ç½®åœ¨å‘¨å›´å‡½æ•°çš„å…¥å£å—ä¸­ï¼Œä»¥ä¿æŒå®ƒä»¬åœ¨å¾ªç¯é‡æ„åä»ç„¶å¯è§ã€‚å›¾ 7 å±•ç¤ºäº†å¾—åˆ°çš„ IRã€‚ å¤šé¢ä½“è¡¨ç¤ºçš„å…¶ä½™ç»„ä»¶å¦‚ä¸‹æ´¾ç”Ÿï¼šè¯­å¥çš„åŸŸè¢«å®šä¹‰ä¸ºå…¶æ‰€åŒ…å«å¾ªç¯çš„è¿­ä»£ç©ºé—´ï¼Œç”±å„è‡ªçš„ä¸‹ç•Œå’Œä¸Šç•Œçº¦æŸï¼Œå¹¶ä¸ä»»ä½•â€œifâ€æ¡ä»¶ç›¸äº¤ã€‚è¿™ä¸ªè¿‡ç¨‹åˆ©ç”¨äº† MLIR ç›´æ¥å°†è¾¹ç•Œå’Œæ¡ä»¶è¡¨ç¤ºä¸ºä»¿å°„æ„é€ çš„ç‰¹æ€§ã€‚æ¯ä¸ªè¯­å¥çš„è®¿é—®å…³ç³»ä½œä¸º affine.loadï¼ˆè¯»å–ï¼‰å’Œ affine.storeï¼ˆå¿…é¡»å†™å…¥ï¼‰æ“ä½œçš„ä»¿å°„æ˜ å°„çš„å¹¶é›†è·å¾—ï¼Œå…³ç³»çš„å³ä¾§è¢«æ³¨é‡Šä¸ºä¸è¢«è®¿é—®çš„ memref å¯¹åº”çš„â€œæ•°ç»„â€ï¼Œè¿™å¯¹åº”äº SSA å€¼ã€‚åˆå§‹è°ƒåº¦æ˜¯ä½¿ç”¨ (2d + 1) å½¢å¼åˆ†é…çš„ï¼Œå¥‡æ•°ç»´åº¦è¡¨ç¤ºè¾“å…¥ç¨‹åºä¸­å¾ªç¯çš„è¯æ³•é¡ºåºï¼Œè€Œå¶æ•°ç»´åº¦ç­‰äºå¾ªç¯å¼•å¯¼å˜é‡ã€‚OpenScop ä¸­çš„ä»¿å°„æ„é€ è¡¨ç¤ºä¸ºçº¿æ€§ç­‰å¼ (= 0) æˆ–ä¸ç­‰å¼ (â‰¥ 0) ç³»æ•°çš„åˆ—è¡¨ï¼Œè¿™æ­£å¥½ä¸ MLIR ä¸­çš„å†…éƒ¨è¡¨ç¤ºç›¸åŒ¹é…ï¼Œä½¿è½¬æ¢å˜å¾—ç®€å•æ˜äº†ã€‚ d) ä»£ç ç”Ÿæˆå› MLIRï¼šPluto è°ƒåº¦å™¨å› æ­¤ç”Ÿæˆäº† OpenScop ä¸­çš„æ–°è°ƒåº¦ã€‚ä»ä»¿å°„è°ƒåº¦ç”Ÿæˆå¾ªç¯ç»“æ„æ˜¯ä¸€ä¸ªå·²è§£å†³ä½†ç›¸å½“å¤æ‚çš„é—®é¢˜ [13]ï¼Œ[14]ã€‚Polygeist ä¾èµ–äº CLooG [13] æ¥ç”Ÿæˆåˆå§‹çš„å¾ªç¯çº§ ASTï¼Œç„¶åå°†å…¶è½¬æ¢ä¸ºä»¿å°„æ–¹è¨€çš„å¾ªç¯å’Œæ¡ä»¶ã€‚åœ¨ä»£ç ç”Ÿæˆæ—¶æ— éœ€ç®€åŒ–ä»¿å°„è¡¨è¾¾å¼ï¼Œå› ä¸º MLIR å¯ä»¥ç›´æ¥æ¥å—å®ƒä»¬ï¼Œå¹¶èƒ½å¤Ÿåœ¨åç»­é˜¶æ®µè¿›è¡Œç®€åŒ–ã€‚è¯­å¥ä½œä¸ºå…·æœ‰é‡å†™æ“ä½œæ•°çš„å‡½æ•°è°ƒç”¨å¼•å…¥ï¼Œç„¶åè¿›è¡Œå†…è”ã€‚ # D. Controlling Statement Granularity Recall that Polygeist reconstructs \"statements\" from sequences of primitive operations (Section III-C). We initially designed an approach that recovers the statement structure similar to that in the C input, but this is not a requirement. Instead, statements can be formed from any subsets of MLIR operations as long as they can be organized into loops and sorted topologically (i.e., there are no use-def cycles between statements). To expose the dependencies between such statements to the affine scheduler, we reuse the idea of going through scratchpad memory: each statement writes the values required by other statements to dedicated memory locations, and the following statements read from those. The scratchpads are subject to partial array expansion [23] to minimize their effect on the affine scheduler as single-element scratchpad arrays create artificial scalar dependencies. This change in statement granularity gives the affine scheduler unprecedented flexibility allowing it to chose different schedules for different parts of the same C statement. Consider, for example, the statement S in Figure 8(top) surrounded by three loops iterating over i, j and k. Such contraction patterns are common in computational programs (this particular example can be found in the correlation benchmark with Bâ‰¡C, see Section V-E). The loop order that best exploits the locality is (k, i, j), which results in temporal locality for reads from B (the value is reused in all iterations of the now-innermost j loop) and in spatial locality for reads from C (consecutive values are read by consecutive iterations, increasing the likelihood of L1 cache hits). Yet, Pluto never proposes such an order because of a reduction dependency along the k dimension due to repeated read/write access to A[i][j] as Pluto tends to pick loops with fewer dependencies as outermost. While the dependency itself is inevitable, it can be moved into a separate statement T in Figure 8(bottom left). This approach provides scheduler with more freedom of choice for the first statement at a lesser memory cost than expanding the entire A array. It also factors out the reduction into a \"canonical\" statement that is easier to process for the downstream passes, e.g., vectorization. Implementing this transformation at the C level would require manipulating C AST and reasoning about C (or even C++) semantics. This is typically out of reach for source-tosource polyhedral optimizers such as Pluto that treat statements as black boxes. While it is possible to implement this transformation at the LLVM IR level, e.g., in Polly, where statements are also reconstructed and injection of temporary allocations is easy, the heuristic driving the transformation is based on the loop structure and multi-dimensional access patterns which are difficult to recover at such a low level [9]. The space of potential splittings is huge-each MLIR operation can potentially become a statement. Therefore, we devise a heuristic to address the contraction cases similar to Figure 8. Reduction statement splitting applies to statements: â€¢ surrounded by at least 3 loops; â€¢ with LHS =RHS, and using all loops but the innermost; â€¢ with two or more different access patterns on the RHS. This covers statements that could have locality improved by a different loop order and with low risk of undesired fission. This heuristic merely serves as an illustration of the kind of new transformations Polygeist can enable. D. æ§åˆ¶è¯­å¥ç²’åº¦ å›æƒ³ä¸€ä¸‹ï¼ŒPolygeist æ˜¯é€šè¿‡åŸå§‹æ“ä½œçš„åºåˆ—é‡å»ºâ€œè¯­å¥â€çš„ï¼ˆè§ç¬¬ä¸‰èŠ‚Cï¼‰ã€‚æˆ‘ä»¬æœ€åˆè®¾è®¡äº†ä¸€ç§æ¢å¤ä¸ C è¾“å…¥ä¸­ç›¸ä¼¼çš„è¯­å¥ç»“æ„çš„æ–¹æ³•ï¼Œä½†è¿™å¹¶ä¸æ˜¯å¿…éœ€çš„ã€‚å®é™…ä¸Šï¼Œåªè¦å¯ä»¥å°†è¯­å¥ç»„ç»‡æˆå¾ªç¯å¹¶è¿›è¡Œæ‹“æ‰‘æ’åºï¼ˆå³è¯­å¥ä¹‹é—´æ²¡æœ‰ä½¿ç”¨-å®šä¹‰å¾ªç¯ï¼‰ï¼Œè¯­å¥å¯ä»¥ç”±ä»»ä½•å­é›†çš„ MLIR æ“ä½œå½¢æˆã€‚ä¸ºäº†å‘ä»¿å°„è°ƒåº¦å™¨æš´éœ²è¿™äº›è¯­å¥ä¹‹é—´çš„ä¾èµ–å…³ç³»ï¼Œæˆ‘ä»¬é‡ç”¨äº†é€šè¿‡ä¸´æ—¶å­˜å‚¨å™¨çš„æ€æƒ³ï¼šæ¯ä¸ªè¯­å¥å°†å…¶ä»–è¯­å¥æ‰€éœ€çš„å€¼å†™å…¥ä¸“ç”¨å†…å­˜ä½ç½®ï¼Œéšåè¯­å¥ä»è¿™äº›ä½ç½®è¯»å–ã€‚ä¸´æ—¶å­˜å‚¨å™¨å—åˆ°éƒ¨åˆ†æ•°ç»„æ‰©å±•çš„é™åˆ¶[23]ï¼Œä»¥æœ€å°åŒ–å®ƒä»¬å¯¹ä»¿å°„è°ƒåº¦å™¨çš„å½±å“ï¼Œå› ä¸ºå•å…ƒç´ çš„ä¸´æ—¶å­˜å‚¨å™¨æ•°ç»„ä¼šäº§ç”Ÿäººä¸ºçš„æ ‡é‡ä¾èµ–å…³ç³»ã€‚è¿™ç§è¯­å¥ç²’åº¦çš„å˜åŒ–ä¸ºä»¿å°„è°ƒåº¦å™¨æä¾›äº†å‰æ‰€æœªæœ‰çš„çµæ´»æ€§ï¼Œä½¿å…¶èƒ½å¤Ÿä¸ºåŒä¸€ C è¯­å¥çš„ä¸åŒéƒ¨åˆ†é€‰æ‹©ä¸åŒçš„è°ƒåº¦ã€‚ä»¥å›¾8ï¼ˆé¡¶éƒ¨ï¼‰ä¸­çš„è¯­å¥ S ä¸ºä¾‹ï¼Œè¯¥è¯­å¥è¢«ä¸‰ä¸ªé’ˆå¯¹ iã€j å’Œ k çš„å¾ªç¯åŒ…å›´ã€‚è¿™ç§æ”¶ç¼©æ¨¡å¼åœ¨è®¡ç®—ç¨‹åºä¸­å¾ˆå¸¸è§ï¼ˆæ­¤ç‰¹å®šç¤ºä¾‹å¯ä»¥åœ¨ç›¸å…³åŸºå‡†ä¸­æ‰¾åˆ°ï¼ŒBâ‰¡Cï¼Œè§ç¬¬äº”èŠ‚Eï¼‰ã€‚æœ€ä½³åˆ©ç”¨å±€éƒ¨æ€§çš„å¾ªç¯é¡ºåºæ˜¯ (k, i, j)ï¼Œè¿™å¯¹ä» B çš„è¯»å–äº§ç”Ÿæ—¶æ•ˆå±€éƒ¨æ€§ï¼ˆè¯¥å€¼åœ¨ç°åœ¨æœ€å†…å±‚çš„ j å¾ªç¯çš„æ‰€æœ‰è¿­ä»£ä¸­è¢«é‡ç”¨ï¼‰å¹¶å¯¹ä» C çš„è¯»å–äº§ç”Ÿç©ºé—´å±€éƒ¨æ€§ï¼ˆè¿ç»­çš„å€¼è¢«è¿ç»­çš„è¿­ä»£è¯»å–ï¼Œä»è€Œå¢åŠ äº† L1 ç¼“å­˜å‘½ä¸­ç‡çš„å¯èƒ½æ€§ï¼‰ã€‚ç„¶è€Œï¼ŒPluto ä»æœªæå‡ºè¿™æ ·çš„é¡ºåºï¼Œå› ä¸ºåœ¨ k ç»´åº¦ä¸Šç”±äºå¯¹ A[i][j] çš„é‡å¤è¯»/å†™è®¿é—®è€Œå­˜åœ¨å‡å°‘ä¾èµ–å…³ç³»ï¼ŒPluto è¶‹å‘äºé€‰æ‹©ä¾èµ–å…³ç³»è¾ƒå°‘çš„å¾ªç¯ä½œä¸ºæœ€å¤–å±‚ã€‚è™½ç„¶è¿™ç§ä¾èµ–å…³ç³»æœ¬èº«æ˜¯ä¸å¯é¿å…çš„ï¼Œä½†å®ƒå¯ä»¥è½¬ç§»åˆ°å›¾8ï¼ˆåº•éƒ¨å·¦ä¾§ï¼‰çš„å•ç‹¬è¯­å¥ T ä¸­ã€‚è¿™ç§æ–¹æ³•ä¸ºè°ƒåº¦å™¨æä¾›äº†æ›´å¤šçš„é€‰æ‹©è‡ªç”±åº¦ï¼Œå†…å­˜æˆæœ¬ç›¸å¯¹è¾ƒä½ï¼Œè€Œä¸æ˜¯æ‰©å±•æ•´ä¸ª A æ•°ç»„ã€‚å®ƒè¿˜å°†å‡å°‘é—®é¢˜åˆ†è§£ä¸ºä¸€ä¸ªâ€œè§„èŒƒâ€è¯­å¥ï¼Œä½¿å¾—ä¸‹æ¸¸å¤„ç†ï¼ˆä¾‹å¦‚å‘é‡åŒ–ï¼‰æ›´å®¹æ˜“è¿›è¡Œã€‚ åœ¨ C çº§åˆ«å®ç°è¿™ä¸€è½¬æ¢å°†éœ€è¦æ“ä½œ C æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰å¹¶æ¨ç† Cï¼ˆç”šè‡³ C++ï¼‰çš„è¯­ä¹‰ã€‚è¿™é€šå¸¸è¶…å‡ºäº†è¯¸å¦‚ Pluto è¿™æ ·çš„æºåˆ°æºå¤šé¢ä½“ä¼˜åŒ–å™¨çš„èƒ½åŠ›ï¼Œå› ä¸ºè¿™äº›ä¼˜åŒ–å™¨å°†è¯­å¥è§†ä¸ºé»‘ç®±ã€‚è™½ç„¶åœ¨ LLVM IR çº§åˆ«å®ç°è¿™ä¸€è½¬æ¢ä¹Ÿæ˜¯å¯èƒ½çš„ï¼Œä¾‹å¦‚åœ¨ Polly ä¸­ï¼Œåœ¨é‚£é‡Œè¯­å¥ä¹Ÿè¢«é‡å»ºä¸”æš‚æ—¶åˆ†é…çš„æ³¨å…¥è¾ƒä¸ºå®¹æ˜“ï¼Œä½†é©±åŠ¨è½¬æ¢çš„å¯å‘å¼æ˜¯åŸºäºå¾ªç¯ç»“æ„å’Œå¤šç»´è®¿é—®æ¨¡å¼çš„ï¼Œè€Œåœ¨å¦‚æ­¤ä½çš„çº§åˆ«æ¢å¤è¿™äº›ä¿¡æ¯æ˜¯å›°éš¾çš„[9]ã€‚ æ½œåœ¨åˆ†å‰²çš„ç©ºé—´æ˜¯å·¨å¤§çš„â€”â€”æ¯ä¸ª MLIR æ“ä½œéƒ½æœ‰å¯èƒ½æˆä¸ºä¸€ä¸ªè¯­å¥ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ç§å¯å‘å¼æ–¹æ³•æ¥å¤„ç†ç±»ä¼¼äºå›¾8çš„æ”¶ç¼©æƒ…å†µã€‚å‡å°‘è¯­å¥åˆ†å‰²é€‚ç”¨äºä»¥ä¸‹è¯­å¥ï¼š â€¢ è‡³å°‘è¢« 3 ä¸ªå¾ªç¯åŒ…å›´ï¼› â€¢ å·¦ä¾§ = å³ä¾§ï¼Œå¹¶ä¸”ä½¿ç”¨æ‰€æœ‰å¾ªç¯ï¼Œé™¤äº†æœ€å†…å±‚çš„ï¼› â€¢ å³ä¾§å…·æœ‰ä¸¤ä¸ªæˆ–æ›´å¤šä¸åŒçš„è®¿é—®æ¨¡å¼ã€‚è¿™æ¶µç›–äº†é‚£äº›å¯èƒ½é€šè¿‡ä¸åŒå¾ªç¯é¡ºåºæ”¹å–„å±€éƒ¨æ€§çš„è¯­å¥ï¼Œå¹¶ä¸”é£é™©è¾ƒä½ï¼Œä¸ä¼šäº§ç”Ÿä¸å¸Œæœ›çš„åˆ†è£‚ã€‚è¿™ä¸ªå¯å‘å¼æ–¹æ³•ä»…ä½œä¸º Polygeist èƒ½å¤Ÿå¯ç”¨çš„æ–°è½¬æ¢ç±»å‹çš„ç¤ºä¾‹ã€‚ # E. Post-Transformations and Backend Polygeist allows one to operate on both quasi-syntactic and SSA level, enabling analyses and optimizations that are extremely difficult, if not impossible, to perform at either level in isolation. In addition to statement splitting, we propose two techniques that demonstrate the potential of Polygeist. a) Transforming Loops with Carried Values (Reductions): Polygeist leverages MLIR's first-class support for loopcarried values to detect, express and transform reduction-like loops. This support does not require source code annotations, unlike source-level tools [24] that use annotations to enable detection, nor complex modifications for parallel code emission, unlike Polly [25], which suffers from LLVM missing first-class parallel constructs. We do not modify the polyhedral scheduler either, relying on post-processing for reduction parallelization, including outermost parallel reduction loops. The overall approach follows the definition proposed in [26] with adaptations to MLIR's region-based IR, and is illustrated in Figure 9. Polygeist identifies memory locations modified on each iteration, i.e. load/store pairs with loop-invariant subscripts and no interleaving aliasing stores, by scanning the single-block body of the loop. These are transformed into loop-carried values or secondary induction variables, with the load/store pair lifted out of the loop and repurposed for reading the initial and storing the final value. Loop-carried values may be updated by a chain of side effect-free operations in the loop body. If this chain is known to be associative and commutative, the loop is a reduction. Loop-carried values are detected even in absence of reduction-compatible operations. Loops with such values contribute to mem2reg, decreasing memory footprint, but are not subject to parallelization. b) Late Parallelization: Rather than relying on the dependence distance information obtained by the affine scheduler, Polygeist performs a separate polyhedral analysis to detect loop parallelism in the generated code. The analysis itself is a classical polyhedral dependence analysis [27], [28] implemented on top of MLIR region structure. Performing it after SSA-based optimizations, in particular mem2reg and reduction detection, allows parallelizing more loops. In particular, reduction loops and loops with variables whose value is only relevant within a single iteration similar to live-range reordering [29] but without expensive additional polyhedral analyses (live-range of an SSA value defined in a loop never extends beyond the loop). E. åå˜æ¢åŠåç«¯ Polygeist ä½¿å¾—åœ¨ quasi-syntactic å’Œ SSA å±‚é¢ä¸Šæ“ä½œæˆä¸ºå¯èƒ½ï¼Œä»è€Œå®ç°äº†åœ¨ä»»ä½•ä¸€ä¸ªå±‚é¢ä¸Šå•ç‹¬è¿›è¡Œåˆ†æå’Œä¼˜åŒ–æ—¶æå…¶å›°éš¾ï¼ˆç”šè‡³ä¸å¯èƒ½ï¼‰çš„ä»»åŠ¡ã€‚é™¤äº†è¯­å¥æ‹†åˆ†ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸¤ç§å±•ç¤º Polygeist æ½œåŠ›çš„æŠ€æœ¯ã€‚ a) è½¬æ¢å¸¦æœ‰å»¶ç»­å€¼çš„å¾ªç¯ï¼ˆå½’çº¦ï¼‰ï¼šPolygeist åˆ©ç”¨ MLIR å¯¹å¾ªç¯æºå¸¦å€¼çš„ä¸€çº§æ”¯æŒï¼Œæ¥æ£€æµ‹ã€è¡¨è¾¾å’Œè½¬æ¢ç±»ä¼¼å½’çº¦çš„å¾ªç¯ã€‚è¿™ç§æ”¯æŒä¸éœ€è¦æºä»£ç æ³¨é‡Šï¼Œè€Œä¸ä½¿ç”¨æ³¨é‡Šä»¥å¯ç”¨æ£€æµ‹çš„æºçº§å·¥å…· [24] ä¸åŒï¼Œä¹Ÿä¸éœ€è¦å¤æ‚çš„ä¿®æ”¹æ¥è¿›è¡Œå¹¶è¡Œä»£ç çš„ç”Ÿæˆï¼Œä¸ Polly [25] ä¸åŒï¼Œåè€…å—åˆ° LLVM ç¼ºå¤±ä¸€çº§å¹¶è¡Œæ„é€ çš„é™åˆ¶ã€‚æˆ‘ä»¬ä¹Ÿæœªå¯¹å¤šé¢ä½“è°ƒåº¦å™¨è¿›è¡Œä¿®æ”¹ï¼Œè€Œæ˜¯ä¾èµ–åå¤„ç†æ¥è¿›è¡Œå½’çº¦å¹¶è¡ŒåŒ–ï¼ŒåŒ…æ‹¬æœ€å¤–å±‚çš„å¹¶è¡Œå½’çº¦å¾ªç¯ã€‚ æ€»ä½“æ–¹æ³•éµå¾ªäº† [26] ä¸­æå‡ºçš„å®šä¹‰ï¼Œé’ˆå¯¹ MLIR çš„åŸºäºåŒºåŸŸçš„ä¸­é—´è¡¨ç¤ºè¿›è¡Œäº†è°ƒæ•´ï¼Œå¦‚å›¾ 9 æ‰€ç¤ºã€‚Polygeist é€šè¿‡æ‰«æå¾ªç¯çš„å•å—ä¸»ä½“ï¼Œè¯†åˆ«æ¯æ¬¡è¿­ä»£ä¸­è¢«ä¿®æ”¹çš„å†…å­˜ä½ç½®ï¼Œå³å…·æœ‰å¾ªç¯ä¸å˜ä¸‹æ ‡ä¸”æ²¡æœ‰äº¤é”™åˆ«åå­˜å‚¨çš„åŠ è½½/å­˜å‚¨å¯¹ã€‚è¿™äº›è¢«è½¬æ¢ä¸ºå¾ªç¯æºå¸¦å€¼æˆ–äºŒæ¬¡å½’çº³å˜é‡ï¼ŒåŠ è½½/å­˜å‚¨å¯¹è¢«æå‡åˆ°å¾ªç¯å¤–å¹¶é‡æ–°ç”¨äºè¯»å–åˆå§‹å€¼å’Œå­˜å‚¨æœ€ç»ˆå€¼ã€‚åœ¨å¾ªç¯ä¸»ä½“ä¸­ï¼Œå¾ªç¯æºå¸¦å€¼å¯ä»¥é€šè¿‡ä¸€ç³»åˆ—æ— å‰¯ä½œç”¨æ“ä½œè¿›è¡Œæ›´æ–°ã€‚å¦‚æœè¿™ä¸ªé“¾è¢«è®¤ä¸ºæ˜¯ç»“åˆçš„å’Œäº¤æ¢çš„ï¼Œé‚£ä¹ˆè¯¥å¾ªç¯å³ä¸ºå½’çº¦ã€‚å³ä½¿åœ¨æ²¡æœ‰åˆé€‚çš„å½’çº¦æ“ä½œçš„æƒ…å†µä¸‹ï¼Œå¾ªç¯æºå¸¦å€¼ä¹Ÿèƒ½è¢«æ£€æµ‹åˆ°ã€‚å…·æœ‰æ­¤ç±»å€¼çš„å¾ªç¯å°†å¯¹ mem2reg äº§ç”Ÿè´¡çŒ®ï¼Œé™ä½å†…å­˜å ç”¨ï¼Œä½†ä¸é€‚åˆè¿›è¡Œå¹¶è¡ŒåŒ–ã€‚ b) å»¶è¿Ÿå¹¶è¡ŒåŒ–ï¼šPolygeist å¹¶ä¸ä¾èµ–äºé€šè¿‡ä»¿å°„è°ƒåº¦å™¨è·å–çš„ä¾èµ–è·ç¦»ä¿¡æ¯ï¼Œè€Œæ˜¯å¯¹ç”Ÿæˆçš„ä»£ç è¿›è¡Œå•ç‹¬çš„å¤šé¢ä½“åˆ†æä»¥æ£€æµ‹å¾ªç¯å¹¶è¡Œæ€§ã€‚è¯¥åˆ†ææœ¬èº«æ˜¯ä¸€ç§ç»å…¸çš„å¤šé¢ä½“ä¾èµ–åˆ†æ [27]ã€[28]ï¼Œåœ¨ MLIR åŒºåŸŸç»“æ„ä¹‹ä¸Šå®ç°ã€‚åœ¨è¿›è¡Œ SSA åŸºäºä¼˜åŒ–ä¹‹åæ‰§è¡Œè¿™ä¸€æ­¥ï¼Œç‰¹åˆ«æ˜¯ mem2reg å’Œå½’çº¦æ£€æµ‹ï¼Œèƒ½å¤Ÿå¹¶è¡ŒåŒ–æ›´å¤šçš„å¾ªç¯ã€‚ç‰¹åˆ«æ˜¯ï¼Œå½’çº¦å¾ªç¯å’Œé‚£äº›å˜é‡å€¼ä»…åœ¨å•æ¬¡è¿­ä»£å†…ç›¸å…³çš„å¾ªç¯ï¼ˆç±»ä¼¼äºæ´»è·ƒèŒƒå›´é‡æ’åº [29]ï¼Œä½†æ²¡æœ‰æ˜‚è´µçš„é¢å¤–å¤šé¢ä½“åˆ†æï¼‰éƒ½å¾—åˆ°å¤„ç†ï¼ˆåœ¨å¾ªç¯ä¸­å®šä¹‰çš„ SSA å€¼çš„æ´»è·ƒèŒƒå›´ä»ä¸è¶…å‡ºå¾ªç¯ï¼‰ã€‚ # IV. EVALUATION Our evaluation has two goals. 1) We want to demonstrate that the code produced by Polygeist without additional op- timization does not have any inexplicable performance differences than a state-of-the-art compiler like Clang. 2) We explore how Polygeist's internal representation can support a mix of affine and SSA-based transformation in the same compilation flow, and evaluate the potential benefits compared to existing source and compiler-based polyhedral tools. æˆ‘ä»¬çš„è¯„ä¼°æœ‰ä¸¤ä¸ªç›®æ ‡ã€‚1ï¼‰æˆ‘ä»¬å¸Œæœ›è¯æ˜ï¼ŒPolygeist ç”Ÿæˆçš„ä»£ç åœ¨æ²¡æœ‰é¢å¤–ä¼˜åŒ–çš„æƒ…å†µä¸‹ï¼Œå…¶æ€§èƒ½ä¸åƒ Clang è¿™æ ·çš„ç°ä»£ç¼–è¯‘å™¨æ²¡æœ‰ä»»ä½•ä¸å¯è§£é‡Šçš„å·®å¼‚ã€‚2ï¼‰æˆ‘ä»¬æ¢è®¨ Polygeist çš„å†…éƒ¨è¡¨ç¤ºå¦‚ä½•åœ¨åŒä¸€ç¼–è¯‘æµç¨‹ä¸­æ”¯æŒç»“åˆä½¿ç”¨ä»¿å°„å˜æ¢å’ŒåŸºäº SSA çš„å˜æ¢ï¼Œå¹¶è¯„ä¼°ä¸ç°æœ‰çš„æºä»£ç å’Œç¼–è¯‘å™¨åŸºç¡€ä¸Šçš„å¤šé¢ä½“å·¥å…·ç›¸æ¯”çš„æ½œåœ¨ä¼˜åŠ¿ã€‚ # A. Experimental Setup We ran our experiments on an AWS c5.metal instance with hyper-threading and Turbo Boost disabled. The system is Ubuntu 20.04 running on a dual-socket Intel Xeon Platinum 8275CL CPU at 3.0 GHz with 24 cores each, with 0.75, 35, 35.75 MB L1, L2, L3 cache per socket, respectively, and 256 GB RAM. We ran all 30 benchmarks from Poly-Bench [19], using the \"EXTRALARGE\" dataset. Pluto is unable to extract SCoP from the adi benchmark. We ran a total of 5 trials for each benchmark, taking the execution time reported by PolyBench; the median result is taken unless stated otherwise. Every measurement or result reported in the following sections refers to double-precision data. All experiments were run on cores 1-8, which ensured that all threads were on the same socket and did not potentially conflict with processes scheduled on core 0. In all cases, we use two-stage compilation: (i) using clang at -O3 excluding unrolling and vectorization; or Polygeist to emit LLVM IR from C; (ii) using clang at -O3 to emit the final binary. As several optimizations are not idempotent, a second round of optimization can potentially significantly boost (and rarely, hinder) performance. This is why we chose to only perform vectorization and unrolling at the last optimization stage. Since Polygeist applies some optimizations at the MLIR level (e.g., mem2reg), we compare against the twostage compilation pipeline as a more fair baseline (CLANG). We also evaluate a single-stage compilation to assess the effect of the two-stage flow (CLANGSING). æˆ‘ä»¬åœ¨ä¸€å° AWS c5.metal å®ä¾‹ä¸Šè¿›è¡Œå®éªŒï¼Œè¯¥å®ä¾‹ç¦ç”¨äº†è¶…çº¿ç¨‹å’Œ Turbo Boostã€‚ç³»ç»Ÿä¸º Ubuntu 20.04ï¼Œè¿è¡ŒäºåŒæ’æ§½ Intel Xeon Platinum 8275CL CPUï¼Œä¸»é¢‘ä¸º 3.0 GHzï¼Œæ¯ä¸ªæ’æ§½æœ‰ 24 ä¸ªæ ¸å¿ƒï¼ŒL1ã€L2 å’Œ L3 ç¼“å­˜åˆ†åˆ«ä¸º 0.75 MBã€35 MB å’Œ 35.75 MBï¼Œå¹¶é…å¤‡ 256 GB RAMã€‚æˆ‘ä»¬ä½¿ç”¨â€œEXTRALARGEâ€æ•°æ®é›†è¿è¡Œ Poly-Bench [19] ä¸­çš„æ‰€æœ‰ 30 ä¸ªåŸºå‡†æµ‹è¯•ã€‚Pluto æ— æ³•ä» adi åŸºå‡†æµ‹è¯•ä¸­æå– SCoPã€‚æˆ‘ä»¬å¯¹æ¯ä¸ªåŸºå‡†æµ‹è¯•è¿›è¡Œäº†æ€»å…± 5 æ¬¡è¯•éªŒï¼Œé‡‡ç”¨ PolyBench æŠ¥å‘Šçš„æ‰§è¡Œæ—¶é—´ï¼›é™¤éå¦æœ‰è¯´æ˜ï¼Œç»“æœä»¥ä¸­ä½æ•°çš„å½¢å¼ç»™å‡ºã€‚ä»¥ä¸‹å„èŠ‚ä¸­æŠ¥å‘Šçš„æ¯ä¸ªæµ‹é‡æˆ–ç»“æœå‡ä¸åŒç²¾åº¦æ•°æ®ç›¸å…³ã€‚æ‰€æœ‰å®éªŒå‡åœ¨æ ¸å¿ƒ 1-8 ä¸Šè¿è¡Œï¼Œä»¥ç¡®ä¿æ‰€æœ‰çº¿ç¨‹ä½äºåŒä¸€æ’æ§½ï¼Œå¹¶ä¸”ä¸ä¼šä¸è°ƒåº¦åœ¨æ ¸å¿ƒ 0 ä¸Šçš„è¿›ç¨‹å‘ç”Ÿæ½œåœ¨å†²çªã€‚ åœ¨æ‰€æœ‰æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬é‡‡ç”¨ä¸¤é˜¶æ®µç¼–è¯‘ï¼š(i) ä½¿ç”¨ clang ä»¥ -O3 çº§åˆ«ç¼–è¯‘ï¼Œä¸åŒ…æ‹¬å±•å¼€å’Œå‘é‡åŒ–ï¼›æˆ–ä½¿ç”¨ Polygeist ä» C å‘å‡º LLVM IRï¼›(ii) ä½¿ç”¨ clang ä»¥ -O3 çº§åˆ«å‘å‡ºæœ€ç»ˆäºŒè¿›åˆ¶æ–‡ä»¶ã€‚ç”±äºæŸäº›ä¼˜åŒ–å¹¶éå¹‚ç­‰çš„ï¼Œå› æ­¤ç¬¬äºŒè½®ä¼˜åŒ–å¯èƒ½ä¼šæ˜¾è‘—æå‡ï¼ˆè€Œå¾ˆå°‘æƒ…å†µä¼šæŠ‘åˆ¶ï¼‰æ€§èƒ½ã€‚è¿™å°±æ˜¯æˆ‘ä»¬é€‰æ‹©ä»…åœ¨æœ€åä¼˜åŒ–é˜¶æ®µè¿›è¡Œå‘é‡åŒ–å’Œå±•å¼€çš„åŸå› ã€‚ç”±äº Polygeist åœ¨ MLIR çº§åˆ«åº”ç”¨äº†ä¸€äº›ä¼˜åŒ–ï¼ˆä¾‹å¦‚ï¼Œmem2regï¼‰ï¼Œæˆ‘ä»¬å°†å…¶ä¸ä¸¤é˜¶æ®µç¼–è¯‘æµç¨‹ï¼ˆCLANGï¼‰è¿›è¡Œæ¯”è¾ƒï¼Œä½œä¸ºæ›´å…¬å¹³çš„åŸºçº¿ã€‚æˆ‘ä»¬è¿˜è¯„ä¼°äº†å•é˜¶æ®µç¼–è¯‘ï¼Œä»¥è¯„ä¼°ä¸¤é˜¶æ®µæµç¨‹çš„æ•ˆæœï¼ˆCLANGSINGï¼‰ã€‚ # B. Baseline Performance Polygeist must generate code with runtime as close as possible to that of existing compilation flows to establish a solid baseline. In other words, Polygeist should not introduce overhead nor speedup unless explicitly instructed otherwise, to allow for measuring the effects of additional optimizations. We evaluate this by comparing the runtime of programs produced by Polygeist with those produced by Clang at the same commit (Apr 2021) 2 . Figure 10 summarizes the results with the following flows: â€¢ CLANG: A compilation of the program using Clang, when running two stages of optimization; â€¢ CLANGSING: A compilation of the program using Clang, when running one stage of optimization; â€¢ MLIR-CLANG: A compilation flow using the Polygeist frontend and preprocessing optimizations within MLIR, but not running polyhedral scheduling nor postprocessing. B. åŸºçº¿æ€§èƒ½ Polygeistå¿…é¡»ç”Ÿæˆå°½å¯èƒ½æ¥è¿‘ç°æœ‰ç¼–è¯‘æµç¨‹çš„è¿è¡Œæ—¶ä»£ç ï¼Œä»¥å»ºç«‹ä¸€ä¸ªç¨³å›ºçš„åŸºçº¿ã€‚æ¢å¥è¯è¯´ï¼ŒPolygeistä¸åº”è¯¥å¼•å…¥å¼€é”€æˆ–åŠ é€Ÿï¼Œé™¤éæ˜ç¡®æŒ‡ç¤ºï¼Œä»¥ä¾¿èƒ½å¤Ÿæµ‹é‡é¢å¤–ä¼˜åŒ–çš„æ•ˆæœã€‚æˆ‘ä»¬é€šè¿‡æ¯”è¾ƒPolygeistç”Ÿæˆçš„ç¨‹åºä¸åŒä¸€æäº¤ç‰ˆæœ¬ï¼ˆ2021å¹´4æœˆï¼‰ä¸‹Clangç”Ÿæˆçš„ç¨‹åºçš„è¿è¡Œæ—¶æ¥è¯„ä¼°è¿™ä¸€ç‚¹ã€‚å›¾10æ€»ç»“äº†ä»¥ä¸‹å‡ ç§æµç¨‹çš„ç»“æœï¼š â€¢ CLANGï¼šä½¿ç”¨Clangç¼–è¯‘ç¨‹åºï¼Œè¿è¡Œä¸¤é˜¶æ®µä¼˜åŒ–çš„è¿‡ç¨‹ï¼› â€¢ CLANGSINGï¼šä½¿ç”¨Clangç¼–è¯‘ç¨‹åºï¼Œè¿è¡Œä¸€é˜¶æ®µä¼˜åŒ–çš„è¿‡ç¨‹ï¼› â€¢ MLIR-CLANGï¼šä½¿ç”¨Polygeistå‰ç«¯çš„ç¼–è¯‘æµç¨‹ï¼Œåœ¨MLIRå†…è¿›è¡Œé¢„å¤„ç†ä¼˜åŒ–ï¼Œä½†ä¸æ‰§è¡Œå¤šé¢ä½“è°ƒåº¦æˆ–åå¤„ç†ã€‚ # C. Compilation Flows We compare Polygeist with a source-level and an IR-level optimizer (Pluto and Polly) in the following configurations: â€¢ PLUTO: Pluto compiler auto-transformation [11] using polycc 3 with -noparallel and -tile flags; â€¢ PLUTOPAR: Same as above but with -parallel flag; â€¢ POLLY: Polly [7] LLVM passes with affine scheduling and tiling, and no pattern-based optimizations [30]; â€¢ POLLYPAR: Same as above with auto-parallelization; â€¢ POLYGEIST: Our flow with Pluto and extra transforms; â€¢ POLYGEISTPAR: Same as above but with -parallel Pluto schedule, Polygeist parallelization and reductions. Running between source and LLVM IR levels, we expect Polygeist to benefit from both worlds, thus getting code that is on par or better than competitors. When using Pluto, both standalone and within Polygeist, we disable the emission of vectorization hints and loop unrolling to make sure both transformations are fully controlled by the LLVM optimizer, which also runs in Polly flows. We run Polly in the latest stage of Clang compilation, using -mllvm -polly and additional flags to enable affine scheduling, tiling and parallelization as required. Polly is taken at the same LLVM commit as Clang. We disable pattern-based optimizations [30] that are not available elsewhere. Figures 11 and12 summarize the results for sequential and parallel flows, respectively. æˆ‘ä»¬å°†Polygeistä¸æºä»£ç çº§å’Œä¸­é—´è¡¨ç¤ºçº§ä¼˜åŒ–å™¨ï¼ˆPlutoå’ŒPollyï¼‰è¿›è¡Œæ¯”è¾ƒï¼Œé…ç½®å¦‚ä¸‹ï¼š PLUTOï¼šä½¿ç”¨-polycc 3åŠ-noparallelå’Œ-tileæ ‡å¿—çš„Plutoç¼–è¯‘å™¨è‡ªåŠ¨è½¬æ¢ï¼› PLUTOPARï¼šä¸ä¸Šè¿°ç›¸åŒï¼Œä½†ä½¿ç”¨-parallelæ ‡å¿—ï¼› POLLYï¼šPolly [7]çš„LLVMé€šé“ï¼Œå…·æœ‰ä»¿å°„è°ƒåº¦å’Œåˆ‡ç‰‡ï¼Œæ²¡æœ‰åŸºäºæ¨¡å¼çš„ä¼˜åŒ– [30]ï¼› POLLYPARï¼šä¸ä¸Šè¿°ç›¸åŒï¼Œä½†è¿›è¡Œäº†è‡ªåŠ¨å¹¶è¡ŒåŒ–ï¼› POLYGEISTï¼šæˆ‘ä»¬çš„å·¥ä½œæµï¼Œç»“åˆäº†Plutoå’Œé¢å¤–çš„å˜æ¢ï¼› POLYGEISTPARï¼šä¸ä¸Šè¿°ç›¸åŒï¼Œä½†ä½¿ç”¨-parallelçš„Plutoè°ƒåº¦ï¼ŒPolygeistå¹¶è¡ŒåŒ–å’Œå½’çº¦ã€‚ åœ¨æºä»£ç å’ŒLLVM IRçº§åˆ«ä¹‹é—´è¿è¡Œæ—¶ï¼Œæˆ‘ä»¬æœŸæœ›Polygeistèƒ½å¤Ÿä»è¿™ä¸¤è€…çš„ä¼˜ç‚¹ä¸­å—ç›Šï¼Œä»è€Œç”Ÿæˆçš„ä»£ç èƒ½å¤Ÿä¸ç«äº‰å¯¹æ‰‹ç›¸åª²ç¾æˆ–æ›´ä¼˜ã€‚åœ¨ä½¿ç”¨Plutoæ—¶ï¼Œæ— è®ºæ˜¯ç‹¬ç«‹åœ°è¿˜æ˜¯åœ¨Polygeistä¸­ï¼Œæˆ‘ä»¬éƒ½ä¼šç¦ç”¨å‘é‡åŒ–æç¤ºå’Œå¾ªç¯å±•å¼€çš„å‘å‡ºï¼Œä»¥ç¡®ä¿è¿™ä¸¤ç§å˜æ¢éƒ½å®Œå…¨ç”±LLVMä¼˜åŒ–å™¨æ§åˆ¶ï¼Œè¯¥ä¼˜åŒ–å™¨ä¹Ÿåœ¨Pollyæµç¨‹ä¸­è¿è¡Œã€‚æˆ‘ä»¬åœ¨Clangç¼–è¯‘çš„æœ€æ–°é˜¶æ®µè¿è¡ŒPollyï¼Œä½¿ç”¨-mllvm -pollyåŠå…¶ä»–æ ‡å¿—ä»¥å¯ç”¨ä»¿å°„è°ƒåº¦ã€åˆ‡ç‰‡å’Œå¹¶è¡ŒåŒ–ã€‚Pollyä¸Clangä½¿ç”¨ç›¸åŒçš„LLVMæäº¤ç‰ˆæœ¬ã€‚æˆ‘ä»¬ç¦ç”¨åœ¨å…¶ä»–åœ°æ–¹ä¸å¯ç”¨çš„åŸºäºæ¨¡å¼çš„ä¼˜åŒ– [30]ã€‚å›¾11å’Œå›¾12åˆ†åˆ«æ€»ç»“äº†é¡ºåºå’Œå¹¶è¡Œæµç¨‹çš„ç»“æœã€‚ # A. Benchmarking The transformation of reduction loops, in particular parallelization, may result in a different order of partial result accumulation. This is not allowed under IEEE 754 semantics, but is supported by compilers with -ffast-math option. We found that Polybench allocation function hinders Clang/LLVM alias analysis, negatively affecting performance 2 LLVM commit 20d5c42e0ef5d252b434bcb610b04f1cb79fe771 3 Pluto commit dae26e77b94b2624a540c08ec7128f20cd7b7985 in, e.g., adi. Therefore, we modified all benchmarks to use malloc that is known to produce non-aliasing pointers. é™ä½å¾ªç¯çš„è½¬æ¢ï¼Œç‰¹åˆ«æ˜¯å¹¶è¡ŒåŒ–ï¼Œå¯èƒ½ä¼šå¯¼è‡´éƒ¨åˆ†ç»“æœç´¯ç§¯çš„é¡ºåºå‘ç”Ÿå˜åŒ–ã€‚è¿™åœ¨ IEEE 754 è¯­ä¹‰ä¸‹æ˜¯ä¸å…è®¸çš„ï¼Œä½†ä½¿ç”¨ -ffast-math é€‰é¡¹çš„ç¼–è¯‘å™¨æ”¯æŒè¿™ç§æƒ…å†µã€‚æˆ‘ä»¬å‘ç°ï¼ŒPolybench çš„åˆ†é…å‡½æ•°ä¼šå¦¨ç¢ Clang/LLVM çš„åˆ«ååˆ†æï¼Œä»è€Œå¯¹æ€§èƒ½äº§ç”Ÿè´Ÿé¢å½±å“ 2 LLVM æäº¤ 20d5c42e0ef5d252b434bcb610b04f1cb79fe771 3 Pluto æäº¤ dae26e77b94b2624a540c08ec7128f20cd7b7985ï¼Œä¸¾ä¾‹æ¥è¯´ï¼Œåœ¨ adi ä¸­ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¿®æ”¹äº†æ‰€æœ‰åŸºå‡†æµ‹è¯•ï¼Œä½¿ç”¨å·²çŸ¥ä¼šäº§ç”Ÿéåˆ«åæŒ‡é’ˆçš„ mallocã€‚ # B. Baseline Comparison We did not observe a significant difference between the runtimes of CLANG and CLANGSING configurations, with a geometric mean of 0.43% symmetric difference 4 across benchmarks. Therefore, we only consider CLANG as baseline throughout the remainder of this paper. We did not observe a significant difference between the runtimes of CLANG and MLIR-CLANG configurations either, with a geometric mean of 0.24% symmetric difference. We found a variation in runtimes of short-running benchmarks, in particular jacobi-1d. This can be attributed to the interaction with the data initialization and benchmarking code, and with other OS processes. Excluding the benchmarks running in under 0.05s (jacobi-1d, gesummv, atax, bicg) from the analysis, we obtain 0.32% and 0.17% geomean symmetric differences respectively for the two comparisons above. These results suggest that our flow has no unexplained (dis)advantages over the baseline. æˆ‘ä»¬æ²¡æœ‰è§‚å¯Ÿåˆ°CLANGå’ŒCLANGSINGé…ç½®ä¹‹é—´çš„è¿è¡Œæ—¶é—´å­˜åœ¨æ˜¾è‘—å·®å¼‚ï¼Œåœ¨åŸºå‡†æµ‹è¯•ä¸­ï¼Œå®ƒä»¬çš„å‡ ä½•å¹³å‡å¯¹ç§°å·®ä¸º0.43%ã€‚å› æ­¤ï¼Œåœ¨æœ¬æ–‡çš„å…¶ä½™éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬ä»…è€ƒè™‘CLANGä½œä¸ºåŸºçº¿ã€‚åŒæ ·ï¼Œæˆ‘ä»¬ä¹Ÿæ²¡æœ‰è§‚å¯Ÿåˆ°CLANGå’ŒMLIR-CLANGé…ç½®ä¹‹é—´çš„è¿è¡Œæ—¶é—´å­˜åœ¨æ˜¾è‘—å·®å¼‚ï¼Œå…¶å‡ ä½•å¹³å‡å¯¹ç§°å·®ä¸º0.24%ã€‚ æˆ‘ä»¬å‘ç°çŸ­è¿è¡ŒåŸºå‡†çš„è¿è¡Œæ—¶é—´å­˜åœ¨å˜åŠ¨ï¼Œç‰¹åˆ«æ˜¯åœ¨jacobi-1dä¸Šã€‚è¿™å¯ä»¥å½’å› äºæ•°æ®åˆå§‹åŒ–å’ŒåŸºå‡†æµ‹è¯•ä»£ç ä¹‹é—´çš„ç›¸äº’ä½œç”¨ï¼Œä»¥åŠå…¶ä»–æ“ä½œç³»ç»Ÿè¿›ç¨‹çš„å½±å“ã€‚ä»åˆ†æä¸­æ’é™¤è¿è¡Œæ—¶é—´å°‘äº0.05ç§’çš„åŸºå‡†ï¼ˆå¦‚jacobi-1dã€gesummvã€ataxã€bicgï¼‰ï¼Œæˆ‘ä»¬åˆ†åˆ«è·å¾—ä¸Šè¿°ä¸¤ä¸ªæ¯”è¾ƒçš„å‡ ä½•å¹³å‡å¯¹ç§°å·®ä¸º0.32%å’Œ0.17%ã€‚è¿™äº›ç»“æœè¡¨æ˜ï¼Œæˆ‘ä»¬çš„æµç¨‹åœ¨åŸºçº¿ä¹‹ä¸Šæ²¡æœ‰æœªè§£é‡Šçš„ï¼ˆä¸ï¼‰ä¼˜åŠ¿ã€‚ # C. Performance Differences in Sequential Code Overall, Polygeist leads to larger speedups, with 2.53Ã— geometric mean, than both Pluto (2.34Ã—) and Polly (1.41Ã—), although improvements are not systematic. Some difference between Polygeist and Polly is due to the employed polyhedral schedulers, e.g., in lu and mvt. Polygeist produces code faster tha both Pluto and Polly in 2mm, 3mm and others thanks to statement splitting, see Section V-E. Given identical statements and schedules, codegen-level optimization accounts for other performance difference. seidel-2d is the clearest example: Pluto executes 2.7â€¢10 11 more integer instructions than Polygeist. Assuming these to be index/address computations, a mix of add (throughput 1/2 or 1/4) and imul/shl (thoughput 1), we can expect a â‰ˆ 59s difference at 3GHz, consistent with experimental observations. Polygeist optimizes away a part of those in its post-optimization phase and emits homogeneous address computation from memref with proper machine size type, enabling more aggressive bound analysis and simplification in the downstream compiler. Conversely, jacobi-2d has poorer performance because Polygeist gives up on simplifying CLooG code, with up to 75 statement copies in 40 branches, for compiler performance reasons, as opposed to Clang that takes up to 5s to process it but results in better vectorization. Further work is necessary to address this issue by emitting vector instructions directly from Polygeist. æ•´ä½“è€Œè¨€ï¼ŒPolygeist ç›¸è¾ƒäº Plutoï¼ˆ2.34Ã—ï¼‰å’Œ Pollyï¼ˆ1.41Ã—ï¼‰æä¾›äº†æ›´å¤§çš„åŠ é€Ÿï¼Œå‡ ä½•å¹³å‡å€¼ä¸º 2.53Ã—ï¼Œå°½ç®¡æ”¹è¿›å¹¶ä¸æ˜¯ç³»ç»Ÿæ€§çš„ã€‚Polygeist å’Œ Polly ä¹‹é—´çš„ä¸€äº›å·®å¼‚æ˜¯ç”±äºæ‰€é‡‡ç”¨çš„å¤šé¢ä½“è°ƒåº¦å™¨ï¼Œä¾‹å¦‚åœ¨ lu å’Œ mvt ä¸­ã€‚å¾—ç›Šäºè¯­å¥åˆ†å‰²ï¼ŒPolygeist åœ¨ 2mmã€3mm åŠå…¶ä»–æŸäº›æƒ…å†µä¸‹ç”Ÿæˆçš„ä»£ç é€Ÿåº¦è¶…è¿‡äº† Pluto å’Œ Pollyï¼Œè¯¦è§ç¬¬ V-E èŠ‚ã€‚ åœ¨ç»™å®šç›¸åŒè¯­å¥å’Œè°ƒåº¦çš„æƒ…å†µä¸‹ï¼Œä»£ç ç”Ÿæˆå±‚é¢çš„ä¼˜åŒ–æ˜¯é€ æˆå…¶ä»–æ€§èƒ½å·®å¼‚çš„åŸå› ã€‚seidel-2d æ˜¯æœ€æ˜æ˜¾çš„ä¾‹å­ï¼šPluto æ‰§è¡Œçš„æ•´æ•°æŒ‡ä»¤æ¯” Polygeist å¤šå‡º 2.7â€¢10^11 æ¬¡ã€‚å‡è®¾è¿™äº›æŒ‡ä»¤éƒ½æ˜¯ç´¢å¼•/åœ°å€è®¡ç®—ï¼Œæ··åˆäº† addï¼ˆååé‡ä¸º 1/2 æˆ– 1/4ï¼‰å’Œ imul/shlï¼ˆååé‡ä¸º 1ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥é¢„è®¡åœ¨ 3GHz ä¸‹ä¼šæœ‰ â‰ˆ 59 ç§’çš„å·®å¼‚ï¼Œè¿™ä¸å®éªŒè§‚å¯Ÿç»“æœä¸€è‡´ã€‚Polygeist åœ¨å…¶åä¼˜åŒ–é˜¶æ®µä¼˜åŒ–æ‰äº†ä¸€éƒ¨åˆ†æŒ‡ä»¤ï¼Œå¹¶ä» memref å‘å‡ºé€‚å½“æœºå™¨å¤§å°ç±»å‹çš„å‡åŒ€åœ°å€è®¡ç®—ï¼Œä½¿ä¸‹æ¸¸ç¼–è¯‘å™¨èƒ½å¤Ÿè¿›è¡Œæ›´æ¿€è¿›çš„ç•Œé™åˆ†æå’Œç®€åŒ–ã€‚ç›¸åï¼Œç”±äº Polygeist ä¸ºäº†ç¼–è¯‘å™¨æ€§èƒ½åŸå› æ”¾å¼ƒäº†å¯¹ CLooG ä»£ç çš„ç®€åŒ–ï¼Œjacobi-2d çš„æ€§èƒ½è¾ƒå·®ï¼Œåœ¨ 40 ä¸ªåˆ†æ”¯ä¸­æœ‰å¤šè¾¾ 75 ä¸ªè¯­å¥å‰¯æœ¬ï¼Œè€Œ Clang å¤„ç†è¿™äº›ä»£ç éœ€è€—æ—¶å¤šè¾¾ 5 ç§’ï¼Œä½†å…¶ç»“æœå´å®ç°äº†æ›´å¥½çš„å‘é‡åŒ–ã€‚éœ€è¦è¿›ä¸€æ­¥çš„å·¥ä½œæ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œé€šè¿‡ç›´æ¥ä» Polygeist å‘å‡ºå‘é‡æŒ‡ä»¤ã€‚ # D. Performance Differences In Parallel Code Similarly to sequential code, some performance differences are due to different schedulers. For example, in cholesky and lu, both Pluto and Polygeist outperform Polly, and the remaining gap can be attributed to codegen-level differences. Conversely, in gemver and mvt Polly has a benefit over both Fig. 10. Mean and 95% confidence intervals (log scale) of program run time across 5 runs of Polybench in CLANG, CLANGSING and MLIR-CLANG configurations, lower is better. The run times of code produced by Polygeist without optimization is comparable to that of Clang. No significant variation is observed between single and double optimization. Short-running jacobi-1d shows high intra-group variation. Fig. 11. Median speedup over CLANG for sequential configurations (log scale), higher is better. Polygeist outperforms (2.53Ã— geomean speedup) both Pluto (2.34Ã—) and Polly (1.41Ã—) on average. Pluto can't process adi, which is therefore excluded from summary statistics. Fig. 12. Median speedup over CLANG for parallel configurations (log scale), higher is better. Polygeist outperforms (9.47Ã— geomean speedup) both Pluto (7.54Ã—) and Polly (3.26Ã—) on average. Pluto can't process adi, which is therefore excluded from summary statistics. Pluto and Polygeist. On ludcmp and syr(2)k, SSA-level optimizations let Polygeist produce code which is faster than Pluto and at least as fast as Polly. These results demonstrate that Polygeist indeed leverages the benefits of both the affine and SSA-based optimizations. Polygeist is the only flow that obtains speedup on deriche (6.9Ã—) and symm (7.7Ã—). Examining the output code, we observe that only Polygeist manages to parallelize these two benchmarks. Considering the input code in Figure 13, one can observe that the i loop reuses the ym1 variable, which is in-terpreted as parallelism-preventing loop-carried dependency by polyhedral schedulers. Polygeist performs its own parallelism analysis after promoting ym1 to an SSA register (carried by the j loop) whose use-def range does not prevent parallelization. Similarly, the Polygeist parallelizer identifies two benchmarks with parallel reduction loops that are not contained in other parallel loops: gramschmidt and durbin. gramschmidt benefits from a 56Ã— speedup with Polygeist, compared to 34Ã— with Polly and 54Ã— with Pluto. durbin sees a 6Ã— slowdown since the new parallel loop has relatively for (i=0; if64 { %0=affine.load %y1[%i,%j] // ... affine.yield %0 }} Fig. 13. Excerpt from the deriche benchmark. The outer loop reuses ym1 which makes it appear non-parallel to affine schedulers (left). Polygeist detects parallelism thanks to its mem2reg optimization, reduction-like loop-carried %ym1 value detection and late parallelization (right). few iterations and is nested inside a sequential loop, leading to synchronization costs that outweigh the parallelism benefit. Section V-F explores the durbin benchmark in more detail. Polybench is a collection of codes (mostly) known to be parallel and, as such, has little need for reduction parallelization on CPU where one degree of parallelism is sufficient. When targeting inherently target architectures as GPUs, however, exploiting reduction parallelism could be vital for achieving peak performance [31], [24]. åŒæ ·ï¼Œå¯¹äºå¹¶è¡Œä»£ç ï¼ŒæŸäº›æ€§èƒ½å·®å¼‚æ˜¯ç”±äºä¸åŒçš„è°ƒåº¦å™¨ã€‚ä¾‹å¦‚ï¼Œåœ¨ cholesky å’Œ lu ä¸­ï¼ŒPluto å’Œ Polygeist çš„æ€§èƒ½éƒ½ä¼˜äº Pollyï¼Œå‰©ä½™çš„å·®è·å¯ä»¥å½’å› äºä»£ç ç”Ÿæˆçº§åˆ«çš„å·®å¼‚ã€‚ç›¸åï¼Œåœ¨ gemver å’Œ mvt ä¸­ï¼ŒPolly ç›¸è¾ƒäºä¸¤è€…çš†æœ‰ä¼˜åŠ¿ã€‚ å›¾ 10 æ˜¾ç¤ºäº†åœ¨ CLANGã€CLANGSING å’Œ MLIR-CLANG é…ç½®ä¸‹ï¼ŒPolybench çš„äº”æ¬¡è¿è¡Œä¸­ç¨‹åºè¿è¡Œæ—¶é—´çš„å‡å€¼å’Œ 95% ç½®ä¿¡åŒºé—´ï¼ˆå¯¹æ•°å°ºåº¦ï¼‰ï¼Œå€¼è¶Šä½è¶Šå¥½ã€‚ç”± Polygeist äº§ç”Ÿçš„æœªä¼˜åŒ–ä»£ç çš„è¿è¡Œæ—¶é—´ä¸ Clang çš„è¿è¡Œæ—¶é—´ç›¸å½“ã€‚ä¸åŒç¨‹åº¦çš„å•é‡å’ŒåŒé‡ä¼˜åŒ–ä¹‹é—´æ²¡æœ‰è§‚å¯Ÿåˆ°æ˜¾è‘—å·®å¼‚ã€‚è¿è¡Œæ—¶é—´è¾ƒçŸ­çš„ jacobi-1d æ˜¾ç¤ºå‡ºé«˜çš„ç»„å†…å˜å¼‚æ€§ã€‚ å›¾ 11 æ˜¾ç¤ºäº†åœ¨é¡ºåºé…ç½®ä¸‹ç›¸å¯¹äº CLANG çš„ä¸­ä½æ•°åŠ é€Ÿæ¯”ï¼ˆå¯¹æ•°å°ºåº¦ï¼‰ï¼Œå€¼è¶Šé«˜è¶Šå¥½ã€‚Polygeist åœ¨å¹³å‡æƒ…å†µä¸‹çš„åŠ é€Ÿæ¯”ï¼ˆå‡ ä½•å‡å€¼åŠ é€Ÿæ¯”ä¸º 2.53Ã—ï¼‰ä¼˜äº Plutoï¼ˆ2.34Ã—ï¼‰å’Œ Pollyï¼ˆ1.41Ã—ï¼‰ã€‚Pluto æ— æ³•å¤„ç† adiï¼Œå› æ­¤è¯¥æ¡ˆä¾‹è¢«æ’é™¤åœ¨æ€»ç»“ç»Ÿè®¡ä¹‹å¤–ã€‚ å›¾ 12 æ˜¾ç¤ºäº†åœ¨å¹¶è¡Œé…ç½®ä¸‹ç›¸å¯¹äº CLANG çš„ä¸­ä½æ•°åŠ é€Ÿæ¯”ï¼ˆå¯¹æ•°å°ºåº¦ï¼‰ï¼Œå€¼è¶Šé«˜è¶Šå¥½ã€‚Polygeist åœ¨å¹³å‡æƒ…å†µä¸‹çš„åŠ é€Ÿæ¯”ï¼ˆå‡ ä½•å‡å€¼åŠ é€Ÿæ¯”ä¸º 9.47Ã—ï¼‰ä¼˜äº Plutoï¼ˆ7.54Ã—ï¼‰å’Œ Pollyï¼ˆ3.26Ã—ï¼‰ã€‚Pluto æ— æ³•å¤„ç† adiï¼Œå› æ­¤è¯¥æ¡ˆä¾‹ä¹Ÿè¢«æ’é™¤åœ¨æ€»ç»“ç»Ÿè®¡ä¹‹å¤–ã€‚ åœ¨ ludcmp å’Œ syr(2)k ä¸­ï¼ŒSSA çº§åˆ«çš„ä¼˜åŒ–ä½¿å¾— Polygeist ç”Ÿæˆçš„ä»£ç æ¯” Pluto æ›´å¿«ï¼Œå¹¶ä¸”è‡³å°‘ä¸ Polly åŒæ ·å¿«ã€‚è¿™äº›ç»“æœè¡¨æ˜ï¼ŒPolygeist ç¡®å®åˆ©ç”¨äº†ä»¿å°„ä¼˜åŒ–å’Œ SSA åŸºç¡€ä¼˜åŒ–çš„ä¼˜ç‚¹ã€‚ Polygeist æ˜¯å”¯ä¸€åœ¨ dericheï¼ˆåŠ é€Ÿæ¯” 6.9Ã—ï¼‰å’Œ symmï¼ˆåŠ é€Ÿæ¯” 7.7Ã—ï¼‰ä¸Šå®ç°åŠ é€Ÿçš„ç¼–è¯‘æµç¨‹ã€‚é€šè¿‡æ£€æŸ¥è¾“å‡ºä»£ç ï¼Œæˆ‘ä»¬è§‚å¯Ÿåˆ°åªæœ‰ Polygeist æˆåŠŸåœ°å¯¹è¿™ä¸¤ä¸ªåŸºå‡†è¿›è¡Œäº†å¹¶è¡ŒåŒ–ã€‚è€ƒè™‘åˆ°å›¾ 13 ä¸­çš„è¾“å…¥ä»£ç ï¼Œå¯ä»¥è§‚å¯Ÿåˆ° i å¾ªç¯é‡ç”¨äº† ym1 å˜é‡ï¼Œè¿™è¢«ä»¿å°„è°ƒåº¦å™¨è§£é‡Šä¸ºå¦¨ç¢å¹¶è¡ŒåŒ–çš„å¾ªç¯æºå¸¦ä¾èµ–ã€‚Polygeist åœ¨å°† ym1 æå‡ä¸ºä¸€ä¸ªç”± j å¾ªç¯æºå¸¦çš„ SSA å¯„å­˜å™¨åï¼Œè¿›è¡Œè‡ªå·±çš„å¹¶è¡Œæ€§åˆ†æï¼Œå…¶ä½¿ç”¨å®šä¹‰èŒƒå›´ä¸å¦¨ç¢å¹¶è¡ŒåŒ–ã€‚ ç±»ä¼¼åœ°ï¼ŒPolygeist çš„å¹¶è¡ŒåŒ–å™¨è¯†åˆ«å‡ºä¸¤ä¸ªå…·æœ‰å¹¶è¡Œå½’çº¦å¾ªç¯çš„åŸºå‡†ï¼Œè¿™äº›å¾ªç¯ä¸åŒ…å«åœ¨å…¶ä»–å¹¶è¡Œå¾ªç¯ä¸­ï¼šgramschmidt å’Œ durbinã€‚ç›¸æ¯”äº Polly çš„ 34Ã— å’Œ Pluto çš„ 54Ã—ï¼Œgramschmidt åœ¨ Polygeist çš„å¸®åŠ©ä¸‹è·å¾—äº† 56Ã— çš„åŠ é€Ÿã€‚durbin åˆ™å‡ºç°äº† 6Ã— çš„å‡é€Ÿï¼Œå› ä¸ºæ–°çš„å¹¶è¡Œå¾ªç¯è¿­ä»£æ¬¡æ•°ç›¸å¯¹è¾ƒå°‘ï¼Œå¹¶ä¸”åµŒå¥—åœ¨ä¸€ä¸ªé¡ºåºå¾ªç¯å†…ï¼Œå¯¼è‡´åŒæ­¥æˆæœ¬è¶…è¿‡äº†å¹¶è¡ŒåŒ–å¸¦æ¥çš„å¥½å¤„ã€‚ç¬¬ V-F èŠ‚å°†æ›´è¯¦ç»†åœ°æ¢è®¨ durbin åŸºå‡†ã€‚ Polybench æ˜¯ä¸€ç»„ï¼ˆå¤§å¤šæ•°å·²çŸ¥ï¼‰å…·æœ‰å¹¶è¡Œç‰¹æ€§çš„ä»£ç ï¼Œå› æ­¤åœ¨ CPU ä¸Šè¿›è¡Œå½’çº¦å¹¶è¡ŒåŒ–çš„éœ€æ±‚ä¸å¤§ï¼Œå› ä¸ºåªæœ‰ä¸€åº¦çš„å¹¶è¡Œæ€§å°±å·²è¶³å¤Ÿã€‚ç„¶è€Œï¼Œå½“é’ˆå¯¹å›ºæœ‰çš„ç›®æ ‡æ¶æ„å¦‚ GPU æ—¶ï¼Œåˆ©ç”¨å½’çº¦å¹¶è¡Œæ€§å¯èƒ½å¯¹äºå®ç°å³°å€¼æ€§èƒ½è‡³å…³é‡è¦ [31], [24]ã€‚ # E. Case Study: Statement Splitting We identified 5 benchmarks where the statement splitting heuristic applied: 2mm, 3mm, correlation, covariance and trmm. To assess the effect of the transformation, we executed these benchmarks with statement splitting disabled, suffixed with -nosplit in Figure 14. In sequential versions, 2mm is 4.1% slower (3.13s vs 3.26s), but the other benchmarks see speedups of 25%, 50%, 51% and 27%, respectively. For parallel versions, the speedups are of 36%, 20%, 44%, 40% and -9% respectively. Examination of polyhedral scheduler outputs demonstrates that it indeed produced the desired schedules. For example, in the correlation benchmark which had the statement A[i][j] += B[k][i] * B[k][j] Polygeist was able to find the (k, i, j) loop order after splitting. Using hardware performance counters on sequential code we confirm that the overall cache miss ratio has indeed decreased by 75%, 50%, 20%, 27%, and -26%, respectively. However, the memory traffic estimated by the number of bus cycles has increased by 9% for 2mm, and decreased by 18%, 32%, 32%, and 21% for the other benchmarks. This metric strongly correlates with the observed performance difference in the same run (r = 0.99, p = 3 â€¢ 10 -11 ). This behavior is likely due to the scheduler producing a different fusion structure, e.g., not fusing outermost loops in 2mm, which also affects locality. Similar results can be observed for parallel code. Further research is necessary to exploit the statement splitting opportunities, created by Polygeist, and interplay with fusion. E. æ¡ˆä¾‹ç ”ç©¶ï¼šè¯­å¥æ‹†åˆ† æˆ‘ä»¬ç¡®å®šäº† 5 ä¸ªåŸºå‡†æµ‹è¯•ï¼Œå…¶ä¸­åº”ç”¨äº†è¯­å¥æ‹†åˆ†å¯å‘å¼æ–¹æ³•ï¼š2mmã€3mmã€ç›¸å…³æ€§ã€åæ–¹å·®å’Œ trmmã€‚ä¸ºäº†è¯„ä¼°å˜æ¢çš„æ•ˆæœï¼Œæˆ‘ä»¬æ‰§è¡Œäº†è¿™äº›åŸºå‡†æµ‹è¯•ï¼Œå¹¶ç¦ç”¨äº†è¯­å¥æ‹†åˆ†ï¼Œç”¨ -nosplit åç¼€æ ‡è®°ï¼Œå¦‚å›¾ 14 æ‰€ç¤ºã€‚åœ¨é¡ºåºç‰ˆæœ¬ä¸­ï¼Œ2mm çš„é€Ÿåº¦æ…¢äº† 4.1%ï¼ˆ3.13 ç§’å¯¹æ¯” 3.26 ç§’ï¼‰ï¼Œä½†å…¶ä»–åŸºå‡†æµ‹è¯•åˆ†åˆ«çœ‹åˆ°äº† 25%ã€50%ã€51% å’Œ 27% çš„åŠ é€Ÿã€‚å¯¹äºå¹¶è¡Œç‰ˆæœ¬ï¼Œé€Ÿåº¦æå‡åˆ†åˆ«ä¸º 36%ã€20%ã€44%ã€40% å’Œ -9%ã€‚ å¯¹å¤šé¢ä½“è°ƒåº¦å™¨è¾“å‡ºçš„æ£€æŸ¥è¡¨æ˜ï¼Œå®ƒç¡®å®ç”Ÿæˆäº†é¢„æœŸçš„è°ƒåº¦ã€‚ä¾‹å¦‚ï¼Œåœ¨ç›¸å…³æ€§åŸºå‡†ä¸­ï¼Œè¯­å¥ A[i][j] += B[k][i] * B[k][j] Polygeist èƒ½å¤Ÿåœ¨æ‹†åˆ†åæ‰¾åˆ° (k, i, j) çš„å¾ªç¯é¡ºåºã€‚é€šè¿‡åœ¨é¡ºåºä»£ç ä¸Šä½¿ç”¨ç¡¬ä»¶æ€§èƒ½è®¡æ•°å™¨ï¼Œæˆ‘ä»¬ç¡®è®¤æ•´ä½“ç¼“å­˜ç¼ºå¤±ç‡ç¡®å®åˆ†åˆ«é™ä½äº† 75%ã€50%ã€20%ã€27% å’Œ -26%ã€‚ç„¶è€Œï¼Œç”±æ€»åŒ£å‘¨æœŸä¼°ç®—çš„å†…å­˜æµé‡åœ¨ 2mm ä¸­å¢åŠ äº† 9%ï¼Œè€Œå…¶ä»–åŸºå‡†æµ‹è¯•åˆ™åˆ†åˆ«å‡å°‘äº† 18%ã€32%ã€32% å’Œ 21%ã€‚è¯¥æŒ‡æ ‡ä¸åŒä¸€è¿è¡Œä¸­è§‚å¯Ÿåˆ°çš„æ€§èƒ½å·®å¼‚å¼ºç›¸å…³ï¼ˆr = 0.99ï¼Œp = 3 â€¢ 10 -11ï¼‰ã€‚è¿™ç§è¡Œä¸ºå¯èƒ½æ˜¯ç”±äºè°ƒåº¦å™¨äº§ç”Ÿäº†ä¸åŒçš„èåˆç»“æ„ï¼Œä¾‹å¦‚ï¼Œåœ¨ 2mm ä¸­æ²¡æœ‰èåˆæœ€å¤–å±‚çš„å¾ªç¯ï¼Œè¿™ä¹Ÿå½±å“äº†å±€éƒ¨æ€§ã€‚å¹¶è¡Œä»£ç ä¸­ä¹Ÿå¯ä»¥è§‚å¯Ÿåˆ°ç±»ä¼¼çš„ç»“æœã€‚è¿›ä¸€æ­¥çš„ç ”ç©¶æœ‰å¿…è¦åˆ©ç”¨ Polygeist åˆ›é€ çš„è¯­å¥æ‹†åˆ†æœºä¼šï¼Œå¹¶ä¸èåˆè¿›è¡Œç›¸äº’ä½œç”¨ã€‚ # F. Case Study: Reduction Parallelization in durbin In this benchmark, Polygeist uses its reduction optimization to create a parallel loop that other tools cannot. For the relatively small input run by default, N = 4000 iterations inside another sequential loop with N iterations, the overall performance decreases. We hypothesize that the cost of creating parallel threads and synchronizing them outweighs the benefit of the additional parallelism and test our hypothesis by increasing N . Considering the results in Figure 15, one observes that Polygeist starts yielding speedups (> 1) for N â‰¥ 16000 whereas Polly only does so at N â‰¥ 224000, and to a much lesser extent: 6.62Ã— vs 1.01Ã—. Without reduction parallelization, Polygeist follows the same trajectory as Polly. Pluto fails to parallelize any innermost loop and shows no speedup. This evidences in favor of our hypothesis and highlights the importance of being able to parallelize reductions. F. æ¡ˆä¾‹ç ”ç©¶ï¼šDurbinä¸­çš„å½’çº¦å¹¶è¡ŒåŒ– åœ¨è¿™ä¸ªåŸºå‡†æµ‹è¯•ä¸­ï¼ŒPolygeiståˆ©ç”¨å…¶å½’çº¦ä¼˜åŒ–åˆ›å»ºäº†ä¸€ä¸ªå…¶ä»–å·¥å…·æ— æ³•å®ç°çš„å¹¶è¡Œå¾ªç¯ã€‚å¯¹äºé»˜è®¤è¿è¡Œçš„ç›¸å¯¹è¾ƒå°çš„è¾“å…¥ï¼ŒN = 4000çš„è¿­ä»£åµŒå¥—åœ¨å¦ä¸€ä¸ªå…·æœ‰Næ¬¡è¿­ä»£çš„é¡ºåºå¾ªç¯ä¸­ï¼Œæ•´ä½“æ€§èƒ½å‡ºç°ä¸‹é™ã€‚æˆ‘ä»¬å‡è®¾åˆ›å»ºå¹¶è¡Œçº¿ç¨‹å’ŒåŒæ­¥å®ƒä»¬çš„æˆæœ¬è¶…è¿‡äº†é¢å¤–å¹¶è¡Œæ€§å¸¦æ¥çš„æ”¶ç›Šï¼Œå¹¶é€šè¿‡å¢åŠ Næ¥éªŒè¯æˆ‘ä»¬çš„å‡è®¾ã€‚æ ¹æ®å›¾15ä¸­çš„ç»“æœï¼Œå¯ä»¥è§‚å¯Ÿåˆ°ï¼ŒPolygeiståœ¨N â‰¥ 16000æ—¶å¼€å§‹äº§ç”ŸåŠ é€Ÿæ•ˆæœï¼ˆ> 1ï¼‰ï¼Œè€ŒPollyä»…åœ¨N â‰¥ 224000æ—¶æ‰ä¼šå¦‚æ­¤ï¼Œå¹¶ä¸”å¹…åº¦è¦å°å¾—å¤šï¼š6.62Ã—å¯¹æ¯”1.01Ã—ã€‚åœ¨æ²¡æœ‰å½’çº¦å¹¶è¡ŒåŒ–çš„æƒ…å†µä¸‹ï¼ŒPolygeistçš„è¡¨ç°ä¸Pollyç›¸åŒã€‚Plutoæœªèƒ½å¯¹ä»»ä½•æœ€å†…å±‚å¾ªç¯è¿›è¡Œå¹¶è¡ŒåŒ–ï¼Œå¹¶ä¸”æ˜¾ç¤ºæ²¡æœ‰åŠ é€Ÿã€‚è¿™æ”¯æŒäº†æˆ‘ä»¬çš„å‡è®¾ï¼Œå¹¶å¼ºè°ƒäº†èƒ½å¤Ÿå¹¶è¡ŒåŒ–å½’çº¦çš„é‡è¦æ€§ã€‚ # VI. RELATED WORK a) MLIR Frontends: Since the adoption of MLIR under the LLVM umbrella, several frontends have been created for generating MLIR from domain-specific languages. Teckyl [2] connects the productivity-oriented Tensor Comprehensions [1] notation to MLIR's Linalg dialect. Flang-the LLVM's Fortran frontend-models Fortran-specific constructs using the FIR dialect [32]. COMET, a domain-specific compiler for chemistry, introduces an MLIR-targeting domain-specific frontend from a tensor-based language [33]. NPComp aims at providing the necessary infrastructure to compile numerical Python and PyTorch programs taking advantage of the MLIR infrastructure [34]. PET-to-MLIR converts a subset of polyhedral C code to MLIR's Affine dialect by parsing pet's internal represen-tation. In addition to currently not handling specific constructs (ifs, symbolic bounds, and external function calls), parsing pet's representation limits the frontend's usability as it cannot interface with non-polyhedral code such as initialization, verification, or printing routines [35]. In contrast, Polygeist generates MLIR from non-polyhedral code (though not necessarily in the Affine dialect). CIRCT is a new project under the LLVM umbrella that aims to apply MLIR development methodology to the electronic design automation industry [17]. Stripe uses MLIR Affine dialect as a substrate for loop transformations in machine learning models, including tiling and vectorization, and accepts a custom DSL as input [36]. VI. ç›¸å…³å·¥ä½œ a) MLIRå‰ç«¯ï¼šè‡ªä»MLIRè¢«çº³å…¥LLVMæ¡†æ¶åï¼Œå·²ç»åˆ›å»ºäº†å¤šä¸ªå‰ç«¯ç”¨äºä»ç‰¹å®šé¢†åŸŸè¯­è¨€ç”ŸæˆMLIRã€‚Teckyl [2] å°†é¢å‘ç”Ÿäº§åŠ›çš„å¼ é‡ç†è§£ [1] ç¬¦å·è¿æ¥åˆ°MLIRçš„Linalgæ–¹è¨€ã€‚Flangï¼ŒLLVMçš„Fortranå‰ç«¯ï¼Œä½¿ç”¨FIRæ–¹è¨€å»ºæ¨¡Fortranç‰¹å®šçš„æ„é€  [32]ã€‚COMETï¼Œä¸€ä¸ªé’ˆå¯¹åŒ–å­¦é¢†åŸŸçš„ç‰¹å®šé¢†åŸŸç¼–è¯‘å™¨ï¼Œå¼•å…¥äº†ä¸€ä¸ªä»åŸºäºå¼ é‡çš„è¯­è¨€åˆ°MLIRçš„ç‰¹å®šé¢†åŸŸå‰ç«¯ [33]ã€‚NPCompæ—¨åœ¨æä¾›å¿…è¦çš„åŸºç¡€è®¾æ–½ä»¥ä¾¿ç¼–è¯‘æ•°å€¼Pythonå’ŒPyTorchç¨‹åºï¼Œä»è€Œåˆ©ç”¨MLIRåŸºç¡€è®¾æ–½ [34]ã€‚PET-to-MLIRé€šè¿‡è§£æpetçš„å†…éƒ¨è¡¨ç¤ºï¼Œå°†ä¸€éƒ¨åˆ†å¤šé¢ä½“Cä»£ç è½¬æ¢ä¸ºMLIRçš„Affineæ–¹è¨€ã€‚é™¤äº†å½“å‰ä¸å¤„ç†ç‰¹å®šæ„é€ ï¼ˆå¦‚ifè¯­å¥ã€ç¬¦å·è¾¹ç•Œå’Œå¤–éƒ¨å‡½æ•°è°ƒç”¨ï¼‰å¤–ï¼Œè§£æpetçš„è¡¨ç¤ºé™åˆ¶äº†å‰ç«¯çš„å¯ç”¨æ€§ï¼Œå› ä¸ºå®ƒæ— æ³•ä¸éå¤šé¢ä½“ä»£ç ï¼ˆå¦‚åˆå§‹åŒ–ã€éªŒè¯æˆ–æ‰“å°ä¾‹ç¨‹ï¼‰æ¥å£ [35]ã€‚ç›¸å¯¹è€Œè¨€ï¼ŒPolygeistèƒ½å¤Ÿä»éå¤šé¢ä½“ä»£ç ç”ŸæˆMLIRï¼ˆå°½ç®¡ä¸ä¸€å®šåœ¨Affineæ–¹è¨€ä¸­ï¼‰ã€‚CIRCTæ˜¯ä¸€ä¸ªæ–°çš„é¡¹ç›®ï¼Œæ—¨åœ¨å°†MLIRå¼€å‘æ–¹æ³•åº”ç”¨äºç”µå­è®¾è®¡è‡ªåŠ¨åŒ–è¡Œä¸šï¼Œéš¶å±äºLLVMæ¡†æ¶ [17]ã€‚Stripeä½¿ç”¨MLIRçš„Affineæ–¹è¨€ä½œä¸ºæœºå™¨å­¦ä¹ æ¨¡å‹ä¸­çš„å¾ªç¯å˜æ¢çš„åŸºç¡€ï¼ŒåŒ…æ‹¬æ‹†åˆ†å’Œå‘é‡åŒ–ï¼Œå¹¶æ¥å—è‡ªå®šä¹‰DSLä½œä¸ºè¾“å…¥ [36]ã€‚ # b) Compilers Leveraging Multiple Representations: The SUIF compiler infrastructure pioneered a combined internal representation that supports higher-level transformations, including loop optimization and parallelization [37] and, in particular, reduction parallelization [38]. Polygeist leverages MLIR abstractions unavailable in SUIF: regular and affine for loops, OpenMP reduction constructs, etc. It also benefits from the SSA+regions form, which is only available as external extension in SUIF [39], for IR simplification. PIPS supports loop transformations and inter-procedural optimization when targeting OpenMP [40], [41]. Polygeist differs from both by emitting machine code rather than source code, which allows it to emit parallel runtime and other directives that have no representation in the source language such as C. c) Combining \"Classical\" and Polyhedral Flows: Few papers have focused on combining \"classical\", mostly ASTlevel, and polyhedral transformations. PolyAST pioneered the approach by combining an affine scheduler with ASTlevel heuristics for fusion and tiling [42], although similar results were demonstrated with only polyhedral transformations [43]. An analogous approach was experimented in CUDA-CHiLL [44]. Arguably, many automated polyhedral flows perform loop fusion and/or tiling as a separate step that can be assimilated to classical transformations. Pluto [11] uses several \"syntactic\" postprocessing passes to exploit spatial locality and parallelism in stencils [45]. Several tools have been proposed to drive polyhedral loop transformations with scripts using classical loop transformations such as fusion and permutation as operations, including URUK [46], CHiLL [47] and Clay [48]. Polygeist differs from all of these because it preserves the results of such transformations in its IR along with polyhedral constructs and enables interaction between different levels of abstraction. d) Additional (Post-)Polyhedral Transformations: Support for handling reduction loops was proposed in Polly [25], but the code generation is not implemented. At the syntactic level, reduction support was added to PET via manual annotation with PENCIL directives [24]. R-Stream reportedly uses a variant of statement splitting to affect scheduler's behavior and optimize memory consumption [49]. POLYSIMD uses variable renaming around PPCG polyhedral flow to improve vectorization [50]. Polygeist automates these leveraging both SSA and polyhedral information. b) åˆ©ç”¨å¤šç§è¡¨ç¤ºçš„ç¼–è¯‘å™¨ï¼šSUIFç¼–è¯‘å™¨åŸºç¡€è®¾æ–½å¼€åˆ›äº†ä¸€ç§ç»„åˆå†…éƒ¨è¡¨ç¤ºï¼Œæ”¯æŒæ›´é«˜çº§çš„è½¬æ¢ï¼ŒåŒ…æ‹¬å¾ªç¯ä¼˜åŒ–å’Œå¹¶è¡ŒåŒ– [37]ï¼Œå°¤å…¶æ˜¯å½’çº¦å¹¶è¡ŒåŒ– [38]ã€‚Polygeiståˆ©ç”¨SUIFä¸­ä¸å¯ç”¨çš„MLIRæŠ½è±¡ï¼šå¸¸è§„å’Œä»¿å°„å¾ªç¯ï¼ŒOpenMPå½’çº¦æ„é€ ç­‰ã€‚å®ƒè¿˜å—ç›Šäºä»…ä½œä¸ºå¤–éƒ¨æ‰©å±•å­˜åœ¨äºSUIFä¸­çš„SSA+åŒºåŸŸå½¢å¼ [39]ï¼Œå¯ä»¥ç”¨äºä¸­é—´è¡¨ç¤ºçš„ç®€åŒ–ã€‚PIPSåœ¨é’ˆå¯¹OpenMPæ—¶æ”¯æŒå¾ªç¯è½¬æ¢å’Œè¿‡ç¨‹é—´ä¼˜åŒ– [40]ï¼Œ[41]ã€‚Polygeistä¸è¿™ä¸¤è€…çš„ä¸åŒä¹‹å¤„åœ¨äºå®ƒå‘å‡ºæœºå™¨ä»£ç è€Œä¸æ˜¯æºä»£ç ï¼Œä»è€Œèƒ½å¤Ÿå‘å‡ºå¹¶è¡Œè¿è¡Œæ—¶å’Œå…¶ä»–åœ¨æºè¯­è¨€ï¼ˆå¦‚Cï¼‰ä¸­æ²¡æœ‰è¡¨ç¤ºçš„æŒ‡ä»¤ã€‚ c) ç»“åˆâ€œç»å…¸â€å’Œå¤šé¢ä½“æµç¨‹ï¼šå°‘æ•°è®ºæ–‡å…³æ³¨äºå°†â€œç»å…¸â€çš„ã€å¤§å¤šæ•°æ˜¯ASTçº§åˆ«çš„è½¬åŒ–ä¸å¤šé¢ä½“è½¬åŒ–ç»“åˆèµ·æ¥ã€‚PolyASTé€šè¿‡ç»“åˆä»¿å°„è°ƒåº¦å™¨ä¸ASTçº§åˆ«çš„å¯å‘å¼æ–¹æ³•è¿›è¡Œèåˆå’Œåˆ‡ç‰‡ [42]ï¼Œå¼€åˆ›äº†è¿™ç§æ–¹æ³•ï¼Œå°½ç®¡ä»…ä½¿ç”¨å¤šé¢ä½“è½¬åŒ–ä¹Ÿå±•ç¤ºäº†ç±»ä¼¼çš„ç»“æœ [43]ã€‚CUDA-CHiLL [44] ä¹Ÿå®éªŒäº†ä¸€ç§ç±»ä¼¼çš„æ–¹æ³•ã€‚å¯ä»¥è¯´ï¼Œè®¸å¤šè‡ªåŠ¨åŒ–çš„å¤šé¢ä½“æµç¨‹å°†å¾ªç¯èåˆå’Œ/æˆ–åˆ‡ç‰‡ä½œä¸ºä¸€ä¸ªç‹¬ç«‹æ­¥éª¤æ¥æ‰§è¡Œï¼Œè¿™å¯ä»¥è¢«è®¤ä¸ºæ˜¯ä¸€ç§ç»å…¸è½¬åŒ–ã€‚Pluto [11] ä½¿ç”¨å‡ ä¸ªâ€œè¯­æ³•â€åå¤„ç†è¿‡ç¨‹æ¥åˆ©ç”¨æ¨¡æ¿ä¸­çš„ç©ºé—´å±€éƒ¨æ€§å’Œå¹¶è¡Œæ€§ [45]ã€‚å·²æå‡ºå¤šä¸ªå·¥å…·ï¼Œä»¥ç»å…¸å¾ªç¯è½¬åŒ–å¦‚èåˆå’Œæ’åˆ—ä½œä¸ºæ“ä½œï¼Œé©±åŠ¨å¤šé¢ä½“å¾ªç¯è½¬åŒ–ï¼ŒåŒ…æ‹¬URUK [46]ã€CHiLL [47] å’ŒClay [48]ã€‚Polygeistä¸è¿™äº›å·¥å…·çš„ä¸åŒä¹‹å¤„åœ¨äºå®ƒåœ¨å…¶IRä¸­ä¿ç•™äº†æ­¤ç±»è½¬åŒ–çš„ç»“æœï¼Œå¹¶ä¸”ä¸å¤šé¢ä½“æ„é€ ä¸€èµ·ï¼Œå…è®¸ä¸åŒæŠ½è±¡å±‚æ¬¡ä¹‹é—´çš„äº¤äº’ã€‚ d) é¢å¤–çš„ï¼ˆåï¼‰å¤šé¢ä½“è½¬åŒ–ï¼šPolly [25] æå‡ºäº†å¤„ç†å½’çº¦å¾ªç¯çš„æ”¯æŒï¼Œä½†å¹¶æœªå®ç°ä»£ç ç”Ÿæˆã€‚åœ¨è¯­æ³•å±‚é¢ï¼Œé€šè¿‡æ‰‹åŠ¨æ³¨é‡Šä½¿ç”¨PENCILæŒ‡ä»¤å‘PETæ·»åŠ äº†å½’çº¦æ”¯æŒ [24]ã€‚æ®æŠ¥é“ï¼ŒR-Streamä½¿ç”¨äº†ä¸€ç§å˜ä½“çš„è¯­å¥æ‹†åˆ†ä»¥å½±å“è°ƒåº¦å™¨çš„è¡Œä¸ºå¹¶ä¼˜åŒ–å†…å­˜æ¶ˆè€— [49]ã€‚POLYSIMDåœ¨PPCGå¤šé¢ä½“æµç¨‹å‘¨å›´ä½¿ç”¨å˜é‡é‡å‘½åä»¥æ”¹å–„å‘é‡åŒ– [50]ã€‚Polygeiståˆ©ç”¨SSAå’Œå¤šé¢ä½“ä¿¡æ¯è‡ªåŠ¨åŒ–è¿™äº›æ“ä½œã€‚ # e) Integration of Polyhedral Optimizers into Compilers: Polyhedral optimization passes are available in production (GCC [8], LLVM [7], IBM XL [51]) and research (R-Stream [49], ROSE [52]) compilers. In most cases, the polyhedral abstraction must be extracted from a lower-level representation before being transformed and lowered in a dedicated code generation step [13], [14]. This extraction process is not guaranteed and may fail to recover high-level information available at the source level [9]. Furthermore, common compiler optimizations such as LICM are known to interfere with it [10]. Polygeist maintains a sufficient amount of high-level information, in particular loop and n-D array structure, to circumvent these problems by design. Source-to-source polyhedral compilers such as Pluto [11] and PPCG [5] operate on a C or C++ level. They lack interaction with other compiler optimizations and a global vision of the code, which prevents, e.g., constant propagation and inlining that could improve the results of polyhedral optimization. Being positioned between the AST and LLVM IR levels, Polygeist enables the interaction between higherand lower-level abstractions that is otherwise reduced to compiler pragmas, i.e. mere optimization hints. Furthermore, Polygeist can rely on MLIR's progressive raising [53] to target abstractions higher level than C code with less effort than polyhedral frameworks [54]. e) èšåˆä¼˜åŒ–å™¨ä¸ç¼–è¯‘å™¨çš„é›†æˆ: èšåˆä¼˜åŒ–ä¼ é€’åœ¨ç”Ÿäº§ï¼ˆGCC [8]ï¼ŒLLVM [7]ï¼ŒIBM XL [51]ï¼‰å’Œç ”ç©¶ï¼ˆR-Stream [49]ï¼ŒROSE [52]ï¼‰ç¼–è¯‘å™¨ä¸­å¯ç”¨ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå¿…é¡»ä»ä½çº§è¡¨ç¤ºä¸­æå–èšåˆæŠ½è±¡ï¼Œç„¶ååœ¨ä¸“é—¨çš„ä»£ç ç”Ÿæˆæ­¥éª¤ä¸­è¿›è¡Œè½¬æ¢å’Œé™çº§ [13]ï¼Œ[14]ã€‚è¿™ä¸ªæå–è¿‡ç¨‹å¹¶ä¸æ˜¯ä¿è¯æˆåŠŸçš„ï¼Œå¯èƒ½æ— æ³•æ¢å¤æºçº§åˆ«ä¸Šå¯ç”¨çš„é«˜çº§ä¿¡æ¯ [9]ã€‚æ­¤å¤–ï¼Œå¸¸è§çš„ç¼–è¯‘å™¨ä¼˜åŒ–ï¼Œä¾‹å¦‚LICMï¼Œå·²çŸ¥ä¼šå¯¹æ­¤äº§ç”Ÿå¹²æ‰° [10]ã€‚Polygeist é€šè¿‡è®¾è®¡ç»´æŠ¤è¶³å¤Ÿçš„é«˜çº§ä¿¡æ¯ï¼Œå°¤å…¶æ˜¯å¾ªç¯å’Œå¤šç»´æ•°ç»„ç»“æ„ï¼Œä»¥è§„é¿è¿™äº›é—®é¢˜ã€‚ æºåˆ°æºçš„èšåˆç¼–è¯‘å™¨ï¼Œå¦‚Pluto [11] å’ŒPPCG [5]ï¼Œåœ¨Cæˆ–C++çº§åˆ«ä¸Šè¿è¡Œã€‚å®ƒä»¬ç¼ºä¹ä¸å…¶ä»–ç¼–è¯‘å™¨ä¼˜åŒ–çš„äº¤äº’ï¼Œä»¥åŠå¯¹ä»£ç çš„å…¨å±€è§†è§’ï¼Œè¿™é˜»ç¢äº†ä¾‹å¦‚å¸¸é‡ä¼ æ’­å’Œå†…è”ç­‰å¯èƒ½æ”¹å–„èšåˆä¼˜åŒ–ç»“æœçš„è¿‡ç¨‹ã€‚Polygeistä½äºASTå’ŒLLVM IRçº§åˆ«ä¹‹é—´ï¼Œä½¿å¾—æ›´é«˜çº§åˆ«å’Œä½çº§åˆ«æŠ½è±¡ä¹‹é—´çš„äº¤äº’æˆä¸ºå¯èƒ½ï¼Œè€Œè¿™ç§äº¤äº’åœ¨å…¶ä»–æƒ…å†µä¸‹ä»…é™äºç¼–è¯‘å™¨æŒ‡ç¤ºï¼Œå³ä»…ä»…æ˜¯ä¼˜åŒ–æç¤ºã€‚æ­¤å¤–ï¼ŒPolygeistå¯ä»¥ä¾é MLIRçš„é€æ­¥æå‡ [53]ï¼Œä»¥æ¯”èšåˆæ¡†æ¶ [54] æ›´å°‘çš„åŠªåŠ›ï¼Œé’ˆå¯¹æ›´é«˜äºCä»£ç çš„æŠ½è±¡ã€‚ # VII. DISCUSSION A. Limitations a) Frontend: While Polygeist could technically accept any valid C or C++ thanks to building off Clang, it has the following limitations. Only structs with values of the same type or are used within specific functions (such as FILE within fprintf) are supported due to the lack of a struct-type in high-level MLIR dialects. All functions that allocate memory must be compiled with Polygeist and not a C++ compiler to ensure that a memref is emitted rather than a pointer. b) Optimizer: The limitations of the optimizer are inherited from those of the tools involved. In particular, the MLIR affine value categorization results in all-or-nothing modeling, degrading any loop to non-affine if it contains even one nonaffine access or a negative step. Running Polygeist's backend on code not generated by Polygeist's frontend, which reverses loops with negative steps, is limited to loops with positive indices. Finally, MLIR does not yet provide extensive support for non-convex sets (typically expressed as unions). Work is ongoing within MLIR to address such issues. c) Experiments: While our experiments clearly demonstrate the benefits of the techniques implemented in Polygeist-statement splitting and late (reduction) parallelization -non-negligible effects are due to scheduler difference: Pluto in Polygeist and isl in Polly. The version of Polly using Pluto 5 is not compatible with modern LLVM necessary to leverage MLIR. Connecting isl scheduler to Polygeist may have yielded results closer to Polly, but still not comparable more directly because of the interplay between SCoP detection, statement formation and affine scheduling. VII. è®¨è®º A. é™åˆ¶a) å‰ç«¯ï¼šå°½ç®¡PolygeistæŠ€æœ¯ä¸Šå¯ä»¥æ¥å—ä»»ä½•æœ‰æ•ˆçš„Cæˆ–C++ä»£ç ï¼Œå› ä¸ºå®ƒæ˜¯åŸºäºClangæ„å»ºçš„ï¼Œä½†ä»ç„¶å­˜åœ¨ä»¥ä¸‹é™åˆ¶ã€‚ç”±äºé«˜å±‚æ¬¡MLIRæ–¹è¨€ä¸­ç¼ºä¹ç»“æ„ç±»å‹ï¼Œä»…æ”¯æŒå€¼ç±»å‹ç›¸åŒçš„ç»“æ„ä½“ï¼Œæˆ–åœ¨ç‰¹å®šå‡½æ•°å†…ï¼ˆå¦‚fprintfä¸­çš„FILEï¼‰ä½¿ç”¨çš„ç»“æ„ä½“ã€‚æ‰€æœ‰åˆ†é…å†…å­˜çš„å‡½æ•°å¿…é¡»ä½¿ç”¨Polygeistç¼–è¯‘ï¼Œè€Œä¸æ˜¯ä½¿ç”¨C++ç¼–è¯‘å™¨ï¼Œè¿™æ ·æ‰èƒ½ç¡®ä¿ç”Ÿæˆçš„æ˜¯memrefè€ŒéæŒ‡é’ˆã€‚b) ä¼˜åŒ–å™¨ï¼šä¼˜åŒ–å™¨çš„é™åˆ¶æºè‡ªäºæ‰€æ¶‰åŠå·¥å…·çš„é™åˆ¶ã€‚ç‰¹åˆ«æ˜¯ï¼ŒMLIRçš„ä»¿å°„å€¼åˆ†ç±»å¯¼è‡´äº†å…¨æœ‰æˆ–å…¨æ— çš„å»ºæ¨¡ï¼Œå¦‚æœä»»ä½•å¾ªç¯ä¸­åŒ…å«ä¸€ä¸ªéä»¿å°„è®¿é—®æˆ–è´Ÿæ­¥é•¿ï¼Œå°±ä¼šå°†è¯¥å¾ªç¯é™çº§ä¸ºéä»¿å°„ã€‚å¯¹ä¸æ˜¯ç”±Polygeistå‰ç«¯ç”Ÿæˆçš„ä»£ç ä½¿ç”¨Polygeistçš„åç«¯è¿è¡Œæ—¶ï¼Œå°†é™åˆ¶åœ¨å…·æœ‰æ­£ç´¢å¼•çš„å¾ªç¯ä¸Šã€‚æœ€åï¼ŒMLIRç›®å‰å°šæœªæä¾›å¯¹éå‡¸é›†åˆçš„å¹¿æ³›æ”¯æŒï¼ˆé€šå¸¸ä»¥å¹¶é›†çš„å½¢å¼è¡¨ç¤ºï¼‰ã€‚MLIRå†…éƒ¨æ­£åœ¨è¿›è¡Œç›¸å…³å·¥ä½œä»¥è§£å†³æ­¤ç±»é—®é¢˜ã€‚c) å®éªŒï¼šå°½ç®¡æˆ‘ä»¬çš„å®éªŒæ¸…æ¥šåœ°å±•ç¤ºäº†åœ¨Polygeistä¸­å®ç°çš„æŠ€æœ¯çš„å¥½å¤„â€”â€”è¯­å¥æ‹†åˆ†å’ŒåæœŸï¼ˆå½’çº¦ï¼‰å¹¶è¡ŒåŒ–â€”â€”ä½†ä»æœ‰ä¸å®¹å¿½è§†çš„æ•ˆæœæ˜¯ç”±äºè°ƒåº¦å™¨çš„å·®å¼‚ï¼šPolygeistä¸­çš„Plutoå’ŒPollyä¸­çš„islã€‚ä½¿ç”¨Pluto 5çš„Pollyç‰ˆæœ¬ä¸ç°ä»£LLVMä¸å…¼å®¹ï¼Œè€Œåè€…åˆæ˜¯åˆ©ç”¨MLIRæ‰€å¿…éœ€çš„ã€‚å°†islè°ƒåº¦å™¨è¿æ¥åˆ°Polygeistå¯èƒ½ä¼šä½¿ç»“æœæ›´æ¥è¿‘Pollyï¼Œä½†ä»ç„¶æ— æ³•æ›´ç›´æ¥åœ°è¿›è¡Œæ¯”è¾ƒï¼Œå› ä¸ºSCoPæ£€æµ‹ã€è¯­å¥å½¢æˆå’Œä»¿å°„è°ƒåº¦ä¹‹é—´çš„ç›¸äº’ä½œç”¨ã€‚ # B. Opportunities and Future Work Connecting MLIR to existing polyhedral flows opens numerous avenues for compiler optimization research, connecting polyhedral and conventional SSA-based compiler transformations. This gives polyhedral schedulers access to important analyses such as aliasing and useful information such as precise data layout and target machine description. Arguably, this information is already leveraged by Polly, but the representational mismatch between LLVM IR and affine loops makes it difficult to exploit them efficiently. MLIR exposes similar information at a sufficiently high level to make it usable in affine transformations. By mixing abstractions in a single module, MLIR provides finer-grain control over the entire transformation process. An extension of Polygeist can, e.g., ensure loop vectorization by directly emitting vector instructions instead of relying on pragmas, which are often merely a recommendation for the compiler. The flow can also control lower-level mechanisms like prefetching or emit specialized hardware instructions. Conversely, polyhedral analyses can guarantee downstream passes that, e.g., address computation never produces out-ofbounds accesses and other information. Future work is necessary on controlling statement granularity made possible by Polygeist. Beyond affecting affine schedules, this technique enables easy rematerialization and local transposition buffers, crucial on GPUs [55], as well as software pipelining; all without having to produce C source which is known to be complex [56]. On the other hand, this may have an effect on the compilation time as the number of statements is an important factor in the complexity bound of the dependence analysis and scheduling algorithms. å°†MLIRä¸ç°æœ‰çš„å¤šé¢ä½“æµç¨‹è¿æ¥èµ·æ¥ï¼Œä¸ºç¼–è¯‘å™¨ä¼˜åŒ–ç ”ç©¶å¼€è¾Ÿäº†è®¸å¤šæ–°é€”å¾„ï¼Œè¿æ¥äº†å¤šé¢ä½“å’Œä¼ ç»Ÿçš„åŸºäºSSAçš„ç¼–è¯‘å™¨è½¬æ¢ã€‚è¿™ä½¿å¾—å¤šé¢ä½“è°ƒåº¦å™¨å¯ä»¥è®¿é—®ä¸€äº›é‡è¦çš„åˆ†æä¿¡æ¯ï¼Œå¦‚åˆ«ååˆ†æä»¥åŠç²¾ç¡®çš„æ•°æ®å¸ƒå±€å’Œç›®æ ‡æœºå™¨æè¿°ç­‰æœ‰ç”¨ä¿¡æ¯ã€‚å¯ä»¥è¯´ï¼Œè¿™äº›ä¿¡æ¯å·²ç»è¢«Pollyåˆ©ç”¨ï¼Œä½†LLVM IRå’Œä»¿å°„å¾ªç¯ä¹‹é—´çš„è¡¨ç¤ºä¸åŒ¹é…ä½¿å¾—é«˜æ•ˆåˆ©ç”¨è¿™äº›ä¿¡æ¯å˜å¾—å›°éš¾ã€‚MLIRä»¥è¶³å¤Ÿé«˜çš„æŠ½è±¡å±‚çº§æš´éœ²äº†ç±»ä¼¼çš„ä¿¡æ¯ï¼Œä½¿å…¶å¯ç”¨äºä»¿å°„å˜æ¢ã€‚ é€šè¿‡åœ¨å•ä¸ªæ¨¡å—ä¸­æ··åˆä¸åŒçš„æŠ½è±¡ï¼ŒMLIRå¯¹æ•´ä¸ªè½¬æ¢è¿‡ç¨‹æä¾›äº†æ›´ç»†ç²’åº¦çš„æ§åˆ¶ã€‚Polygeistçš„æ‰©å±•å¯ä»¥ç¡®ä¿é€šè¿‡ç›´æ¥å‘å‡ºå‘é‡æŒ‡ä»¤æ¥å®ç°å¾ªç¯å‘é‡åŒ–ï¼Œè€Œä¸æ˜¯ä¾èµ–äºå¸¸å¸¸åªæ˜¯ç¼–è¯‘å™¨å»ºè®®çš„pragmaæŒ‡ä»¤ã€‚è¯¥æµç¨‹è¿˜å¯ä»¥æ§åˆ¶æ›´ä½å±‚æ¬¡çš„æœºåˆ¶ï¼Œå¦‚é¢„å–æˆ–å‘å‡ºä¸“ç”¨çš„ç¡¬ä»¶æŒ‡ä»¤ã€‚åä¹‹ï¼Œå¤šé¢ä½“åˆ†æå¯ä»¥ç¡®ä¿ä¸‹æ¸¸çš„å¤„ç†è¿‡ç¨‹ï¼Œä¾‹å¦‚ï¼Œåœ°å€è®¡ç®—æ°¸è¿œä¸ä¼šå¯¼è‡´è¶Šç•Œè®¿é—®ï¼Œä»¥åŠå…¶ä»–ä¿¡æ¯ã€‚ åœ¨Polygeistçš„æ”¯æŒä¸‹ï¼Œæ§åˆ¶è¯­å¥ç²’åº¦çš„æœªæ¥å·¥ä½œæ˜¯å¿…è¦çš„ã€‚é™¤äº†å½±å“ä»¿å°„è°ƒåº¦å¤–ï¼Œè¯¥æŠ€æœ¯è¿˜ä½¿å¾—è½»æ¾çš„é‡æ–°ç‰©åŒ–å’Œå±€éƒ¨è½¬ç½®ç¼“å†²æˆä¸ºå¯èƒ½ï¼Œè¿™åœ¨GPUä¸Šæ˜¯è‡³å…³é‡è¦çš„[55]ï¼Œä»¥åŠè½¯ä»¶æµæ°´çº¿åŒ–ï¼›æ‰€æœ‰è¿™äº›éƒ½ä¸éœ€è¦ç”Ÿæˆå·²çŸ¥å¤æ‚çš„Cæºä»£ç [56]ã€‚å¦ä¸€æ–¹é¢ï¼Œè¯­å¥æ•°é‡å¯èƒ½ä¼šå¯¹ç¼–è¯‘æ—¶é—´äº§ç”Ÿå½±å“ï¼Œå› ä¸ºè¯­å¥æ•°é‡æ˜¯ä¾èµ–åˆ†æå’Œè°ƒåº¦ç®—æ³•å¤æ‚æ€§è¾¹ç•Œçš„é‡è¦å› ç´ ã€‚ # C. Alternatives Instead of allowing polyhedral tools to parse and generate MLIR, one could emit C (or C++) code from MLIR 6 and use C-based polyhedral tools on the C source, but this approach decreases the expressiveness of the flow. Some MLIR constructs, such as parallel reduction loops, can be directly expressed in the polyhedral model, whereas they would require a non-trivial and non-guaranteed raising step in C. Some other constructs, such as prevectorized affine memory operations, cannot be expressed in C at all. Polygeist enables transparent handling of such constructs in MLIR-to-MLIR flows, but we leave the details of such handling for future work. The Polygeist flow can be similarly connected to other polyhedral formats, in particular isl. We choose OpenScop for this work because it is supported by a wider variety of tools. isl uses schedule trees [57] to represent the initial and transformed program schedule. Schedule trees are sufficiently close to the nested-operation IR model making the conversion straightforward: \"for\" loops correspond to band nodes (one loop per band dimension), \"if\" conditionals correspond to filter nodes, function-level constants can be included into the context node. The tree structure remains the same as that of MLIR regions. The inverse conversion can be obtained using isl's AST generation facility [14]. æ›¿ä»£æ–¹æ¡ˆ ä¸å…¶è®©å¤šé¢ä½“å·¥å…·è§£æå¹¶ç”ŸæˆMLIRï¼Œä¸å¦‚ç›´æ¥ä»MLIRå‘å‡ºCï¼ˆæˆ–C++ï¼‰ä»£ç ï¼Œå¹¶åœ¨Cæºä»£ç ä¸Šä½¿ç”¨åŸºäºCçš„å¤šé¢ä½“å·¥å…·ï¼Œä½†è¿™ç§æ–¹æ³•é™ä½äº†ç¼–è¯‘æµç¨‹çš„è¡¨è¾¾èƒ½åŠ›ã€‚ä¸€äº›MLIRæ„é€ ï¼Œä¾‹å¦‚å¹¶è¡Œå½’çº¦å¾ªç¯ï¼Œå¯ä»¥ç›´æ¥åœ¨å¤šé¢ä½“æ¨¡å‹ä¸­è¡¨è¾¾ï¼Œè€Œåœ¨Cä¸­å´éœ€è¦ä¸€ä¸ªå¤æ‚ä¸”ä¸ä¿è¯å¯è¡Œçš„æå‡æ­¥éª¤ã€‚å¦ä¸€äº›æ„é€ ï¼Œä¾‹å¦‚é¢„å‘é‡åŒ–çš„ä»¿å°„å†…å­˜æ“ä½œï¼Œåˆ™æ ¹æœ¬æ— æ³•åœ¨Cä¸­è¡¨è¾¾ã€‚Polygeistæ”¯æŒåœ¨MLIRåˆ°MLIRçš„æµç¨‹ä¸­é€æ˜åœ°å¤„ç†è¿™äº›æ„é€ ï¼Œä½†æˆ‘ä»¬å°†æ­¤ç±»å¤„ç†çš„ç»†èŠ‚ç•™å¾…æœªæ¥ç ”ç©¶ã€‚ Polygeistæµç¨‹ä¹Ÿå¯ä»¥ä¸å…¶ä»–å¤šé¢ä½“æ ¼å¼ç›¸è¿æ¥ï¼Œç‰¹åˆ«æ˜¯ä¸islç›¸è¿ã€‚æˆ‘ä»¬é€‰æ‹©OpenScopä½œä¸ºæœ¬ç ”ç©¶çš„å¯¹è±¡ï¼Œå› ä¸ºå®ƒå¾—åˆ°æ›´å¤šå·¥å…·çš„æ”¯æŒã€‚islä½¿ç”¨è°ƒåº¦æ ‘æ¥è¡¨ç¤ºåˆå§‹å’Œè½¬åŒ–åçš„ç¨‹åºè°ƒåº¦ã€‚è°ƒåº¦æ ‘ä¸åµŒå¥—æ“ä½œçš„IRæ¨¡å‹éå¸¸æ¥è¿‘ï¼Œä½¿å¾—è½¬æ¢å˜å¾—ç®€å•ï¼šforå¾ªç¯å¯¹åº”äºå¸¦èŠ‚ç‚¹ï¼ˆæ¯ä¸ªå¸¦ç»´åº¦ä¸€ä¸ªå¾ªç¯ï¼‰ï¼Œifæ¡ä»¶å¯¹åº”äºè¿‡æ»¤èŠ‚ç‚¹ï¼Œå‡½æ•°çº§å¸¸é‡å¯ä»¥åŒ…å«åœ¨ä¸Šä¸‹æ–‡èŠ‚ç‚¹ä¸­ã€‚æ ‘ç»“æ„ä¸MLIRåŒºåŸŸä¿æŒä¸€è‡´ã€‚é€†å‘è½¬æ¢å¯ä»¥é€šè¿‡islçš„ASTç”Ÿæˆå·¥å…·è·å¾—ã€‚ # VIII. CONCLUSION Part-1 We present Polygeist, a compilation workflow for importing existing C or C++ code into MLIR and allows polyhedral tools, such as Pluto, to optimize MLIR programs. This enables MLIR to benefit from decades of research in polyhedral compilation. We demonstrate that the code generated by Polygeist has comparable performance with Clang, enabling unbiased comparisons between transformations built for MLIR and existing polyhedral frameworks. Finally, we demonstrate the optimization opportunities enabled by Polygeist considering two complementary transformations: statement splitting and reduction parallelization. In both cases, Polygeist achieves better performance than state-of-the-art polyhedral compiler and source-to-source optimizer. comments regarding how this may need to be modified to run on a system with hardware or software configuration that is distinct from what we used. As expected, the command description mirrors much of the content of the docker file. While a docker file is certainly more convenient and a good way of getting the compiler set up, similar changes to expectations of how many cores the system has in the evaluation will be required even with Docker. To compile Polygeist, one must first compile several of its dependencies. We ran our experiments on an AWS c5.metal instance based on Ubuntu 20.04. We've tailored our build instructions to such a system. While many of the instructions are general and independent of machine, or OS, some steps may not be (and we describe what locations they may occur below). $ sudo apt update $ sudo apt install apt-utils $ sudo apt install tzdata build-essential \\ libtool autoconf pkg-config flex bison \\ libgmp-dev clang-9 libclang-9-dev texinfo \\ cmake ninja-build git texlive-full numactl # Change default compilers to make Pluto happy $ sudo update-alternatives --install \\ /usr/bin/llvm-config llvm-config \\ /usr/bin/llvm-config-9 100 $ sudo update-alternatives --install \\ /usr/bin/FileCheck FileCheck-9 \\ /usr/bin/FileCheck 100 $ sudo update-alternatives --install \\ /usr/bin/clang clang \\ /usr/bin/clang-9 100 $ sudo update-alternatives --install \\ /usr/bin/clang++ clang++ \\ /usr/bin/clang++-9 100 To begin, let us download a utility repository, which will contain several scripts and other files useful for compilation and benchmarking: $ cd $ git clone \\ https://github.com/wsmoses/Polygeist-Script\\ scripts One can now compile and build Pluto as shown below: æˆ‘ä»¬æå‡ºäº†Polygeistï¼Œä¸€ç§å°†ç°æœ‰Cæˆ–C++ä»£ç å¯¼å…¥MLIRçš„ç¼–è¯‘å·¥ä½œæµç¨‹ï¼Œå¹¶å…è®¸å¤šé¢ä½“å·¥å…·ï¼ˆå¦‚Plutoï¼‰å¯¹MLIRç¨‹åºè¿›è¡Œä¼˜åŒ–ã€‚è¿™ä½¿å¾—MLIRèƒ½å¤Ÿå—ç›Šäºæ•°åå¹´æ¥åœ¨å¤šé¢ä½“ç¼–è¯‘æ–¹é¢çš„ç ”ç©¶ã€‚æˆ‘ä»¬è¯æ˜äº†Polygeistç”Ÿæˆçš„ä»£ç åœ¨æ€§èƒ½ä¸Šä¸Clangç›¸å½“ï¼Œä»è€Œå®ç°äº†é’ˆå¯¹MLIRæ„å»ºçš„å˜æ¢ä¸ç°æœ‰å¤šé¢ä½“æ¡†æ¶ä¹‹é—´çš„å…¬æ­£æ¯”è¾ƒã€‚æœ€åï¼Œæˆ‘ä»¬å±•ç¤ºäº†Polygeistæ‰€å¸¦æ¥çš„ä¼˜åŒ–æœºä¼šï¼Œè€ƒè™‘äº†ä¸¤ç§äº’è¡¥çš„å˜æ¢ï¼šè¯­å¥æ‹†åˆ†å’Œå½’çº¦å¹¶è¡ŒåŒ–ã€‚åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼ŒPolygeistçš„æ€§èƒ½å‡ä¼˜äºæœ€å…ˆè¿›çš„å¤šé¢ä½“ç¼–è¯‘å™¨å’Œæºåˆ°æºä¼˜åŒ–å™¨ã€‚ å…³äºå¦‚ä½•åœ¨ç¡¬ä»¶æˆ–è½¯ä»¶é…ç½®ä¸æˆ‘ä»¬æ‰€ä½¿ç”¨çš„ä¸åŒçš„ç³»ç»Ÿä¸Šè¿è¡Œï¼Œè¿™å¯èƒ½éœ€è¦ä¿®æ”¹çš„è¯„è®ºã€‚å¦‚é¢„æœŸçš„é‚£æ ·ï¼Œå‘½ä»¤æè¿°ä¸dockeræ–‡ä»¶çš„å†…å®¹ç›¸ä¼¼ã€‚è™½ç„¶dockeræ–‡ä»¶æ— ç–‘æ›´æ–¹ä¾¿ï¼Œæ˜¯è®¾ç½®ç¼–è¯‘å™¨çš„å¥½æ–¹æ³•ï¼Œä½†å³ä¾¿ä½¿ç”¨Dockerï¼Œå¯¹äºè¯„ä¼°ç³»ç»Ÿçš„æ ¸å¿ƒæ•°é‡çš„æœŸæœ›ä¹Ÿéœ€è¦ç±»ä¼¼çš„æ›´æ”¹ã€‚ è¦ç¼–è¯‘Polygeistï¼Œé¦–å…ˆéœ€è¦ç¼–è¯‘å…¶è‹¥å¹²ä¾èµ–é¡¹ã€‚æˆ‘ä»¬åœ¨åŸºäºUbuntu 20.04çš„AWS c5.metalå®ä¾‹ä¸Šè¿è¡Œäº†å®éªŒã€‚æˆ‘ä»¬æ ¹æ®è¯¥ç³»ç»Ÿè°ƒæ•´äº†æ„å»ºè¯´æ˜ã€‚è™½ç„¶è®¸å¤šè¯´æ˜æ˜¯é€šç”¨çš„ï¼Œä¸æœºå™¨æˆ–æ“ä½œç³»ç»Ÿæ— å…³ï¼Œä½†æŸäº›æ­¥éª¤å¯èƒ½å¹¶éå¦‚æ­¤ï¼ˆæˆ‘ä»¬å°†åœ¨ä¸‹æ–‡ä¸­æè¿°å®ƒä»¬å¯èƒ½å‡ºç°çš„ä½ç½®ï¼‰ã€‚ $ sudo apt update $ sudo apt install apt-utils $ sudo apt install tzdata build-essential \\ libtool autoconf pkg-config flex bison \\ libgmp-dev clang-9 libclang-9-dev texinfo \\ cmake ninja-build git texlive-full numactl # æ›´æ”¹é»˜è®¤ç¼–è¯‘å™¨ä»¥ä½¿Plutoæ­£å¸¸å·¥ä½œ $ sudo update-alternatives --install \\ /usr/bin/llvm-config llvm-config \\ /usr/bin/llvm-config-9 100 $ sudo update-alternatives --install \\ /usr/bin/FileCheck FileCheck-9 \\ /usr/bin/FileCheck 100 $ sudo update-alternatives --install \\ /usr/bin/clang clang \\ /usr/bin/clang-9 100 $ sudo update-alternatives --install \\ /usr/bin/clang++ clang++ \\ /usr/bin/clang++-9 100 é¦–å…ˆï¼Œè®©æˆ‘ä»¬ä¸‹è½½ä¸€ä¸ªå®ç”¨å·¥å…·åº“ï¼Œå…¶ä¸­å°†åŒ…å«ä¸€äº›ç¼–è¯‘å’ŒåŸºå‡†æµ‹è¯•æ‰€éœ€çš„è„šæœ¬å’Œå…¶ä»–æ–‡ä»¶ï¼š $ cd $ git clone \\ https://github.com/wsmoses/Polygeist-Script\\ scripts ç°åœ¨å¯ä»¥æŒ‰ç…§ä¸‹é¢çš„æ­¥éª¤ç¼–è¯‘å’Œæ„å»ºPlutoï¼š # VIII. CONCLUSION Part-2 $ cd $ git clone \\ https://github.com/bondhugula/pluto $ cd pluto/ $ git checkout e5a039096547e0a3d34686295c $ git submodule init $ git submodule update $ ./autogen.sh $ ./configure $ make -jnprocÇ¸ ext one can build LLVM, MLIR, and the frontend by performing the following: From here, we need to modify omp.h by copying the version from the scripts repository and replacing the version we just built. 8$ cd $ export OMP_FILE=find \\ $HOME/mlir-clang/build -iname omp.h$ cp $HOME/scripts/omp.h $OMP_FILE Let us now build the MLIR polyhedral analyses, along with the specific version of LLVM it requires. We shall begin by downloading the requisite code and building its dependencies. $ cd $ git clone --recursive \\ https://github.com/kumasento/polymer -b pact $ cd polymer/ $ cd llvm/ $ mkdir build $ cd build/ $ cmake ../llvm \\ -DLLVM_ENABLE_PROJECTS=\"llvm;clang;mlir\" \\ -DLLVM_TARGETS_TO_BUILD=\"host\" \\ -DLLVM_ENABLE_ASSERTIONS=ON \\ -DCMAKE_BUILD_TYPE=Release \\ -DLLVM_INSTALL_UTILS=ON \\ -G Ninja $ ninja -jnproc$ ninja check-mlir We can now build the MLIR polyhedral analyses and export the corresponding build artifacts. $ cd ~/polymer $ mkdir build $ cd build $ export BUILD=$PWD/../llvm/build $ cmake .. \\ -DCMAKE_BUILD_TYPE=DEBUG \\ -DMLIR_DIR=$BUILD/lib/cmake/mlir \\ -DLLVM_DIR=$BUILD/lib/cmake/llvm \\ -DLLVM_ENABLE_ASSERTIONS=ON \\ -DLLVM_EXTERNAL_LIT=$BUILD/bin/llvm-lit \\ -G Ninja $ ninja -jnproc$ export LD_LIBRARY_PATH= \\ pwd/pluto/lib:$LD_LIBRARY_PATH $ ninja check-polymer Finally, we are ready to begin benchmarking. We begin by running a script that disables turbo boost & hyperthreading and remaining nonessential services on the machine. The script is specific to both the number of cores on the AWS instance (all cores except the non hyperthreaded cores on the first socket were disabled), as well as the image used (all nonessential services still present on the image were disabled) and thus may require modification if intending to be used on a different machine. $ cd ~/scripts/ $ sudo bash ./hyper.sh $ cd $ git clone \\ https://github.com/bondhugula/pluto $ cd pluto/ $ git checkout e5a039096547e0a3d34686295c $ git submodule init $ git submodule update $ ./autogen.sh $ ./configure $ make -jnproc æ¥ä¸‹æ¥ï¼Œå¯ä»¥é€šè¿‡æ‰§è¡Œä»¥ä¸‹æ“ä½œæ¥æ„å»ºLLVMã€MLIRå’Œå‰ç«¯ï¼š ä»è¿™é‡Œå¼€å§‹ï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡å¤åˆ¶è„šæœ¬åº“ä¸­çš„ç‰ˆæœ¬å¹¶æ›¿æ¢æˆ‘ä»¬åˆšåˆšæ„å»ºçš„ç‰ˆæœ¬æ¥ä¿®æ”¹omp.hã€‚ $ cd $ export OMP_FILE=find \\ $HOME/mlir-clang/build -iname omp.h $ cp $HOME/scripts/omp.h $OMP_FILE ç°åœ¨è®©æˆ‘ä»¬æ„å»ºMLIRå¤šé¢ä½“åˆ†æï¼Œä»¥åŠå®ƒæ‰€éœ€çš„ç‰¹å®šç‰ˆæœ¬çš„LLVMã€‚æˆ‘ä»¬å°†å¼€å§‹ä¸‹è½½æ‰€éœ€çš„ä»£ç å¹¶æ„å»ºå…¶ä¾èµ–é¡¹ã€‚ $ cd $ git clone --recursive \\ https://github.com/kumasento/polymer -b pact $ cd polymer/ $ cd llvm/ $ mkdir build $ cd build/ $ cmake ../llvm \\ -DLLVM_ENABLE_PROJECTS=\"llvm;clang;mlir\" \\ -DLLVM_TARGETS_TO_BUILD=\"host\" \\ -DLLVM_ENABLE_ASSERTIONS=ON \\ -DCMAKE_BUILD_TYPE=Release \\ -DLLVM_INSTALL_UTILS=ON \\ -G Ninja $ ninja -jnproc $ ninja check-mlir ç°åœ¨æˆ‘ä»¬å¯ä»¥æ„å»ºMLIRå¤šé¢ä½“åˆ†æå¹¶å¯¼å‡ºç›¸åº”çš„æ„å»ºäº§ç‰©ã€‚ $ cd ~/polymer $ mkdir build $ cd build $ export BUILD=$PWD/../llvm/build $ cmake .. \\ -DCMAKE_BUILD_TYPE=DEBUG \\ -DMLIR_DIR=$BUILD/lib/cmake/mlir \\ -DLLVM_DIR=$BUILD/lib/cmake/llvm \\ -DLLVM_ENABLE_ASSERTIONS=ON \\ -DLLVM_EXTERNAL_LIT=$BUILD/bin/llvm-lit \\ -G Ninja $ ninja -jnproc $ export LD_LIBRARY_PATH= \\ pwd/pluto/lib:$LD_LIBRARY_PATH $ ninja check-polymer æœ€åï¼Œæˆ‘ä»¬å‡†å¤‡å¼€å§‹åŸºå‡†æµ‹è¯•ã€‚æˆ‘ä»¬é¦–å…ˆè¿è¡Œä¸€ä¸ªè„šæœ¬ï¼Œç¦ç”¨æ¶¡è½®æå‡å’Œè¶…çº¿ç¨‹ï¼Œå¹¶å…³é—­æœºå™¨ä¸Šä»ç„¶ä¸å¿…è¦çš„æœåŠ¡ã€‚è¯¥è„šæœ¬ç‰¹å®šäºAWSå®ä¾‹ä¸Šçš„æ ¸å¿ƒæ•°é‡ï¼ˆæ‰€æœ‰æ ¸å¿ƒä¸­é™¤ç¬¬ä¸€ä¸ªæ’æ§½ä¸Šçš„éè¶…çº¿ç¨‹æ ¸å¿ƒå¤–å‡è¢«ç¦ç”¨ï¼‰ï¼Œä»¥åŠä½¿ç”¨çš„é•œåƒï¼ˆé•œåƒä¸Šä»å­˜åœ¨çš„æ‰€æœ‰ä¸å¿…è¦æœåŠ¡è¢«ç¦ç”¨ï¼‰ï¼Œå› æ­¤å¦‚æœæ‰“ç®—åœ¨å…¶ä»–æœºå™¨ä¸Šä½¿ç”¨ï¼Œå¯èƒ½éœ€è¦è¿›è¡Œä¿®æ”¹ã€‚ $ cd ~/scripts/ $ sudo bash ./hyper.sh # VIII. CONCLUSION Part-3 We can now run the benchmarking script. The script itself has assumptions about cores and layout (setting taskset -c 1-8 numactl -i all for example). If using a different machine, these settings may need to be tweaked as appropriate. cd ~/scripts/ $ cd polybench-c-4.2.1-beta/ $ ./run.sh # Output comes through stdout The output of this script will contain the runtime of each trial, describing what compilation setting was used, as well as which benchmark was run. æˆ‘ä»¬ç°åœ¨å¯ä»¥è¿è¡ŒåŸºå‡†æµ‹è¯•è„šæœ¬ã€‚è¯¥è„šæœ¬æœ¬èº«å¯¹æ ¸å¿ƒå’Œå¸ƒå±€æœ‰ä¸€äº›å‡è®¾ï¼ˆä¾‹å¦‚ï¼Œè®¾ç½® taskset -c 1-8 numactl -i allï¼‰ã€‚å¦‚æœä½¿ç”¨ä¸åŒçš„æœºå™¨ï¼Œå¯èƒ½éœ€è¦æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´è¿™äº›è®¾ç½®ã€‚ cd ~/scripts/ $ cd polybench-c-4.2.1-beta/ $ ./run.sh # è¾“å‡ºé€šè¿‡æ ‡å‡†è¾“å‡ºç”Ÿæˆ è¯¥è„šæœ¬çš„è¾“å‡ºå°†åŒ…å«æ¯æ¬¡è¯•éªŒçš„è¿è¡Œæ—¶é—´ï¼Œæè¿°æ‰€ä½¿ç”¨çš„ç¼–è¯‘è®¾ç½®ä»¥åŠè¿è¡Œäº†å“ªä¸ªåŸºå‡†æµ‹è¯•ã€‚ # The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the United States Air Force or the U.S. Government. The U.S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation herein. æœ¬æ–‡ä»¶ä¸­åŒ…å«çš„è§‚ç‚¹å’Œç»“è®ºæ˜¯ä½œè€…çš„è§‚ç‚¹ï¼Œä¸åº”è¢«è§£è¯»ä¸ºä»£è¡¨ç¾å›½ç©ºå†›æˆ–ç¾å›½æ”¿åºœçš„å®˜æ–¹æ”¿ç­–ï¼Œæ— è®ºæ˜¯æ˜ç¤ºè¿˜æ˜¯æš—ç¤ºã€‚ç¾å›½æ”¿åºœè¢«æˆæƒä¸ºäº†æ”¿åºœç›®çš„å¤å°å’Œåˆ†å‘è¯¥æ–‡ä»¶çš„å°åˆ·æœ¬ï¼Œå°½ç®¡è¿™é‡Œæœ‰ä»»ä½•ç‰ˆæƒè¯´æ˜ã€‚ # APPENDIX In this artifact appendix, we describe how to build Polygeist and evaluate its performance (as well as baseline compilers) on the Polybench benchmark suite. We provide two mechanisms for artifact evaluation: a Docker container 7 , and a commandby-command description of the installation process, along with åœ¨æœ¬é™„å½•ä¸­ï¼Œæˆ‘ä»¬æè¿°äº†å¦‚ä½•æ„å»ºPolygeistå¹¶è¯„ä¼°å…¶åœ¨PolybenchåŸºå‡†æµ‹è¯•å¥—ä»¶ä¸Šçš„æ€§èƒ½ï¼ˆä»¥åŠåŸºå‡†ç¼–è¯‘å™¨ï¼‰ã€‚æˆ‘ä»¬æä¾›äº†ä¸¤ç§è‰ºæœ¯å“è¯„ä¼°æœºåˆ¶ï¼šä¸€ä¸ªDockerå®¹å™¨ä»¥åŠé€æ­¥å‘½ä»¤æè¿°çš„å®‰è£…è¿‡ç¨‹ï¼Œè¿åŒ "},"Learn/LearnPolygeist/Note.html":{"url":"Learn/LearnPolygeist/Note.html","title":"Note","keywords":"","body":"Polygeist: Raising C to Polyhedral MLIR Published in: 2021 30th International Conference on Parallel Architectures and Compilation Techniques (PACT) å‘è¡¨äºï¼š2021 å¹´ç¬¬ 30 å±Šå›½é™…å¹¶è¡Œæ¶æ„ä¸ç¼–è¯‘æŠ€æœ¯ä¼šè®®ï¼ˆPACTï¼‰ Abstract: æ‘˜è¦ï¼š We present Polygeist, a new compilation flow that connects the MLIR compiler infrastructure to cutting edge polyhedral optimization tools. It consists of a C and C++ frontend capable of converting a broad range of existing codes into MLIR suitable for polyhedral transformation and a bi-directional conversion between MLIR and OpenScop exchange format. The Polygeist/MLIR intermediate representation featuring high-level (affine) loop constructs and n-D arrays embedded into a single static assignment (SSA) substrate enables an unprecedented combination of SSA-based and polyhedral optimizations. We illustrate this by proposing and implementing two extra transformations: statement splitting and reduction parallelization. Our evaluation demonstrates that Polygeist outperforms on average both an LLVM IR-level optimizer (Polly) and a source-to-source state-of-the-art polyhedral compiler (Pluto) when exercised on the Polybench/C benchmark suite in sequential (2.53x vs 1.41x, 2.34x) and parallel mode (9.47x vs 3.26x, 7.54x) thanks to the new representation and transformations. æˆ‘ä»¬ä»‹ç» Polygeistï¼Œè¿™æ˜¯ä¸€ç§æ–°çš„ç¼–è¯‘æµç¨‹ï¼Œå®ƒå°† MLIR ç¼–è¯‘å™¨åŸºç¡€è®¾æ–½ä¸å‰æ²¿çš„å¤šé¢ä½“ä¼˜åŒ–å·¥å…·è¿æ¥èµ·æ¥ã€‚å®ƒåŒ…æ‹¬ä¸€ä¸ª C å’Œ C++å‰ç«¯ï¼Œèƒ½å¤Ÿå°†å¹¿æ³›ç°æœ‰çš„ä»£ç è½¬æ¢ä¸ºé€‚ç”¨äºå¤šé¢ä½“å˜æ¢çš„ MLIRï¼Œå¹¶å®ç° MLIR ä¸ OpenScop äº¤æ¢æ ¼å¼çš„åŒå‘è½¬æ¢ã€‚å…·æœ‰é«˜çº§ï¼ˆä»¿å°„ï¼‰å¾ªç¯æ„é€ å’ŒåµŒå…¥åˆ°å•ä¸ªé™æ€èµ‹å€¼ï¼ˆSSAï¼‰åŸºåº•çš„ Polygeist/MLIR ä¸­é—´è¡¨ç¤ºï¼Œå®ç°äº†åŸºäº SSA å’Œå¤šé¢ä½“ä¼˜åŒ–çš„å‰æ‰€æœªæœ‰çš„ç»„åˆã€‚æˆ‘ä»¬é€šè¿‡æå‡ºå¹¶å®ç°ä¸¤ä¸ªé¢å¤–çš„è½¬æ¢æ¥å±•ç¤ºè¿™ä¸€ç‚¹ï¼šè¯­å¥æ‹†åˆ†å’Œå‡å°‘å¹¶è¡ŒåŒ–ã€‚æˆ‘ä»¬çš„è¯„ä¼°è¡¨æ˜ï¼Œåœ¨ Polybench/C åŸºå‡†æµ‹è¯•å¥—ä»¶ä¸Šï¼ŒPolygeist åœ¨é¡ºåºï¼ˆ2.53 å€ vs 1.41 å€ï¼Œ2.34 å€ï¼‰å’Œå¹¶è¡Œæ¨¡å¼ï¼ˆ9.47 å€ vs 3.26 å€ï¼Œ7.54 å€ï¼‰ä¸Šå¹³å‡ä¼˜äº LLVM IR çº§åˆ«çš„ä¼˜åŒ–å™¨ï¼ˆPollyï¼‰å’Œæºåˆ°æºçš„å‰æ²¿å¤šé¢ä½“ç¼–è¯‘å™¨ï¼ˆPlutoï¼‰ï¼Œè¿™å¾—ç›Šäºæ–°çš„è¡¨ç¤ºå’Œè½¬æ¢ã€‚ William S. Moses Polygeist: Affine C in MLIR [MLIR Open Design Meeting 02/11/2021] https://www.youtube.com/@billymoses7764 getting_started/Use_Polygeist Retargeting and Respecializing GPU Workloads for Performance Portability é‡æ–°å®šä½å’Œé’ˆå¯¹æ€§èƒ½å¯ç§»æ¤æ€§é‡æ–°ä¸“ä¸šåŒ–çš„ GPU å·¥ä½œè´Ÿè½½ In order to come close to peak performance, accelerators like GPUs require significant architecture-specific tuning that understand the availability of shared memory, parallelism, tensor cores, etc. Unfortunately, the pursuit of higher performance and lower costs have led to a significant diversification of architecture designs, even from the same vendor. This creates the need for performance portability across different GPUs, especially important for programs in a particular programming model with a certain architecture in mind. Even when the program can be seamlessly executed on a different architecture, it may suffer a performance penalty due to it not being sized appropriately to the available hardware resources such as fast memory and registers, let alone not using newer advanced features of the architecture. We propose a new approach to improving performance of (legacy) CUDA programs for modern machines by automatically adjusting the amount of work each parallel thread does, and the amount of memory and register resources it requires. By operating within the MLIR compiler infrastructure, we are able to also target AMD GPUs by performing automatic translation from CUDA and simultaneously adjust the program granularity to fit the size of target GPUs. Combined with autotuning assisted by the platform-specific compiler, our approach demonstrates 27% geomean speedup on the Rodinia benchmark suite over baseline CUDA implementation as well as performance parity between similar NVIDIA and AMD GPUs executing the same CUDA program. ä¸ºäº†æ¥è¿‘å³°å€¼æ€§èƒ½ï¼Œåƒ GPU è¿™æ ·çš„åŠ é€Ÿå™¨éœ€è¦é’ˆå¯¹ç‰¹å®šæ¶æ„è¿›è¡Œæ˜¾è‘—çš„è°ƒæ•´ï¼Œè¿™äº›è°ƒæ•´ç†è§£å…±äº«å†…å­˜ã€å¹¶è¡Œæ€§ã€å¼ é‡æ ¸å¿ƒç­‰çš„å¯ç”¨æ€§ã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿½æ±‚æ›´é«˜çš„æ€§èƒ½å’Œæ›´ä½çš„æˆæœ¬å¯¼è‡´äº†æ¶æ„è®¾è®¡çš„æ˜¾è‘—å¤šæ ·åŒ–ï¼Œå³ä½¿æ˜¯æ¥è‡ªåŒä¸€ä¾›åº”å•†çš„äº§å“ä¹Ÿæ˜¯å¦‚æ­¤ã€‚è¿™äº§ç”Ÿäº†åœ¨ä¸åŒ GPU ä¹‹é—´å®ç°æ€§èƒ½å¯ç§»æ¤æ€§çš„éœ€æ±‚ï¼Œè¿™å¯¹äºç‰¹å®šç¼–ç¨‹æ¨¡å‹å’Œç‰¹å®šæ¶æ„çš„ç¨‹åºå°¤ä¸ºé‡è¦ã€‚å³ä½¿ç¨‹åºå¯ä»¥åœ¨ä¸åŒçš„æ¶æ„ä¸Šæ— ç¼æ‰§è¡Œï¼Œå®ƒä¹Ÿå¯èƒ½å› ä¸ºæœªé€‚å½“è°ƒæ•´ä»¥é€‚åº”å¯ç”¨çš„ç¡¬ä»¶èµ„æºï¼ˆå¦‚å¿«é€Ÿå†…å­˜å’Œå¯„å­˜å™¨ï¼‰è€Œé­å—æ€§èƒ½æŸå¤±ï¼Œæ›´ä¸ç”¨è¯´æ²¡æœ‰ä½¿ç”¨æ¶æ„çš„æ–°å…ˆè¿›ç‰¹æ€§ã€‚æˆ‘ä»¬æå‡ºäº†ä¸€ç§æ–°æ–¹æ³•ï¼Œé€šè¿‡è‡ªåŠ¨è°ƒæ•´æ¯ä¸ªå¹¶è¡Œçº¿ç¨‹æ‰§è¡Œçš„å·¥ä½œé‡ä»¥åŠå®ƒæ‰€éœ€çš„å†…å­˜å’Œå¯„å­˜å™¨èµ„æºï¼Œæ¥æé«˜ï¼ˆé—ç•™ï¼‰CUDA ç¨‹åºåœ¨ç°ä»£æœºå™¨ä¸Šçš„æ€§èƒ½ã€‚ é€šè¿‡åœ¨ MLIR ç¼–è¯‘å™¨åŸºç¡€è®¾æ–½ä¸­æ“ä½œï¼Œæˆ‘ä»¬èƒ½å¤Ÿé€šè¿‡è‡ªåŠ¨ä» CUDA è¿›è¡Œç¿»è¯‘æ¥é’ˆå¯¹ AMD GPU è¿›è¡Œç›®æ ‡å®šä½ï¼ŒåŒæ—¶è°ƒæ•´ç¨‹åºç²’åº¦ä»¥é€‚åº”ç›®æ ‡ GPU çš„å¤§å°ã€‚ç»“åˆå¹³å°ç‰¹å®šç¼–è¯‘å™¨è¾…åŠ©çš„è‡ªåŠ¨è°ƒæ•´ï¼Œæˆ‘ä»¬çš„æ–¹æ³•åœ¨ Rodinia åŸºå‡†æµ‹è¯•å¥—ä»¶ä¸Šç›¸å¯¹äºåŸºçº¿ CUDA å®ç°å®ç°äº† 27%çš„å‡ ä½•å¹³å‡é€Ÿåº¦æå‡ï¼Œä»¥åŠæ‰§è¡Œç›¸åŒ CUDA ç¨‹åºæ—¶ç±»ä¼¼ NVIDIA å’Œ AMD GPU ä¹‹é—´çš„æ€§èƒ½å¯¹ç­‰ã€‚ Frontend Performance Differences 8% performance boost on Floyd-Warshall occurs if Polygeist generates a single MLIR module for both benchmarking and timing code by default MLIR doesn't properly generate LLVM datalayout, preventing vectorization for MLIR-generated code (patched in our lowering) Different choice of allocation function can make a 30% impact on some tests (adi) LLVM strength-reduction is fragile and sometimes misses reversed loop induction variable (remaining gap in adi) å¦‚æœ Polygeist é»˜è®¤ä¸ºåŸºå‡†æµ‹è¯•å’Œè®¡æ—¶ä»£ç ç”Ÿæˆå•ä¸ª MLIR æ¨¡å—ï¼Œåˆ™ Floyd-Warshall çš„æ€§èƒ½å°†æå‡ 8% MLIR æ— æ³•æ­£ç¡®ç”Ÿæˆ LLVM æ•°æ®å¸ƒå±€ï¼Œä»è€Œé˜»æ­¢äº† MLIR ç”Ÿæˆçš„ä»£ç çš„çŸ¢é‡åŒ–ï¼ˆåœ¨æˆ‘ä»¬çš„é™ä½ç‰ˆæœ¬ä¸­è¿›è¡Œäº†ä¿®è¡¥ï¼‰ ä¸åŒçš„åˆ†é…å‡½æ•°é€‰æ‹©å¯èƒ½ä¼šå¯¹æŸäº›æµ‹è¯• ï¼ˆadiï¼‰ äº§ç”Ÿ 30% çš„å½±å“ LLVM å¼ºåº¦é™ä½å¾ˆè„†å¼±ï¼Œæœ‰æ—¶ä¼šé”™è¿‡åå‘ç¯æ„Ÿåº”å˜é‡ï¼ˆADI ä¸­çš„å‰©ä½™é—´éš™ï¼‰ Poligeist MLIR Compiler Frontend Polygeist çš„æ ¸å¿ƒåŠŸèƒ½ Polygeist çš„ä¸»è¦ç›®æ ‡æ˜¯ bridging the gap between C/C++ and MLIRã€‚å®ƒå…·æœ‰ä»¥ä¸‹æ ¸å¿ƒåŠŸèƒ½: C/C++å‰ç«¯:èƒ½å¤Ÿè§£æå’Œåˆ†æå¹¿æ³›çš„ C å’Œ C++ä»£ç ã€‚ MLIR ç”Ÿæˆ:å°† C/C++ä»£ç è½¬æ¢ä¸ºé€‚åˆå¤šé¢ä½“å˜æ¢çš„ MLIR è¡¨ç¤ºã€‚ å¤šé¢ä½“ä¼˜åŒ–:åˆ©ç”¨ MLIR çš„å¤šé¢ä½“ä¼˜åŒ–èƒ½åŠ›è¿›è¡Œé«˜çº§å¾ªç¯ä¼˜åŒ–ã€‚ å¹¶è¡Œä¼˜åŒ–:æ”¯æŒè‡ªåŠ¨å¹¶è¡ŒåŒ–å’Œå¹¶è¡Œæ„é€ çš„ä¼˜åŒ–ã€‚ GPU åç«¯æ”¯æŒ:åŒ…æ‹¬ CUDA å’Œ ROCm åç«¯,å®ç° GPU åŠ é€Ÿã€‚ è¿™äº›åŠŸèƒ½ä½¿ Polygeist æˆä¸ºè¿æ¥ä¼ ç»Ÿ C/C++ä»£ç å’Œç°ä»£ MLIR ç¼–è¯‘æ¶æ„çš„å…³é”®å·¥å…·ã€‚ Polygeist çš„å·¥ä½œåŸç† Polygeist çš„å·¥ä½œæµç¨‹å¯ä»¥ç®€è¦æ¦‚æ‹¬ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤: è§£æ C/C++ä»£ç :ä½¿ç”¨ Clang çš„å‰ç«¯èƒ½åŠ›è§£æè¾“å…¥çš„ C/C++ä»£ç ã€‚ AST åˆ†æ:å¯¹æŠ½è±¡è¯­æ³•æ ‘(AST)è¿›è¡Œæ·±å…¥åˆ†æ,æå–ç¨‹åºçš„ç»“æ„å’Œè¯­ä¹‰ä¿¡æ¯ã€‚ MLIR ç”Ÿæˆ:åŸºäº AST åˆ†æç»“æœ,ç”Ÿæˆå¯¹åº”çš„ MLIR è¡¨ç¤ºã€‚ å¤šé¢ä½“å»ºæ¨¡:å°† MLIR è¡¨ç¤ºè½¬æ¢ä¸ºå¤šé¢ä½“æ¨¡å‹,ä¸ºåç»­ä¼˜åŒ–é“ºå¹³é“è·¯ã€‚ ä¼˜åŒ–åº”ç”¨:åº”ç”¨å¤šé¢ä½“ä¼˜åŒ–ã€å¹¶è¡Œä¼˜åŒ–ç­‰é«˜çº§ä¼˜åŒ–æŠ€æœ¯ã€‚ ä»£ç ç”Ÿæˆ:å°†ä¼˜åŒ–åçš„ MLIR è½¬æ¢å› LLVM IR æˆ–ç›´æ¥ç”Ÿæˆç›®æ ‡ä»£ç ã€‚ é€šè¿‡è¿™ä¸€ç³»åˆ—æ­¥éª¤,Polygeist èƒ½å¤Ÿå……åˆ†åˆ©ç”¨ MLIR çš„å¼ºå¤§åŠŸèƒ½,åŒæ—¶ä¿æŒå¯¹åŸå§‹ C/C++ä»£ç çš„å…¼å®¹æ€§ã€‚ Polygeist çš„ä¼˜åŠ¿ä¸åº”ç”¨ Polygeist ä¸º C/C++ç¨‹åºå¸¦æ¥äº†è¯¸å¤šä¼˜åŠ¿: é«˜çº§ä¼˜åŒ–:é€šè¿‡å¤šé¢ä½“æ¨¡å‹,å¯ä»¥è¿›è¡Œæ›´å¤æ‚å’Œæœ‰æ•ˆçš„å¾ªç¯ä¼˜åŒ–ã€‚ å¹¶è¡ŒåŒ–:è‡ªåŠ¨æ£€æµ‹å’Œåˆ©ç”¨å¹¶è¡Œæœºä¼š,æé«˜ç¨‹åºæ€§èƒ½ã€‚ å¯ç§»æ¤æ€§:é€šè¿‡ MLIR è¡¨ç¤º,å¯ä»¥æ›´å®¹æ˜“åœ°å°†ç¨‹åºç§»æ¤åˆ°ä¸åŒçš„ç¡¬ä»¶å¹³å°ã€‚ GPU åŠ é€Ÿ:å†…ç½®çš„ CUDA å’Œ ROCm åç«¯æ”¯æŒ,ç®€åŒ– GPU ç¼–ç¨‹ã€‚ ä¸ LLVM ç”Ÿæ€ç³»ç»Ÿé›†æˆ:ä½œä¸º LLVM é¡¹ç›®çš„ä¸€éƒ¨åˆ†,å¯ä»¥æ— ç¼é›†æˆåˆ°ç°æœ‰çš„ LLVM å·¥å…·é“¾ä¸­ã€‚ è¿™äº›ä¼˜åŠ¿ä½¿ Polygeist åœ¨é«˜æ€§èƒ½è®¡ç®—ã€ç§‘å­¦è®¡ç®—ã€æœºå™¨å­¦ä¹ ç­‰é¢†åŸŸå…·æœ‰å¹¿æ³›çš„åº”ç”¨å‰æ™¯ã€‚ å®é™…åº”ç”¨æ¡ˆä¾‹ ä»¥ä¸‹æ˜¯ Polygeist åœ¨å®é™…é¡¹ç›®ä¸­çš„åº”ç”¨æ¡ˆä¾‹: ç§‘å­¦è®¡ç®—ä¼˜åŒ–:åœ¨ä¸€ä¸ªå¤§è§„æ¨¡æ•°å€¼æ¨¡æ‹Ÿé¡¹ç›®ä¸­,ä½¿ç”¨ Polygeist å¯¹æ ¸å¿ƒè®¡ç®— kernel è¿›è¡Œä¼˜åŒ–,é€šè¿‡å¤šé¢ä½“å˜æ¢å’Œè‡ªåŠ¨å¹¶è¡ŒåŒ–,æ€§èƒ½æå‡äº† 30%ã€‚ æœºå™¨å­¦ä¹ æ¡†æ¶:æŸå¼€æºæœºå™¨å­¦ä¹ æ¡†æ¶ä½¿ç”¨ Polygeist ä¼˜åŒ–å…¶ C++åç«¯,å®ç°äº†æ›´é«˜æ•ˆçš„å¼ é‡è¿ç®—,åœ¨æŸäº›æ¨¡å‹ä¸Šæ¨ç†é€Ÿåº¦æå‡äº† 20%ã€‚ å›¾å½¢æ¸²æŸ“å¼•æ“:ä¸€ä¸ªæ¸¸æˆå¼•æ“é¡¹ç›®åˆ©ç”¨ Polygeist çš„ GPU åç«¯æ”¯æŒ,ç®€åŒ–äº† CUDA ä»£ç çš„ç”Ÿæˆè¿‡ç¨‹,å¤§å¤§æé«˜äº†å¼€å‘æ•ˆç‡ã€‚ è¿™äº›æ¡ˆä¾‹å±•ç¤ºäº† Polygeist åœ¨æå‡ç¨‹åºæ€§èƒ½å’Œç®€åŒ–å¼€å‘æµç¨‹æ–¹é¢çš„å·¨å¤§æ½œåŠ›ã€‚ cgeist input.c -S -emit-mlir | mlir-opt --canonicalize --cse > output.mlir 2022 LLVMHPC William S. Moses, Polygeist: C++ Frontend for MLIR text The MLIR Framework MLIR is a recent compiler infrastructure designed for reuse and extensibility Rather than providing a predefined set of instructions and types, MLIR operates on collections of dialects that contain sets of interoperable user-defined operations, attributes and types Anyone can define their own optimizable dialect/operation, with a large set of existing dialects (structured control flow, affine, GPU, quantum, fully homomorphic encryption, circuits, LLVM, and more!) MLIR æ˜¯ä¸€ç§ä¸ºé‡ç”¨å’Œå¯æ‰©å±•æ€§è€Œè®¾è®¡çš„æœ€æ–°ç¼–è¯‘å™¨åŸºç¡€æ¶æ„ MLIR ä¸æ˜¯æä¾›ä¸€ç»„é¢„å®šä¹‰çš„æŒ‡ä»¤å’Œç±»å‹,è€Œæ˜¯å¯¹åŒ…å«ä¸€ç»„å¯äº’æ“ä½œçš„ç”¨æˆ·å®šä¹‰æ“ä½œã€å±æ€§å’Œç±»å‹çš„æ–¹è¨€é›†åˆè¿›è¡Œæ“ä½œ ä»»ä½•äººéƒ½å¯ä»¥ä½¿ç”¨å¤§é‡ç°æœ‰æ–¹è¨€(ç»“æ„åŒ–æ§åˆ¶æµã€ä»¿å°„ã€GPUã€é‡å­ã€å®Œå…¨åŒæ€åŠ å¯†ã€ç”µè·¯ã€LLVM ç­‰!)å®šä¹‰è‡ªå·±å¯ä¼˜åŒ–çš„æ–¹è¨€/æ“ä½œã€‚ The Polyhedral Model Represent programs as a collection of computations and constraints on a multi-dimensional grid (polyhedron) Makes it easy to analyze and specify program transformations best exploit the available hardware Loop restructuring for spatial/temporal locality, automatic parallelization, etc. One of the best frameworks for optimizing compute-intensive programs like machine learning kernels or scientific simulations as well as for programming accelerators. Preserve the parallel structure Maintain GPU parallelism in a form understandable to the compiler Enables optimization between caller and kernel Enable parallelism-specific optimization å°†ç¨‹åºè¡¨ç¤ºä¸ºå¤šç»´ç½‘æ ¼(å¤šé¢ä½“)ä¸Šçš„è®¡ç®—å’Œçº¦æŸé›†åˆ ä¾¿äºåˆ†æå’ŒæŒ‡å®šæœ€ä½³åˆ©ç”¨å¯ç”¨ç¡¬ä»¶çš„ç¨‹åºè½¬æ¢ ç”¨äºç©ºé—´/æ—¶é—´å±€éƒ¨æ€§ã€è‡ªåŠ¨å¹¶è¡ŒåŒ–ç­‰çš„å¾ªç¯é‡æ„ ä¼˜åŒ–æœºå™¨å­¦ä¹ å†…æ ¸æˆ–ç§‘å­¦æ¨¡æ‹Ÿç­‰è®¡ç®—å¯†é›†å‹ç¨‹åºä»¥åŠç¼–ç¨‹åŠ é€Ÿå™¨çš„æœ€ä½³æ¡†æ¶ä¹‹ä¸€ã€‚ Synchronization via Memory Synchronization (sync_threads) ensures all threads within a block finish executing codeA before executing codeB The desired synchronization behavior can be reproduced by defining sync_threads to have the union of the memory semantics of the code before and after the sync. This prevents code motion of instructions which require the synchronization for correctness, but permits other code motion (e.g. index computation). åŒæ­¥ ï¼ˆsync_threadsï¼‰ ç¡®ä¿å—ä¸­çš„æ‰€æœ‰çº¿ç¨‹åœ¨æ‰§è¡Œ CodeB ä¹‹å‰å®Œæˆå¯¹ CodeA çš„æ‰§è¡Œ å¯ä»¥é€šè¿‡å®šä¹‰ sync_threads æ¥é‡ç°æ‰€éœ€çš„åŒæ­¥è¡Œä¸ºï¼Œä»¥ä¾¿åœ¨åŒæ­¥ä¹‹å‰å’Œä¹‹åå…·æœ‰ä»£ç çš„å†…å­˜è¯­ä¹‰çš„å¹¶é›†ã€‚ è¿™å¯ä»¥é˜²æ­¢éœ€è¦åŒæ­¥ä»¥ç¡®ä¿æ­£ç¡®æ€§çš„æŒ‡ä»¤çš„ä»£ç ç§»åŠ¨ï¼Œä½†å…è®¸å…¶ä»–ä»£ç ç§»åŠ¨ï¼ˆä¾‹å¦‚ç´¢å¼•è®¡ç®—ï¼‰ã€‚ High-level synchronization representation enables new optimizations, like sync elimination. A synchronize instruction is not needed if the set of read/writes before the sync donâ€™t conflict with the read/writes after the sync. é«˜çº§åŒæ­¥è¡¨ç¤ºæ”¯æŒæ–°çš„ä¼˜åŒ–ï¼Œä¾‹å¦‚åŒæ­¥æ¶ˆé™¤ã€‚ å¦‚æœåŒæ­¥å‰çš„è¯»/å†™é›†ä¸åŒæ­¥åçš„è¯»/å†™é›†ä¸å†²çªï¼Œåˆ™ä¸éœ€è¦ synchronize æŒ‡ä»¤ã€‚ __global__ void bpnn_layerforward(...) { __shared__ float node[HEIGHT]; __shared__ float weights[HEIGHT][WIDTH]; if ( tx == 0 ) node[ty] = input[index_in] ; // Unnecessary Barrier #1 // None of the read/writes below the sync // (weights, hidden) // intersect with the read/writes above the sync // (node, input) __syncthreads(); // Unnecessary Store #1 weights[ty][tx] = hidden[index]; __syncthreads(); // Unnecessary Load #1 weights[ty][tx] = weights[ty][tx] * node[ty]; // â€¦ } GPU Transpilation A unified representation of parallelism enables programs in one parallel architecture (e.g. CUDA) to be compiled to another (e.g. CPU/OpenMP) Most CPU backends do not have an equivalent block synchronization Efficiently lower a top-level synchronization by distributing the parallel for loop around the sync, and interchanging control flow parallel_for %i = 0 to N { codeA(%i); sync_threads; codeB(%i); } ; => parallel_for %i = 0 to N { codeA(%i); } parallel_for %i = 0 to N { codeB(%i); } GPU Synchronization Lowering: Control Flow Synchronization within control flow (for, if, while, etc) can be lowered by splitting around the control flop and interchanging the parallelism. parallel_for %i = 0 to N { for %j = â€¦ { codeB1(%i, %j); sync_threads; codeB2(%i, %j); } } ; Interchange => for %j = â€¦ { parallel_for %i = 0 to N { codeB1(%i, %j); sync_threads; codeB2(%i, %j); } } ; Split => for %j = â€¦ { parallel_for %i = 0 to N { codeB1(%i, %j); } parallel_for %i = 0 to N { codeB2(%i, %j); } } GPU Transpilation Performance CUDA programs transcompiled by Polygeist not only match the performance of handwritten OpenMP programs, but achieve a speedup! 58% geomean speedup on Rodinia 2.7x geomean speedup on PyTorch versus built-in CPU backend (also using our MocCUDA compatibility layer) "},"Learn/LearnPolyhedralModel/AffineTransformation.html":{"url":"Learn/LearnPolyhedralModel/AffineTransformation.html","title":"AffineTransformation","keywords":"","body":"Affine transformation text text text In Euclidean geometry, an affine transformation or affinity (from the Latin, affinis, \"connected with\") is a geometric transformation that preserves lines and parallelism, but not necessarily Euclidean distances and angles. åœ¨æ¬§å‡ é‡Œå¾—å‡ ä½•ä¸­ï¼Œä»¿å°„å˜æ¢æˆ–äº²å’ŒåŠ›ï¼ˆæ¥è‡ªæ‹‰ä¸è¯­ affinisï¼Œâ€œè¿æ¥â€ï¼‰æ˜¯ä¸€ç§å‡ ä½•å˜æ¢ï¼Œå®ƒä¿ç•™çº¿æ¡å’Œå¹³è¡Œåº¦ï¼Œä½†ä¸ä¸€å®šæ˜¯æ¬§å‡ é‡Œå¾—è·ç¦»å’Œè§’åº¦ã€‚ More generally, an affine transformation is an automorphism of an affine space (Euclidean spaces are specific affine spaces), that is, a function which maps an affine space onto itself while preserving both the dimension of any affine subspaces (meaning that it sends points to points, lines to lines, planes to planes, and so on) and the ratios of the lengths of parallel line segments. Consequently, sets of parallel affine subspaces remain parallel after an affine transformation. An affine transformation does not necessarily preserve angles between lines or distances between points, though it does preserve ratios of distances between points lying on a straight line. æ›´ä¸€èˆ¬åœ°è¯´ï¼Œä»¿å°„å˜æ¢æ˜¯ä»¿å°„ç©ºé—´çš„è‡ªåŒæ€ï¼ˆæ¬§å‡ é‡Œå¾—ç©ºé—´æ˜¯ç‰¹å®šçš„ä»¿å°„ç©ºé—´ï¼‰ï¼Œå³ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒå°†ä»¿å°„ç©ºé—´æ˜ å°„åˆ°è‡ªèº«ï¼ŒåŒæ—¶ä¿ç•™ä»»ä½•ä»¿å°„å­ç©ºé—´çš„ç»´åº¦ï¼ˆæ„å‘³ç€å®ƒå°†ç‚¹å‘é€åˆ°ç‚¹ã€çº¿åˆ°çº¿ã€å¹³é¢åˆ°å¹³é¢ç­‰ï¼‰å’Œå¹³è¡Œé•¿åº¦çš„æ¯”ç‡çº¿æ®µã€‚å› æ­¤ï¼Œå¹¶è¡Œä»¿å°„å­ç©ºé—´é›†åœ¨ä»¿å°„å˜æ¢åä¿æŒå¹³è¡Œã€‚ä»¿å°„å˜æ¢ä¸ä¸€å®šä¿ç•™çº¿æ¡ä¹‹é—´çš„è§’åº¦æˆ–ç‚¹ä¹‹é—´çš„è·ç¦»ï¼Œå°½ç®¡å®ƒç¡®å®ä¿ç•™äº†ä½äºç›´çº¿ä¸Šçš„ç‚¹ä¹‹é—´çš„è·ç¦»æ¯”ç‡ã€‚ If X is the point set of an affine space, then every affine transformation on X can be represented as the composition of a linear transformation on X and a translation of X. Unlike a purely linear transformation, an affine transformation need not preserve the origin of the affine space. Thus, every linear transformation is affine, but not every affine transformation is linear. å¦‚æœ X æ˜¯ä»¿å°„ç©ºé—´çš„ç‚¹é›†ï¼Œåˆ™ X ä¸Šçš„æ¯ä¸ªä»¿å°„å˜æ¢éƒ½å¯ä»¥è¡¨ç¤ºä¸º X ä¸Šçš„çº¿æ€§å˜æ¢å’Œ X çš„å¹³ç§»çš„ç»„åˆã€‚ä¸çº¯çº¿æ€§å˜æ¢ä¸åŒï¼Œä»¿å°„å˜æ¢ä¸éœ€è¦ä¿ç•™ä»¿å°„ç©ºé—´çš„åŸç‚¹ã€‚å› æ­¤ï¼Œæ¯ä¸ªçº¿æ€§å˜æ¢éƒ½æ˜¯ä»¿å°„å˜æ¢ï¼Œä½†å¹¶éæ¯ä¸ªä»¿å°„å˜æ¢éƒ½æ˜¯çº¿æ€§å˜æ¢ã€‚ Examples of affine transformations include translation, scaling, homothety, similarity, reflection, rotation, hyperbolic rotation, shear mapping, and compositions of them in any combination and sequence. ä»¿å°„å˜æ¢çš„ç¤ºä¾‹åŒ…æ‹¬å¹³ç§»ã€ç¼©æ”¾ã€åŒè´¨æ€§ã€ç›¸ä¼¼æ€§ã€åå°„ã€æ—‹è½¬ã€åŒæ›²æ—‹è½¬ã€å‰ªåˆ‡æ˜ å°„ä»¥åŠå®ƒä»¬ä»¥ä»»æ„ç»„åˆå’Œé¡ºåºçš„ç»„åˆã€‚ Viewing an affine space as the complement of a hyperplane at infinity of a projective space, the affine transformations are the projective transformations of that projective space that leave the hyperplane at infinity invariant, restricted to the complement of that hyperplane. å°†ä»¿å°„ç©ºé—´è§†ä¸ºæŠ•å½±ç©ºé—´æ— ç©·è¿œå¤„çš„è¶…å¹³é¢çš„è¡¥ç ï¼Œä»¿å°„å˜æ¢æ˜¯è¯¥å°„å½±ç©ºé—´çš„æŠ•å½±å˜æ¢ï¼Œå®ƒä½¿æ— ç©·è¿œå¤„çš„è¶…å¹³é¢ä¿æŒä¸å˜ï¼Œä»…é™äºè¯¥è¶…å¹³é¢çš„è¡¥ç ã€‚ A generalization of an affine transformation is an affine map[1] (or affine homomorphism or affine mapping) between two (potentially different) affine spaces over the same field k. Let (X, V, k) and (Z, W, k) be two affine spaces with X and Z the point sets and V and W the respective associated vector spaces over the field k. A map f: X â†’ Z is an affine map if there exists a linear map mf : V â†’ W such that mf (x âˆ’ y) = f (x) âˆ’ f (y) for all x, y in X.[2] ä»¿å°„å˜æ¢çš„æ³›åŒ–æ˜¯åŒä¸€åŸŸk ä¸Šä¸¤ä¸ªï¼ˆå¯èƒ½ä¸åŒçš„ï¼‰ä»¿å°„ç©ºé—´ä¹‹é—´çš„ä»¿å°„æ˜ å°„1ï¼ˆæˆ–ä»¿å°„åŒæ€æˆ–ä»¿å°„æ˜ å°„ï¼‰ã€‚è®¾ ï¼ˆXï¼Œ Vï¼Œ kï¼‰ å’Œ ï¼ˆZï¼Œ Wï¼Œ kï¼‰ æ˜¯ä¸¤ä¸ªä»¿å°„ç©ºé—´ï¼Œå…¶ä¸­ X å’Œ Z æ˜¯ç‚¹é›†ï¼ŒV å’Œ W æ˜¯åœº k ä¸Šå„è‡ªçš„å…³è”å‘é‡ç©ºé—´ã€‚å¦‚æœå­˜åœ¨çº¿æ€§æ˜ å°„mf ï¼š V â†’ Wï¼Œä½¿å¾— xf ï¼ˆx âˆ’ yï¼‰ = f ï¼ˆxï¼‰ âˆ’ f ï¼ˆyï¼‰ å¯¹äº X.2 ä¸­çš„æ‰€æœ‰ xã€y â†’ Z æ˜¯ä»¿å°„æ˜ å°„ "},"Learn/LearnPolyhedralModel/Note.html":{"url":"Learn/LearnPolyhedralModel/Note.html","title":"Note","keywords":"","body":"Polyhedral Model cs6120-Advanced Compilers text text The polyhedral model (also called the polytope method) is a mathematical framework for programs that perform large numbers of operations -- too large to be explicitly enumerated -- thereby requiring a compact representation. Nested loop programs are the typical, but not the only example, and the most common use of the model is for loop nest optimization in program optimization. The polyhedral method treats each loop iteration within nested loops as lattice points inside mathematical objects called polyhedra, performs affine transformations or more general non-affine transformations such as tiling on the polytopes, and then converts the transformed polytopes into equivalent, but optimized (depending on targeted optimization goal), loop nests through polyhedra scanning. å¤šé¢ä½“æ¨¡å‹ï¼ˆä¹Ÿç§°ä¸ºå¤šé¢ä½“æ–¹æ³•ï¼‰æ˜¯ä¸€ä¸ªæ•°å­¦æ¡†æ¶ï¼Œç”¨äºæ‰§è¡Œå¤§é‡è¿ç®—çš„ç¨‹åº -- å¤ªå¤§è€Œæ— æ³•æ˜¾å¼åˆ—ä¸¾ -- å› æ­¤éœ€è¦ç´§å‡‘çš„è¡¨ç¤ºã€‚åµŒå¥—å¾ªç¯ç¨‹åºæ˜¯å…¸å‹çš„ä½†ä¸æ˜¯å”¯ä¸€çš„ä¾‹å­ï¼Œè¯¥æ¨¡å‹æœ€å¸¸è§çš„ç”¨é€”æ˜¯ç¨‹åºä¼˜åŒ–ä¸­çš„å¾ªç¯åµŒå¥—ä¼˜åŒ–ã€‚å¤šé¢ä½“æ–¹æ³•å°†åµŒå¥—å¾ªç¯ä¸­çš„æ¯ä¸ªå¾ªç¯è¿­ä»£è§†ä¸ºç§°ä¸ºå¤šé¢ä½“çš„æ•°å­¦å¯¹è±¡å†…çš„æ ¼å­ç‚¹ï¼Œæ‰§è¡Œä»¿å°„å˜æ¢æˆ–æ›´é€šç”¨çš„éä»¿å°„å˜æ¢ï¼Œä¾‹å¦‚åœ¨å¤šé¢ä½“ä¸Šå¹³é“ºï¼Œç„¶åé€šè¿‡å¤šé¢ä½“æ‰«æå°†è½¬æ¢åçš„å¤šé¢ä½“è½¬æ¢ä¸ºç­‰æ•ˆä½†ä¼˜åŒ–ï¼ˆå–å†³äºç›®æ ‡ä¼˜åŒ–ç›®æ ‡ï¼‰çš„å¾ªç¯åµŒå¥—ã€‚ Polyhedral model in programming Frameworks supporting the polyhedral model å¤šé¢ä½“æ¨¡å‹åŠå…¶åœ¨å¾ªç¯ç¼–è¯‘ä¼˜åŒ–ä¸­çš„åº”ç”¨ å¤šé¢ä½“æ¨¡å‹æ˜¯ä¸€ä¸ªç”¨äºè¡¨ç¤ºå’Œä¼˜åŒ–ç¨‹åºçš„æ•°å­¦æ¡†æ¶ï¼Œå°¤å…¶é€‚ç”¨äºæ¶‰åŠå¾ªç¯çš„ç¨‹åºã€‚å®ƒæ˜¯ç¼–è¯‘å™¨æŠ€æœ¯ä¸­æ‰§è¡Œä¼˜åŒ–çš„å¼ºå¤§å·¥å…·ï¼Œå°¤å…¶åœ¨é«˜æ€§èƒ½è®¡ç®—ä¸­å…·æœ‰é‡è¦ä½œç”¨ã€‚ä¸‹é¢æˆ‘ä»¬å°†è¯¦ç»†è§£æè¯¥æ¦‚å¿µåŠå…¶åœ¨å¾ªç¯ä¼˜åŒ–ä¸­çš„åº”ç”¨ã€‚ å¤šé¢ä½“æ¨¡å‹æ¦‚è¿° å¤šé¢ä½“æ¨¡å‹æ˜¯ä¸€ä¸ªç”¨äºæè¿°å¾ªç¯åŠå…¶è¿­ä»£çš„æ•°å­¦æŠ½è±¡ï¼Œé‡‡ç”¨å¤šç»´å‡ ä½•ä½“ï¼ˆå³å¤šé¢ä½“ï¼‰æ¥è¡¨ç¤ºå¾ªç¯çš„è¿­ä»£ç©ºé—´ã€‚é€šè¿‡å¯¹è¿™äº›å¤šé¢ä½“çš„ä¼˜åŒ–ï¼Œå¯ä»¥æå‡ç¨‹åºçš„æ‰§è¡Œæ•ˆç‡ã€‚ åœ¨å¤šé¢ä½“æ¨¡å‹ä¸­ï¼Œå¾ªç¯é€šè¿‡ä»¥ä¸‹å…³é”®è¦ç´ è¿›è¡Œè¡¨ç¤ºï¼š å¾ªç¯è¾¹ç•Œï¼šå®šä¹‰å¾ªç¯å˜é‡å¯èƒ½å–çš„èŒƒå›´ã€‚ ä¾èµ–å…³ç³»ï¼šæè¿°å¾ªç¯è¿­ä»£ä¹‹é—´çš„å…³ç³»ï¼Œç‰¹åˆ«æ˜¯æ•°æ®ä¾èµ–ï¼ˆå¦‚è¯»åå†™æˆ–å†™åè¯»ï¼‰ï¼Œè¿™äº›å…³ç³»å¿…é¡»åœ¨è½¬æ¢è¿‡ç¨‹ä¸­ä¿æŒä¸€è‡´ã€‚ è¿­ä»£ç©ºé—´ï¼šè¡¨ç¤ºæ‰€æœ‰å¯èƒ½çš„å¾ªç¯è¿­ä»£çš„å¤šç»´ç©ºé—´ï¼Œé€šå¸¸ä»¥å¤šé¢ä½“å½¢å¼å¯è§†åŒ–ï¼Œæ¯ä¸ªç‚¹ä»£è¡¨ä¸€ä¸ªå¾ªç¯çš„è¿­ä»£ã€‚ å¤šé¢ä½“æ¨¡å‹çš„å·¥ä½œåŸç† å¾ªç¯è¡¨ç¤ºï¼šåœ¨å¤šé¢ä½“æ¨¡å‹ä¸­ï¼Œå¾ªç¯é€šè¿‡ä¸€ç»„æ•°å­¦ä¸ç­‰å¼è¡¨ç¤ºï¼Œè¿™äº›ä¸ç­‰å¼å®šä¹‰äº†å¾ªç¯å˜é‡çš„è¾¹ç•Œã€‚ä¾‹å¦‚ï¼ŒåµŒå¥—å¾ªç¯å¯ä»¥ç”¨ä¸€ç»„ä¸ç­‰å¼æ¥æè¿°ï¼Œè¿™äº›ä¸ç­‰å¼æ„æˆä¸€ä¸ªå¤šé¢ä½“ï¼Œå…¶ä¸­æ¯ä¸ªç‚¹å¯¹åº”å¾ªç¯çš„ä¸€ä¸ªè¿­ä»£ã€‚ ä¾èµ–åˆ†æï¼šåœ¨å¾ªç¯ç¨‹åºä¸­ï¼Œä¸åŒè¿­ä»£ä¹‹é—´å¯èƒ½ä¼šå­˜åœ¨æ•°æ®ä¾èµ–ã€‚å¤šé¢ä½“æ¨¡å‹å¯ä»¥å¸®åŠ©æ­£å¼åˆ†æè¿™äº›ä¾èµ–ï¼Œåˆ¤æ–­å“ªäº›è¿­ä»£å¯ä»¥å¹¶è¡Œæ‰§è¡Œï¼Œå“ªäº›éœ€è¦æŒ‰ç…§ç‰¹å®šé¡ºåºæ‰§è¡Œä»¥ä¿è¯ç¨‹åºæ­£ç¡®æ€§ã€‚ è½¬æ¢æ“ä½œï¼šå¤šé¢ä½“æ¨¡å‹å…è®¸å¯¹å¾ªç¯è¿›è¡Œå„ç§è½¬æ¢ï¼Œä¾‹å¦‚ï¼š å¾ªç¯èåˆï¼šå°†ä¸¤ä¸ªå¾ªç¯åˆå¹¶ä¸ºä¸€ä¸ªå¾ªç¯ï¼Œä»¥æé«˜æ•°æ®å±€éƒ¨æ€§ã€‚ å¾ªç¯åˆ†è£‚ï¼šå°†ä¸€ä¸ªå¾ªç¯æ‹†åˆ†ä¸ºä¸¤ä¸ªï¼Œä»¥æé«˜å¹¶è¡Œæ€§æˆ–æ•°æ®å±€éƒ¨æ€§ã€‚ å¾ªç¯å—åŒ–ï¼ˆTilingï¼‰ï¼šå°†å¾ªç¯è¿­ä»£ç©ºé—´åˆ†æˆæ›´å°çš„å—ï¼ˆtileï¼‰ï¼Œä»¥æé«˜ç¼“å­˜ä½¿ç”¨æ•ˆç‡å’Œå±€éƒ¨æ€§ã€‚ å¾ªç¯äº¤æ¢ï¼šæ”¹å˜åµŒå¥—å¾ªç¯çš„æ‰§è¡Œé¡ºåºï¼Œä»¥æ”¹å–„å†…å­˜è®¿é—®æ¨¡å¼æˆ–å¹¶è¡Œæ€§ã€‚ å¤šé¢ä½“æ¨¡å‹åœ¨å¾ªç¯ç¼–è¯‘ä¼˜åŒ–ä¸­çš„åº”ç”¨ å¹¶è¡ŒåŒ–ï¼šå¤šé¢ä½“æ¨¡å‹å¯ä»¥å¸®åŠ©è¯†åˆ«å¹¶è¡Œæ‰§è¡Œçš„æœºä¼šã€‚é€šè¿‡åˆ†æè¿­ä»£ç©ºé—´å’Œæ•°æ®ä¾èµ–å…³ç³»ï¼Œæ¨¡å‹èƒ½å¤Ÿåˆ¤æ–­å“ªäº›å¾ªç¯è¿­ä»£å¯ä»¥å®‰å…¨åœ°å¹¶è¡Œæ‰§è¡Œï¼Œè¿™å¯¹äºå¤šæ ¸å¤„ç†å™¨çš„åˆ©ç”¨è‡³å…³é‡è¦ã€‚ ç¼“å­˜ä¼˜åŒ–ï¼šå¤šé¢ä½“æ¨¡å‹é€šè¿‡è½¬æ¢å¾ªç¯æ¥ä¼˜åŒ–å†…å­˜è®¿é—®æ¨¡å¼ï¼Œæå‡æ•°æ®å±€éƒ¨æ€§ã€‚ä¾‹å¦‚ï¼Œé€šè¿‡åº”ç”¨å¾ªç¯å—åŒ–æˆ–åˆ†å—æŠ€æœ¯ï¼Œæ¨¡å‹ç¡®ä¿å¤šä¸ªå¾ªç¯è¿­ä»£è®¿é—®çš„æ•°æ®å¯ä»¥é€‚é…åˆ°ç¼“å­˜ä¸­ï¼Œä»è€Œå‡å°‘å†…å­˜å»¶è¿Ÿã€‚ çŸ¢é‡åŒ–ï¼šå¤šé¢ä½“æ¨¡å‹å¯ä»¥å¸®åŠ©åˆ¤æ–­å“ªäº›å¾ªç¯éƒ¨åˆ†å¯ä»¥è¿›è¡ŒçŸ¢é‡åŒ–ï¼Œä»è€Œæ›´å¥½åœ°åˆ©ç”¨ç°ä»£å¤„ç†å™¨çš„ SIMDï¼ˆå•æŒ‡ä»¤å¤šæ•°æ®ï¼‰æŒ‡ä»¤é›†ã€‚ ä¹±åºæ‰§è¡Œï¼šé€šè¿‡åˆ†æå¾ªç¯ä¾èµ–å…³ç³»ï¼Œå¤šé¢ä½“æ¨¡å‹å¯ä»¥å¸®åŠ©ç¼–è¯‘å™¨ç¡®å®šå“ªäº›è¿­ä»£å¯ä»¥ä¹±åºæ‰§è¡Œï¼Œä»è€Œæé«˜æŒ‡ä»¤çº§å¹¶è¡Œæ€§ï¼Œå¹¶åœ¨ç°ä»£å¤„ç†å™¨ä¸Šè·å¾—æ›´å¥½çš„æ€§èƒ½ã€‚ è‡ªåŠ¨å¹¶è¡ŒåŒ–ï¼šè¯¥æ¨¡å‹åœ¨è‡ªåŠ¨å¹¶è¡ŒåŒ–ç¼–è¯‘å™¨ä¸­æ‰®æ¼”é‡è¦è§’è‰²ï¼Œé€šè¿‡åˆ†æå¾ªç¯ç»“æ„å’Œä¾èµ–å…³ç³»ï¼Œå®ƒå¯ä»¥å†³å®šå“ªäº›å¾ªç¯æˆ–å¾ªç¯éƒ¨åˆ†å¯ä»¥å®‰å…¨å¹¶è¡ŒåŒ–ã€‚ é’ˆå¯¹ç‰¹å®šæ¶æ„çš„ä¼˜åŒ–ï¼šå¤šé¢ä½“æ¨¡å‹å¯ä»¥ç”Ÿæˆé’ˆå¯¹ç‰¹å®šç¡¬ä»¶çš„ä¼˜åŒ–ä»£ç ï¼Œå¦‚ GPUï¼Œé€šè¿‡åº”ç”¨é€‚åˆè¯¥æ¶æ„å†…å­˜å±‚æ¬¡ç»“æ„å’Œå¤„ç†èƒ½åŠ›çš„è½¬æ¢æ¥æå‡æ€§èƒ½ã€‚ å¤šé¢ä½“æ¨¡å‹çš„ä¼˜ç‚¹ æ•°å­¦ä¸¥è°¨æ€§ï¼šå¤šé¢ä½“æ¨¡å‹æä¾›äº†ä¸€ç§ç²¾ç¡®ä¸”æ­£å¼çš„æ–¹å¼æ¥æè¿°å¾ªç¯ï¼Œä½¿ç¼–è¯‘å™¨å¯ä»¥æ›´å®¹æ˜“åœ°æ¨ç†å¾ªç¯ä¼˜åŒ–ã€‚ è¡¨è¾¾èƒ½åŠ›å¼ºï¼šå®ƒèƒ½å¤Ÿåœ¨ä¸€ä¸ªç»Ÿä¸€çš„æ¡†æ¶ä¸­è¡¨è¾¾å¤šç§å¾ªç¯ä¼˜åŒ–ï¼Œå¦‚å¹¶è¡ŒåŒ–ã€å±€éƒ¨æ€§ä¼˜åŒ–å’ŒçŸ¢é‡åŒ–ã€‚ è‡ªåŠ¨åŒ–ï¼šå®ƒèƒ½å¤Ÿè‡ªåŠ¨ä¼˜åŒ–ä»£ç ï¼Œå‡å°‘æ‰‹åŠ¨è°ƒæ•´çš„éœ€æ±‚ã€‚ å¤šé¢ä½“æ¨¡å‹çš„æŒ‘æˆ˜ å¤æ‚æ€§ï¼šå¤šé¢ä½“æ¨¡å‹æ•°å­¦ä¸Šè¾ƒä¸ºå¤æ‚ï¼Œåœ¨ç¼–è¯‘å™¨ä¸­å®ç°èµ·æ¥å¯èƒ½å…·æœ‰ä¸€å®šéš¾åº¦ï¼Œå°¤å…¶æ˜¯åœ¨å¤„ç†å…·æœ‰å¤æ‚ä¾èµ–å…³ç³»çš„ç¨‹åºæ—¶ã€‚ å¯æ‰©å±•æ€§ï¼šå¯¹äºå¤§è§„æ¨¡åº”ç”¨ç¨‹åºï¼Œç®¡ç†å¤šé¢ä½“è¡¨ç¤ºçš„å¼€é”€å¯èƒ½ä¼šéå¸¸å¤§ï¼Œå°¤å…¶æ˜¯åœ¨å†…å­˜å’Œè®¡ç®—ä¸Šã€‚ ç¤ºä¾‹ è€ƒè™‘ä¸€ä¸ªç®€å•çš„åµŒå¥—å¾ªç¯ï¼š for (i = 0; i åœ¨å¤šé¢ä½“æ¨¡å‹ä¸­ï¼Œiå’Œjçš„è¿­ä»£ç©ºé—´è¢«è¡¨ç¤ºä¸ºä¸€ä¸ªäºŒç»´å¤šé¢ä½“ã€‚ä¾èµ–åˆ†æè¡¨æ˜ï¼Œå†…å¾ªç¯çš„æ¯æ¬¡è¿­ä»£ä¾èµ–äºå‰å‡ æ¬¡è¿­ä»£çš„æ•°æ®ã€‚åŸºäºæ­¤ï¼Œæ¨¡å‹å¯ä»¥åº”ç”¨å¾ªç¯èåˆæˆ–å—åŒ–ç­‰ä¼˜åŒ–æŠ€æœ¯ï¼Œä»è€Œæé«˜ç¼“å­˜ä½¿ç”¨æ•ˆç‡æˆ–å¹¶è¡Œæ€§ã€‚ ç»“è®º å¤šé¢ä½“æ¨¡å‹æ˜¯ä¸€ä¸ªç”¨äºä¼˜åŒ–å¾ªç¯çš„å¤æ‚å·¥å…·ã€‚é€šè¿‡å°†å¾ªç¯è¡¨ç¤ºä¸ºå¤šé¢ä½“å¹¶åˆ†æå…¶ä¾èµ–å…³ç³»ï¼Œæ¨¡å‹èƒ½å¤Ÿå®ç°åŒ…æ‹¬å¹¶è¡ŒåŒ–ã€å¾ªç¯è½¬æ¢ï¼ˆå¦‚å—åŒ–ã€èåˆç­‰ï¼‰å’Œå†…å­˜ä¼˜åŒ–åœ¨å†…çš„å¤šç§ä¼˜åŒ–ã€‚å°½ç®¡å®ƒçš„å®ç°è¾ƒä¸ºå¤æ‚ï¼Œä½†å®ƒå·²æˆä¸ºé«˜æ€§èƒ½ç¼–è¯‘æŠ€æœ¯çš„åŸºç¡€ï¼Œå°¤å…¶åœ¨ç§‘å­¦è®¡ç®—å’Œé«˜æ€§èƒ½åº”ç”¨ä¸­å…·æœ‰é‡è¦æ„ä¹‰ã€‚ The Polyhedral Model is a mathematical framework used to represent and optimize programs, particularly those involving loops. It is a powerful tool for performing optimization in compiler technology, especially in high-performance computing. Let's break down the concept and its application to loop optimization. Polyhedral Model Overview The Polyhedral Model is a mathematical abstraction used to describe loops and their iterations in terms of multi-dimensional shapes, or polyhedra. These polyhedra represent the iteration spaces of loops, and their optimization helps improve the performance of programs. In the polyhedral model, loops are represented using the following key components: Loop Bounds: The range of indices that a loop variable can take. Dependences: The relationships between iterations of loops, specifically data dependencies (such as read-after-write or write-after-read), which must be respected during transformations. Iteration Spaces: The multi-dimensional space that represents all possible iterations of the loops. These are often visualized as polyhedra (multi-dimensional geometric objects) where each point corresponds to an iteration of the loop. How the Polyhedral Model Works Representation of Loops: In the polyhedral model, loops are represented in a high-level mathematical form. For example, a nested loop can be described by a set of inequalities that define the bounds of the loop's variables. This set of inequalities is a polyhedron, where each point corresponds to an iteration of the loop. Dependence Analysis: In loop programs, data can be dependent across different iterations. The polyhedral model enables the formal analysis of such dependencies, helping identify if iterations can be executed in parallel or need to be executed in a specific order to preserve correctness. Transformations: The polyhedral model allows for a variety of transformations on the loops, such as: Loop Fusion: Combining two loops into one to improve data locality. Loop Fission: Splitting a loop into two to enhance parallelism or data locality. Loop Tiling (Blocking): Dividing the loop iteration space into smaller blocks (tiles) to improve cache usage and locality. Loop Interchange: Changing the order of nested loops to improve memory access patterns or parallelism. Applications in Loop Compilation and Optimization Parallelism: The polyhedral model helps identify opportunities for parallel execution. By analyzing the iteration space and data dependencies, it can determine whether iterations can be safely executed in parallel, which is crucial for leveraging multi-core processors. Cache Optimization: The polyhedral model can help optimize memory access patterns by transforming loops to improve data locality. For example, by applying loop blocking or tiling, the model can ensure that data accessed by multiple iterations of the loop fit within the cache, reducing memory latency. Vectorization: The polyhedral model aids in determining which parts of the loop can be vectorized, allowing for better utilization of SIMD (Single Instruction, Multiple Data) instructions on modern processors. Out-of-Order Execution: By analyzing loop dependencies, the polyhedral model helps compilers determine which iterations can be executed out of order, improving instruction-level parallelism and performance on modern processors. Automatic Parallelization: The model plays a crucial role in compilers that automatically parallelize code. By analyzing the loop structure and dependencies, it can decide which loops or parts of loops can be parallelized safely. Optimization for Specific Architectures: The polyhedral model can be used to generate optimized code for specific hardware, such as GPUs, by applying transformations that are well-suited for the architecture's memory hierarchy and processing capabilities. Advantages of the Polyhedral Model Mathematical Rigor: The polyhedral model provides a formal and precise way to describe loops, making it easier for compilers to reason about loop optimizations. Expressive Power: It can express a wide range of loop optimizations, such as parallelism, locality, and vectorization, in a unified framework. Automation: It enables automatic optimization of code, reducing the need for manual tuning. Challenges of the Polyhedral Model Complexity: The polyhedral model is mathematically complex and can be difficult to implement in compilers, especially for very large programs with intricate dependencies. Scalability: For large-scale applications, the overhead of managing polyhedral representations can be significant, especially in terms of memory and computation. Example Consider a simple nested loop: for (i = 0; i The polyhedral model represents the iteration space of i and j as a 2D polyhedron. Dependence analysis would show that each iteration of the inner loop depends on data from the previous iterations. Based on this, the polyhedral model can apply optimizations like loop fusion or tiling to improve cache usage or parallelism. Conclusion The Polyhedral Model is a sophisticated tool used in compilers for optimizing loops. By representing loops as polyhedra and analyzing their dependencies, it allows for a range of optimizations, including parallelization, loop transformations (tiling, fusion, etc.), and memory optimizations. Although it can be complex to implement, it has become a foundational technique for high-performance compilation, especially in scientific computing and high-performance applications. "},"Learn/LearnROCm/ROCm.html":{"url":"Learn/LearnROCm/ROCm.html","title":"ROCm","keywords":"","body":"Optimized GPU Software Stack ä¼˜åŒ–çš„ GPU è½¯ä»¶å †æ ˆ AMD ROCmâ„¢ is an open software stack including drivers, development tools, and APIs that enable GPU programming from low-level kernel to end-user applications. ROCm is optimized for Generative AI and HPC applications, and is easy to migrate existing code into. AMD ROCmâ„¢ æ˜¯ä¸€ä¸ªå¼€æ”¾è½¯ä»¶å †æ ˆï¼ŒåŒ…æ‹¬é©±åŠ¨ç¨‹åºã€å¼€å‘å·¥å…·å’Œ APIï¼Œæ”¯æŒä»ä½çº§å†…æ ¸åˆ°æœ€ç»ˆç”¨æˆ·åº”ç”¨ç¨‹åºçš„ GPU ç¼–ç¨‹ã€‚ ROCm é’ˆå¯¹ç”Ÿæˆå¼ AI å’Œ HPC åº”ç”¨ç¨‹åºè¿›è¡Œäº†ä¼˜åŒ–ï¼Œå¹¶ä¸”æ˜“äºå°†ç°æœ‰ä»£ç è¿ç§»åˆ°å…¶ä¸­ã€‚ ROCm 3 æ˜¯ç”¨äºå›¾å½¢å¤„ç†å•å…ƒ(GPU) ç¼–ç¨‹çš„Advanced Micro Devices (AMD) è½¯ä»¶å †æ ˆã€‚ ROCm è·¨è¶Šå¤šä¸ªé¢†åŸŸï¼šå›¾å½¢å¤„ç†å•å…ƒä¸Šçš„é€šç”¨è®¡ç®—(GPGPU)ã€é«˜æ€§èƒ½è®¡ç®—(HPC)ã€å¼‚æ„è®¡ç®—ã€‚å®ƒæä¾›äº†å¤šç§ç¼–ç¨‹æ¨¡å‹ï¼š HIP ï¼ˆåŸºäº GPU å†…æ ¸çš„ç¼–ç¨‹ï¼‰ã€ OpenMP ï¼ˆåŸºäºæŒ‡ä»¤çš„ç¼–ç¨‹ï¼‰å’ŒOpenCL ã€‚ wiki/ROCm AMD ROCm documentation "},"Learn/LearnROS/ROS-Packages.html":{"url":"Learn/LearnROS/ROS-Packages.html","title":"ROS-Packages","keywords":"","body":"ROS Packages Package Purpose learn_turtlesim You gotta start somewhere. learn_arduino Poking at the real world. learn_rviz Static visualisations of robot models. learn_tf Dynamic visualisations of robot models. learn_joy Interactive visualisations of robot models. learn_imu WIP - Read and display data from an IMU. learn_webcam Stream video from a USB webcam. learn_kinect Stream video and more from an Xbox 360 Kinect. jaws_description The first Jaws modelled as a URDF. jaws_visualization WIP - A visual demonstration of Jaws. "},"Learn/LearnROS/ROS.html":{"url":"Learn/LearnROS/ROS.html","title":"ROS","keywords":"","body":"ROS: Robot Operating System index.ros.org wiki.ros: Tutorials wiki.ros: cn Introduction github: ros-infrastructure github: ROS core stacks github: ros-gbp rep: learn-ros blog: ros-tutorials ROSï¼ˆæœºå™¨äººæ“ä½œç³»ç»Ÿï¼‰æä¾›åº“å’Œå·¥å…·æ¥å¸®åŠ©è½¯ä»¶å¼€å‘äººå‘˜åˆ›å»ºæœºå™¨äººåº”ç”¨ç¨‹åºã€‚å®ƒæä¾›ç¡¬ä»¶æŠ½è±¡ã€è®¾å¤‡é©±åŠ¨ç¨‹åºã€åº“ã€å¯è§†åŒ–å·¥å…·ã€æ¶ˆæ¯ä¼ é€’ã€åŒ…ç®¡ç†ç­‰ã€‚ ROS Releases/Distributions ros: Distributions ros2: Releases ros - os version match ROS: ROS Box Turtle 2010.03.02 ROS C Turtle 2010.08.02 ROS Diamondback 2011.03.01 ROS Electric Emys 2011.08.30 ROS Fuerte Turtle 2012.04.23 ROS Groovy Galapagos 2012.12.31 ROS Hydro Medusa 2013.09.04 ROS Indigo Igloo 2014.07.22 ROS Jade Turtle 2015.05.23 ROS Kinetic Kame 2016.05.23 ROS Lunar Loggerhead 2017.05.23 ROS Melodic Morenia 2018.05.23 ROS Noetic Ninjemys 2020.05.23 ROS2: ROS 2 Ardent Apalone 2017.12.08 ROS 2 Bouncy Bolson 2018.05.31 ROS 2 Crystal Clemmys 2018.12.12 ROS 2 Dashing Diademata 2019.05.31 ROS 2 Eloquent Elusor 2019.12.12 ROS 2 Foxy Fitzroy 2020.06.05 ROS 2 Galactic Geochelone 2021.05.23 ROS 2 Humble Hawksbill 2022.05.23 ROS 2 Iron Irwini 2023.05.23 ROS 2 Jazzy Jalisco 2024.05.23 There is a new ROS 2 distribution released yearly on May 23rd (World Turtle Day). ROS Noetic Ninjemys wiki ROS Noetic Ninjemys is the thirteenth ROS distribution release. It was released on May 23rd, 2020. Concepts REP: ROS Enhancement Proposals REPs are documents that define standards, conventions, and best practices for the ROS ecosystem. They are similar to RFCs (Request for Comments) in the internet protocol community or PEPs (Python Enhancement Proposals) in the Python community. Filesystem Level Packages Metapackages Package Manifests Repositories Message (msg) types: Message Description, stored in my_package/msg/MyMessageType.msg Service (srv) types: Service Description, stored in my_package/srv/MyServiceType.srv Graph Level Nodes: process that performs computation Master: provides name registration and lookup to the rest of the Computation Graph Parameter Server: allows data to be stored by key in a central location Messages: data structure for communication Topics: messages are routed via a transport system with publish/subscribe semantics a node sends a message by publishing it to a given topic a node receives a message by subscribing to the appropriate topic Services: request/reply is done via a service a node offers a service under a specific name a client uses the service by sending the request message and awaiting the reply Bags: a format for saving and playing back ROS message data mechanism for storing ROS message data, such as sensor data Community Level Distributions Repositories ROS Wiki ... names: Package Resource Names and Graph Resource Names Graph Resource Names: provides a hierarchical naming structure that is used for all resources in ROS Computation Graph Graph Resource Names are an important mechanism in ROS for providing encapsulation. Each resource is defined within a namespace, which it may share with many other resources. In general, resources can create resources within their namespace and they can access resources within or above their own namespace. Connections can be made between resources in distinct namespaces, but this is generally done by integration code above both namespaces. This encapsulation isolates different portions of the system from accidentally grabbing the wrong named resource or globally hijacking names. æ¯ä¸ªèµ„æºéƒ½åœ¨ä¸€ä¸ªå‘½åç©ºé—´ä¸­å®šä¹‰ï¼Œè¯¥å‘½åç©ºé—´å¯ä»¥ä¸è®¸å¤šå…¶ä»–èµ„æºå…±äº«ã€‚ é€šå¸¸ï¼Œèµ„æºå¯ä»¥åœ¨å…¶å‘½åç©ºé—´ä¸­åˆ›å»ºèµ„æºï¼Œå¹¶ä¸”å¯ä»¥è®¿é—®å…¶è‡ªå·±çš„å‘½åç©ºé—´å†…æˆ–ä¹‹ä¸Šçš„èµ„æºã€‚ å¯ä»¥åœ¨ä¸åŒå‘½åç©ºé—´ä¸­çš„èµ„æºä¹‹é—´å»ºç«‹è¿æ¥ï¼Œä½†è¿™é€šå¸¸æ˜¯é€šè¿‡ä¸¤ä¸ªå‘½åç©ºé—´ä¸Šæ–¹çš„é›†æˆä»£ç å®Œæˆçš„ã€‚ è¿™ç§å°è£…å°†ç³»ç»Ÿçš„ä¸åŒéƒ¨åˆ†ä¸æ„å¤–è·å–é”™è¯¯çš„å‘½åèµ„æºæˆ–å…¨å±€åŠ«æŒåç§°éš”ç¦»å¼€æ¥ã€‚ /: global namespace four types of Graph Resource Names: base, relative, global, and private base relative/name /global/name ~private/name Package Resource Names \"std_msgs/String\" refers to the \"String\" message type in the \"std_msgs\" Package. Higher-Level Concepts wiki Coordinate Frames/Transforms The tf package provides a distributed, ROS-based framework for calculating the positions of multiple coordinate frames over time. Actions/Tasks The actionlib package defines a common, topic-based interface for preemptible tasks in ROS. Message Ontology common_msgs stack provides a set of common message types for interacting with robots. actionlib_msgs: messages for representing actions diagnostic_msgs: messages for sending diagnostic data. geometry_msgs: messages for representing common geometric primitives. nav_msgs: messages for navigation. sensor_msgs: messages for representing sensor data. Plugins pluginlib package provides tools for writing and dynamically loading plugins using the ROS build system. Filters filters package provides a set of filters for processing data streams. Robot Model The urdf package defines an XML format for representing a robot model and provides a C++ parser. Client Libraries A ROS client library is a collection of code that eases the job of the ROS programmer. It takes many of the ROS concepts and makes them accessible via code. In general, these libraries let you write ROS nodes, publish and subscribe to topics, write and call services, and use the Parameter Server. Such a library can be implemented in any programming language, though the current focus is on providing robust C++ and Python support. ROS å®¢æˆ·ç«¯åº“æ˜¯ç®€åŒ– ROS ç¨‹åºå‘˜å·¥ä½œçš„ä»£ç é›†åˆã€‚å®ƒé‡‡ç”¨äº†è®¸å¤š ROS æ¦‚å¿µï¼Œå¹¶ä½¿å…¶å¯ä»¥é€šè¿‡ä»£ç è®¿é—®ã€‚é€šå¸¸ï¼Œè¿™äº›åº“å…è®¸æ‚¨ç¼–å†™ ROS èŠ‚ç‚¹ã€å‘å¸ƒå’Œè®¢é˜…ä¸»é¢˜ã€ç¼–å†™å’Œè°ƒç”¨æœåŠ¡ä»¥åŠä½¿ç”¨ Parameter Serverã€‚è¿™æ ·çš„åº“å¯ä»¥ç”¨ä»»ä½•ç¼–ç¨‹è¯­è¨€å®ç°ï¼Œå°½ç®¡ç›®å‰çš„é‡ç‚¹æ˜¯æä¾›å¼ºå¤§çš„ C++ å’Œ Python æ”¯æŒã€‚ roscpp rospy roslisp ... Technical Overview Tools rosdep rosdep is a command-line tool for installing system dependencies. # install sudo apt-get install python3-rosdep # or pip install rosdep # source install git clone https://github.com/ros-infrastructure/rosdep cd rosdep source setup.sh # init rosdep, needs to call only once after installation sudo rosdep init # update rosdep update # install system dependencies # install dependency of a package rosdep install AMAZING_PACKAGE # install dependency of all packages in the workspace # cd into the catkin workspace, run: rosdep install --from-paths src --ignore-src -r -y catkin Low-level build system macros and infrastructure for ROS. wiki.ros: catkin wiki.ros: catkin conceptual overview catkin ros: rep-0128 catkin is the official build system of ROS and the successor to the original ROS build system, rosbuild. catkin combines CMake macros and Python scripts to provide some functionality on top of CMake's normal workflow. catkin was designed to be more conventional than rosbuild, allowing for better distribution of packages, better cross-compiling support, and better portability. catkin's workflow is very similar to CMake's but adds support for automatic 'find package' infrastructure and building multiple, dependent projects at the same time. catkin æ˜¯ ROS çš„å®˜æ–¹æ„å»ºç³»ç»Ÿï¼Œä¹Ÿæ˜¯åŸå§‹ ROS æ„å»ºç³»ç»Ÿ rosbuild çš„ç»§æ‰¿è€…ã€‚catkin ç»“åˆäº† CMake å®å’Œ Python è„šæœ¬ï¼Œåœ¨ CMake çš„æ­£å¸¸å·¥ä½œæµç¨‹ä¹‹ä¸Šæä¾›äº†ä¸€äº›åŠŸèƒ½ã€‚Catkin çš„è®¾è®¡æ¯” rosbuild æ›´ä¼ ç»Ÿï¼Œå…è®¸æ›´å¥½çš„åŒ…åˆ†å‘ã€æ›´å¥½çš„äº¤å‰ç¼–è¯‘æ”¯æŒå’Œæ›´å¥½çš„å¯ç§»æ¤æ€§ã€‚catkin çš„å·¥ä½œæµç¨‹ä¸ CMake çš„å·¥ä½œæµç¨‹éå¸¸ç›¸ä¼¼ï¼Œä½†å¢åŠ äº†å¯¹è‡ªåŠ¨â€œæŸ¥æ‰¾åŒ…â€åŸºç¡€è®¾æ–½çš„æ”¯æŒï¼Œå¹¶åŒæ—¶æ„å»ºå¤šä¸ªä¾èµ–çš„é¡¹ç›®ã€‚ # debian 12 bookworm catkin/stable 0.8.10-9 all # python3 python3-catkin/stable,now 0.8.10-9 al Usage: cd path/to/your/catkin_workspace # will build any packages in /catkin_workspace/src catkin_make # equivalent to cd path/to/your/catkin_workspace cd src catkin_init_workspace cd .. mkdir build cd build cmake ../src -DCMAKE_INSTALL_PREFIX=../install -DCATKIN_DEVEL_PREFIX=../devel make # build specific package catkin_make -DCATKIN_WHITELIST_PACKAGES=\"package1;package2\" # revert back to building all packages: catkin_make -DCATKIN_WHITELIST_PACKAGES=\"\" # generate build and devel dir under workspace root # install catkin_make install # specific source catkin_make --source my_src catkin_make install --source my_src rosinstall_generator generattes .rosinstall files containing information about repositories with ROS packages/stacks. # usage rosinstall_generator PACKAGE DEPENDENCY1 DEPENDENCY2 > PACKAGE.rosinstall # example rosinstall_generator desktop --rosdistro noetic --deps --tar > noetic-desktop.rosinstall vcstool Command-line tools for maintaining a workspace of projects from multiple version-control systems. vcstool provides commands to manage several local SCM repositories (supports git, mercurial, subversion, bazaar) based on a single workspace definition file (.repos or .rosinstall). vcs help # example vcs import --input noetic-desktop.rosinstall ./src "},"Learn/LearnROS/ROS2.html":{"url":"Learn/LearnROS/ROS2.html","title":"ROS2","keywords":"","body":"text text https://github.com/pokusew/ros2-build Install ROS2 HUMBLE on debian12 bookworm Source installation ROS 2 Humble vcstool catkin_pkg pyparsing pip install empy==3.3.2 # 4.2 has error when compiling lark conda install pytest colcon - collective construction?? https://colcon.readthedocs.io/en/released/ vcstool https://wiki.ros.org/vcstool "},"Learn/LearnROS/ROS2_debian12.html":{"url":"Learn/LearnROS/ROS2_debian12.html","title":"ROS2_debian12","keywords":"","body":"To install ROS 2 Humble Hawksbill on Debian 12, follow this detailed step-by-step guide: 1. Add the ROS 2 Package Repository a. Configure your sources list Open a terminal and add the ROS 2 repository to your systemâ€™s sources list: sudo sh -c 'echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(lsb_release -cs) main\" > /etc/apt/sources.list.d/ros2-latest.list' Note: Since Debian is not officially supported by ROS 2, you might need to replace $(lsb_release -cs) with the equivalent Ubuntu codename for the target ROS 2 Humble distribution (e.g., jammy for Ubuntu 22.04). b. Add the GPG key Import the GPG key used to sign the ROS 2 packages: sudo apt update sudo apt install -y curl gnupg2 lsb-release curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key | sudo tee /usr/share/keyrings/ros-archive-keyring.gpg > /dev/null 2. Install ROS 2 Humble a. Update package index Update your local package index to include the ROS 2 repository: sudo apt update b. Install ROS 2 Install the ROS 2 Humble desktop full package: sudo apt install ros-humble-desktop If you want a lighter installation, you can use one of the following commands instead: For the base packages:sudo apt install ros-humble-ros-base For specific tools or packages, list available ROS 2 packages:apt search ros-humble 3. Set Up the Environment a. Source the ROS 2 setup file Add the ROS 2 setup script to your shell configuration file (.bashrc or .zshrc): echo \"source /opt/ros/humble/setup.bash\" >> ~/.bashrc source ~/.bashrc If you use zsh, modify .zshrc: echo \"source /opt/ros/humble/setup.zsh\" >> ~/.zshrc source ~/.zshrc b. Verify the installation Check the ROS 2 version: ros2 --version 4. Install Additional Tools (Optional) a. ROS 2 Command Line Tools Install development tools and utilities for building and debugging: sudo apt install python3-colcon-common-extensions python3-rosdep python3-argcomplete b. Initialize rosdep Set up rosdep for managing dependencies: sudo rosdep init rosdep update 5. Test the Installation a. Launch the ROS 2 demo Run the talker and listener example to ensure ROS 2 is working: Open a terminal and start a talker:ros2 run demo_nodes_cpp talker Open another terminal and start a listener:ros2 run demo_nodes_cpp listener You should see messages being published by the talker and received by the listener. 6. Troubleshooting If ros2 commands are not recognized, check if ROS 2 is correctly sourced:source /opt/ros/humble/setup.bash If any dependencies are missing, use rosdep to install them:rosdep install --from-paths src --ignore-src -r -y This should allow you to successfully install and configure ROS 2 Humble on Debian 12! The error occurs because the ROS 2 Humble binaries are built for Ubuntu 22.04 (jammy), which relies on certain dependencies (like libpython3.10) that are not available in Debian 12 (bookworm) by default. To resolve this issue, you can try the following approaches: Option 1: Use Docker for ROS 2 Using Docker is the easiest and cleanest way to run ROS 2 on Debian 12 without dealing with compatibility issues. Install Docker: sudo apt update sudo apt install -y docker.io sudo usermod -aG docker $USER Pull the ROS 2 Humble Docker image: docker pull osrf/ros:humble-desktop Run the Docker container: docker run -it --rm osrf/ros:humble-desktop This method isolates ROS 2 from your system, ensuring all dependencies work seamlessly. Option 2: Build ROS 2 Humble from Source If you need ROS 2 natively installed, you can build it from source with the following steps: 1. Install Required Tools sudo apt update sudo apt install -y build-essential cmake git python3-colcon-common-extensions python3-rosdep python3-vcstool wget 2. Install ROS 2 Dependencies sudo rosdep init rosdep update 3. Clone the ROS 2 Humble Source Code Create a workspace and clone the ROS 2 repositories: mkdir -p ~/ros2_humble/src cd ~/ros2_humble wget https://raw.githubusercontent.com/ros2/ros2/humble/ros2.repos vcs import src 4. Resolve Dependencies Install all required dependencies: rosdep install --from-paths src --ignore-src --rosdistro humble -y --skip-keys \"libpython3.10 libopencv-core4.5d libpcl-common1.12\" 5. Build ROS 2 Build the workspace: colcon build --symlink-install 6. Source the ROS 2 Setup Add the setup script to your shell configuration: echo \"source ~/ros2_humble/install/setup.bash\" >> ~/.bashrc source ~/.bashrc Option 3: Manually Add Missing Dependencies Manually resolving dependency issues can be complex but may work in some cases: Enable Debian Backports or Experimental Repositories: sudo nano /etc/apt/sources.list Add the following line: deb http://deb.debian.org/debian bookworm-backports main contrib non-free Install libpython3.10: Download the necessary package from Ubuntu's jammy repository and install it manually. Example: wget http://archive.ubuntu.com/ubuntu/pool/main/p/python3.10/libpython3.10_3.10.6-1_amd64.deb sudo dpkg -i libpython3.10_3.10.6-1_amd64.deb Repeat for Other Dependencies: Identify the missing dependencies and manually download and install them. Recommendation The most reliable option for running ROS 2 Humble on Debian 12 is using Docker. Building from source is feasible but requires more effort to resolve all dependency issues. Let me know if you'd like assistance with a specific approach! "},"Learn/LearnROS/SourceInstall.html":{"url":"Learn/LearnROS/SourceInstall.html","title":"SourceInstall","keywords":"","body":"Install ROS from source ROS Noetic on Debian 12 Install from source: wiki.ros: Installation csdn blog: Debian12 é€šè¿‡æºç å®‰è£… ros-noetic Compiling ros1 noetic from source on Ubuntu 22.04 Debian 12, Bookworm Dependencies: # use apt or pip to install: python3- rosdep rosinstall-generator vcstools vcstool # init rosdep sudo rosdep init rosdep update # use apt build-essential libboost1.74-all-dev # ç‰ˆæœ¬ä¸èƒ½å¤ªé«˜, debian12 bookworm default v1.0.0 liblog4cxx10v5_0.10.0 liblog4cxx-dev_0.10.0 # need lower version -> v1.11.2, can download from pkgs.org libogre-1.12-dev ogre-1.12-tools liburdfdom-tools liburdfdom-headers-dev liburdfdom-dev libbz2-dev libgpgme-dev liborocos-kdl-dev/stable 1.5.1-2+b4 amd64 Kinematics and Dynamics Library development files liborocos-kdl1.5/stable,now 1.5.1-2+b4 amd64 [installed,automatic] Kinematics and Dynamics Library runtime Installation: # create catkin workspace mkdir ~/ros_catkin_ws cd ~/ros_catkin_ws # download source code for ros noetic, use vcstool, build all od Desktop # generates rosinstall file for noetic-desktop rosinstall_generator desktop --rosdistro noetic --deps --tar > noetic-desktop.rosinstall mkdir src # use vcs to download all source code base on xx.rosinstall vcs import --input noetic-desktop.rosinstall ./src # resolve dependencies (in official doc) # in debian 12 bookworm, please manually install the dependencies in the former section rosdep install --from-paths ./src --ignore-packages-from-source --rosdistro noetic -y # build, use catkin_make_isolate ./src/catkin/bin/catkin_make_isolated --install \\ -DCMAKE_BUILD_TYPE=Release \\ -DPYTHON_EXECUTABLE=/usr/bin/python3 # use your python3 path --install-space path/to/install # default is ~/ros_catkin_ws/install_isolated # after build success, all files have been installed in ~/ros_catkin_ws/install_isolated # source the setup.sh file, or add it to your ~/.bashrc source ~/ros_catkin_ws/install_isolated/setup.sh Other problems: roscore # if stack on roscore, do: pip uninstall rosgraph sudo apt-get install python3-rosgraph python3-rosgraph-msgs "},"Learn/LearnRust/LifetimeExample.html":{"url":"Learn/LearnRust/LifetimeExample.html","title":"LifetimeExample","keywords":"","body":"Lifetime Example Problem rust: å¦‚ä¸‹ç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸ'input çš„å«ä¹‰æ˜¯ä»€ä¹ˆï¼Œæ ‡æ³¨äº†ä¼šæ€ä¹ˆæ ·ï¼Œå¦‚æœä¸æ ‡æ³¨ä¼šæ€ä¹ˆæ ·ï¼Œè¯·ä¸¾ä¾‹è¯´æ˜. pub enum ExprSymbol { NumSymbol(&'input str), Op(Box>, Opcode, Box>), Error, } GPT åœ¨ä½ çš„ä»£ç ä¸­ï¼Œç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ 'input çš„æ„ä¹‰åœ¨äºå®ƒé™åˆ¶äº†æšä¸¾ ExprSymbol çš„å®ä¾‹ä¸­å¼•ç”¨çš„å­—ç¬¦ä¸²ï¼ˆæˆ–å…¶ä»–å¸¦æœ‰ç”Ÿå‘½å‘¨æœŸçš„éƒ¨åˆ†ï¼‰çš„ç”Ÿå‘½å‘¨æœŸã€‚å…·ä½“æ¥è¯´ï¼š å«ä¹‰ ç”Ÿå‘½å‘¨æœŸ 'input æ˜¯ç”¨æ¥è¡¨æ˜ï¼š ExprSymbol ç±»å‹ä¸­çš„æ‰€æœ‰å¸¦æœ‰ç”Ÿå‘½å‘¨æœŸçš„å­—æ®µï¼Œå…¶ç”Ÿå‘½å‘¨æœŸå¿…é¡»ä¸ 'input åŒ¹é…ã€‚ å…·ä½“æ¥è¯´ï¼ŒNumSymbol(&'input str) çš„å­—ç¬¦ä¸²å¼•ç”¨å¿…é¡»å­˜åœ¨è‡³å°‘ä¸ ExprSymbol çš„ç”Ÿå‘½å‘¨æœŸä¸€æ ·é•¿ã€‚ å¦‚æœæ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ ç”Ÿå‘½å‘¨æœŸ 'input çš„æ ‡æ³¨å¯ä»¥æ˜ç¡®æŒ‡å®šè¿™ä¸ªæšä¸¾ä¸­å¼•ç”¨æ•°æ®çš„å…³ç³»ï¼Œä½¿å¾—ç¼–è¯‘å™¨èƒ½å¤Ÿè¿½è¸ªæ•°æ®çš„ç”Ÿå‘½å‘¨æœŸå¹¶é˜²æ­¢æ‚¬ç©ºå¼•ç”¨ç­‰é—®é¢˜ã€‚ ä¾‹å¦‚ï¼š fn parse_expr(input: &'a str) -> ExprSymbol { ExprSymbol::NumSymbol(input) // ç¡®ä¿ `input` çš„ç”Ÿå‘½å‘¨æœŸä¸è¿”å›å€¼ä¸€è‡´ } åœ¨è¿™ç§æƒ…å†µä¸‹ï¼š parse_expr è¿”å›çš„ ExprSymbol ç»“æ„ä½“ä¸­çš„å­—ç¬¦ä¸²å¼•ç”¨ &'a str çš„ç”Ÿå‘½å‘¨æœŸä¸ä¼ å…¥çš„ input ä¸€è‡´ã€‚ å¦‚æœåœ¨è°ƒç”¨ parse_expr å input è¢«é‡Šæ”¾ï¼Œåˆ™ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œå› ä¸º ExprSymbol ä¸­ä»ç„¶å­˜å‚¨äº†å¯¹ input çš„å¼•ç”¨ã€‚ å¦‚æœä¸æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ å¦‚æœä¸æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼ŒRust ç¼–è¯‘å™¨ä¼šæ— æ³•æ¨æ–­ ExprSymbol ä¸­å­—ç¬¦ä¸²å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸã€‚è¿™ä¼šå¯¼è‡´ä»¥ä¸‹æƒ…å†µï¼š å¦‚æœ ExprSymbol çš„æ‰€æœ‰æˆå‘˜ä¸­ä¸åŒ…å«å¼•ç”¨ï¼Œåˆ™å¯ä»¥ç§»é™¤ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼ŒRust ä¼šè®¤ä¸ºå®ƒæ²¡æœ‰ä»»ä½•ä¾èµ–ç”Ÿå‘½å‘¨æœŸçš„æ•°æ®ï¼Œç¼–è¯‘æ­£å¸¸ã€‚ å¦‚æœæœ‰å¼•ç”¨ï¼ˆå¦‚ &strï¼‰ï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼Œå› ä¸ºå®ƒéœ€è¦æ˜¾å¼çš„ç”Ÿå‘½å‘¨æœŸæ¥æè¿°æ•°æ®å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸå…³ç³»ã€‚ ä¾‹å¦‚ï¼š pub enum ExprSymbol { NumSymbol(&str), // ç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼šéœ€è¦æ˜¾å¼ç”Ÿå‘½å‘¨æœŸ Op(Box, Opcode, Box), Error, } ç¼–è¯‘å™¨ä¼šæç¤ºç±»ä¼¼é”™è¯¯ï¼š error[E0106]: missing lifetime specifier --> src/main.rs:2:17 | 2 | NumSymbol(&str), | ^ expected named lifetime parameter åŸå› æ˜¯ Rust æ— æ³•è‡ªåŠ¨æ¨æ–­ &str çš„ç”Ÿå‘½å‘¨æœŸã€‚ ä¸¾ä¾‹è¯´æ˜ æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ fn example(input: &'a str) -> ExprSymbol { ExprSymbol::NumSymbol(input) } fn main() { let input = String::from(\"123\"); let symbol = example(&input); // input çš„ç”Ÿå‘½å‘¨æœŸå’Œ symbol ä¿æŒä¸€è‡´ println!(\"{:?}\", symbol); // input å’Œ symbol ç”Ÿå‘½å‘¨æœŸä¸€è‡´ï¼Œå› æ­¤åœ¨ input é‡Šæ”¾å‰ symbol æ˜¯æœ‰æ•ˆçš„ } ä¸æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼ˆå°è¯•ç§»é™¤ï¼‰ pub enum ExprSymbol { NumSymbol(&str), // é”™è¯¯ï¼šç¼ºå°‘ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ Op(Box, Opcode, Box), Error, } è¿™ç§æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼šè¦æ±‚æ·»åŠ ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œå› ä¸ºå®ƒéœ€è¦ç¡®ä¿ &str çš„ç”Ÿå‘½å‘¨æœŸä¸€è‡´ï¼Œé¿å…æ‚¬ç©ºå¼•ç”¨æˆ–å†…å­˜å®‰å…¨é—®é¢˜ã€‚ æ€»ç»“ æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ æ˜¯ä¸ºäº†æ˜ç¡®ç±»å‹ä¸­çš„å¼•ç”¨ä¸å…¶ç”Ÿå‘½å‘¨æœŸçš„å…³ç³»ï¼Œè®© Rust ç¼–è¯‘å™¨èƒ½å¤Ÿç¡®ä¿å†…å­˜å®‰å…¨ã€‚ å¦‚æœä¸æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼ŒRust æ— æ³•æ¨æ–­å¸¦æœ‰å¼•ç”¨çš„ç»“æ„ä½“çš„ç”Ÿå‘½å‘¨æœŸï¼Œä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ã€‚ åœ¨ä½ çš„ä¾‹å­ä¸­ï¼Œç”Ÿå‘½å‘¨æœŸ 'input ç¡®ä¿äº† ExprSymbol ä¸­çš„æ‰€æœ‰å­—ç¬¦ä¸²å¼•ç”¨å¿…é¡»ä¸ 'input ç”Ÿå‘½å‘¨æœŸä¸€è‡´ï¼Œä»è€Œé¿å…åœ¨ ExprSymbol æ´»è·ƒæ—¶åº•å±‚æ•°æ®è¢«é‡Šæ”¾çš„é—®é¢˜ã€‚ "},"Learn/LearnRust/Problems_Solutions.html":{"url":"Learn/LearnRust/Problems_Solutions.html","title":"Problems_Solutions","keywords":"","body":"Problems and Solutions "},"Learn/LearnRust/Resources.html":{"url":"Learn/LearnRust/Resources.html","title":"Resources","keywords":"","body":"Rust Resources Rust The Rust Reference Rust Ref: zh ~~ The Rust Programming Language The Rust Programming Language: Experiment Type Rust ç¨‹åºè®¾è®¡è¯­è¨€ (zh) - 2022 Rust ç¨‹åºè®¾è®¡è¯­è¨€ (zh) - 2024-05-02 ~~ effective rust: 35 Specific Ways to Improve Your Rust Code effective-rust-cn ~~ The Rustonomicon: The Dark Arts of Unsafe Rust Rust è¯­è¨€åœ£ç»(Rust Course) rust-by-example The Cargo Book The Little Book of Rust Macros ~~ Rust RFCs - RFC Book ~~ releases github releases ~~ Rust è¯­è¨€ä¸­æ–‡ç¤¾åŒº clippy Rust Design Patterns Newtype Index Pattern Embrace the newtype pattern -- Effective Rust Idiomatic tree and graph like structures in Rust Rust Compiler cranelift: a fast, secure, relatively simple and innovative compiler backend rustc_codegen_cranelift wasmtime: About A lightweight WebAssembly runtime that is fast, secure, and standards-compliant Rust OS NUDT-OS-Book rcore-os rCore-Tutorial-Book-v3 haibo_chen Others rust-for-linux ä¸€æ–‡è¯»æ‡‚ä»€ä¹ˆæ˜¯è¿›ç¨‹ã€çº¿ç¨‹ã€åç¨‹ rust-cli Joel on Software git submodule update --init --recursive Commands # rustup: Install, manage, and update Rust toolchains. rustup install/default/update/show rustup self uninstall # cargo: Rust's package manager and build system. cargo new # create a new Rust project cargo build # build the current package cargo run # build and run the current package cargo check # check the current package for errors without building cargo test # run the tests in the current package cargo fmt # check formatting of the current package cargo build --release # build the current package with optimizations cargo doc --open # build all dependences doc and open in broswer RUST_BACKTRACE=1 cargo run # checkout backtrace OwnerShip Rust ä¸­çš„æ¯ä¸€ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ª æ‰€æœ‰è€… ï¼ˆ owner ï¼‰ã€‚ å€¼åœ¨ä»»ä¸€æ—¶åˆ»æœ‰ä¸”åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…ã€‚ å½“æ‰€æœ‰è€…ï¼ˆå˜é‡ï¼‰ç¦»å¼€ä½œç”¨åŸŸï¼Œè¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒã€‚ å¼•ç”¨ åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼Œè¦ä¹ˆ åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¦ä¹ˆ åªèƒ½æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨ã€‚ å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„ã€‚ Slice ç±»å‹ slice å…è®¸ä½ å¼•ç”¨é›†åˆä¸­ä¸€æ®µè¿ç»­çš„å…ƒç´ åºåˆ—ï¼Œè€Œä¸ç”¨å¼•ç”¨æ•´ä¸ªé›†åˆã€‚slice æ˜¯ä¸€ç§å¼•ç”¨ï¼Œæ‰€ä»¥å®ƒæ²¡æœ‰æ‰€æœ‰æƒã€‚ fn first_word(s: &String) -> &str { let bytes = s.as_bytes(); for (i, &item) in bytes.iter().enumerate() { if item == b' ' { return &s[0..i]; } } &s[..] } fn main() { let my_string = String::from(\"hello world\"); // `first_word` é€‚ç”¨äº `String`ï¼ˆçš„ sliceï¼‰ï¼Œéƒ¨åˆ†æˆ–å…¨éƒ¨ let word = first_word(&my_string[0..6]); let word = first_word(&my_string[..]); // `first_word` ä¹Ÿé€‚ç”¨äº `String` çš„å¼•ç”¨ï¼Œ // è¿™ç­‰ä»·äºæ•´ä¸ª `String` çš„ slice let word = first_word(&my_string); let my_string_literal = \"hello world\"; // `first_word` é€‚ç”¨äºå­—ç¬¦ä¸²å­—é¢å€¼ï¼Œéƒ¨åˆ†æˆ–å…¨éƒ¨ let word = first_word(&my_string_literal[0..6]); let word = first_word(&my_string_literal[..]); // å› ä¸ºå­—ç¬¦ä¸²å­—é¢å€¼å·²ç» **æ˜¯** å­—ç¬¦ä¸² slice äº†ï¼Œ // è¿™ä¹Ÿæ˜¯é€‚ç”¨çš„ï¼Œæ— éœ€ slice è¯­æ³•ï¼ let word = first_word(my_string_literal); } Struct å­—æ®µåˆå§‹åŒ–ç®€å†™è¯­æ³•ï¼ˆfield init shorthandï¼‰ fn build_user(email: String, username: String) -> User { User { active: true, username, email, sign_in_count: 1, } } ç»“æ„ä½“æ›´æ–°è¯­æ³•ï¼ˆstruct update syntaxï¼‰ ä½¿ç”¨æ—§å®ä¾‹çš„å¤§éƒ¨åˆ†å€¼ä½†æ”¹å˜å…¶éƒ¨åˆ†å€¼æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ç»“æ„ä½“å®ä¾‹ fn main() { // --snip-- let user2 = User { email: String::from(\"another@example.com\"), ..user1 }; } ç¤ºä¾‹ 5-7 ä¸­çš„ä»£ç ä¹Ÿåœ¨ user2 ä¸­åˆ›å»ºäº†ä¸€ä¸ªæ–°å®ä¾‹ï¼Œä½†è¯¥å®ä¾‹ä¸­ email å­—æ®µçš„å€¼ä¸ user1 ä¸åŒï¼Œè€Œ usernameã€ active å’Œ sign_in_count å­—æ®µçš„å€¼ä¸ user1 ç›¸åŒã€‚..user1 å¿…é¡»æ”¾åœ¨æœ€åï¼Œä»¥æŒ‡å®šå…¶ä½™çš„å­—æ®µåº”ä» user1 çš„ç›¸åº”å­—æ®µä¸­è·å–å…¶å€¼ï¼Œä½†æˆ‘ä»¬å¯ä»¥é€‰æ‹©ä»¥ä»»ä½•é¡ºåºä¸ºä»»æ„å­—æ®µæŒ‡å®šå€¼ï¼Œè€Œä¸ç”¨è€ƒè™‘ç»“æ„ä½“å®šä¹‰ä¸­å­—æ®µçš„é¡ºåºã€‚ è¯·æ³¨æ„ï¼Œç»“æ„æ›´æ–°è¯­æ³•å°±åƒå¸¦æœ‰ = çš„èµ‹å€¼ï¼Œå› ä¸ºå®ƒç§»åŠ¨äº†æ•°æ®ï¼Œå°±åƒæˆ‘ä»¬åœ¨â€œå˜é‡ä¸æ•°æ®äº¤äº’çš„æ–¹å¼ï¼ˆä¸€ï¼‰ï¼šç§»åŠ¨â€éƒ¨åˆ†è®²åˆ°çš„ä¸€æ ·ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæ€»ä½“ä¸Šè¯´æˆ‘ä»¬åœ¨åˆ›å»º user2 åå°±ä¸èƒ½å†ä½¿ç”¨ user1 äº†ï¼Œå› ä¸º user1 çš„ username å­—æ®µä¸­çš„ String è¢«ç§»åˆ° user2 ä¸­ã€‚å¦‚æœæˆ‘ä»¬ç»™ user2 çš„ email å’Œ username éƒ½èµ‹äºˆæ–°çš„ String å€¼ï¼Œä»è€Œåªä½¿ç”¨ user1 çš„ active å’Œ sign_in_count å€¼ï¼Œé‚£ä¹ˆ user1 åœ¨åˆ›å»º user2 åä»ç„¶æœ‰æ•ˆã€‚active å’Œ sign_in_count çš„ç±»å‹æ˜¯å®ç° Copy trait çš„ç±»å‹ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨â€œå˜é‡ä¸æ•°æ®äº¤äº’çš„æ–¹å¼ï¼ˆäºŒï¼‰ï¼šå…‹éš†â€ éƒ¨åˆ†è®¨è®ºçš„è¡Œä¸ºåŒæ ·é€‚ç”¨ã€‚ å…ƒç»„ç»“æ„ä½“ï¼ˆtuple structsï¼‰ struct Color(i32, i32, i32); struct Point(i32, i32, i32); fn main() { let black = Color(0, 0, 0); let origin = Point(0, 0, 0); } ç±»å•å…ƒç»“æ„ä½“ï¼ˆunit-like structsï¼‰ æ²¡æœ‰ä»»ä½•å­—æ®µçš„ç»“æ„ä½“ ç±»å•å…ƒç»“æ„ä½“å¸¸å¸¸åœ¨ä½ æƒ³è¦åœ¨æŸä¸ªç±»å‹ä¸Šå®ç° trait ä½†ä¸éœ€è¦åœ¨ç±»å‹ä¸­å­˜å‚¨æ•°æ®çš„æ—¶å€™å‘æŒ¥ä½œç”¨ã€‚ struct AlwaysEqual; fn main() { let subject = AlwaysEqual; } sdsd dsd "},"Learn/LearnRust/RustBook.html":{"url":"Learn/LearnRust/RustBook.html","title":"RustBook","keywords":"","body":"Rust Book Rust ä¹Ÿä¸ºç³»ç»Ÿç¼–ç¨‹ä¸–ç•Œå¸¦æ¥äº†ç°ä»£åŒ–çš„å¼€å‘å·¥å…·ï¼š Cargo æ˜¯å†…ç½®çš„ä¾èµ–ç®¡ç†å™¨å’Œæ„å»ºå·¥å…·ï¼Œå®ƒèƒ½è½»æ¾å¢åŠ ã€ç¼–è¯‘å’Œç®¡ç†ä¾èµ–ï¼Œå¹¶ä½¿ä¾èµ–åœ¨ Rust ç”Ÿæ€ç³»ç»Ÿä¸­ä¿æŒä¸€è‡´ã€‚ Rustfmt æ ¼å¼åŒ–å·¥å…·ç¡®ä¿å¼€å‘è€…éµå¾ªä¸€è‡´çš„ä»£ç é£æ ¼ã€‚ rust-analyzer ä¸ºé›†æˆå¼€å‘ç¯å¢ƒï¼ˆIDEï¼‰æä¾›äº†å¼ºå¤§çš„ä»£ç è¡¥å…¨å’Œå†…è”é”™è¯¯ä¿¡æ¯åŠŸèƒ½ã€‚ rustup ä¸‹è½½ Rustï¼Œè¿™æ˜¯ä¸€ä¸ªç®¡ç† Rust ç‰ˆæœ¬å’Œç›¸å…³å·¥å…·çš„å‘½ä»¤è¡Œå·¥å…· "},"Learn/LearnRust/RustLanRef.html":{"url":"Learn/LearnRust/RustLanRef.html","title":"RustLanRef","keywords":"","body":"Rust Language Reference Ref Traits ç‰¹æ€§ unsafe? trait IDENTIFIER GenericParams? ( : TypeParamBounds? )? WhereClause? { InnerAttribute* AssociatedItem* } A trait describes an abstract interface that types can implement. This interface consists of associated items, which come in three varieties. Trait declaration defines a trait in the type namespace of the module or block where it is located. Associated items are defined as members of the trait within their respective namespaces. Associated types are defined in the type namespace. Associated constants and associated functions are defined in the value namespace. All traits define an implicit type parameter Self that refers to â€œthe type that is implementing this interfaceâ€. Traits may also contain additional type parameters. These type parameters, including Self, may be constrained by other traits and so forth as usual. Traits are implemented for specific types through separate implementations. Trait functions may omit the function body by replacing it with a semicolon. This indicates that the implementation must define the function. If the trait function defines a body, this definition acts as a default for any implementation which does not override it. Similarly, associated constants may omit the equals sign and expression to indicate implementations must define the constant value. Associated types must never define the type, the type may only be specified in an implementation. Trait functions are not allowed to be const. trait æè¿°äº†ä¸€ä¸ªç±»èƒ½å®ç°çš„æŠ½è±¡æ¥å£ã€‚ è¿™ä¸ª æ¥å£ç”±ä¸€äº› ç›¸å…³é¡¹ç›®æ„æˆï¼ŒåŒ…æ‹¬ï¼š functions å‡½æ•° types ç±»å‹ constants å¸¸æ•° trait çš„å£°æ˜åœ¨è¯¥å£°æ˜æ‰€åœ¨çš„ module æˆ– block ä¸­çš„å‘½åç©ºé—´å®šä¹‰äº†ä¸€ä¸ª trait æ‰€æœ‰ç‰¹å¾éƒ½å®šä¹‰äº†ä¸€ä¸ªéšå¼ç±»å‹å‚æ•° Self ï¼Œå®ƒæŒ‡çš„æ˜¯â€œå®ç°è¯¥æ¥å£çš„ç±»å‹â€ã€‚ç‰¹å¾è¿˜å¯èƒ½åŒ…å«å…¶ä»–ç±»å‹å‚æ•°ã€‚è¿™äº›ç±»å‹å‚æ•°ï¼ŒåŒ…æ‹¬ Self ï¼Œå¯èƒ½ä¼šåƒå¾€å¸¸ä¸€æ ·å—åˆ°å…¶ä»–ç‰¹å¾ç­‰çš„çº¦æŸã€‚ å¯¹ä¸€ä¸ªç‰¹å®šç±»å‹çš„ trait å®ç°æ˜¯ä¸ trait çš„å®šä¹‰ç›¸åˆ†å¼€çš„ ç‰¹å¾å‡½æ•°å¯ä»¥é€šè¿‡ç”¨åˆ†å·æ›¿æ¢æ¥çœç•¥å‡½æ•°ä½“ã€‚è¿™è¡¨æ˜å®ç°å¿…é¡»å®šä¹‰è¯¥å‡½æ•°ã€‚ å¦‚æœç‰¹å¾å‡½æ•°å®šä¹‰äº†ä¸€ä¸ªå‡½æ•°ä½“ï¼Œåˆ™æ­¤å®šä¹‰å°†å……å½“ä»»ä½•ä¸è¦†ç›–å®ƒçš„å®ç°çš„é»˜è®¤å€¼ã€‚ ç±»ä¼¼åœ°ï¼Œå…³è”çš„å¸¸é‡å¯ä»¥çœç•¥ç­‰å·å’Œè¡¨è¾¾å¼ä»¥æŒ‡ç¤ºå®ç°å¿…é¡»å®šä¹‰å¸¸é‡å€¼ã€‚ å…³è”ç±»å‹ç»ä¸èƒ½å®šä¹‰è¯¥ç±»å‹ï¼Œè¯¥ç±»å‹åªèƒ½åœ¨å®ç°ä¸­æŒ‡å®šã€‚ trait function ä¸èƒ½ä¸º const ï¼Ÿ // Examples of associated trait items with and without definitions. trait Example { const CONST_NO_DEFAULT: i32; const CONST_WITH_DEFAULT: i32 = 99; type TypeNoDefault; fn method_without_default(&self); fn method_with_default(&self) {} } Trait bounds æ³›å‹é¡¹å¯èƒ½ä¼šä½¿ç”¨ traits ä½œä¸º type parameters çš„é™åˆ¶ï¼ˆboundsï¼‰ã€‚ Trait and lifetime bounds Trait and lifetime bounds provide a way for generic items to restrict which types and lifetimes are used as their parameters. Bounds can be provided on any type in a where clause. There are also shorter forms for certain common cases: ç‰¹å¾å’Œç”Ÿå‘½å‘¨æœŸç•Œé™ä¸ºé€šç”¨é¡¹æä¾›äº†ä¸€ç§æ–¹æ³•æ¥é™åˆ¶å°†å“ªäº›ç±»å‹å’Œç”Ÿå‘½å‘¨æœŸç”¨ä½œå…¶å‚æ•°ã€‚å¯ä»¥åœ¨ where å­å¥ä¸­ä¸ºä»»ä½•ç±»å‹æä¾›ç•Œé™ã€‚å¯¹äºæŸäº›å¸¸è§æƒ…å†µï¼Œè¿˜æœ‰æ›´ç®€çŸ­çš„å½¢å¼ï¼š Bounds written after declaring a generic parameter: fn f() {} is the same as fn f() where A: Copy {}. å£°æ˜é€šç”¨å‚æ•°åå†™å…¥çš„ç•Œé™ï¼š fn f() {} ä¸ fn f() where A: Copy {} ã€‚ In trait declarations as supertraits: trait Circle : Shape {} is equivalent to trait Circle where Self : Shape {}. åœ¨ä½œä¸º supertraits çš„ç‰¹å¾å£°æ˜ä¸­ï¼š trait Circle : Shape {} ç›¸å½“äº trait Circle where Self : Shape {} ã€‚ In trait declarations as bounds on associated types: trait A { type B: Copy; } is equivalent to trait A where Self::B: Copy { type B; }. åœ¨ç‰¹å¾å£°æ˜ä¸­ä½œä¸ºå…³è”ç±»å‹çš„è¾¹ç•Œï¼š trait A { type B: Copy; } ç›¸å½“äº trait A where Self::B: Copy { type B; } ã€‚ Bounds on an item must be satisfied when using the item. When type checking and borrow checking a generic item, the bounds can be used to determine that a trait is implemented for a type. For example, given Ty: Trait ä½¿ç”¨ç‰©å“æ—¶å¿…é¡»æ»¡è¶³ç‰©å“çš„é™åˆ¶ã€‚å½“ç±»å‹æ£€æŸ¥å’Œå€Ÿç”¨æ£€æŸ¥é€šç”¨é¡¹æ—¶ï¼Œè¾¹ç•Œå¯ç”¨äºç¡®å®šæ˜¯å¦ä¸ºç±»å‹å®ç°äº†ç‰¹å¾ã€‚ä¾‹å¦‚ï¼Œç»™å®š Ty: Trait In the body of a generic function, methods from Trait can be called on Ty values. Likewise associated constants on the Trait can be used. åœ¨æ³›å‹å‡½æ•°ä½“å†…ï¼Œå¯ä»¥åœ¨ Ty ä¸Šè°ƒç”¨ Trait ä¸­çš„æ–¹æ³• ä»·å€¼è§‚ã€‚åŒæ ·å¯ä»¥ä½¿ç”¨ Trait ä¸Šçš„å…³è”å¸¸é‡ã€‚ Associated types from Trait can be used. å¯ä»¥ä½¿ç”¨ Trait ä¸­çš„å…³è”ç±»å‹ã€‚ Generic functions and types with a T: Trait bounds can be used with Ty being used for T. å¸¦æœ‰ T: Trait è¾¹ç•Œå¯ä»¥ä¸ Ty ä¸€èµ·ä½¿ç”¨ ç”¨äº T ã€‚ Trait objects ç‰¹æ€§å¯¹è±¡ A trait object is an opaque value of another type that implements a set of traits. The set of traits is made up of an object safe base trait plus any number of auto traits. ç‰¹å¾å¯¹è±¡æ˜¯å®ç°ä¸€ç»„ç‰¹å¾çš„å¦ä¸€ç§ç±»å‹çš„ä¸é€æ˜å€¼ã€‚è¯¥ç‰¹å¾é›†ç”± å¯¹è±¡å®‰å…¨åŸºæœ¬ç‰¹å¾(object safe base trait)åŠ ä¸Šä»»æ„æ•°é‡çš„ è‡ªåŠ¨ç‰¹å¾ (auto traits)ç»„æˆã€‚ Trait objects implement the base trait, its auto traits, and any supertraits of the base trait. Trait å¯¹è±¡å®ç°åŸºæœ¬ç‰¹å¾ã€å…¶è‡ªåŠ¨ç‰¹å¾å’Œä»»ä½•åŸºæœ¬ç‰¹å¾çš„è¶…çº§ç‰¹å¾ã€‚ Trait objects are written as the keyword dyn followed by a set of trait bounds, but with the following restrictions on the trait bounds. All traits except the first trait must be auto traits, there may not be more than one lifetime, and opt-out bounds (e.g. ?Sized) are not allowed. Furthermore, paths to traits may be parenthesized. Trait å¯¹è±¡è¢«ç¼–å†™ä¸ºå…³é”®å­— dyn åè·Ÿä¸€ç»„ ç‰¹å¾è¾¹ç•Œï¼Œä½†å¯¹ç‰¹å¾è¾¹ç•Œæœ‰ä»¥ä¸‹é™åˆ¶ã€‚ é™¤ç¬¬ä¸€ä¸ªç‰¹å¾ä¹‹å¤–çš„æ‰€æœ‰ç‰¹å¾éƒ½å¿…é¡»æ˜¯è‡ªåŠ¨ç‰¹å¾ï¼Œä¸èƒ½æœ‰è¶…è¿‡ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸï¼Œå¹¶ä¸”ä¸å…è®¸é€‰æ‹©é€€å‡ºè¾¹ç•Œï¼ˆä¾‹å¦‚?Sized ï¼‰ã€‚ æ­¤å¤–ï¼Œç‰¹å¾çš„è·¯å¾„å¯ä»¥ç”¨æ‹¬å·æ‹¬èµ·æ¥ã€‚ For example, given a trait Trait, the following are all trait objects:ä¾‹å¦‚ï¼Œç»™å®šä¸€ä¸ªç‰¹å¾ Trait ï¼Œä»¥ä¸‹éƒ½æ˜¯ç‰¹å¾å¯¹è±¡ï¼š dyn Trait dyn Trait + Send dyn Trait + Send + Sync dyn Trait + 'static dyn Trait + Send + 'static dyn Trait + dyn 'static + Trait. dyn (Trait) Two trait object types alias each other if the base traits alias each other and if the sets of auto traits are the same and the lifetime bounds are the same. For example, dyn Trait + Send + UnwindSafe is the same as dyn Trait + UnwindSafe + Send. Due to the opaqueness of which concrete type the value is of, trait objects are dynamically sized types. Like all DSTs, trait objects are used behind some type of pointer; for example &dyn SomeTrait or Box. Each instance of a pointer to a trait object includes: ç”±äºå€¼å±äºå“ªç§å…·ä½“ç±»å‹çš„ä¸é€æ˜æ€§ï¼Œç‰¹å¾å¯¹è±¡æ˜¯ åŠ¨æ€è°ƒæ•´å¤§å°çš„ç±»å‹ã€‚åƒæ‰€æœ‰ DSTs ä¸€æ · ï¼Œç‰¹å¾å¯¹è±¡ç”¨åœ¨æŸç§ç±»å‹çš„æŒ‡é’ˆåé¢ï¼›ä¾‹å¦‚ &dyn SomeTraitæˆ– Box ã€‚æŒ‡å‘ç‰¹å¾å¯¹è±¡çš„æŒ‡é’ˆçš„æ¯ä¸ªå®ä¾‹åŒ…æ‹¬ï¼š a pointer to an instance of a type T that implements SomeTrait æŒ‡å‘å®ç° SomeTraitçš„ç±»å‹ Tå®ä¾‹çš„æŒ‡é’ˆ a virtual method table , often just called a vtable , which contains, for each method of SomeTrait and its supertraits that T implements, a pointer to Tâ€™s implementation (i.e. a function pointer). è™šæ‹Ÿæ–¹æ³•è¡¨ï¼Œé€šå¸¸ç®€ç§°ä¸º vtable ï¼Œå…¶ä¸­åŒ…å« T å®ç°çš„ SomeTrait åŠå…¶è¶…ç‰¹å¾çš„æ¯ä¸ªæ–¹æ³•ï¼Œä¸€ä¸ªæŒ‡å‘ T å®ç°çš„æŒ‡é’ˆï¼ˆå³å‡½æ•°æŒ‡é’ˆï¼‰ã€‚ The purpose of trait objects is to permit â€œlate bindingâ€ of methods. Calling a method on a trait object results in virtual dispatch at runtime: that is, a function pointer is loaded from the trait object vtable and invoked indirectly. The actual implementation for each vtable entry can vary on an object-by-object basis. ç‰¹å¾å¯¹è±¡çš„ç›®çš„æ˜¯å…è®¸æ–¹æ³•çš„â€œåæœŸç»‘å®šâ€ã€‚åœ¨ç‰¹å¾å¯¹è±¡ä¸Šè°ƒç”¨æ–¹æ³•ä¼šå¯¼è‡´è¿è¡Œæ—¶è™šæ‹Ÿåˆ†æ´¾ï¼šä¹Ÿå°±æ˜¯è¯´ï¼Œä»ç‰¹å¾å¯¹è±¡ vtable åŠ è½½å‡½æ•°æŒ‡é’ˆå¹¶é—´æ¥è°ƒç”¨ã€‚æ¯ä¸ª vtable æ¡ç›®çš„å®é™…å®ç°å¯èƒ½å› å¯¹è±¡è€Œå¼‚ã€‚ An example of a trait object: trait Printable { fn stringify(&self) -> String; } impl Printable for i32 { fn stringify(&self) -> String { self.to_string() } } fn print(a: Box) { println!(\"{}\", a.stringify()); } fn main() { print(Box::new(10) as Box); } In this example, the trait Printable occurs as a trait object in both the type signature of print, and the cast expression in main. åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œç‰¹å¾ Printable ä½œä¸ºç‰¹å¾å¯¹è±¡å‡ºç°åœ¨ print çš„ç±»å‹ç­¾åå’Œ main ä¸­çš„å¼ºåˆ¶è½¬æ¢è¡¨è¾¾å¼ä¸­ã€‚ Trait Object Lifetime Bounds ç‰¹å¾å¯¹è±¡ç”Ÿå‘½å‘¨æœŸç•Œé™ Since a trait object can contain references, the lifetimes of those references need to be expressed as part of the trait object. This lifetime is written as Trait + 'a. There are defaults that allow this lifetime to usually be inferred with a sensible choice. ç”±äºç‰¹å¾å¯¹è±¡å¯ä»¥åŒ…å«å¼•ç”¨ï¼Œå› æ­¤è¿™äº›å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ éœ€è¦è¡¨è¾¾ä¸ºç‰¹å¾å¯¹è±¡çš„ä¸€éƒ¨åˆ†ã€‚æ­¤ lifetime å¯å†™ä¸º Trait + 'a .æœ‰ä¸€äº›é»˜è®¤å€¼å…è®¸é€šå¸¸é€šè¿‡æ˜æ™ºçš„é€‰æ‹©æ¥æ¨æ–­æ­¤ç”Ÿå‘½å‘¨æœŸã€‚ Attributes å±æ€§ attributes // inner attribute #![Attr] // outer attribute #[Arrt] An attribute is a general, free-form metadatum that is interpreted according to name, convention, language, and compiler version. Attributes are modeled on Attributes in ECMA-335, with the syntax coming from ECMA-334 (C#). Inner attributes , written with a bang (!) after the hash (#), apply to the item that the attribute is declared within. Outer attributes , written without the bang after the hash, apply to the thing that follows the attribute. The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (=) followed by an expression. See the meta item syntax below for more details. An attribute may be unsafe to apply. To avoid undefined behavior when using these attributes, certain obligations that cannot be checked by the compiler must be met. To assert these have been, the attribute is wrapped in unsafe(..), e.g. #[unsafe(no_mangle)]. The following attributes are unsafe: export_name link_section no_mangle Attributes can be classified into the following kinds: Built-in attributes Macro attributes Derive macro helper attributes Tool attributes Attributes may be applied to many things in the language: All item declarations accept outer attributes while external blocks, functions, implementations, and modules accept inner attributes. Most statements accept outer attributes (see Expression Attributes for limitations on expression statements). Block expressions accept outer and inner attributes, but only when they are the outer expression of an expression statement or the final expression of another block expression. Enum variants and struct and union fields accept outer attributes. Match expression arms accept outer attributes. Generic lifetime or type parameter accept outer attributes. Expressions accept outer attributes in limited situations, see Expression Attributes for details. Function, closure and function pointer parameters accept outer attributes. This includes attributes on variadic parameters denoted with ... in function pointers and external blocks. Examples: // General metadata applied to the enclosing module or crate. #![crate_type = \"lib\"] // A function marked as a unit test #[test] fn test_foo() { /* ... */ } // A conditionally-compiled module #[cfg(target_os = \"linux\")] mod bar { /* ... */ } // A lint attribute used to suppress a warning/error #[allow(non_camel_case_types)] type int8_t = i8; // Inner attribute applies to the entire function. fn some_unused_variables() { #![allow(unused_variables)] let x = (); let y = (); let z = (); } Built-in attributes index The following is an index of all built-in attributes. Conditional compilation cfg â€” Controls conditional compilation. cfg_attr â€” Conditionally includes attributes. Testing test â€” Marks a function as a test. ignore â€” Disables a test function. should_panic â€” Indicates a test should generate a panic. Derive derive â€” Automatic trait implementations. automatically_derived â€” Marker for implementations created by derive. Macros macro_export â€” Exports a macro_rules macro for cross-crate usage. macro_use â€” Expands macro visibility, or imports macros from other crates. proc_macro â€” Defines a function-like macro. proc_macro_derive â€” Defines a derive macro. proc_macro_attribute â€” Defines an attribute macro. Diagnostics allow, expect, warn, deny, forbid â€” Alters the default lint level. deprecated â€” Generates deprecation notices. must_use â€” Generates a lint for unused values. diagnostic::on_unimplemented â€” Hints the compiler to emit a certain error message if a trait is not implemented. ABI, linking, symbols, and FFI link â€” Specifies a native library to link with an extern block. link_name â€” Specifies the name of the symbol for functions or statics in an extern block. link_ordinal â€” Specifies the ordinal of the symbol for functions or statics in an extern block. no_link â€” Prevents linking an extern crate. repr â€” Controls type layout. crate_type â€” Specifies the type of crate (library, executable, etc.). no_main â€” Disables emitting the main symbol. export_name â€” Specifies the exported symbol name for a function or static. link_section â€” Specifies the section of an object file to use for a function or static. no_mangle â€” Disables symbol name encoding. used â€” Forces the compiler to keep a static item in the output object file. crate_name â€” Specifies the crate name. Code generation inline â€” Hint to inline code. cold â€” Hint that a function is unlikely to be called. no_builtins â€” Disables use of certain built-in functions. target_feature â€” Configure platform-specific code generation. track_caller - Pass the parent call location to std::panic::Location::caller(). instruction_set - Specify the instruction set used to generate a functions code Documentation doc â€” Specifies documentation. See The Rustdoc Book for more information. Doc comments are transformed into doc attributes. Preludes no_std â€” Removes std from the prelude. no_implicit_prelude â€” Disables prelude lookups within a module. Modules path â€” Specifies the filename for a module. Limits recursion_limit â€” Sets the maximum recursion limit for certain compile-time operations. type_length_limit â€” Sets the maximum size of a polymorphic type. Runtime panic_handler â€” Sets the function to handle panics. global_allocator â€” Sets the global memory allocator. windows_subsystem â€” Specifies the windows subsystem to link with. Features feature â€” Used to enable unstable or experimental compiler features. See The Unstable Book for features implemented in rustc. Type System non_exhaustive â€” Indicate that a type will have more fields/variants added in future. Debugger debugger_visualizer â€” Embeds a file that specifies debugger output for a type. collapse_debuginfo â€” Controls how macro invocations are encoded in debuginfo. Derive æ´¾ç”Ÿ derivable-traits deriveå±æ€§å…è®¸ä¸ºæ•°æ®ç»“æ„è‡ªåŠ¨ç”Ÿæˆæ–°çš„ç¨‹åºé¡¹ã€‚å®ƒä½¿ç”¨ MetaListPathså…ƒé¡¹å±æ€§å¥æ³•ï¼ˆä¸ºç¨‹åºé¡¹ï¼‰æŒ‡å®šä¸€ç³»åˆ—è¦å®ç°çš„ trait æˆ–æŒ‡å®šè¦æ‰§è¡Œçš„æ´¾ç”Ÿå®çš„è·¯å¾„ã€‚ ä¾‹å¦‚ï¼Œä¸‹é¢çš„æ´¾ç”Ÿå±æ€§å°†ä¸ºç»“æ„ä½“ Foo åˆ›å»ºä¸€ä¸ªå®ç° PartialEq trait å’Œ Clone trait çš„å®ç°(impl item)ï¼Œç±»å‹å‚æ•° T å°†è¢«æ´¾ç”Ÿå‡ºçš„å®ç°(impl)åŠ ä¸Š PartialEq æˆ–^1^ Clone çº¦æŸï¼š #[test] #[should_panic(expected = \"values don't match\")] fn mytest() { assert_eq!(1, 2, \"values don't match\"); } 1ã€è‡ªåŠ¨æ´¾ç”Ÿå¸¸ç”¨çš„ traitsï¼š Rust æä¾›äº†ä¸€äº›å¸¸ç”¨çš„ traitsï¼Œå¯ä»¥é€šè¿‡ #[derive()] å±æ€§è‡ªåŠ¨ä¸ºç»“æ„ä½“æˆ–æšä¸¾å®ç°è¿™äº› traitsã€‚ä¸€äº›å¸¸è§çš„å¯æ´¾ç”Ÿ traits åŒ…æ‹¬ï¼š Debugï¼šé€šè¿‡å®ç° Debug traitï¼Œå¯ä»¥ä½¿ç”¨ println!(\"{:?}\", my_struct) æ¥æ‰“å°ç»“æ„ä½“çš„è°ƒè¯•ä¿¡æ¯ã€‚ Cloneï¼šé€šè¿‡å®ç° Clone traitï¼Œå¯ä»¥ä½¿ç”¨ my_struct.clone() åˆ›å»ºç»“æ„ä½“çš„å…‹éš†å‰¯æœ¬ã€‚ PartialEq å’Œ Eqï¼šé€šè¿‡å®ç° PartialEq traitï¼Œå¯ä»¥è¿›è¡Œç»“æ„ä½“çš„éƒ¨åˆ†ç›¸ç­‰æ€§æ¯”è¾ƒï¼Œè€Œ Eq trait åˆ™å®ç°äº†å®Œå…¨ç›¸ç­‰æ€§æ¯”è¾ƒã€‚ PartialOrd å’Œ Ordï¼šé€šè¿‡å®ç° PartialOrd traitï¼Œå¯ä»¥å¯¹ç»“æ„ä½“è¿›è¡Œéƒ¨åˆ†æœ‰åºæ€§æ¯”è¾ƒï¼Œè€Œ Ord trait å®ç°äº†å®Œå…¨æœ‰åºæ€§æ¯”è¾ƒã€‚ 2ã€è‡ªå®šä¹‰ traits çš„è‡ªåŠ¨æ´¾ç”Ÿï¼š é™¤äº†æ´¾ç”Ÿå¸¸è§çš„ traitsï¼Œæ‚¨è¿˜å¯ä»¥è‡ªå®šä¹‰ traitsï¼Œå¹¶ä½¿ç”¨ #[derive()] å±æ€§ä¸ºç»“æ„ä½“æˆ–æšä¸¾è‡ªåŠ¨ç”Ÿæˆå®ç°ä»£ç ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨å®šä¹‰äº†ä¸€ä¸ªåä¸º MyTrait çš„è‡ªå®šä¹‰ traitï¼Œå¹¶å¸Œæœ›ä¸ºç»“æ„ä½“è‡ªåŠ¨å®ç°å®ƒï¼Œå¯ä»¥è¿™æ ·å†™ï¼š trait MyTrait { // trait æ–¹æ³•å®šä¹‰ } #[derive(MyTrait)] struct MyStruct { // ç»“æ„ä½“å­—æ®µ } æ³¨æ„ï¼Œå¯¹äºè‡ªå®šä¹‰ traits çš„æ´¾ç”Ÿï¼Œæ‚¨éœ€è¦åœ¨ç¼–å†™ MyTrait trait æ—¶æ‰‹åŠ¨å®ç° #[derive(MyTrait)] çš„é€»è¾‘ï¼Œæˆ–è€…ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“æä¾›çš„æ´¾ç”Ÿå®ã€‚ 3ã€æ‰‹åŠ¨å®ç° traitsï¼š æŸäº› traits æ— æ³•é€šè¿‡ #[derive()] å±æ€§è‡ªåŠ¨æ´¾ç”Ÿï¼Œå› ä¸ºå®ƒä»¬å¯èƒ½éœ€è¦æ›´å¤šçš„ä¿¡æ¯æˆ–è‡ªå®šä¹‰å®ç°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨éœ€è¦æ‰‹åŠ¨ä¸ºç»“æ„ä½“æˆ–æšä¸¾å®ç°è¿™äº› traitsã€‚æ‰‹åŠ¨å®ç° traits é€šå¸¸æ¶‰åŠä¸ºæ¯ä¸ª trait æ–¹æ³•æä¾›å…·ä½“çš„å®ç°ä»£ç ã€‚ä»¥ä¸‹æ˜¯æ‰‹åŠ¨å®ç° MyTrait trait çš„ç¤ºä¾‹ï¼š trait MyTrait { // trait æ–¹æ³•å®šä¹‰ } struct MyStruct { // ç»“æ„ä½“å­—æ®µ } impl MyTrait for MyStruct { // MyTrait æ–¹æ³•çš„å…·ä½“å®ç° } #[derive[Debug]] #[derive(Debug)] struct Rectangle { width: u32, height: u32, } fn main() { let rect1 = Rectangle { width: 30, height: 50, }; println!(\"rect1 is {rect1:?}\"); } åœ¨ {} ä¸­åŠ å…¥ :? æŒ‡ç¤ºç¬¦å‘Šè¯‰ println! æˆ‘ä»¬æƒ³è¦ä½¿ç”¨å«åš Debug çš„è¾“å‡ºæ ¼å¼ã€‚Debug æ˜¯ä¸€ä¸ª traitï¼Œå®ƒå…è®¸æˆ‘ä»¬ä»¥ä¸€ç§å¯¹å¼€å‘è€…æœ‰å¸®åŠ©çš„æ–¹å¼æ‰“å°ç»“æ„ä½“ï¼Œä»¥ä¾¿å½“æˆ‘ä»¬è°ƒè¯•ä»£ç æ—¶èƒ½çœ‹åˆ°å®ƒçš„å€¼ã€‚ å½“æˆ‘ä»¬æœ‰ä¸€ä¸ªæ›´å¤§çš„ç»“æ„ä½“æ—¶ï¼Œèƒ½æœ‰æ›´æ˜“è¯»ä¸€ç‚¹çš„è¾“å‡ºå°±å¥½äº†ï¼Œä¸ºæ­¤å¯ä»¥ä½¿ç”¨ {:#?} æ›¿æ¢ println! å­—ç¬¦ä¸²ä¸­çš„ {:?}ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ä½¿ç”¨ {:#?} é£æ ¼å°†ä¼šè¾“å‡ºå¦‚ä¸‹ï¼š $ cargo run Compiling rectangles v0.1.0 (file:///projects/rectangles) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s Running `target/debug/rectangles` rect1 is Rectangle { width: 30, height: 50, } å¦ä¸€ç§ä½¿ç”¨ Debug æ ¼å¼æ‰“å°æ•°å€¼çš„æ–¹æ³•æ˜¯ä½¿ç”¨ dbg! å®ã€‚dbg! å®æ¥æ”¶ä¸€ä¸ªè¡¨è¾¾å¼çš„æ‰€æœ‰æƒï¼ˆä¸ println! å®ç›¸åï¼Œåè€…æ¥æ”¶çš„æ˜¯å¼•ç”¨ï¼‰ï¼Œæ‰“å°å‡ºä»£ç ä¸­è°ƒç”¨ dbg! å®æ—¶æ‰€åœ¨çš„æ–‡ä»¶å’Œè¡Œå·ï¼Œä»¥åŠè¯¥è¡¨è¾¾å¼çš„ç»“æœå€¼ï¼Œå¹¶è¿”å›è¯¥å€¼çš„æ‰€æœ‰æƒã€‚ æ³¨æ„ï¼šè°ƒç”¨ dbg! å®ä¼šæ‰“å°åˆ°æ ‡å‡†é”™è¯¯æ§åˆ¶å°æµï¼ˆstderrï¼‰ï¼Œä¸ println! ä¸åŒï¼Œåè€…ä¼šæ‰“å°åˆ°æ ‡å‡†è¾“å‡ºæ§åˆ¶å°æµï¼ˆstdoutï¼‰ã€‚ #[derive(Debug)] struct Rectangle { width: u32, height: u32, } fn main() { let scale = 2; let rect1 = Rectangle { width: dbg!(30 * scale), height: 50, }; dbg!(&rect1); } $ cargo run Compiling rectangles v0.1.0 (file:///projects/rectangles) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s Running `target/debug/rectangles` [src/main.rs:10:16] 30 * scale = 60 [src/main.rs:14:5] &rect1 = Rectangle { width: 60, height: 50, } Method and Impl #[derive(Debug)] struct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(&self) -> u32 { self.width * self.height } } fn main() { let rect1 = Rectangle { width: 30, height: 50, }; println!( \"The area of the rectangle is {} square pixels.\", rect1.area() ); } ä¸ºäº†ä½¿å‡½æ•°å®šä¹‰äº Rectangle çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œæˆ‘ä»¬å¼€å§‹äº†ä¸€ä¸ª impl å—ï¼ˆimpl æ˜¯ implementation çš„ç¼©å†™ï¼‰ï¼Œè¿™ä¸ª impl å—ä¸­çš„æ‰€æœ‰å†…å®¹éƒ½å°†ä¸ Rectangle ç±»å‹ç›¸å…³è”ã€‚æ¥ç€å°† area å‡½æ•°ç§»åŠ¨åˆ° impl å¤§æ‹¬å·ä¸­ï¼Œå¹¶å°†ç­¾åä¸­çš„ç¬¬ä¸€ä¸ªï¼ˆåœ¨è¿™é‡Œä¹Ÿæ˜¯å”¯ä¸€ä¸€ä¸ªï¼‰å‚æ•°å’Œå‡½æ•°ä½“ä¸­å…¶ä»–åœ°æ–¹çš„å¯¹åº”å‚æ•°æ”¹æˆ selfã€‚ç„¶ååœ¨ main ä¸­å°†æˆ‘ä»¬å…ˆå‰è°ƒç”¨ area æ–¹æ³•å¹¶ä¼ é€’ rect1 ä½œä¸ºå‚æ•°çš„åœ°æ–¹ï¼Œæ”¹æˆä½¿ç”¨ æ–¹æ³•è¯­æ³• ï¼ˆ method syntax ï¼‰åœ¨ Rectangle å®ä¾‹ä¸Šè°ƒç”¨ area æ–¹æ³•ã€‚æ–¹æ³•è¯­æ³•è·å–ä¸€ä¸ªå®ä¾‹å¹¶åŠ ä¸Šä¸€ä¸ªç‚¹å·ï¼Œåè·Ÿæ–¹æ³•åã€åœ†æ‹¬å·ä»¥åŠä»»ä½•å‚æ•°ã€‚ åœ¨ area çš„ç­¾åä¸­ï¼Œä½¿ç”¨ &self æ¥æ›¿ä»£ rectangle: &Rectangleï¼Œ&self å®é™…ä¸Šæ˜¯ self: &Self çš„ç¼©å†™ã€‚åœ¨ä¸€ä¸ª impl å—ä¸­ï¼ŒSelf ç±»å‹æ˜¯ impl å—çš„ç±»å‹çš„åˆ«åã€‚æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»æœ‰ä¸€ä¸ªåä¸º self çš„ Self ç±»å‹çš„å‚æ•°ï¼Œæ‰€ä»¥ Rust è®©ä½ åœ¨ç¬¬ä¸€ä¸ªå‚æ•°ä½ç½®ä¸Šåªç”¨ self è¿™ä¸ªåå­—æ¥ç®€åŒ–ã€‚æ³¨æ„ï¼Œæˆ‘ä»¬ä»ç„¶éœ€è¦åœ¨ self å‰é¢ä½¿ç”¨ & æ¥è¡¨ç¤ºè¿™ä¸ªæ–¹æ³•å€Ÿç”¨äº† Self å®ä¾‹ï¼Œå°±åƒæˆ‘ä»¬åœ¨ rectangle: &Rectangle ä¸­åšçš„é‚£æ ·ã€‚æ–¹æ³•å¯ä»¥é€‰æ‹©è·å¾— self çš„æ‰€æœ‰æƒï¼Œæˆ–è€…åƒæˆ‘ä»¬è¿™é‡Œä¸€æ ·ä¸å¯å˜åœ°å€Ÿç”¨ selfï¼Œæˆ–è€…å¯å˜åœ°å€Ÿç”¨ selfï¼Œå°±è·Ÿå…¶ä»–å‚æ•°ä¸€æ ·ã€‚ è¿™é‡Œé€‰æ‹© &self çš„ç†ç”±è·Ÿåœ¨å‡½æ•°ç‰ˆæœ¬ä¸­ä½¿ç”¨ &Rectangle æ˜¯ç›¸åŒçš„ï¼šæˆ‘ä»¬å¹¶ä¸æƒ³è·å–æ‰€æœ‰æƒï¼Œåªå¸Œæœ›èƒ½å¤Ÿè¯»å–ç»“æ„ä½“ä¸­çš„æ•°æ®ï¼Œè€Œä¸æ˜¯å†™å…¥ã€‚å¦‚æœæƒ³è¦åœ¨æ–¹æ³•ä¸­æ”¹å˜è°ƒç”¨æ–¹æ³•çš„å®ä¾‹ï¼Œéœ€è¦å°†ç¬¬ä¸€ä¸ªå‚æ•°æ”¹ä¸º &mut selfã€‚é€šè¿‡ä»…ä»…ä½¿ç”¨ self ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°æ¥ä½¿æ–¹æ³•è·å–å®ä¾‹çš„æ‰€æœ‰æƒæ˜¯å¾ˆå°‘è§çš„ï¼›è¿™ç§æŠ€æœ¯é€šå¸¸ç”¨åœ¨å½“æ–¹æ³•å°† self è½¬æ¢æˆåˆ«çš„å®ä¾‹çš„æ—¶å€™ï¼Œè¿™æ—¶æˆ‘ä»¬æƒ³è¦é˜²æ­¢è°ƒç”¨è€…åœ¨è½¬æ¢ä¹‹åä½¿ç”¨åŸå§‹çš„å®ä¾‹ã€‚ ä½¿ç”¨æ–¹æ³•æ›¿ä»£å‡½æ•°ï¼Œé™¤äº†å¯ä½¿ç”¨æ–¹æ³•è¯­æ³•å’Œä¸éœ€è¦åœ¨æ¯ä¸ªå‡½æ•°ç­¾åä¸­é‡å¤ self çš„ç±»å‹ä¹‹å¤–ï¼Œå…¶ä¸»è¦å¥½å¤„åœ¨äºç»„ç»‡æ€§ã€‚æˆ‘ä»¬å°†æŸä¸ªç±»å‹å®ä¾‹èƒ½åšçš„æ‰€æœ‰äº‹æƒ…éƒ½ä¸€èµ·æ”¾å…¥ impl å—ä¸­ï¼Œè€Œä¸æ˜¯è®©å°†æ¥çš„ç”¨æˆ·åœ¨æˆ‘ä»¬çš„åº“ä¸­åˆ°å¤„å¯»æ‰¾ Rectangle çš„åŠŸèƒ½ã€‚ è‡ªåŠ¨å¼•ç”¨å’Œè§£å¼•ç”¨ï¼ˆ automatic referencing and dereferencingï¼‰ Rust å¹¶æ²¡æœ‰ä¸€ä¸ªä¸ -> ç­‰æ•ˆçš„è¿ç®—ç¬¦ï¼›ç›¸åï¼ŒRust æœ‰ä¸€ä¸ªå« è‡ªåŠ¨å¼•ç”¨å’Œè§£å¼•ç”¨ ï¼ˆ automatic referencing and dereferencing ï¼‰çš„åŠŸèƒ½ã€‚æ–¹æ³•è°ƒç”¨æ˜¯ Rust ä¸­å°‘æ•°å‡ ä¸ªæ‹¥æœ‰è¿™ç§è¡Œä¸ºçš„åœ°æ–¹ã€‚ å®ƒæ˜¯è¿™æ ·å·¥ä½œçš„ï¼šå½“ä½¿ç”¨ object.something() è°ƒç”¨æ–¹æ³•æ—¶ï¼ŒRust ä¼šè‡ªåŠ¨ä¸º object æ·»åŠ  &ã€&mut æˆ– * ä»¥ä¾¿ä½¿ object ä¸æ–¹æ³•ç­¾ååŒ¹é…ã€‚ p1.distance(&p2); (&p1).distance(&p2); ç¬¬ä¸€è¡Œçœ‹èµ·æ¥ç®€æ´çš„å¤šã€‚è¿™ç§è‡ªåŠ¨å¼•ç”¨çš„è¡Œä¸ºä¹‹æ‰€ä»¥æœ‰æ•ˆï¼Œæ˜¯å› ä¸ºæ–¹æ³•æœ‰ä¸€ä¸ªæ˜ç¡®çš„æ¥æ”¶è€…â€”â€”â€”â€” self çš„ç±»å‹ã€‚åœ¨ç»™å‡ºæ¥æ”¶è€…å’Œæ–¹æ³•åçš„å‰æä¸‹ï¼ŒRust å¯ä»¥æ˜ç¡®åœ°è®¡ç®—å‡ºæ–¹æ³•æ˜¯ä»…ä»…è¯»å–ï¼ˆ&selfï¼‰ï¼Œåšå‡ºä¿®æ”¹ï¼ˆ&mut selfï¼‰æˆ–è€…æ˜¯è·å–æ‰€æœ‰æƒï¼ˆselfï¼‰ã€‚äº‹å®ä¸Šï¼ŒRust å¯¹æ–¹æ³•æ¥æ”¶è€…çš„éšå¼å€Ÿç”¨è®©æ‰€æœ‰æƒåœ¨å®è·µä¸­æ›´å‹å¥½ã€‚ å…³è”å‡½æ•° æ‰€æœ‰åœ¨ impl å—ä¸­å®šä¹‰çš„å‡½æ•°è¢«ç§°ä¸º å…³è”å‡½æ•° ï¼ˆ associated functions ï¼‰ï¼Œå› ä¸ºå®ƒä»¬ä¸ impl åé¢å‘½åçš„ç±»å‹ç›¸å…³ã€‚æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸ä»¥ self ä¸ºç¬¬ä¸€å‚æ•°çš„å…³è”å‡½æ•°ï¼ˆå› æ­¤ä¸æ˜¯æ–¹æ³•ï¼‰ï¼Œå› ä¸ºå®ƒä»¬å¹¶ä¸ä½œç”¨äºä¸€ä¸ªç»“æ„ä½“çš„å®ä¾‹ã€‚æˆ‘ä»¬å·²ç»ä½¿ç”¨äº†ä¸€ä¸ªè¿™æ ·çš„å‡½æ•°ï¼šåœ¨ String ç±»å‹ä¸Šå®šä¹‰çš„ String::from å‡½æ•°ã€‚ ä¸æ˜¯æ–¹æ³•çš„å…³è”å‡½æ•°ç»å¸¸è¢«ç”¨ä½œè¿”å›ä¸€ä¸ªç»“æ„ä½“æ–°å®ä¾‹çš„æ„é€ å‡½æ•°ã€‚è¿™äº›å‡½æ•°çš„åç§°é€šå¸¸ä¸º new ï¼Œä½† new å¹¶ä¸æ˜¯ä¸€ä¸ªå…³é”®å­—ã€‚ä¾‹å¦‚æˆ‘ä»¬å¯ä»¥æä¾›ä¸€ä¸ªå«åš square å…³è”å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªç»´åº¦å‚æ•°å¹¶ä¸”åŒæ—¶ä½œä¸ºå®½å’Œé«˜ï¼Œè¿™æ ·å¯ä»¥æ›´è½»æ¾çš„åˆ›å»ºä¸€ä¸ªæ­£æ–¹å½¢ Rectangle è€Œä¸å¿…æŒ‡å®šä¸¤æ¬¡åŒæ ·çš„å€¼ï¼š impl Rectangle { fn square(size: u32) -> Self { Self { width: size, height: size, } } } å…³é”®å­— Self åœ¨å‡½æ•°çš„è¿”å›ç±»å‹ä¸­ä»£æŒ‡åœ¨ impl å…³é”®å­—åå‡ºç°çš„ç±»å‹ï¼Œåœ¨è¿™é‡Œæ˜¯ Rectangle ä½¿ç”¨ç»“æ„ä½“åå’Œ :: è¯­æ³•æ¥è°ƒç”¨è¿™ä¸ªå…³è”å‡½æ•°ï¼šæ¯”å¦‚ let sq = Rectangle::square(3);ã€‚è¿™ä¸ªå‡½æ•°ä½äºç»“æ„ä½“çš„å‘½åç©ºé—´ä¸­ï¼š:: è¯­æ³•ç”¨äºå…³è”å‡½æ•°å’Œæ¨¡å—åˆ›å»ºçš„å‘½åç©ºé—´ã€‚ç¬¬ä¸ƒç« ä¼šè®²åˆ°æ¨¡å—ã€‚ Option æšä¸¾å’Œå…¶ç›¸å¯¹äºç©ºå€¼çš„ä¼˜åŠ¿ è¿™ä¸€éƒ¨åˆ†ä¼šåˆ†æä¸€ä¸ª Option çš„æ¡ˆä¾‹ï¼ŒOption æ˜¯æ ‡å‡†åº“å®šä¹‰çš„å¦ä¸€ä¸ªæšä¸¾ã€‚Option ç±»å‹åº”ç”¨å¹¿æ³›å› ä¸ºå®ƒç¼–ç äº†ä¸€ä¸ªéå¸¸æ™®éçš„åœºæ™¯ï¼Œå³ä¸€ä¸ªå€¼è¦ä¹ˆæœ‰å€¼è¦ä¹ˆæ²¡å€¼ã€‚ ä¾‹å¦‚ï¼Œå¦‚æœè¯·æ±‚ä¸€ä¸ªéç©ºåˆ—è¡¨çš„ç¬¬ä¸€é¡¹ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªå€¼ï¼Œå¦‚æœè¯·æ±‚ä¸€ä¸ªç©ºçš„åˆ—è¡¨ï¼Œå°±ä»€ä¹ˆä¹Ÿä¸ä¼šå¾—åˆ°ã€‚ä»ç±»å‹ç³»ç»Ÿçš„è§’åº¦æ¥è¡¨è¾¾è¿™ä¸ªæ¦‚å¿µå°±æ„å‘³ç€ç¼–è¯‘å™¨éœ€è¦æ£€æŸ¥æ˜¯å¦å¤„ç†äº†æ‰€æœ‰åº”è¯¥å¤„ç†çš„æƒ…å†µï¼Œè¿™æ ·å°±å¯ä»¥é¿å…åœ¨å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­éå¸¸å¸¸è§çš„ bugã€‚ ç¼–ç¨‹è¯­è¨€çš„è®¾è®¡ç»å¸¸è¦è€ƒè™‘åŒ…å«å“ªäº›åŠŸèƒ½ï¼Œä½†è€ƒè™‘æ’é™¤å“ªäº›åŠŸèƒ½ä¹Ÿå¾ˆé‡è¦ã€‚Rust å¹¶æ²¡æœ‰å¾ˆå¤šå…¶ä»–è¯­è¨€ä¸­æœ‰çš„ç©ºå€¼åŠŸèƒ½ã€‚ ç©ºå€¼ ï¼ˆNull ï¼‰æ˜¯ä¸€ä¸ªå€¼ï¼Œå®ƒä»£è¡¨æ²¡æœ‰å€¼ã€‚åœ¨æœ‰ç©ºå€¼çš„è¯­è¨€ä¸­ï¼Œå˜é‡æ€»æ˜¯è¿™ä¸¤ç§çŠ¶æ€ä¹‹ä¸€ï¼šç©ºå€¼å’Œéç©ºå€¼ã€‚ Tony Hoareï¼Œnull çš„å‘æ˜è€…ï¼Œåœ¨ä»– 2009 å¹´çš„æ¼”è®² â€œNull References: The Billion Dollar Mistakeâ€ ä¸­æ›¾ç»è¯´åˆ°ï¼š I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years. æˆ‘ç§°ä¹‹ä¸ºæˆ‘åäº¿ç¾å…ƒçš„é”™è¯¯ã€‚å½“æ—¶ï¼Œæˆ‘åœ¨ä¸ºä¸€ä¸ªé¢å‘å¯¹è±¡è¯­è¨€è®¾è®¡ç¬¬ä¸€ä¸ªç»¼åˆæ€§çš„é¢å‘å¼•ç”¨çš„ç±»å‹ç³»ç»Ÿã€‚æˆ‘çš„ç›®æ ‡æ˜¯é€šè¿‡ç¼–è¯‘å™¨çš„è‡ªåŠ¨æ£€æŸ¥æ¥ä¿è¯æ‰€æœ‰å¼•ç”¨çš„ä½¿ç”¨éƒ½åº”è¯¥æ˜¯ç»å¯¹å®‰å…¨çš„ã€‚ä¸è¿‡æˆ‘æœªèƒ½æŠµæŠ—ä½å¼•å…¥ä¸€ä¸ªç©ºå¼•ç”¨çš„è¯±æƒ‘ï¼Œä»…ä»…æ˜¯å› ä¸ºå®ƒæ˜¯è¿™ä¹ˆçš„å®¹æ˜“å®ç°ã€‚è¿™å¼•å‘äº†æ— æ•°é”™è¯¯ã€æ¼æ´å’Œç³»ç»Ÿå´©æºƒï¼Œåœ¨ä¹‹åçš„å››åå¤šå¹´ä¸­é€ æˆäº†æ•°åäº¿ç¾å…ƒçš„è‹¦ç—›å’Œä¼¤å®³ã€‚ ç©ºå€¼çš„é—®é¢˜åœ¨äºå½“ä½ å°è¯•åƒä¸€ä¸ªéç©ºå€¼é‚£æ ·ä½¿ç”¨ä¸€ä¸ªç©ºå€¼ï¼Œä¼šå‡ºç°æŸç§å½¢å¼çš„é”™è¯¯ã€‚å› ä¸ºç©ºå’Œéç©ºçš„å±æ€§æ— å¤„ä¸åœ¨ï¼Œéå¸¸å®¹æ˜“å‡ºç°è¿™ç±»é”™è¯¯ã€‚ ç„¶è€Œï¼Œç©ºå€¼å°è¯•è¡¨è¾¾çš„æ¦‚å¿µä»ç„¶æ˜¯æœ‰æ„ä¹‰çš„ï¼šç©ºå€¼æ˜¯ä¸€ä¸ªå› ä¸ºæŸç§åŸå› ç›®å‰æ— æ•ˆæˆ–ç¼ºå¤±çš„å€¼ã€‚ é—®é¢˜ä¸åœ¨äºæ¦‚å¿µè€Œåœ¨äºå…·ä½“çš„å®ç°ã€‚ä¸ºæ­¤ï¼ŒRust å¹¶æ²¡æœ‰ç©ºå€¼ï¼Œä¸è¿‡å®ƒç¡®å®æ‹¥æœ‰ä¸€ä¸ªå¯ä»¥ç¼–ç å­˜åœ¨æˆ–ä¸å­˜åœ¨æ¦‚å¿µçš„æšä¸¾ã€‚è¿™ä¸ªæšä¸¾æ˜¯ Optionï¼Œè€Œä¸”å®ƒå®šä¹‰äºæ ‡å‡†åº“ä¸­ï¼Œå¦‚ä¸‹ï¼š enum Option { None, Some(T), } Option æšä¸¾æ˜¯å¦‚æ­¤æœ‰ç”¨ä»¥è‡³äºå®ƒç”šè‡³è¢«åŒ…å«åœ¨äº† prelude ä¹‹ä¸­ï¼Œä½ ä¸éœ€è¦å°†å…¶æ˜¾å¼å¼•å…¥ä½œç”¨åŸŸã€‚å¦å¤–ï¼Œå®ƒçš„æˆå‘˜ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œå¯ä»¥ä¸éœ€è¦ Option:: å‰ç¼€æ¥ç›´æ¥ä½¿ç”¨ Some å’Œ Noneã€‚å³ä¾¿å¦‚æ­¤ Option ä¹Ÿä»æ˜¯å¸¸è§„çš„æšä¸¾ï¼ŒSome(T) å’Œ None ä»æ˜¯ Option çš„æˆå‘˜ã€‚ è¯­æ³•æ˜¯ä¸€ä¸ªæˆ‘ä»¬è¿˜æœªè®²åˆ°çš„ Rust åŠŸèƒ½ã€‚å®ƒæ˜¯ä¸€ä¸ªæ³›å‹ç±»å‹å‚æ•°ï¼Œç¬¬åç« ä¼šæ›´è¯¦ç»†çš„è®²è§£æ³›å‹ã€‚ç›®å‰ï¼Œæ‰€æœ‰ä½ éœ€è¦çŸ¥é“çš„å°±æ˜¯ æ„å‘³ç€ Option æšä¸¾çš„ Some æˆå‘˜å¯ä»¥åŒ…å«ä»»æ„ç±»å‹çš„æ•°æ®ï¼ŒåŒæ—¶æ¯ä¸€ä¸ªç”¨äº T ä½ç½®çš„å…·ä½“ç±»å‹ä½¿å¾— Option æ•´ä½“ä½œä¸ºä¸åŒçš„ç±»å‹ã€‚è¿™é‡Œæ˜¯ä¸€äº›åŒ…å«æ•°å­—ç±»å‹å’Œå­—ç¬¦ä¸²ç±»å‹ Option å€¼çš„ä¾‹å­ï¼š let some_number = Some(5); let some_char = Some('e'); let absent_number: Option = None; some_number çš„ç±»å‹æ˜¯ Optionã€‚some_char çš„ç±»å‹æ˜¯ Optionï¼Œæ˜¯ä¸åŒäº some_numberçš„ç±»å‹ã€‚å› ä¸ºæˆ‘ä»¬åœ¨ Some æˆå‘˜ä¸­æŒ‡å®šäº†å€¼ï¼ŒRust å¯ä»¥æ¨æ–­å…¶ç±»å‹ã€‚å¯¹äº absent_numberï¼ŒRust éœ€è¦æˆ‘ä»¬æŒ‡å®š Option æ•´ä½“çš„ç±»å‹ï¼Œå› ä¸ºç¼–è¯‘å™¨åªé€šè¿‡ None å€¼æ— æ³•æ¨æ–­å‡º Some æˆå‘˜ä¿å­˜çš„å€¼çš„ç±»å‹ã€‚è¿™é‡Œæˆ‘ä»¬å‘Šè¯‰ Rust å¸Œæœ› absent_number æ˜¯ Option ç±»å‹çš„ã€‚ å½“æœ‰ä¸€ä¸ª Some å€¼æ—¶ï¼Œæˆ‘ä»¬å°±çŸ¥é“å­˜åœ¨ä¸€ä¸ªå€¼ï¼Œè€Œè¿™ä¸ªå€¼ä¿å­˜åœ¨ Some ä¸­ã€‚å½“æœ‰ä¸ª None å€¼æ—¶ï¼Œåœ¨æŸç§æ„ä¹‰ä¸Šï¼Œå®ƒè·Ÿç©ºå€¼å…·æœ‰ç›¸åŒçš„æ„ä¹‰ï¼šå¹¶æ²¡æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„å€¼ã€‚é‚£ä¹ˆï¼ŒOption ä¸ºä»€ä¹ˆå°±æ¯”ç©ºå€¼è¦å¥½å‘¢ï¼Ÿ ç®€è€Œè¨€ä¹‹ï¼Œå› ä¸º Option å’Œ Tï¼ˆè¿™é‡Œ T å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼‰æ˜¯ä¸åŒçš„ç±»å‹ï¼Œç¼–è¯‘å™¨ä¸å…è®¸åƒä¸€ä¸ªè‚¯å®šæœ‰æ•ˆçš„å€¼é‚£æ ·ä½¿ç”¨ Optionã€‚ä¾‹å¦‚ï¼Œè¿™æ®µä»£ç ä¸èƒ½ç¼–è¯‘ï¼Œå› ä¸ºå®ƒå°è¯•å°† Option ä¸ i8 ç›¸åŠ ï¼š let x: i8 = 5; let y: Option = Some(5); let sum = x + y; $ cargo run Compiling enums v0.1.0 (file:///projects/enums) error[E0277]: cannot add `Option` to `i8` --> src/main.rs:5:17 | 5 | let sum = x + y; | ^ no implementation for `i8 + Option` | = help: the trait `Add>` is not implemented for `i8` = help: the following other types implement trait `Add`: `&'a i8` implements `Add` `&i8` implements `Add` `i8` implements `Add` `i8` implements `Add` For more information about this error, try `rustc --explain E0277`. error: could not compile `enums` (bin \"enums\") due to 1 previous error å¾ˆå¥½ï¼äº‹å®ä¸Šï¼Œé”™è¯¯ä¿¡æ¯æ„å‘³ç€ Rust ä¸çŸ¥é“è¯¥å¦‚ä½•å°† Option ä¸ i8 ç›¸åŠ ï¼Œå› ä¸ºå®ƒä»¬çš„ç±»å‹ä¸åŒã€‚å½“åœ¨ Rust ä¸­æ‹¥æœ‰ä¸€ä¸ªåƒ i8 è¿™æ ·ç±»å‹çš„å€¼æ—¶ï¼Œç¼–è¯‘å™¨ç¡®ä¿å®ƒæ€»æ˜¯æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„å€¼ã€‚æˆ‘ä»¬å¯ä»¥è‡ªä¿¡ä½¿ç”¨è€Œæ— éœ€åšç©ºå€¼æ£€æŸ¥ã€‚åªæœ‰å½“ä½¿ç”¨ Optionï¼ˆæˆ–è€…ä»»ä½•ç”¨åˆ°çš„ç±»å‹ï¼‰çš„æ—¶å€™éœ€è¦æ‹…å¿ƒå¯èƒ½æ²¡æœ‰å€¼ï¼Œè€Œç¼–è¯‘å™¨ä¼šç¡®ä¿æˆ‘ä»¬åœ¨ä½¿ç”¨å€¼ä¹‹å‰å¤„ç†äº†ä¸ºç©ºçš„æƒ…å†µã€‚ æ¢å¥è¯è¯´ï¼Œåœ¨å¯¹ Option è¿›è¡Œè¿ç®—ä¹‹å‰å¿…é¡»å°†å…¶è½¬æ¢ä¸º Tã€‚é€šå¸¸è¿™èƒ½å¸®åŠ©æˆ‘ä»¬æ•è·åˆ°ç©ºå€¼æœ€å¸¸è§çš„é—®é¢˜ä¹‹ä¸€ï¼šå‡è®¾æŸå€¼ä¸ä¸ºç©ºä½†å®é™…ä¸Šä¸ºç©ºçš„æƒ…å†µã€‚ æ¶ˆé™¤äº†é”™è¯¯åœ°å‡è®¾ä¸€ä¸ªéç©ºå€¼çš„é£é™©ï¼Œä¼šè®©ä½ å¯¹ä»£ç æ›´åŠ æœ‰ä¿¡å¿ƒã€‚ä¸ºäº†æ‹¥æœ‰ä¸€ä¸ªå¯èƒ½ä¸ºç©ºçš„å€¼ï¼Œä½ å¿…é¡»è¦æ˜¾å¼çš„å°†å…¶æ”¾å…¥å¯¹åº”ç±»å‹çš„ Option ä¸­ã€‚æ¥ç€ï¼Œå½“ä½¿ç”¨è¿™ä¸ªå€¼æ—¶ï¼Œå¿…é¡»æ˜ç¡®çš„å¤„ç†å€¼ä¸ºç©ºçš„æƒ…å†µã€‚åªè¦ä¸€ä¸ªå€¼ä¸æ˜¯ Option ç±»å‹ï¼Œä½ å°± å¯ä»¥ å®‰å…¨çš„è®¤å®šå®ƒçš„å€¼ä¸ä¸ºç©ºã€‚è¿™æ˜¯ Rust çš„ä¸€ä¸ªç»è¿‡æ·±æ€ç†Ÿè™‘çš„è®¾è®¡å†³ç­–ï¼Œæ¥é™åˆ¶ç©ºå€¼çš„æ³›æ»¥ä»¥å¢åŠ  Rust ä»£ç çš„å®‰å…¨æ€§ã€‚ é‚£ä¹ˆå½“æœ‰ä¸€ä¸ª Option çš„å€¼æ—¶ï¼Œå¦‚ä½•ä» Some æˆå‘˜ä¸­å–å‡º T çš„å€¼æ¥ä½¿ç”¨å®ƒå‘¢ï¼ŸOption æšä¸¾æ‹¥æœ‰å¤§é‡ç”¨äºå„ç§æƒ…å†µçš„æ–¹æ³•ï¼šä½ å¯ä»¥æŸ¥çœ‹å®ƒçš„æ–‡æ¡£ã€‚ç†Ÿæ‚‰ Option çš„æ–¹æ³•å°†å¯¹ä½ çš„ Rust ä¹‹æ—…éå¸¸æœ‰ç”¨ã€‚ æ€»çš„æ¥è¯´ï¼Œä¸ºäº†ä½¿ç”¨ Option å€¼ï¼Œéœ€è¦ç¼–å†™å¤„ç†æ¯ä¸ªæˆå‘˜çš„ä»£ç ã€‚ä½ æƒ³è¦ä¸€äº›ä»£ç åªå½“æ‹¥æœ‰ Some(T) å€¼æ—¶è¿è¡Œï¼Œå…è®¸è¿™äº›ä»£ç ä½¿ç”¨å…¶ä¸­çš„ Tã€‚ä¹Ÿå¸Œæœ›ä¸€äº›ä»£ç åªåœ¨å€¼ä¸º None æ—¶è¿è¡Œï¼Œè¿™äº›ä»£ç å¹¶æ²¡æœ‰ä¸€ä¸ªå¯ç”¨çš„ T å€¼ã€‚match è¡¨è¾¾å¼å°±æ˜¯è¿™ä¹ˆä¸€ä¸ªå¤„ç†æšä¸¾çš„æ§åˆ¶æµç»“æ„ï¼šå®ƒä¼šæ ¹æ®æšä¸¾çš„æˆå‘˜è¿è¡Œä¸åŒçš„ä»£ç ï¼Œè¿™äº›ä»£ç å¯ä»¥ä½¿ç”¨åŒ¹é…åˆ°çš„å€¼ä¸­çš„æ•°æ®ã€‚ PS: C/C++å¦‚æœç¨‹åºå‘˜ä¸å¤Ÿå°å¿ƒæ³¨æ„ï¼Œå¾ˆå®¹æ˜“é€ æˆæœ‰ç©ºæŒ‡é’ˆçš„æƒ…å†µï¼Œå¹¶ä¸”å¿˜äº†æ£€æŸ¥ï¼Œå°±ä¼šå¯¼è‡´å¯¹ç©ºæŒ‡é’ˆçš„ä½¿ç”¨ï¼ï¼ï¼ˆCSC-2024 C++ æƒ¨ç—›çš„æ•™è®­ - ä¾èµ–å…³ç³»åˆ†æéä¸­æ²¡æœ‰å¯¹å‡½æ•°å¯èƒ½ä¼ å…¥ç©ºæŒ‡é’ˆè¿›è¡Œæ£€æŸ¥ï¼Œå¯¼è‡´å¯¹ç©ºæŒ‡é’ˆçš„æ“ä½œï¼ï¼‰ ä¸ºä»€ä¹ˆè¦å¼•å…¥ç©ºæŒ‡é’ˆï¼Ÿå¦‚æœä¸å¾—ä¸å¼•å…¥æŸç§ä¸ºâ€œç©ºâ€çš„çŠ¶æ€ï¼Œæœ€å¥½ wrap ä¸€ä¸‹ï¼ï¼å°±åƒ rust ä¸­çš„ Option ä¸€æ ·ï¼ "},"Learn/LearnRust/RustProgrammingLanguage.html":{"url":"Learn/LearnRust/RustProgrammingLanguage.html","title":"RustProgrammingLanguage","keywords":"","body":"Rust Programming Language Ch3: Common Programming Concepts Shadowing: éšè—ï¼Œå®šä¹‰ä¸€ä¸ªä¸ä¹‹å‰å˜é‡åŒåçš„æ–°å˜é‡ï¼Œç¬¬ä¸€ä¸ªå˜é‡è¢«ç¬¬äºŒä¸ªå˜é‡éšè—ã€‚ Ch9: é”™è¯¯å¤„ç† Rust è¦æ±‚ä½ æ‰¿è®¤é”™è¯¯çš„å¯èƒ½æ€§ï¼Œå¹¶åœ¨ä½ çš„ä»£ç ç¼–è¯‘å‰é‡‡å–ä¸€äº›è¡ŒåŠ¨ã€‚ å¯æ¢å¤çš„ recoverable: å‘ç”¨æˆ·æŠ¥å‘Šé”™è¯¯ ä½¿ç”¨ Result å¤„ç† ä¸å¯æ¢å¤çš„ unrecorverable: ç«‹å³ panic åœæ­¢ç¨‹åº ä½¿ç”¨ panic! å¤„ç† é€šè¿‡ backtrace æŸ¥çœ‹è°ƒç”¨æ ˆä¿¡æ¯ ä½¿ç”¨ Result å¤„ç†å¯æ¢å¤çš„ (recoverable) é”™è¯¯ use std::fs::File; fn main() { let greeting_file_result = File::open(\"hello.txt\"); // Result let greeting_file = match greeting_file_result { Ok(file) => file, Err(error) => panic!(\"Problem opening the file: {error:?}\"), }; } åŒ¹é…ä¸åŒçš„é”™è¯¯ use std::fs::File; use std::io::ErrorKind; fn main() { let greeting_file_result = File::open(\"hello.txt\"); let greeting_file = match greeting_file_result { Ok(file) => file, Err(error) => match error.kind() { ErrorKind::NotFound => match File::create(\"hello.txt\") { Ok(fc) => fc, Err(e) => panic!(\"Problem creating the file: {e:?}\"), }, other_error => { panic!(\"Problem opening the file: {other_error:?}\"); } }, }; } ä½¿ç”¨é—­åŒ…å’Œ unwrap_or_else æ–¹æ³• use std::fs::File; use std::io::ErrorKind; fn main() { let greeting_file = File::open(\"hello.txt\").unwrap_or_else(|error| { if error.kind() == ErrorKind::NotFound { File::create(\"hello.txt\").unwrap_or_else(|error| { panic!(\"Problem creating the file: {:?}\", error); }) } else { panic!(\"Problem opening the file: {:?}\", error); } }); } å¤±è´¥æ—¶ panic çš„ç®€å†™ï¼šunwrap å’Œ expect å¦‚æœ Result å€¼æ˜¯æˆå‘˜ Okï¼Œunwrap ä¼šè¿”å› Ok ä¸­çš„å€¼ã€‚å¦‚æœ Result æ˜¯æˆå‘˜ Errï¼Œunwrap ä¼šä¸ºæˆ‘ä»¬è°ƒç”¨ panic! use std::fs::File; fn main() { let greeting_file = File::open(\"hello.txt\").unwrap(); } expect ä¸ unwrap çš„ä½¿ç”¨æ–¹å¼ä¸€æ ·ï¼šè¿”å›æ–‡ä»¶å¥æŸ„æˆ–è°ƒç”¨ panic! å®ã€‚expect åœ¨è°ƒç”¨ panic! æ—¶ä½¿ç”¨çš„é”™è¯¯ä¿¡æ¯å°†æ˜¯æˆ‘ä»¬ä¼ é€’ç»™ expect çš„å‚æ•°ï¼Œè€Œä¸åƒ unwrap é‚£æ ·ä½¿ç”¨é»˜è®¤çš„ panic! ä¿¡æ¯ã€‚ use std::fs::File; fn main() { let greeting_file = File::open(\"hello.txt\") .expect(\"hello.txt should be included in this project\"); } ä¼ æ’­é”™è¯¯ propagating use std::fs::File; use std::io::{self, Read}; fn read_username_from_file() -> Result { let username_file_result = File::open(\"hello.txt\"); let mut username_file = match username_file_result { Ok(file) => file, Err(e) => return Err(e), }; let mut username = String::new(); match username_file.read_to_string(&mut username) { Ok(_) => Ok(username), Err(e) => Err(e), } } ä¼ æ’­é”™è¯¯çš„ç®€å†™ï¼š? è¿ç®—ç¬¦ Result å€¼ä¹‹åçš„ ? è¢«å®šä¹‰ä¸ºä¸ç¤ºä¾‹ 9-6 ä¸­å®šä¹‰çš„å¤„ç† Result å€¼çš„ match è¡¨è¾¾å¼æœ‰ç€å®Œå…¨ç›¸åŒçš„å·¥ä½œæ–¹å¼ã€‚å¦‚æœ Result çš„å€¼æ˜¯ Okï¼Œè¿™ä¸ªè¡¨è¾¾å¼å°†ä¼šè¿”å› Ok ä¸­çš„å€¼è€Œç¨‹åºå°†ç»§ç»­æ‰§è¡Œã€‚å¦‚æœå€¼æ˜¯ Errï¼ŒErr å°†ä½œä¸ºæ•´ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼Œå°±å¥½åƒä½¿ç”¨äº† return å…³é”®å­—ä¸€æ ·ï¼Œè¿™æ ·é”™è¯¯å€¼å°±è¢«ä¼ æ’­ç»™äº†è°ƒç”¨è€…ã€‚ use std::fs::File; use std::io::{self, Read}; fn read_username_from_file() -> Result { let mut username_file = File::open(\"hello.txt\")?; let mut username = String::new(); username_file.read_to_string(&mut username)?; Ok(username) } ? è¿ç®—ç¬¦æ‰€ä½¿ç”¨çš„é”™è¯¯å€¼è¢«ä¼ é€’ç»™äº† from å‡½æ•°ï¼Œå®ƒå®šä¹‰äºæ ‡å‡†åº“çš„ From trait ä¸­ï¼Œå…¶ç”¨æ¥å°†é”™è¯¯ä»ä¸€ç§ç±»å‹è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹ã€‚å½“ ? è¿ç®—ç¬¦è°ƒç”¨ from å‡½æ•°æ—¶ï¼Œæ”¶åˆ°çš„é”™è¯¯ç±»å‹è¢«è½¬æ¢ä¸ºç”±å½“å‰å‡½æ•°è¿”å›ç±»å‹æ‰€æŒ‡å®šçš„é”™è¯¯ç±»å‹ã€‚è¿™åœ¨å½“å‡½æ•°è¿”å›å•ä¸ªé”™è¯¯ç±»å‹æ¥ä»£è¡¨æ‰€æœ‰å¯èƒ½å¤±è´¥çš„æ–¹å¼æ—¶å¾ˆæœ‰ç”¨ï¼Œå³ä½¿å…¶å¯èƒ½ä¼šå› å¾ˆå¤šç§åŸå› å¤±è´¥ã€‚ æˆ‘ä»¬å¯ä»¥å°†ç¤ºä¾‹ 9-7 ä¸­çš„ read_username_from_file å‡½æ•°ä¿®æ”¹ä¸ºè¿”å›ä¸€ä¸ªè‡ªå®šä¹‰çš„ OurError é”™è¯¯ç±»å‹ã€‚å¦‚æœæˆ‘ä»¬ä¹Ÿå®šä¹‰äº† impl From for OurError æ¥ä» io::Error æ„é€ ä¸€ä¸ª OurError å®ä¾‹ï¼Œé‚£ä¹ˆ read_username_from_file å‡½æ•°ä½“ä¸­çš„ ? è¿ç®—ç¬¦è°ƒç”¨ä¼šè°ƒç”¨ from å¹¶è½¬æ¢é”™è¯¯è€Œæ— éœ€åœ¨å‡½æ•°ä¸­å¢åŠ ä»»ä½•é¢å¤–çš„ä»£ç ã€‚ æˆ‘ä»¬ç”šè‡³å¯ä»¥åœ¨ ? ä¹‹åç›´æ¥ä½¿ç”¨é“¾å¼æ–¹æ³•è°ƒç”¨æ¥è¿›ä¸€æ­¥ç¼©çŸ­ä»£ç ï¼Œå¦‚ç¤ºä¾‹ 9-8 æ‰€ç¤ºï¼š use std::fs::File; use std::io::{self, Read}; fn read_username_from_file() -> Result { let mut username = String::new(); File::open(\"hello.txt\")?.read_to_string(&mut username)?; Ok(username) } more simplify: use std::fs; use std::io; fn read_username_from_file() -> Result { fs::read_to_string(\"hello.txt\") } åœ¨ Option å€¼ä¸Šä½¿ç”¨ ? è¿ç®—ç¬¦ é”™è¯¯ä¿¡æ¯ä¹Ÿæåˆ° ? ä¹Ÿå¯ç”¨äº Option å€¼ã€‚å¦‚åŒå¯¹ Result ä½¿ç”¨ ? ä¸€æ ·ï¼Œåªèƒ½åœ¨è¿”å› Option çš„å‡½æ•°ä¸­å¯¹ Option ä½¿ç”¨ ?ã€‚åœ¨ Option ä¸Šè°ƒç”¨ ? è¿ç®—ç¬¦çš„è¡Œä¸ºä¸ Result ç±»ä¼¼ï¼šå¦‚æœå€¼æ˜¯ Noneï¼Œæ­¤æ—¶ None ä¼šä»å‡½æ•°ä¸­æå‰è¿”å›ã€‚å¦‚æœå€¼æ˜¯ Someï¼ŒSome ä¸­çš„å€¼ä½œä¸ºè¡¨è¾¾å¼çš„è¿”å›å€¼åŒæ—¶å‡½æ•°ç»§ç»­ã€‚ç¤ºä¾‹ 9-11 ä¸­æœ‰ä¸€ä¸ªä»ç»™å®šæ–‡æœ¬ä¸­è¿”å›ç¬¬ä¸€è¡Œæœ€åä¸€ä¸ªå­—ç¬¦çš„å‡½æ•°çš„ä¾‹å­ï¼š fn last_char_of_first_line(text: &str) -> Option { text.lines().next()?.chars().last() } è¿™ä¸ªå‡½æ•°è¿”å› Option å› ä¸ºå®ƒå¯èƒ½ä¼šåœ¨è¿™ä¸ªä½ç½®æ‰¾åˆ°ä¸€ä¸ªå­—ç¬¦ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰å­—ç¬¦ã€‚è¿™æ®µä»£ç è·å– text å­—ç¬¦ä¸² slice ä½œä¸ºå‚æ•°å¹¶è°ƒç”¨å…¶ lines æ–¹æ³•ï¼Œè¿™ä¼šè¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­æ¯ä¸€è¡Œçš„è¿­ä»£å™¨ã€‚å› ä¸ºå‡½æ•°å¸Œæœ›æ£€æŸ¥ç¬¬ä¸€è¡Œï¼Œæ‰€ä»¥è°ƒç”¨äº†è¿­ä»£å™¨ next æ¥è·å–è¿­ä»£å™¨ä¸­ç¬¬ä¸€ä¸ªå€¼ã€‚å¦‚æœ text æ˜¯ç©ºå­—ç¬¦ä¸²ï¼Œnext è°ƒç”¨ä¼šè¿”å› Noneï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ ? æ¥åœæ­¢å¹¶ä» last_char_of_first_line è¿”å› Noneã€‚å¦‚æœ text ä¸æ˜¯ç©ºå­—ç¬¦ä¸²ï¼Œnext ä¼šè¿”å›ä¸€ä¸ªåŒ…å« text ä¸­ç¬¬ä¸€è¡Œçš„å­—ç¬¦ä¸² slice çš„ Some å€¼ã€‚ ? ä¼šæå–è¿™ä¸ªå­—ç¬¦ä¸² sliceï¼Œç„¶åå¯ä»¥åœ¨å­—ç¬¦ä¸² slice ä¸Šè°ƒç”¨ chars æ¥è·å–å­—ç¬¦çš„è¿­ä»£å™¨ã€‚æˆ‘ä»¬æ„Ÿå…´è¶£çš„æ˜¯ç¬¬ä¸€è¡Œçš„æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œæ‰€ä»¥å¯ä»¥è°ƒç”¨ last æ¥è¿”å›è¿­ä»£å™¨çš„æœ€åä¸€é¡¹ã€‚è¿™æ˜¯ä¸€ä¸ª Optionï¼Œå› ä¸ºæœ‰å¯èƒ½ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ text ä»¥ä¸€ä¸ªç©ºè¡Œå¼€å¤´è€Œåé¢çš„è¡Œæœ‰æ–‡æœ¬ï¼Œåƒæ˜¯ \"\\nhi\"ã€‚ä¸è¿‡ï¼Œå¦‚æœç¬¬ä¸€è¡Œæœ‰æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œå®ƒä¼šè¿”å›åœ¨ä¸€ä¸ª Some æˆå‘˜ä¸­ã€‚? è¿ç®—ç¬¦ä½œç”¨äºå…¶ä¸­ç»™äº†æˆ‘ä»¬ä¸€ä¸ªç®€æ´çš„è¡¨è¾¾è¿™ç§é€»è¾‘çš„æ–¹å¼ã€‚å¦‚æœæˆ‘ä»¬ä¸èƒ½åœ¨ Option ä¸Šä½¿ç”¨ ? è¿ç®—ç¬¦ï¼Œåˆ™ä¸å¾—ä¸ä½¿ç”¨æ›´å¤šçš„æ–¹æ³•è°ƒç”¨æˆ–è€… match è¡¨è¾¾å¼æ¥å®ç°è¿™äº›é€»è¾‘ã€‚ æ³¨æ„ä½ å¯ä»¥åœ¨è¿”å› Result çš„å‡½æ•°ä¸­å¯¹ Result ä½¿ç”¨ ? è¿ç®—ç¬¦ï¼Œå¯ä»¥åœ¨è¿”å› Option çš„å‡½æ•°ä¸­å¯¹ Option ä½¿ç”¨ ? è¿ç®—ç¬¦ï¼Œä½†æ˜¯ä¸å¯ä»¥æ··åˆæ­é…ã€‚? è¿ç®—ç¬¦ä¸ä¼šè‡ªåŠ¨å°† Result è½¬åŒ–ä¸º Optionï¼Œåä¹‹äº¦ç„¶ï¼›åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œå¯ä»¥ä½¿ç”¨ç±»ä¼¼ Result çš„ ok æ–¹æ³•æˆ–è€… Option çš„ ok_or æ–¹æ³•æ¥æ˜¾å¼è½¬æ¢ã€‚ å¹¸è¿çš„æ˜¯ main å‡½æ•°ä¹Ÿå¯ä»¥è¿”å› Resultï¼Œç¤ºä¾‹ 9-12 ä¸­çš„ä»£ç æ¥è‡ªç¤ºä¾‹ 9-10 ä¸è¿‡ä¿®æ”¹äº† main çš„è¿”å›å€¼ä¸º Result> å¹¶åœ¨ç»“å°¾å¢åŠ äº†ä¸€ä¸ª Ok(()) ä½œä¸ºè¿”å›å€¼ã€‚è¿™æ®µä»£ç å¯ä»¥ç¼–è¯‘ï¼š use std::error::Error; use std::fs::File; fn main() -> Result> { let greeting_file = File::open(\"hello.txt\")?; Ok(()) } Box ç±»å‹æ˜¯ä¸€ä¸ª trait å¯¹è±¡ï¼ˆtrait objectï¼‰ç¬¬åå…«ç«  é¡¾åŠä¸åŒç±»å‹å€¼çš„ trait å¯¹è±¡â€ éƒ¨åˆ†ä¼šåšä»‹ç»ã€‚ç›®å‰å¯ä»¥å°† Box ç†è§£ä¸º â€œä»»ä½•ç±»å‹çš„é”™è¯¯â€ã€‚åœ¨è¿”å› Box é”™è¯¯ç±»å‹ main å‡½æ•°ä¸­å¯¹ Result ä½¿ç”¨ ? æ˜¯å…è®¸çš„ï¼Œå› ä¸ºå®ƒå…è®¸ä»»ä½• Err å€¼æå‰è¿”å›ã€‚å³ä¾¿ main å‡½æ•°ä½“ä»æ¥åªä¼šè¿”å› std::io::Error é”™è¯¯ç±»å‹ï¼Œé€šè¿‡æŒ‡å®š Boxï¼Œè¿™ä¸ªç­¾åä¹Ÿä»æ˜¯æ­£ç¡®çš„ï¼Œç”šè‡³å½“ main å‡½æ•°ä½“ä¸­å¢åŠ æ›´å¤šè¿”å›å…¶ä»–é”™è¯¯ç±»å‹çš„ä»£ç æ—¶ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ å½“ main å‡½æ•°è¿”å› Resultï¼Œå¦‚æœ main è¿”å› Ok(()) å¯æ‰§è¡Œç¨‹åºä¼šä»¥ 0 å€¼é€€å‡ºï¼Œè€Œå¦‚æœ main è¿”å› Err å€¼åˆ™ä¼šä»¥éé›¶å€¼é€€å‡ºï¼›æˆåŠŸé€€å‡ºçš„ç¨‹åºä¼šè¿”å›æ•´æ•° 0ï¼Œè¿è¡Œé”™è¯¯çš„ç¨‹åºä¼šè¿”å›é 0 çš„æ•´æ•°ã€‚Rust ä¹Ÿä¼šä»äºŒè¿›åˆ¶ç¨‹åºä¸­è¿”å›ä¸è¿™ä¸ªæƒ¯ä¾‹ç›¸å…¼å®¹çš„æ•´æ•°ã€‚ main å‡½æ•°ä¹Ÿå¯ä»¥è¿”å›ä»»ä½•å®ç°äº† std::process::Termination trait çš„ç±»å‹ï¼Œå®ƒåŒ…å«äº†ä¸€ä¸ªè¿”å› ExitCode çš„ report å‡½æ•°ã€‚è¯·æŸ¥é˜…æ ‡å‡†åº“æ–‡æ¡£äº†è§£æ›´å¤šä¸ºè‡ªå®šä¹‰ç±»å‹å®ç° Termination trait çš„ç»†èŠ‚ã€‚ ç°åœ¨æˆ‘ä»¬è®¨è®ºè¿‡äº†è°ƒç”¨ panic! æˆ–è¿”å› Result çš„ç»†èŠ‚ï¼Œæ˜¯æ—¶å€™å›åˆ°å®ƒä»¬å„è‡ªé€‚åˆå“ªäº›åœºæ™¯çš„è¯é¢˜äº†ã€‚ åˆ›å»ºè‡ªå®šä¹‰ç±»å‹è¿›è¡Œæœ‰æ•ˆæ€§éªŒè¯ pub struct Guess { value: i32, } impl Guess { pub fn new(value: i32) -> Guess { if value 100 { panic!(\"Guess value must be between 1 and 100, got {value}.\"); } Guess { value } } pub fn value(&self) -> i32 { self.value } } Ch10: Generic Types, Traits, and lifetimes Generic Data Types Traits: Defining Shared Behavior Validating Referenvces with Liftimes Traits trait å®šä¹‰äº†æŸä¸ªç‰¹å®šç±»å‹æ‹¥æœ‰å¯èƒ½ä¸å…¶ä»–ç±»å‹å…±äº«çš„åŠŸèƒ½ã€‚å¯ä»¥é€šè¿‡ trait ä»¥ä¸€ç§æŠ½è±¡çš„æ–¹å¼å®šä¹‰å…±åŒè¡Œä¸ºã€‚ å¯ä»¥ä½¿ç”¨ trait bounds æŒ‡å®šæ³›å‹æ˜¯ä»»ä½•æ‹¥æœ‰ç‰¹å®šè¡Œä¸ºçš„ç±»å‹ã€‚ éœ€è¦æ³¨æ„çš„é™åˆ¶æ˜¯ï¼Œåªæœ‰åœ¨ trait æˆ–ç±»å‹è‡³å°‘æœ‰ä¸€ä¸ªå±äºå½“å‰ crate æ—¶ï¼Œæˆ‘ä»¬æ‰èƒ½å¯¹ç±»å‹å®ç°è¯¥ traitã€‚ ä¾‹å¦‚ï¼Œå¯ä»¥ä¸º aggregator crate çš„è‡ªå®šä¹‰ç±»å‹ Tweet å®ç°å¦‚æ ‡å‡†åº“ä¸­çš„ Display traitï¼Œè¿™æ˜¯å› ä¸º Tweet ç±»å‹ä½äº aggregator crate æœ¬åœ°çš„ä½œç”¨åŸŸä¸­ã€‚ ç±»ä¼¼åœ°ï¼Œä¹Ÿå¯ä»¥åœ¨ aggregator crate ä¸­ä¸º Vec å®ç° Summaryï¼Œè¿™æ˜¯å› ä¸º Summary trait ä½äº aggregator crate æœ¬åœ°ä½œç”¨åŸŸä¸­ã€‚ ä½†æ˜¯ä¸èƒ½ä¸ºå¤–éƒ¨ç±»å‹å®ç°å¤–éƒ¨ traitã€‚ä¾‹å¦‚ï¼Œä¸èƒ½åœ¨ aggregator crate ä¸­ä¸º Vec å®ç° Display traitã€‚è¿™æ˜¯å› ä¸º Display å’Œ Vec éƒ½å®šä¹‰äºæ ‡å‡†åº“ä¸­ï¼Œå®ƒä»¬å¹¶ä¸ä½äº aggregator crate æœ¬åœ°ä½œç”¨åŸŸä¸­ã€‚è¿™ä¸ªé™åˆ¶æ˜¯è¢«ç§°ä¸º ç›¸å¹²æ€§ï¼ˆcoherenceï¼‰çš„ç¨‹åºå±æ€§çš„ä¸€éƒ¨åˆ†ï¼Œæˆ–è€…æ›´å…·ä½“çš„è¯´æ˜¯ å­¤å„¿è§„åˆ™ï¼ˆorphan ruleï¼‰ï¼Œå…¶å¾—åäºä¸å­˜åœ¨çˆ¶ç±»å‹ã€‚è¿™æ¡è§„åˆ™ç¡®ä¿äº†å…¶ä»–äººç¼–å†™çš„ä»£ç ä¸ä¼šç ´åä½ ä»£ç ï¼Œåä¹‹äº¦ç„¶ã€‚æ²¡æœ‰è¿™æ¡è§„åˆ™çš„è¯ï¼Œä¸¤ä¸ª crate å¯ä»¥åˆ†åˆ«å¯¹ç›¸åŒç±»å‹å®ç°ç›¸åŒçš„ traitï¼Œè€Œ Rust å°†æ— ä»å¾—çŸ¥åº”è¯¥ä½¿ç”¨å“ªä¸€ä¸ªå®ç°ã€‚ Validating Referenvces with Liftimes: ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸç¡®ä¿å¼•ç”¨æœ‰æ•ˆ ç”Ÿå‘½å‘¨æœŸé¿å…äº†æ‚¬å‚å¼•ç”¨ dangling reference å€Ÿç”¨æ£€æŸ¥å™¨ borrow checker: æ¯”è¾ƒä½œç”¨åŸŸä»¥ç¡®ä¿æ‰€æœ‰çš„å€Ÿç”¨éƒ½æ˜¯æœ‰æ•ˆçš„ å‡½æ•°ä¸­çš„æ³›å‹ç”Ÿå‘½å‘¨æœŸ ç”Ÿå‘½å‘¨æœŸæ³¨è§£è¯­æ³• å‡½æ•°ç­¾åä¸­çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£ æ·±å…¥ç†è§£ç”Ÿå‘½å‘¨æœŸ ç»“æ„ä½“å®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£ ç”Ÿå‘½å‘¨æœŸçœç•¥ Lifetime Elision æ–¹æ³•å®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£ é™æ€ç”Ÿå‘½å‘¨æœŸ ç»“åˆæ³›å‹ç±»å‹å‚æ•°ã€trait bounds å’Œç”Ÿå‘½å‘¨æœŸ æ€»ç»“ fn longest(x: &str, y: &str) -> &str { if x.len() > y.len() { x } else { y } } $ cargo run Compiling chapter10 v0.1.0 (file:///projects/chapter10) error[E0106]: missing lifetime specifier --> src/main.rs:9:33 | 9 | fn longest(x: &str, y: &str) -> &str { | ---- ---- ^ expected named lifetime parameter | = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y` help: consider introducing a named lifetime parameter | 9 | fn longest(x: &'a str, y: &'a str) -> &'a str { | ++++ ++ ++ ++ For more information about this error, try `rustc --explain E0106`. error: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error æç¤ºæ–‡æœ¬æ­ç¤ºäº†è¿”å›å€¼éœ€è¦ä¸€ä¸ªæ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œå› ä¸º Rust å¹¶ä¸çŸ¥é“å°†è¦è¿”å›çš„å¼•ç”¨æ˜¯æŒ‡å‘ x æˆ– yã€‚äº‹å®ä¸Šæˆ‘ä»¬ä¹Ÿä¸çŸ¥é“ï¼Œå› ä¸ºå‡½æ•°ä½“ä¸­ if å—è¿”å›ä¸€ä¸ª x çš„å¼•ç”¨è€Œ else å—è¿”å›ä¸€ä¸ª y çš„å¼•ç”¨ï¼ ç”Ÿå‘½å‘¨æœŸæ³¨è§£è¯­æ³• å‡½æ•°ç­¾åä¸­çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£ æˆ‘ä»¬å¸Œæœ›å‡½æ•°ç­¾åè¡¨è¾¾å¦‚ä¸‹é™åˆ¶ï¼šè¿™ä¸¤ä¸ªå‚æ•°å’Œè¿”å›çš„å¼•ç”¨å­˜æ´»çš„ä¸€æ ·ä¹…ã€‚ï¼ˆä¸¤ä¸ªï¼‰å‚æ•°å’Œè¿”å›çš„å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ç›¸å…³çš„ã€‚å°±åƒç¤ºä¾‹ 10-21 ä¸­åœ¨æ¯ä¸ªå¼•ç”¨ä¸­éƒ½åŠ ä¸Šäº† 'a é‚£æ ·ã€‚ fn longest(x: &'a str, y: &'a str) -> &'a str { if x.len() > y.len() { x } else { y } } ç°åœ¨å‡½æ•°ç­¾åè¡¨æ˜å¯¹äºæŸäº›ç”Ÿå‘½å‘¨æœŸ 'aï¼Œå‡½æ•°ä¼šè·å–ä¸¤ä¸ªå‚æ•°ï¼Œå®ƒä»¬éƒ½æ˜¯ä¸ç”Ÿå‘½å‘¨æœŸ 'a å­˜åœ¨çš„è‡³å°‘ä¸€æ ·é•¿çš„å­—ç¬¦ä¸² sliceã€‚å‡½æ•°ä¼šè¿”å›ä¸€ä¸ªåŒæ ·ä¹Ÿä¸ç”Ÿå‘½å‘¨æœŸ 'a å­˜åœ¨çš„è‡³å°‘ä¸€æ ·é•¿çš„å­—ç¬¦ä¸² sliceã€‚å®ƒçš„å®é™…å«ä¹‰æ˜¯ longest å‡½æ•°è¿”å›çš„å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¸å‡½æ•°å‚æ•°æ‰€å¼•ç”¨çš„å€¼çš„ç”Ÿå‘½å‘¨æœŸçš„è¾ƒå°è€…ä¸€è‡´ã€‚è¿™äº›å…³ç³»å°±æ˜¯æˆ‘ä»¬å¸Œæœ› Rust åˆ†æä»£ç æ—¶æ‰€ä½¿ç”¨çš„ã€‚ è®°ä½é€šè¿‡åœ¨å‡½æ•°ç­¾åä¸­æŒ‡å®šç”Ÿå‘½å‘¨æœŸå‚æ•°æ—¶ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰æ”¹å˜ä»»ä½•ä¼ å…¥å€¼æˆ–è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸï¼Œè€Œæ˜¯æŒ‡å‡ºä»»ä½•ä¸æ»¡è¶³è¿™ä¸ªçº¦æŸæ¡ä»¶çš„å€¼éƒ½å°†è¢«å€Ÿç”¨æ£€æŸ¥å™¨æ‹’ç»ã€‚æ³¨æ„ longest å‡½æ•°å¹¶ä¸éœ€è¦çŸ¥é“ x å’Œ y å…·ä½“ä¼šå­˜åœ¨å¤šä¹…ï¼Œè€Œåªéœ€è¦çŸ¥é“æœ‰æŸä¸ªå¯ä»¥è¢« 'a æ›¿ä»£çš„ä½œç”¨åŸŸå°†ä¼šæ»¡è¶³è¿™ä¸ªç­¾åã€‚ å½“åœ¨å‡½æ•°ä¸­ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸæ³¨è§£æ—¶ï¼Œè¿™äº›æ³¨è§£å‡ºç°åœ¨å‡½æ•°ç­¾åä¸­ï¼Œè€Œä¸å­˜åœ¨äºå‡½æ•°ä½“ä¸­çš„ä»»ä½•ä»£ç ä¸­ã€‚ç”Ÿå‘½å‘¨æœŸæ³¨è§£æˆä¸ºäº†å‡½æ•°çº¦å®šçš„ä¸€éƒ¨åˆ†ï¼Œéå¸¸åƒç­¾åä¸­çš„ç±»å‹ã€‚è®©å‡½æ•°ç­¾ååŒ…å«ç”Ÿå‘½å‘¨æœŸçº¦å®šæ„å‘³ç€ Rust ç¼–è¯‘å™¨çš„å·¥ä½œå˜å¾—æ›´ç®€å•äº†ã€‚å¦‚æœå‡½æ•°æ³¨è§£æœ‰è¯¯æˆ–è€…è°ƒç”¨æ–¹æ³•ä¸å¯¹ï¼Œç¼–è¯‘å™¨é”™è¯¯å¯ä»¥æ›´å‡†ç¡®åœ°æŒ‡å‡ºä»£ç å’Œé™åˆ¶çš„éƒ¨åˆ†ã€‚å¦‚æœä¸è¿™ä¹ˆåšçš„è¯ï¼ŒRust ç¼–è¯‘ä¼šå¯¹æˆ‘ä»¬æœŸæœ›çš„ç”Ÿå‘½å‘¨æœŸå…³ç³»åšæ›´å¤šçš„æ¨æ–­ï¼Œè¿™æ ·ç¼–è¯‘å™¨å¯èƒ½åªèƒ½æŒ‡å‡ºç¦»å‡ºé—®é¢˜åœ°æ–¹å¾ˆå¤šæ­¥ä¹‹å¤–çš„ä»£ç ã€‚ å½“å…·ä½“çš„å¼•ç”¨è¢«ä¼ é€’ç»™ longest æ—¶ï¼Œè¢« 'a æ‰€æ›¿ä»£çš„å…·ä½“ç”Ÿå‘½å‘¨æœŸæ˜¯ x çš„ä½œç”¨åŸŸä¸ y çš„ä½œç”¨åŸŸç›¸é‡å çš„é‚£ä¸€éƒ¨åˆ†ã€‚æ¢ä¸€ç§è¯´æ³•å°±æ˜¯æ³›å‹ç”Ÿå‘½å‘¨æœŸ 'a çš„å…·ä½“ç”Ÿå‘½å‘¨æœŸç­‰åŒäº x å’Œ y çš„ç”Ÿå‘½å‘¨æœŸä¸­è¾ƒå°çš„é‚£ä¸€ä¸ªã€‚å› ä¸ºæˆ‘ä»¬ç”¨ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸå‚æ•° 'a æ ‡æ³¨äº†è¿”å›çš„å¼•ç”¨å€¼ï¼Œæ‰€ä»¥è¿”å›çš„å¼•ç”¨å€¼å°±èƒ½ä¿è¯åœ¨ x å’Œ y ä¸­è¾ƒçŸ­çš„é‚£ä¸ªç”Ÿå‘½å‘¨æœŸç»“æŸä¹‹å‰ä¿æŒæœ‰æ•ˆã€‚ æ·±å…¥ç†è§£ç”Ÿå‘½å‘¨æœŸ å½“ä»å‡½æ•°è¿”å›ä¸€ä¸ªå¼•ç”¨ï¼Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°éœ€è¦ä¸ä¸€ä¸ªå‚æ•°çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°ç›¸åŒ¹é…ã€‚å¦‚æœè¿”å›çš„å¼•ç”¨ æ²¡æœ‰ æŒ‡å‘ä»»ä½•ä¸€ä¸ªå‚æ•°ï¼Œé‚£ä¹ˆå”¯ä¸€çš„å¯èƒ½å°±æ˜¯å®ƒæŒ‡å‘ä¸€ä¸ªå‡½æ•°å†…éƒ¨åˆ›å»ºçš„å€¼ã€‚ç„¶è€Œå®ƒå°†ä¼šæ˜¯ä¸€ä¸ªæ‚¬å‚å¼•ç”¨ï¼Œå› ä¸ºå®ƒå°†ä¼šåœ¨å‡½æ•°ç»“æŸæ—¶ç¦»å¼€ä½œç”¨åŸŸã€‚ ç»¼ä¸Šï¼Œç”Ÿå‘½å‘¨æœŸè¯­æ³•æ˜¯ç”¨äºå°†å‡½æ•°çš„å¤šä¸ªå‚æ•°ä¸å…¶è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸè¿›è¡Œå…³è”çš„ã€‚ä¸€æ—¦å®ƒä»¬å½¢æˆäº†æŸç§å…³è”ï¼ŒRust å°±æœ‰äº†è¶³å¤Ÿçš„ä¿¡æ¯æ¥å…è®¸å†…å­˜å®‰å…¨çš„æ“ä½œå¹¶é˜»æ­¢ä¼šäº§ç”Ÿæ‚¬å‚æŒ‡é’ˆäº¦æˆ–æ˜¯è¿åå†…å­˜å®‰å…¨çš„è¡Œä¸ºã€‚ ç»“æ„ä½“å®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£ struct ImportantExcerpt { part: &'a str, } fn main() { let novel = String::from(\"Call me Ishmael. Some years ago...\"); let first_sentence = novel.split('.').next().unwrap(); let i = ImportantExcerpt { part: first_sentence, }; } è¿™ä¸ªç»“æ„ä½“æœ‰å”¯ä¸€ä¸€ä¸ªå­—æ®µ partï¼Œå®ƒå­˜æ”¾äº†ä¸€ä¸ªå­—ç¬¦ä¸² sliceï¼Œè¿™æ˜¯ä¸€ä¸ªå¼•ç”¨ã€‚ç±»ä¼¼äºæ³›å‹å‚æ•°ç±»å‹ï¼Œå¿…é¡»åœ¨ç»“æ„ä½“åç§°åé¢çš„å°–æ‹¬å·ä¸­å£°æ˜æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œä»¥ä¾¿åœ¨ç»“æ„ä½“å®šä¹‰ä¸­ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå‚æ•°ã€‚è¿™ä¸ªæ³¨è§£æ„å‘³ç€ ImportantExcerpt çš„å®ä¾‹ä¸èƒ½æ¯”å…¶ part å­—æ®µä¸­çš„å¼•ç”¨å­˜åœ¨çš„æ›´ä¹…ã€‚ è¿™é‡Œçš„ main å‡½æ•°åˆ›å»ºäº†ä¸€ä¸ª ImportantExcerpt çš„å®ä¾‹ï¼Œå®ƒå­˜æ”¾äº†å˜é‡ novel æ‰€æ‹¥æœ‰çš„ String çš„ç¬¬ä¸€ä¸ªå¥å­çš„å¼•ç”¨ã€‚novel çš„æ•°æ®åœ¨ ImportantExcerpt å®ä¾‹åˆ›å»ºä¹‹å‰å°±å­˜åœ¨ã€‚å¦å¤–ï¼Œç›´åˆ° ImportantExcerpt ç¦»å¼€ä½œç”¨åŸŸä¹‹å novel éƒ½ä¸ä¼šç¦»å¼€ä½œç”¨åŸŸï¼Œæ‰€ä»¥ ImportantExcerpt å®ä¾‹ä¸­çš„å¼•ç”¨æ˜¯æœ‰æ•ˆçš„ã€‚ ç”Ÿå‘½å‘¨æœŸçœç•¥ï¼ˆLifetime Elisionï¼‰ çœç•¥è§„åˆ™å¹¶ä¸æä¾›å®Œæ•´çš„æ¨æ–­ï¼šå¦‚æœ Rust åœ¨æ˜ç¡®éµå®ˆè¿™äº›è§„åˆ™çš„å‰æä¸‹å˜é‡çš„ç”Ÿå‘½å‘¨æœŸä»ç„¶æ˜¯æ¨¡æ£±ä¸¤å¯çš„è¯ï¼Œå®ƒä¸ä¼šçŒœæµ‹å‰©ä½™å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸåº”è¯¥æ˜¯ä»€ä¹ˆã€‚ç¼–è¯‘å™¨ä¼šåœ¨å¯ä»¥é€šè¿‡å¢åŠ ç”Ÿå‘½å‘¨æœŸæ³¨è§£æ¥è§£å†³é”™è¯¯é—®é¢˜çš„åœ°æ–¹ç»™å‡ºä¸€ä¸ªé”™è¯¯æç¤ºï¼Œè€Œä¸æ˜¯è¿›è¡Œæ¨æ–­æˆ–çŒœæµ‹ã€‚ å‡½æ•°æˆ–æ–¹æ³•çš„å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸè¢«ç§°ä¸º è¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼ˆinput lifetimesï¼‰ï¼Œè€Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸè¢«ç§°ä¸º è¾“å‡ºç”Ÿå‘½å‘¨æœŸï¼ˆoutput lifetimesï¼‰ã€‚ ç¼–è¯‘å™¨é‡‡ç”¨ä¸‰æ¡è§„åˆ™æ¥åˆ¤æ–­å¼•ç”¨ä½•æ—¶ä¸éœ€è¦æ˜ç¡®çš„æ³¨è§£ã€‚ç¬¬ä¸€æ¡è§„åˆ™é€‚ç”¨äºè¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼Œåä¸¤æ¡è§„åˆ™é€‚ç”¨äºè¾“å‡ºç”Ÿå‘½å‘¨æœŸã€‚å¦‚æœç¼–è¯‘å™¨æ£€æŸ¥å®Œè¿™ä¸‰æ¡è§„åˆ™åä»ç„¶å­˜åœ¨æ²¡æœ‰è®¡ç®—å‡ºç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨ï¼Œç¼–è¯‘å™¨å°†ä¼šåœæ­¢å¹¶ç”Ÿæˆé”™è¯¯ã€‚è¿™äº›è§„åˆ™é€‚ç”¨äº fn å®šä¹‰ï¼Œä»¥åŠ impl å—ã€‚ ç¬¬ä¸€æ¡è§„åˆ™æ˜¯ç¼–è¯‘å™¨ä¸ºæ¯ä¸€ä¸ªå¼•ç”¨å‚æ•°éƒ½åˆ†é…ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°ã€‚æ¢å¥è¯è¯´å°±æ˜¯ï¼Œå‡½æ•°æœ‰ä¸€ä¸ªå¼•ç”¨å‚æ•°çš„å°±æœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼šfn foo(x: &'a i32)ï¼Œæœ‰ä¸¤ä¸ªå¼•ç”¨å‚æ•°çš„å‡½æ•°å°±æœ‰ä¸¤ä¸ªä¸åŒçš„ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œfn foo(x: &'a i32, y: &'b i32)ï¼Œä¾æ­¤ç±»æ¨ã€‚ ç¬¬äºŒæ¡è§„åˆ™æ˜¯å¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œé‚£ä¹ˆå®ƒè¢«èµ‹äºˆæ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼šfn foo(x: &'a i32) -> &'a i32ã€‚ ç¬¬ä¸‰æ¡è§„åˆ™æ˜¯å¦‚æœæ–¹æ³•æœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°å¹¶ä¸”å…¶ä¸­ä¸€ä¸ªå‚æ•°æ˜¯ &self æˆ– &mut selfï¼Œè¯´æ˜æ˜¯ä¸ªå¯¹è±¡çš„æ–¹æ³• (method)(è¯‘è€…æ³¨ï¼šè¿™é‡Œæ¶‰åŠ rust çš„é¢å‘å¯¹è±¡å‚è§ 17 ç« )ï¼Œé‚£ä¹ˆæ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°è¢«èµ‹äºˆ self çš„ç”Ÿå‘½å‘¨æœŸã€‚ç¬¬ä¸‰æ¡è§„åˆ™ä½¿å¾—æ–¹æ³•æ›´å®¹æ˜“è¯»å†™ï¼Œå› ä¸ºåªéœ€æ›´å°‘çš„ç¬¦å·ã€‚ æ–¹æ³•å®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£ impl ImportantExcerpt { fn announce_and_return_part(&self, announcement: &str) -> &str { println!(\"Attention please: {announcement}\"); self.part } } é™æ€ç”Ÿå‘½å‘¨æœŸ 'staticï¼Œå…¶ç”Ÿå‘½å‘¨æœŸèƒ½å¤Ÿå­˜æ´»äºæ•´ä¸ªç¨‹åºæœŸé—´ã€‚æ‰€æœ‰çš„å­—ç¬¦ä¸²å­—é¢å€¼éƒ½æ‹¥æœ‰ 'static ç”Ÿå‘½å‘¨æœŸ ç»“åˆæ³›å‹ç±»å‹å‚æ•°ã€trait bounds å’Œç”Ÿå‘½å‘¨æœŸ use std::fmt::Display; fn longest_with_an_announcement( x: &'a str, y: &'a str, ann: T, ) -> &'a str where T: Display, { println!(\"Announcement! {ann}\"); if x.len() > y.len() { x } else { y } } æ³›å‹ç±»å‹å‚æ•°æ„å‘³ç€ä»£ç å¯ä»¥é€‚ç”¨äºä¸åŒçš„ç±»å‹ã€‚trait å’Œ trait bounds ä¿è¯äº†å³ä½¿ç±»å‹æ˜¯æ³›å‹çš„ï¼Œè¿™äº›ç±»å‹ä¹Ÿä¼šæ‹¥æœ‰æ‰€éœ€è¦çš„è¡Œä¸ºã€‚ç”±ç”Ÿå‘½å‘¨æœŸæ³¨è§£æ‰€æŒ‡å®šçš„å¼•ç”¨ç”Ÿå‘½å‘¨æœŸä¹‹é—´çš„å…³ç³»ä¿è¯äº†è¿™äº›çµæ´»å¤šå˜çš„ä»£ç ä¸ä¼šå‡ºç°æ‚¬å‚å¼•ç”¨ã€‚è€Œæ‰€æœ‰çš„è¿™ä¸€åˆ‡å‘ç”Ÿåœ¨ç¼–è¯‘æ—¶æ‰€ä»¥ä¸ä¼šå½±å“è¿è¡Œæ—¶æ•ˆç‡ï¼ Ch11: Writing Automated Tests How to write Controlling How Tests Are Run Test Orgnizations How to write tests ç¼–å†™æµ‹è¯•å‡½æ•°ï¼š è®¾ç½®ä»»ä½•æ‰€éœ€çš„æ•°æ®æˆ–çŠ¶æ€ è¿è¡Œéœ€è¦æµ‹è¯•çš„ä»£ç  æ–­è¨€å…¶ç»“æœæ˜¯æˆ‘ä»¬æ‰€æœŸæœ›çš„ Rust æä¾›çš„æµ‹è¯•åŠŸèƒ½ï¼štest Attribute, some Macros, and should_panic Attribute. Example: pub fn add(left: usize, right: usize) -> usize { left + right } #[cfg(test)] mod tests { use super::*; #[test] fn it_works() { let result = add(2, 2); assert_eq!(result, 4); } } #[cfg(test)]: æ ‡è®°æ¨¡å—ä¸ºæµ‹è¯•æ¨¡å—ï¼Œåªæœ‰åœ¨è¿è¡Œ cargo test æ—¶æ‰ä¼šç¼–è¯‘å’Œè¿è¡Œæµ‹è¯•ä»£ç ã€‚ use super::*;: å¯¼å…¥çˆ¶æ¨¡å—ï¼Œè¿™æ ·å¯ä»¥ç›´æ¥è°ƒç”¨çˆ¶æ¨¡å—ä¸­çš„å‡½æ•°ã€‚ #[test]: æ ‡è®°å‡½æ•°ä¸ºæµ‹è¯•å‡½æ•°ï¼Œåªæœ‰åœ¨è¿è¡Œ cargo test æ—¶æ‰ä¼šè¿è¡Œæµ‹è¯•å‡½æ•°ã€‚ assert_eq!(result, 4);: æ–­è¨€å‡½æ•°çš„è¿”å›å€¼ç­‰äº 4ã€‚ cargo test: è¿è¡Œæµ‹è¯•ã€‚ assert!(expression): æ–­è¨€è¡¨è¾¾å¼ä¸º trueã€‚ assert_ne!(exp1, exp2): æ–­è¨€è¡¨è¾¾å¼ exp1 != exp2ã€‚ assert_eq!(exp1, exp2): æ–­è¨€è¡¨è¾¾å¼ exp1 == exp2ã€‚ assert_approx_eq!(exp1, exp2, epsilon): æ–­è¨€è¡¨è¾¾å¼ exp1 ä¸ exp2 å·®å€¼å°äºç­‰äº epsilonã€‚ assert_ne_precise!(exp1, exp2): æ–­è¨€è¡¨è¾¾å¼ exp1 ä¸ exp2 å·®å€¼å¤§äº f32::EPSILON æˆ– f64::EPSILONã€‚ assert_xx(abc, def, info): æ–­è¨€ abc ä¸ def xxï¼Œinfo ä¸ºé™„åŠ å¤±è´¥ä¿¡æ¯ã€‚ pub struct Guess { value: i32, } impl Guess { pub fn new(value: i32) -> Guess { if value 100 { panic!( \"Guess value must be greater than or equal to 1, got {value}.\" ); } Guess { value } } } #[cfg(test)] mod tests { use super::*; #[test] #[should_panic] fn greater_than_100() { Guess::new(200); } #[test] #[should_panic(expected = \"less than or equal to 100\")] fn greater_than_100_second() { Guess::new(200); } } #[should_panic]: æ ‡è®°æµ‹è¯•å‡½æ•°æœŸæœ› panicã€‚ #[should_panic(expected = \"less than or equal to 100\")]: æ ‡è®°æµ‹è¯•å‡½æ•°æœŸæœ› panic ä¿¡æ¯åŒ…å« \"less than or equal to 100\"ã€‚ å°† Result ç”¨äºæµ‹è¯• pub fn add(left: usize, right: usize) -> usize { left + right } #[cfg(test)] mod tests { use super::*; // ANCHOR: here #[test] fn it_works() -> Result { let result = add(2, 2); if result == 4 { Ok(()) } else { Err(String::from(\"two plus two does not equal four\")) } } // ANCHOR_END: here } it_works å‡½æ•°è¿”å› Result ç±»å‹ æµ‹è¯•å‡½æ•°ä½“åœ¨æµ‹è¯•é€šè¿‡æ—¶è¿”å› Ok(())ï¼Œæµ‹è¯•å¤±è´¥æ—¶è¿”å› Err(String) Controlling How Tests Are Run å¯ä»¥å°†ä¸€éƒ¨åˆ†å‘½ä»¤è¡Œå‚æ•°ä¼ é€’ç»™ cargo testï¼Œè€Œå°†å¦å¤–ä¸€éƒ¨åˆ†ä¼ é€’ç»™ç”Ÿæˆçš„æµ‹è¯•äºŒè¿›åˆ¶æ–‡ä»¶ã€‚ ä¸ºäº†åˆ†éš”è¿™ä¸¤ç§å‚æ•°ï¼Œéœ€è¦å…ˆåˆ—å‡ºä¼ é€’ç»™ cargo test çš„å‚æ•°ï¼Œæ¥ç€æ˜¯åˆ†éš”ç¬¦ --ï¼Œå†ä¹‹åæ˜¯ä¼ é€’ç»™æµ‹è¯•äºŒè¿›åˆ¶æ–‡ä»¶çš„å‚æ•°ã€‚ è¿è¡Œ cargo test --help ä¼šæç¤º cargo test çš„æœ‰å…³å‚æ•°ï¼Œè€Œè¿è¡Œ cargo test -- --help å¯ä»¥æç¤ºåœ¨åˆ†éš”ç¬¦ä¹‹åä½¿ç”¨çš„æœ‰å…³å‚æ•°ã€‚ å¹¶è¡Œæˆ–è¿ç»­çš„è¿è¡Œæµ‹è¯• cargo test -- --test-threads=1 æ˜¾ç¤ºå‡½æ•°è¾“å‡º cargo test -- --show-output é€šè¿‡æŒ‡å®šåå­—æ¥è¿è¡Œéƒ¨åˆ†æµ‹è¯• cargo test one_hundred: è¿è¡Œåä¸º one_hundred çš„æµ‹è¯•å‡½æ•° cargo test add: æŒ‡å®šéƒ¨åˆ†æµ‹è¯•çš„åç§°ï¼Œè¿è¡Œæ‰€æœ‰åç§°ä¸­åŒ…å« add çš„æµ‹è¯•å‡½æ•° é™¤éç‰¹åˆ«æŒ‡å®šå¦åˆ™å¿½ç•¥æŸäº›æµ‹è¯• #[ignore]ï¼šæ ‡è®°æµ‹è¯•å‡½æ•°ä¸ºå¿½ç•¥çš„æµ‹è¯•å‡½æ•°ã€‚ cargo test -- --ignoredï¼šè¿è¡Œæ‰€æœ‰è¢«æ ‡è®°ä¸ºå¿½ç•¥çš„æµ‹è¯•å‡½æ•°ã€‚ cargo test -- --include-ignoredï¼šè¿è¡Œæ‰€æœ‰æµ‹è¯•å‡½æ•°ï¼ŒåŒ…æ‹¬è¢«æ ‡è®°ä¸ºå¿½ç•¥çš„æµ‹è¯•å‡½æ•°ã€‚ Ch12: An I/O Project parse cmd args read the file reconstruct: dispatch tests driver' env variables stderr äºŒè¿›åˆ¶é¡¹ç›®çš„å…³æ³¨åˆ†ç¦» main å‡½æ•°è´Ÿè´£å¤šä¸ªä»»åŠ¡çš„ç»„ç»‡é—®é¢˜åœ¨è®¸å¤šäºŒè¿›åˆ¶é¡¹ç›®ä¸­å¾ˆå¸¸è§ã€‚æ‰€ä»¥ Rust ç¤¾åŒºå¼€å‘å‡ºä¸€ç±»åœ¨ main å‡½æ•°å¼€å§‹å˜å¾—åºå¤§æ—¶è¿›è¡ŒäºŒè¿›åˆ¶ç¨‹åºçš„å…³æ³¨åˆ†ç¦»çš„æŒ‡å¯¼ã€‚è¿™äº›è¿‡ç¨‹æœ‰å¦‚ä¸‹æ­¥éª¤ï¼š å°†ç¨‹åºæ‹†åˆ†æˆ main.rs å’Œ lib.rs å¹¶å°†ç¨‹åºçš„é€»è¾‘æ”¾å…¥ lib.rs ä¸­ã€‚ å½“å‘½ä»¤è¡Œè§£æé€»è¾‘æ¯”è¾ƒå°æ—¶ï¼Œå¯ä»¥ä¿ç•™åœ¨ main.rs ä¸­ã€‚ å½“å‘½ä»¤è¡Œè§£æå¼€å§‹å˜å¾—å¤æ‚æ—¶ï¼Œä¹ŸåŒæ ·å°†å…¶ä» main.rs æå–åˆ° lib.rs ä¸­ã€‚ ç»è¿‡è¿™äº›è¿‡ç¨‹ä¹‹åä¿ç•™åœ¨ main å‡½æ•°ä¸­çš„è´£ä»»åº”è¯¥è¢«é™åˆ¶ä¸ºï¼š ä½¿ç”¨å‚æ•°å€¼è°ƒç”¨å‘½ä»¤è¡Œè§£æé€»è¾‘ è®¾ç½®ä»»ä½•å…¶ä»–çš„é…ç½® è°ƒç”¨ lib.rs ä¸­çš„ run å‡½æ•° å¦‚æœ run è¿”å›é”™è¯¯ï¼Œåˆ™å¤„ç†è¿™ä¸ªé”™è¯¯ è¿™ä¸ªæ¨¡å¼çš„ä¸€åˆ‡å°±æ˜¯ä¸ºäº†å…³æ³¨åˆ†ç¦»ï¼šmain.rs å¤„ç†ç¨‹åºè¿è¡Œï¼Œè€Œ lib.rs å¤„ç†æ‰€æœ‰çš„çœŸæ­£çš„ä»»åŠ¡é€»è¾‘ã€‚å› ä¸ºä¸èƒ½ç›´æ¥æµ‹è¯• main å‡½æ•°ï¼Œè¿™ä¸ªç»“æ„é€šè¿‡å°†æ‰€æœ‰çš„ç¨‹åºé€»è¾‘ç§»åŠ¨åˆ° lib.rs çš„å‡½æ•°ä¸­ä½¿å¾—æˆ‘ä»¬å¯ä»¥æµ‹è¯•å®ƒä»¬ã€‚ä»…ä»…ä¿ç•™åœ¨ main.rs ä¸­çš„ä»£ç å°†è¶³å¤Ÿå°ä»¥ä¾¿é˜…è¯»å°±å¯ä»¥éªŒè¯å…¶æ­£ç¡®æ€§ã€‚ Ch13: Functional Language Features: Iterators and Closures Closures: Anonymous Functions that capture their Environment Iterators Ch14: More about Cargo and Creates.io Ch15: Smart Pointers Using Box to Point to Data on the Heap Treating Smart Pointers Like Regular References with the Deref Trait Running Code on Cleanup with Drop Trait Rc, the Reference Counted Smart Pointer RefCell and the Interior Mutability Pattern å†…éƒ¨å¯å˜æ€§æ¨¡å¼ Reference Cycles Can Leak Memory å¾ªç¯å¼•ç”¨ä¼šå¯¼è‡´å†…å­˜æ³„æ¼ æ™ºèƒ½æŒ‡é’ˆï¼Œå¦ä¸€æ–¹é¢ï¼Œæ˜¯ä¸€ç§ç±»ä¼¼äºæŒ‡é’ˆçš„æ•°æ®ç»“æ„ï¼Œä½†è¿˜å…·æœ‰é¢å¤–çš„å…ƒæ•°æ®å’ŒåŠŸèƒ½ã€‚æ™ºèƒ½æŒ‡é’ˆçš„æ¦‚å¿µå¹¶éç‰¹æœ‰äº Rustï¼šæ™ºèƒ½æŒ‡é’ˆèµ·æºäº C++ï¼Œä¹Ÿå­˜åœ¨äºå…¶ä»–è¯­è¨€ä¸­ã€‚Rust æ ‡å‡†åº“ä¸­å®šä¹‰äº†å„ç§æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒä»¬æä¾›çš„åŠŸèƒ½è¶…è¶Šäº†å¼•ç”¨æ‰€èƒ½æä¾›çš„ã€‚ä¸ºäº†æ¢è®¨ä¸€èˆ¬æ¦‚å¿µï¼Œæˆ‘ä»¬å°†æŸ¥çœ‹å‡ ä¸ªä¸åŒçš„æ™ºèƒ½æŒ‡é’ˆç¤ºä¾‹ï¼ŒåŒ…æ‹¬å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆç±»å‹ã€‚æ­¤æŒ‡é’ˆå…è®¸æ‚¨é€šè¿‡è·Ÿè¸ªæ‰€æœ‰è€…çš„æ•°é‡æ¥å…è®¸æ•°æ®æœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼Œå½“æ²¡æœ‰æ‰€æœ‰è€…æ—¶ï¼Œæ¸…ç†æ•°æ®ã€‚ Rust æ‹¥æœ‰æ‰€æœ‰æƒå’Œå€Ÿç”¨æ¦‚å¿µï¼Œåœ¨å¼•ç”¨å’Œæ™ºèƒ½æŒ‡é’ˆä¹‹é—´æœ‰é¢å¤–çš„åŒºåˆ«ï¼šå¼•ç”¨ä»…å€Ÿç”¨æ•°æ®ï¼Œè€Œåœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œæ™ºèƒ½æŒ‡é’ˆæ‹¥æœ‰å®ƒä»¬æ‰€æŒ‡å‘çš„æ•°æ®ã€‚ æ™ºèƒ½æŒ‡é’ˆé€šå¸¸ä½¿ç”¨ç»“æ„ä½“å®ç°ã€‚æ™ºèƒ½æŒ‡é’ˆä¸åŒäºç»“æ„ä½“çš„åœ°æ–¹åœ¨äºå…¶å®ç°äº† Deref å’Œ Drop traitã€‚Deref trait å…è®¸æ™ºèƒ½æŒ‡é’ˆç»“æ„ä½“å®ä¾‹è¡¨ç°çš„åƒå¼•ç”¨ä¸€æ ·ï¼Œè¿™æ ·å°±å¯ä»¥ç¼–å†™æ—¢ç”¨äºå¼•ç”¨ã€åˆç”¨äºæ™ºèƒ½æŒ‡é’ˆçš„ä»£ç ã€‚Drop trait å…è®¸æˆ‘ä»¬è‡ªå®šä¹‰å½“æ™ºèƒ½æŒ‡é’ˆç¦»å¼€ä½œç”¨åŸŸæ—¶è¿è¡Œçš„ä»£ç ã€‚ è¿™é‡Œå°†ä¼šè®²åˆ°çš„æ˜¯æ¥è‡ªæ ‡å‡†åº“ä¸­æœ€å¸¸ç”¨çš„ä¸€äº›ï¼š Boxï¼Œç”¨äºåœ¨å †ä¸Šåˆ†é…å€¼ Rcï¼Œä¸€ä¸ªå¼•ç”¨è®¡æ•°ç±»å‹ï¼Œå…¶æ•°æ®å¯ä»¥æœ‰å¤šä¸ªæ‰€æœ‰è€… Ref å’Œ RefMutï¼Œé€šè¿‡ RefCell è®¿é—®ã€‚ï¼ˆ RefCell æ˜¯ä¸€ä¸ªåœ¨è¿è¡Œæ—¶è€Œä¸æ˜¯åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œå€Ÿç”¨è§„åˆ™çš„ç±»å‹ï¼‰ã€‚ å¦å¤–æˆ‘ä»¬ä¼šæ¶‰åŠ å†…éƒ¨å¯å˜æ€§ï¼ˆinterior mutabilityï¼‰æ¨¡å¼ï¼Œè¿™æ˜¯ä¸å¯å˜ç±»å‹æš´éœ²å‡ºæ”¹å˜å…¶å†…éƒ¨å€¼çš„ APIã€‚ æˆ‘ä»¬ä¹Ÿä¼šè®¨è®º å¼•ç”¨å¾ªç¯ï¼ˆreference cyclesï¼‰ä¼šå¦‚ä½•æ³„æ¼å†…å­˜ï¼Œä»¥åŠå¦‚ä½•é¿å…ã€‚ Box Box ç±»å‹æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œå› ä¸ºå®ƒå®ç°äº† Deref traitï¼Œå®ƒå…è®¸ Box å€¼è¢«å½“ä½œå¼•ç”¨å¯¹å¾…ã€‚å½“ Box å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œç”±äº Box ç±»å‹ Drop trait çš„å®ç°ï¼Œbox æ‰€æŒ‡å‘çš„å †æ•°æ®ä¹Ÿä¼šè¢«æ¸…é™¤ã€‚è¿™ä¸¤ä¸ª trait å¯¹äºåœ¨æœ¬ç« ä½™ä¸‹è®¨è®ºçš„å…¶ä»–æ™ºèƒ½æŒ‡é’ˆæ‰€æä¾›çš„åŠŸèƒ½ä¸­ï¼Œå°†ä¼šæ›´ä¸ºé‡è¦ã€‚è®©æˆ‘ä»¬æ›´è¯¦ç»†çš„æ¢ç´¢ä¸€ä¸‹è¿™ä¸¤ä¸ª traitã€‚ é€šè¿‡ Deref trait å°†æ™ºèƒ½æŒ‡é’ˆå½“ä½œå¸¸è§„å¼•ç”¨å¤„ç† ä¸ºäº†å¯ç”¨ * è¿ç®—ç¬¦çš„è§£å¼•ç”¨åŠŸèƒ½ï¼Œéœ€è¦å®ç° Deref traitã€‚ æ¯æ¬¡å½“æˆ‘ä»¬åœ¨ä»£ç ä¸­ä½¿ç”¨ * æ—¶ï¼Œ * è¿ç®—ç¬¦éƒ½è¢«æ›¿æ¢æˆäº†å…ˆè°ƒç”¨ deref æ–¹æ³•å†æ¥ç€ä½¿ç”¨ * è§£å¼•ç”¨çš„æ“ä½œï¼Œä¸”åªä¼šå‘ç”Ÿä¸€æ¬¡ï¼Œä¸ä¼šå¯¹ * æ“ä½œç¬¦æ— é™é€’å½’æ›¿æ¢ï¼Œè§£å¼•ç”¨å‡ºä¸Šé¢ i32 ç±»å‹çš„å€¼å°±åœæ­¢äº†ï¼Œè¿™ä¸ªå€¼ä¸ç¤ºä¾‹ 15-9 ä¸­ assert_eq! çš„ 5 ç›¸åŒ¹é…ã€‚ å‡½æ•°å’Œæ–¹æ³•çš„éšå¼ Deref å¼ºåˆ¶è½¬æ¢ Deref å¼ºåˆ¶è½¬æ¢ï¼ˆderef coercionsï¼‰å°†å®ç°äº† Deref trait çš„ç±»å‹çš„å¼•ç”¨è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹çš„å¼•ç”¨ã€‚ä¾‹å¦‚ï¼ŒDeref å¼ºåˆ¶è½¬æ¢å¯ä»¥å°† &String è½¬æ¢ä¸º &strï¼Œå› ä¸º String å®ç°äº† Deref trait å› æ­¤å¯ä»¥è¿”å› &strã€‚Deref å¼ºåˆ¶è½¬æ¢æ˜¯ Rust åœ¨å‡½æ•°æˆ–æ–¹æ³•ä¼ å‚ä¸Šçš„ä¸€ç§ä¾¿åˆ©æ“ä½œï¼Œå¹¶ä¸”åªèƒ½ä½œç”¨äºå®ç°äº† Deref trait çš„ç±»å‹ã€‚å½“è¿™ç§ç‰¹å®šç±»å‹çš„å¼•ç”¨ä½œä¸ºå®å‚ä¼ é€’ç»™å’Œå½¢å‚ç±»å‹ä¸åŒçš„å‡½æ•°æˆ–æ–¹æ³•æ—¶å°†è‡ªåŠ¨è¿›è¡Œã€‚è¿™æ—¶ä¼šæœ‰ä¸€ç³»åˆ—çš„ deref æ–¹æ³•è¢«è°ƒç”¨ï¼ŒæŠŠæˆ‘ä»¬æä¾›çš„ç±»å‹è½¬æ¢æˆäº†å‚æ•°æ‰€éœ€çš„ç±»å‹ã€‚ Deref å¼ºåˆ¶è½¬æ¢çš„åŠ å…¥ä½¿å¾— Rust ç¨‹åºå‘˜ç¼–å†™å‡½æ•°å’Œæ–¹æ³•è°ƒç”¨æ—¶æ— éœ€å¢åŠ è¿‡å¤šæ˜¾å¼ä½¿ç”¨ & å’Œ * çš„å¼•ç”¨å’Œè§£å¼•ç”¨ã€‚è¿™ä¸ªåŠŸèƒ½ä¹Ÿä½¿å¾—æˆ‘ä»¬å¯ä»¥ç¼–å†™æ›´å¤šåŒæ—¶ä½œç”¨äºå¼•ç”¨æˆ–æ™ºèƒ½æŒ‡é’ˆçš„ä»£ç ã€‚ Deref å¼ºåˆ¶è½¬æ¢å¦‚ä½•ä¸å¯å˜æ€§äº¤äº’ ç±»ä¼¼äºå¦‚ä½•ä½¿ç”¨ Deref trait é‡è½½ä¸å¯å˜å¼•ç”¨çš„ * è¿ç®—ç¬¦ï¼ŒRust æä¾›äº† DerefMut trait ç”¨äºé‡è½½å¯å˜å¼•ç”¨çš„ * è¿ç®—ç¬¦ã€‚ Rust åœ¨å‘ç°ç±»å‹å’Œ trait å®ç°æ»¡è¶³ä¸‰ç§æƒ…å†µæ—¶ä¼šè¿›è¡Œ Deref å¼ºåˆ¶è½¬æ¢ï¼š å½“ T: Deref æ—¶ä» &T åˆ° &Uã€‚ å½“ T: DerefMut æ—¶ä» &mut T åˆ° &mut Uã€‚ å½“ T: Deref æ—¶ä» &mut T åˆ° &Uã€‚ å¤´ä¸¤ä¸ªæƒ…å†µé™¤äº†ç¬¬äºŒç§å®ç°äº†å¯å˜æ€§ä¹‹å¤–æ˜¯ç›¸åŒçš„ï¼šç¬¬ä¸€ç§æƒ…å†µè¡¨æ˜å¦‚æœæœ‰ä¸€ä¸ª &Tï¼Œè€Œ T å®ç°äº†è¿”å› U ç±»å‹çš„ Derefï¼Œåˆ™å¯ä»¥ç›´æ¥å¾—åˆ° &Uã€‚ç¬¬äºŒç§æƒ…å†µè¡¨æ˜å¯¹äºå¯å˜å¼•ç”¨ä¹Ÿæœ‰ç€ç›¸åŒçš„è¡Œä¸ºã€‚ ç¬¬ä¸‰ä¸ªæƒ…å†µæœ‰äº›å¾®å¦™ï¼šRust ä¹Ÿä¼šå°†å¯å˜å¼•ç”¨å¼ºè½¬ä¸ºä¸å¯å˜å¼•ç”¨ã€‚ä½†æ˜¯åä¹‹æ˜¯ ä¸å¯èƒ½ çš„ï¼šä¸å¯å˜å¼•ç”¨æ°¸è¿œä¹Ÿä¸èƒ½å¼ºè½¬ä¸ºå¯å˜å¼•ç”¨ã€‚å› ä¸ºæ ¹æ®å€Ÿç”¨è§„åˆ™ï¼Œå¦‚æœæœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œå…¶å¿…é¡»æ˜¯è¿™äº›æ•°æ®çš„å”¯ä¸€å¼•ç”¨ï¼ˆå¦åˆ™ç¨‹åºå°†æ— æ³•ç¼–è¯‘ï¼‰ã€‚å°†ä¸€ä¸ªå¯å˜å¼•ç”¨è½¬æ¢ä¸ºä¸å¯å˜å¼•ç”¨æ°¸è¿œä¹Ÿä¸ä¼šæ‰“ç ´å€Ÿç”¨è§„åˆ™ã€‚å°†ä¸å¯å˜å¼•ç”¨è½¬æ¢ä¸ºå¯å˜å¼•ç”¨åˆ™éœ€è¦åˆå§‹çš„ä¸å¯å˜å¼•ç”¨æ˜¯æ•°æ®å”¯ä¸€çš„ä¸å¯å˜å¼•ç”¨ï¼Œè€Œå€Ÿç”¨è§„åˆ™æ— æ³•ä¿è¯è¿™ä¸€ç‚¹ã€‚å› æ­¤ï¼ŒRust æ— æ³•å‡è®¾å°†ä¸å¯å˜å¼•ç”¨è½¬æ¢ä¸ºå¯å˜å¼•ç”¨æ˜¯å¯èƒ½çš„ã€‚ ä½¿ç”¨ Drop Trait è¿è¡Œæ¸…ç†ä»£ç  ... Rc å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆ RefCell å’Œå†…éƒ¨å¯å˜æ€§æ¨¡å¼ Ch16: Fearless Concurrency Ch17: Object Oriented Programming Features in Rust é¢å‘å¯¹è±¡è¯­è¨€ç‰¹ç‚¹ é¡¾åŠä¸åŒç±»å‹å€¼çš„ trait å¯¹è±¡ é¢å‘å¯¹è±¡è®¾è®¡æ¨¡å¼çš„å®ç° Ch18: Patterns and Maching Ch19: Advanced Features Ch20: Building a Multithreaded WebServer "},"Learn/PersonalWebsite/Jekyll.html":{"url":"Learn/PersonalWebsite/Jekyll.html","title":"Jekyll","keywords":"","body":"Jekyll Transform your plain text into static websites and blogs.\\ å°†çº¯æ–‡æœ¬è½¬æ¢ä¸ºé™æ€ç½‘ç«™å’Œåšå®¢ã€‚ Jekyll is a static site generator that runs on the Ruby programming language. Simple ç®€å•çš„ No more databases, comment moderation, or pesky updates to installâ€”just your content. ä¸å†éœ€è¦å®‰è£…æ•°æ®åº“ã€è¯„è®ºå®¡æ ¸æˆ–çƒ¦äººçš„æ›´æ–°ï¼Œåªéœ€å®‰è£…æ‚¨çš„å†…å®¹ã€‚ How Jekyll works Static é™æ­¢çš„ Markdown, Liquid, HTML & CSS go in. Static sites come out ready for deployment. åŠ å…¥Markdown ã€ Liquid ã€HTML å’Œ CSSã€‚é™æ€ç«™ç‚¹å‡ºæ¥åå³å¯éƒ¨ç½²ã€‚ Jekyll template guide Blog-aware åšå®¢æ„è¯† Permalinks, categories, pages, posts, and custom layouts are all first-class citizens here. æ°¸ä¹…é“¾æ¥ã€ç±»åˆ«ã€é¡µé¢ã€å¸–å­å’Œè‡ªå®šä¹‰å¸ƒå±€åœ¨è¿™é‡Œéƒ½æ˜¯ä¸€ç­‰å…¬æ°‘ã€‚ Migrate your blog Running in seconds, Quickstart: # make sure satisfy the [prerequisites](https://jekyllrb.com/docs/installation/#requirements) # on Debian: sudo apt-get install ruby-full build-essential # on Ubuntu: sudo apt-get install ruby-full build-essential zlib1g-dev # Install the jekyll and bundler gems gem install bundler jekyll jekyll new my-awesome-site cd my-awesome-site bundle exec jekyll serve # --livereload # => Now browse to http://localhost:4000 Problems: gem install bundler jekyll # Error: # /usr/bin/ruby3.1 -I /usr/lib/ruby/vendor_ruby -r ./siteconf20241228-103530-c2f02s.rb extconf.rb # mkmf.rb can't find header files for ruby at /usr/lib/ruby/include/ruby.h # Solution: sudo apt install ruby-dev # Error # sudo gem install jekyll # Net::OpenTimeout: Failed to open TCP connection to github.com:443 (Connection timed out - user specified timeout) # Solution: # network error, just use proxy. "},"Learn/PersonalWebsite/Note.html":{"url":"Learn/PersonalWebsite/Note.html","title":"Note","keywords":"","body":"Note How to Create a Static Website with Jekyll Andrej Karpathy blog - 2014 Why you (yes, you) should blog - 2017 Hexo Theme Nexmoe pages.github hhw-google-blogger Static Site Generator A static site generator builds a website using plain HTML files. When a user visits a website created by a static site generator, it is loaded no differently than if you had created a website with plain HTML. By contrast, a dynamic site running on a server side language, such as PHP, must be built every time a user visits the site. é™æ€ç«™ç‚¹ç”Ÿæˆå™¨ä½¿ç”¨çº¯ HTML æ–‡ä»¶æ„å»ºç½‘ç«™ã€‚å½“ç”¨æˆ·è®¿é—®ç”±é™æ€ç½‘ç«™ç”Ÿæˆå™¨åˆ›å»ºçš„ç½‘ç«™æ—¶ï¼Œå…¶åŠ è½½æ–¹å¼ä¸æ‚¨ä½¿ç”¨çº¯ HTML åˆ›å»ºç½‘ç«™æ—¶æ²¡æœ‰ä»€ä¹ˆä¸åŒã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨æœåŠ¡å™¨ç«¯è¯­è¨€ï¼ˆä¾‹å¦‚ PHPï¼‰ä¸Šè¿è¡Œçš„åŠ¨æ€ç«™ç‚¹å¿…é¡»åœ¨ç”¨æˆ·æ¯æ¬¡è®¿é—®è¯¥ç«™ç‚¹æ—¶æ„å»ºã€‚ You can treat a static site generator as a very simple sort of CMS (content management system). Instead of having to include your entire header and footer on every page, for example, you can create a header.html and footer.html and load them into each page. Instead of having to write in HTML, you can write in Markdown, which is much faster and more efficient. æ‚¨å¯ä»¥å°†é™æ€ç«™ç‚¹ç”Ÿæˆå™¨è§†ä¸ºä¸€ç§éå¸¸ç®€å•çš„ CMSï¼ˆå†…å®¹ç®¡ç†ç³»ç»Ÿï¼‰ã€‚ä¾‹å¦‚ï¼Œæ‚¨ä¸å¿…åœ¨æ¯ä¸ªé¡µé¢ä¸ŠåŒ…å«æ•´ä¸ªé¡µçœ‰å’Œé¡µè„šï¼Œæ‚¨å¯ä»¥åˆ›å»º header.html å’Œ footer.html å¹¶å°†å®ƒä»¬åŠ è½½åˆ°æ¯ä¸ªé¡µé¢ä¸­ã€‚æ‚¨ä¸å¿…ä½¿ç”¨ HTML ç¼–å†™ï¼Œè€Œæ˜¯å¯ä»¥ä½¿ç”¨ Markdown ç¼–å†™ï¼Œè¿™æ ·æ›´å¿«ã€æ›´é«˜æ•ˆã€‚ Here are some of the main advantages of static site generators over dynamic sites:ä»¥ä¸‹æ˜¯é™æ€ç«™ç‚¹ç”Ÿæˆå™¨ç›¸å¯¹äºåŠ¨æ€ç«™ç‚¹çš„ä¸€äº›ä¸»è¦ä¼˜ç‚¹ï¼š Speed: your website will perform much faster, as the server does not need to parse any content. It only needs to read plain HTML. é€Ÿåº¦: æ‚¨çš„ç½‘ç«™å°†æ‰§è¡Œå¾—æ›´å¿«ï¼Œå› ä¸ºæœåŠ¡å™¨ä¸éœ€è¦è§£æä»»ä½•å†…å®¹ã€‚å®ƒåªéœ€è¦è¯»å–çº¯ HTMLã€‚ Security: your website will be much less vulnerable to attacks, since there is nothing that can be exploited server side. å®‰å…¨æ€§: æ‚¨çš„ç½‘ç«™å°†æ›´ä¸å®¹æ˜“å—åˆ°æ”»å‡»ï¼Œå› ä¸ºæœåŠ¡å™¨ç«¯æ²¡æœ‰ä»»ä½•ä¸œè¥¿å¯ä»¥è¢«åˆ©ç”¨ã€‚ Simplicity: there are no databases or programming languages to deal with. A simple knowledge of HTML and CSS is enough. ç®€å•æ€§: æ— éœ€å¤„ç†æ•°æ®åº“æˆ–ç¼–ç¨‹è¯­è¨€ã€‚äº†è§£ HTML å’Œ CSS çš„ç®€å•çŸ¥è¯†å°±è¶³å¤Ÿäº†ã€‚ Flexibility: you know exactly how your site works, as you made it from scratch. çµæ´»æ€§: æ‚¨ç¡®åˆ‡åœ°çŸ¥é“æ‚¨çš„ç½‘ç«™æ˜¯å¦‚ä½•è¿ä½œçš„ï¼Œå› ä¸ºæ‚¨æ˜¯ä»å¤´å¼€å§‹åˆ›å»ºçš„ã€‚ Of course, dynamic sites have their advantages as well. The addition of an admin panel makes for ease of updating, especially for those who are not tech-savvy. Generally, a static site generator would not be the best idea for making a CMS for a client. Static site generators also don't have the possibility of updating with real time content. It's important to understand how both work to know what would work best for your particular project. å½“ç„¶ï¼ŒåŠ¨æ€ç½‘ç«™ä¹Ÿæœ‰å…¶ä¼˜ç‚¹ã€‚æ·»åŠ ç®¡ç†é¢æ¿å¯ä»¥è½»æ¾æ›´æ–°ï¼Œç‰¹åˆ«æ˜¯å¯¹äºé‚£äº›ä¸ç²¾é€šæŠ€æœ¯çš„äººæ¥è¯´ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œé™æ€ç«™ç‚¹ç”Ÿæˆå™¨å¹¶ä¸æ˜¯ä¸ºå®¢æˆ·åˆ¶ä½œ CMS çš„æœ€ä½³ä¸»æ„ã€‚é™æ€ç«™ç‚¹ç”Ÿæˆå™¨ä¹Ÿæ— æ³•æ›´æ–°å®æ—¶å†…å®¹ã€‚äº†è§£ä¸¤è€…çš„å·¥ä½œåŸç†éå¸¸é‡è¦ï¼Œè¿™æ ·æ‰èƒ½çŸ¥é“å“ªç§æ–¹æ³•æœ€é€‚åˆæ‚¨çš„ç‰¹å®šé¡¹ç›®ã€‚ Self Host Docs Wibesite gitbook: origin project no more maintain, turn into Gitbook. old still have bugs mdBook - rust math delimiters support sick text retype free plan only support 100 pages mkdocs mkdocs-material math delimiters support great, 'dollars' and 'brackets' 'dollars': $xxx$ and xxxxxxxxx 'brackets': \\(...\\) and \\[...\\] docusaurus init project stack, dont know why bookstackapp A platform to create documentation/wiki content built with PHP & Laravel Archbee like notion... hyperbook Hyperbook is a quick and easy way to build interactive workbooks, that support modern standards and runs superfast. looks like great! cant release port?? may have bugs, too small depelop group. "},"Learn/PersonalWebsite/Ruby.html":{"url":"Learn/PersonalWebsite/Ruby.html","title":"Ruby","keywords":"","body":"Ruby Ruby: A dynamic, open source programming language. RubyGems: A package manager for the Ruby programming language. Bundler: A tool for managing Ruby dependencies. Ruby A dynamic, open source programming language with a focus on simplicity and productivity. It has an elegant syntax that is natural to read and easy to write. ä¸€ç§åŠ¨æ€çš„å¼€æºç¼–ç¨‹è¯­è¨€ï¼Œé‡ç‚¹å…³æ³¨ ç®€å•æ€§å’Œç”Ÿäº§åŠ›ã€‚å®ƒæœ‰ä¸€ä¸ªä¼˜é›…çš„è¯­æ³•ï¼š è¯»èµ·æ¥è‡ªç„¶ï¼Œå†™èµ·æ¥ä¹Ÿå®¹æ˜“ã€‚ Features: Simple syntax, Basic OO features (classes, methods, objects, and so on), Special OO features (mixins, singleton methods, renaming, and so on), Operator overloading, Exception handling, Iterators and closures, Garbage collection, Dynamic loading (depending on the architecture), High transportability (runs on various Unices, Windows, DOS, macOS, OS/2, Amiga, and so on). wikipedia: Ruby is an interpreted, high-level, general-purpose programming language. It was designed with an emphasis on programming productivity and simplicity. In Ruby, everything is an object), including primitive data types. It was developed in the mid-1990s by Yukihiro \"Matz\" Matsumoto in Japan. Rubyæ˜¯ä¸€ç§è§£é‡Šå‹ã€é«˜çº§ã€é€šç”¨ç¼–ç¨‹è¯­è¨€ã€‚å®ƒçš„è®¾è®¡é‡ç‚¹æ˜¯ç¼–ç¨‹æ•ˆç‡å’Œç®€å•æ€§ã€‚åœ¨ Ruby ä¸­ï¼Œä¸€åˆ‡éƒ½æ˜¯å¯¹è±¡)ï¼ŒåŒ…æ‹¬åŸå§‹æ•°æ®ç±»å‹ã€‚å®ƒæ˜¯ç”±æ—¥æœ¬æ¾æœ¬å¹¸å¼˜â€œMatzâ€äº 20 ä¸–çºª 90 å¹´ä»£ä¸­æœŸå¼€å‘çš„ã€‚ Ruby is dynamically typed and uses garbage collection) and just-in-time compilation. It supports multiple programming paradigms, including procedural, object-oriented, and functional programming. According to the creator, Ruby was influenced by Perl, Smalltalk, Eiffel), Ada), BASIC, Java), and Lisp).[10]#citenote-about-10)[[3]](https://en.wikipedia.org/wiki/Ruby(programming_language)#cite_note-confreaks-3) Ruby æ˜¯åŠ¨æ€ç±»å‹çš„ï¼Œå¹¶ä½¿ç”¨åƒåœ¾æ”¶é›†)å’Œå³æ—¶ç¼–è¯‘ã€‚å®ƒæ”¯æŒå¤šç§ç¼–ç¨‹èŒƒä¾‹ï¼ŒåŒ…æ‹¬è¿‡ç¨‹å¼ç¼–ç¨‹ã€é¢å‘å¯¹è±¡ç¼–ç¨‹å’Œå‡½æ•°å¼ç¼–ç¨‹ã€‚æ ¹æ®åˆ›å»ºè€…çš„è¯´æ³•ï¼ŒRuby å—åˆ°Perl ã€ Smalltalk ã€ Eiffel) ã€ Ada) ã€ BASIC ã€ Java)å’ŒLisp)çš„å½±å“ã€‚ [ 10 ]#citenote-about-10) [[ 3 ]](https://en.wikipedia.org/wiki/Ruby(programming_language)#cite_note-confreaks-3) RubyGems wikipedia RubyGems is a package manager for the Ruby programming language that provides a standard format for distributing Ruby programs and libraries (in a self-contained format called a \"gem\"), a tool designed to easily manage the installation of gems, and a server for distributing them. It was created by Chad Fowler, Jim Weirich, David Alan Black, Paul Brannan and Richard Kilmer in 2004.[2] RubyGems æ˜¯ Ruby ç¼–ç¨‹è¯­è¨€çš„åŒ…ç®¡ç†å™¨ï¼Œå®ƒæä¾›äº†ç”¨äºåˆ†å‘ Ruby ç¨‹åºå’Œåº“çš„æ ‡å‡†æ ¼å¼ï¼ˆä»¥ç§°ä¸ºâ€œgemâ€çš„ç‹¬ç«‹æ ¼å¼ï¼‰ã€ä¸€ä¸ªæ—¨åœ¨è½»æ¾ç®¡ç† gems å®‰è£…çš„å·¥å…·ä»¥åŠä¸€ä¸ªç”¨äºåˆ†å‘å®ƒä»¬ã€‚å®ƒç”± Chad Fowler ã€ Jim Weirich ã€ David Alan Black ã€ Paul Brannan å’Œ Richard Kilmer äº 2004 å¹´åˆ›å»ºã€‚ [ 2 ]. The interface for RubyGems is a command-line tool called gem which can install and manage libraries (the gems).[3] RubyGems integrates with Ruby run-time loader to help find and load installed gems from standardized library folders. Though it is possible to use a private RubyGems repository, the public repository is most commonly used for gem management. RubyGems çš„ç•Œé¢æ˜¯ä¸€ä¸ªåä¸º gem çš„å‘½ä»¤è¡Œå·¥å…·ï¼Œå®ƒå¯ä»¥å®‰è£…å’Œç®¡ç†åº“ï¼ˆgemsï¼‰ã€‚ [ 3 ] RubyGems ä¸ Ruby è¿è¡Œæ—¶åŠ è½½å™¨é›†æˆï¼Œä»¥å¸®åŠ©ä»æ ‡å‡†åŒ–åº“æ–‡ä»¶å¤¹ä¸­æŸ¥æ‰¾å¹¶åŠ è½½å·²å®‰è£…çš„ gemã€‚å°½ç®¡å¯ä»¥ä½¿ç”¨ç§æœ‰ RubyGems å­˜å‚¨åº“ï¼Œä½†å…¬å…±å­˜å‚¨åº“æœ€å¸¸ç”¨äº gem ç®¡ç†ã€‚ The public repository helps users find gems, resolve dependencies and install them. RubyGems is bundled with the standard Ruby package as of Ruby 1.9.[4] å…¬å…±å­˜å‚¨åº“å¯å¸®åŠ©ç”¨æˆ·æŸ¥æ‰¾ gemã€è§£å†³ä¾èµ–å…³ç³»å¹¶å®‰è£…å®ƒä»¬ã€‚ä» Ruby 1.9 å¼€å§‹ï¼ŒRubyGems ä¸æ ‡å‡† Ruby åŒ…æ†ç»‘åœ¨ä¸€èµ·ã€‚ [ 4 ] Bundler Bundler provides a consistent environment for Ruby projects by tracking and installing the exact gems and versions that are needed. Bundler é€šè¿‡è·Ÿè¸ªå’Œå®‰è£…æ‰€éœ€çš„ç¡®åˆ‡ gem å’Œç‰ˆæœ¬ï¼Œä¸º Ruby é¡¹ç›®æä¾›ä¸€è‡´çš„ç¯å¢ƒã€‚ Bundler is an exit from dependency hell, and ensures that the gems you need are present in development, staging, and production. Starting work on a project is as simple as bundle install. Bundler æ˜¯æ‘†è„±ä¾èµ–åœ°ç‹±çš„å‡ºå£ï¼Œå¹¶ç¡®ä¿æ‚¨éœ€è¦çš„ gem å­˜åœ¨äºå¼€å‘ã€ç™»å°å’Œç”Ÿäº§ä¸­ã€‚å¼€å§‹é¡¹ç›®å·¥ä½œå°±åƒ bundle install ä¸€æ ·ç®€å•ã€‚ Ruby-101 in jekyll Gems Gems are code you can include in Ruby projects. Gems package specific functionality. You can share gems across multiple projects or with other people. Gems can perform actions like: Gems æ˜¯å¯ä»¥åŒ…å«åœ¨ Ruby é¡¹ç›®ä¸­çš„ä»£ç ã€‚ Gems å°è£…ç‰¹å®šåŠŸèƒ½ã€‚æ‚¨å¯ä»¥è·¨å¤šä¸ªé¡¹ç›®æˆ–ä¸å…¶ä»–äººå…±äº« gemã€‚ Gemfile A Gemfile is a list of gems used by your site. Every Jekyll site has a Gemfile in the main folder. Gemfile æ˜¯æ‚¨çš„ç«™ç‚¹ä½¿ç”¨çš„ gem åˆ—è¡¨ã€‚æ¯ä¸ª Jekyll ç«™ç‚¹çš„ä¸»æ–‡ä»¶å¤¹ä¸­éƒ½æœ‰ä¸€ä¸ª Gemfileã€‚ Bundler Bundler is a gem that installs all gems in your Gemfile. To install gems in your Gemfile using Bundler, run the following in the directory that has the Gemfile: bundle install bundle exec jekyll serve To bypass Bundler if you arenâ€™t using a Gemfile, run jekyll serve. Ruby Version Manager (RVM) "},"Learn/PersonalWebsite/al-folio.html":{"url":"Learn/PersonalWebsite/al-folio.html","title":"al-folio","keywords":"","body":"al-folio running-local-al-folio - 2022 running locally: bundle exec jekyll serve --lsi Customize . â”œâ”€â”€ ğŸ“‚ assets/: contains the assets that are displayed in the website â”‚ â””â”€â”€ ğŸ“‚ json/ â”‚ â””â”€â”€ ğŸ“„ resume.json: CV in JSON format (https://jsonresume.org/) â”œâ”€â”€ ğŸ“‚ _bibliography/ â”‚ â””â”€â”€ ğŸ“„ papers.bib: bibliography in BibTeX format â”œâ”€â”€ ğŸ“„ _config.yml: the configuration file of the template â”œâ”€â”€ ğŸ“‚ _data/: contains some of the data used in the template â”‚ â”œâ”€â”€ ğŸ“„ cv.yml: CV in YAML format, used when assets/json/resume.json is not found â”‚ â”œâ”€â”€ ğŸ“„ repositories.yml: users and repositories info in YAML format â”‚ â””â”€â”€ ğŸ“„ socials.yml: your social media and contact info in YAML format â”œâ”€â”€ ğŸ“‚ _includes/: contains code parts that are included in the main HTML file â”‚ â””â”€â”€ ğŸ“„ news.liquid: defines the news section layout in the about page â”œâ”€â”€ ğŸ“‚ _layouts/: contains the layouts to choose from in the frontmatter of the Markdown files â”œâ”€â”€ ğŸ“‚ _news/: the news that will appear in the news section in the about page â”œâ”€â”€ ğŸ“‚ _pages/: contains the pages of the website | â””â”€â”€ ğŸ“„ 404.md: 404 page (page not found) â”œâ”€â”€ ğŸ“‚ _posts/: contains the blog posts â”œâ”€â”€ ğŸ“‚ _projects/: contains the projects â””â”€â”€ ğŸ“‚ _sass/: contains the SASS files that define the style of the website â”œâ”€â”€ ğŸ“„ _base.scss: base style of the website â”œâ”€â”€ ğŸ“„ _cv.scss: style of the CV page â”œâ”€â”€ ğŸ“„ _distill.scss: style of the Distill articles â”œâ”€â”€ ğŸ“„ _layout.scss: style of the overall layout â”œâ”€â”€ ğŸ“„ _themes.scss: themes colors and a few icons â””â”€â”€ ğŸ“„ _variables.scss: variables used in the SASS files "},"Linux/Linux.html":{"url":"Linux/Linux.html","title":"Linux","keywords":"","body":"Linux Desktop_entries "},"Linux/Display/Display.html":{"url":"Linux/Display/Display.html","title":"Display","keywords":"","body":"Great question! Let's go over each component and how they fit together. 1. GNOME GNOME (GNU Network Object Model Environment) is a desktop environment. A desktop environment provides the graphical interface that users interact with, including the desktop, windows, icons, file managers, and settings applications. GNOME is one of the most popular desktop environments for Linux and is used in Debian, Ubuntu, Fedora, and other distributions. Key components provided by GNOME include: Window management: Managing open applications and windows. Applications: Built-in utilities like the file manager, terminal, settings (i.e., gnome-control-center), and more. User interface: Consistent design and behavior for how things look and feel in the system. GNOME uses a display protocol (like X11 or Wayland) to render graphics to the screen, which brings us to the next components. 2. X11 (X Window System) X11, often called the X Window System or just X, is a display server protocol that provides the fundamental layer for graphical display on Unix-like operating systems. It was created in the 1980s and has been the standard display protocol for Linux desktops for a long time. X11â€™s primary responsibilities include: Managing windows (open applications) and their placement. Handling input events (mouse, keyboard). Communication between the hardware (graphics card) and applications. GNOME traditionally ran on top of X11, which would handle all the graphical processing and window management on the display. However, X11 has some limitations, particularly with modern graphics hardware, security, and handling multiple screens, which led to the development of a more modern protocol: Wayland. 3. Wayland Wayland is a newer display server protocol designed to replace X11. It was created to address some of X11â€™s limitations and to provide a simpler, more secure, and efficient system for rendering graphics in modern desktop environments. Waylandâ€™s advantages over X11 include: Improved security: Each application (client) has its own display server instance, reducing security risks. Better performance: Itâ€™s designed to take advantage of modern graphics capabilities, resulting in smoother graphics and lower latency. Simplicity: Waylandâ€™s architecture is much simpler than X11, reducing the number of potential points of failure. In Wayland, the compositor (in this case, GNOMEâ€™s compositor called Mutter) manages windows, input events, and rendering directly, whereas in X11, this was handled by a separate X server. 4. Relationship Between GNOME, X11, and Wayland GNOME is the desktop environment that users interact with. X11 or Wayland is the display protocol that GNOME uses to render graphics to the screen. GNOME can run on top of either X11 or Wayland, depending on the configuration. In a Wayland session, GNOME directly communicates with the Wayland compositor (Mutter), which manages the display. In an X11 session, GNOME interacts with the X server, which acts as a middle layer between the hardware and the applications. Each display protocol has its own strengths and weaknesses. Many Linux distributions, including Debian, have been moving towards using Wayland as the default due to its performance and security benefits. However, some applications and configurations still rely on X11, so X11 remains an option and fallback in many systems. How This Relates to Your Issue Your error message shows that gnome-control-center (the GNOME Settings app) encountered problems because it was running under Wayland but tried to interact with components in an X11 manner, resulting in a crash. This kind of error can happen when applications expect one protocol but the system defaults to another. Switching to an X11 session (or forcing the GNOME Settings app to use X11) is a workaround to avoid these incompatibilities if certain applications or configurations are unstable under Wayland. "},"Linux/Display/GNOME-Default.html":{"url":"Linux/Display/GNOME-Default.html","title":"GNOME-Default","keywords":"","body":"file explorer: nautilus See also: dolphin, caja, thunar, vifm. Launch Nautilus: nautilus Launch Nautilus as root user: nautilus admin:/ Launch Nautilus and display a specific directory: nautilus path/to/directory Launch Nautilus with a specific file or directory selected: nautilus --select path/to/file_or_directory Launch Nautilus in a separated window: nautilus --new-window Close all Nautilus instances: nautilus --quit Display help: nautilus --help settings: gnome-control-center dpkg: Debian package manager. Install a package: dpkg -i path/to/file.deb Remove a package: dpkg -r package List installed packages: dpkg -l pattern List a package's contents: dpkg -L package List contents of a local package file: dpkg -c path/to/file.deb Find out which package owns a file: dpkg -S path/to/file Current Legacy Files Nautilus Web Epiphany Text Editor Gedit Videos Totem Main Menu Alacarte Document Viewer Evince Disk Usage Analyzer Baobab Image Viewer EoG (Eye of GNOME) Passwords and Keys Seahorse GNOME Translation Editor Gtranslator outer disk mount: /media/hhw/Elements SE "},"Linux/Display/Hyprland.html":{"url":"Linux/Display/Hyprland.html","title":"Hyprland","keywords":"","body":"hyprland Github-Hyprland yprland is a 100% independent, dynamic tiling Wayland compositor that doesn't sacrifice on its looks. Hyprland æ˜¯ä¸€ä¸ª 100% ç‹¬ç«‹çš„åŠ¨æ€å¹³é“º Wayland åˆæˆå™¨ï¼Œå®ƒä¸ä¼šç‰ºç‰²å…¶å¤–è§‚ã€‚ It provides the latest Wayland features, is highly customizable, has all the eyecandy, the most powerful plugins, easy IPC, much more QoL stuff than other compositors and more... å®ƒæä¾›æœ€æ–°çš„ Wayland åŠŸèƒ½ï¼Œé«˜åº¦å¯å®šåˆ¶ï¼Œæ‹¥æœ‰æ‰€æœ‰å¸å¼•çœ¼çƒã€æœ€å¼ºå¤§çš„æ’ä»¶ã€ ç®€å•çš„ IPCï¼Œæ¯”å…¶ä»–åˆæˆå™¨æ›´å¤šçš„ QoL ä¸œè¥¿ç­‰ç­‰...... "},"Linux/Display/Wayland.html":{"url":"Linux/Display/Wayland.html","title":"Wayland","keywords":"","body":"Wayland text text Wayland is a replacement for the X11 window system protocol and architecture with the aim to be easier to develop, extend, and maintain. Wayland æ˜¯ X11 çª—å£ç³»ç»Ÿåè®®å’Œæ¶æ„çš„æ›¿ä»£å“ï¼Œæ—¨åœ¨æ›´æ˜“äºå¼€å‘ã€æ‰©å±•å’Œç»´æŠ¤ã€‚ Wayland is the language (protocol) that applications can use to talk to a display server in order to make themselves visible and get input from the user (a person). A Wayland server is called a \"compositor\". Applications are Wayland clients. Wayland æ˜¯åº”ç”¨ç¨‹åºå¯ä»¥ç”¨æ¥ä¸æ˜¾ç¤ºæœåŠ¡å™¨é€šä¿¡çš„è¯­è¨€ï¼ˆåè®®ï¼‰ï¼Œä»¥ä½¿è‡ªèº«å¯è§å¹¶ä»ç”¨æˆ·ï¼ˆä¸€ä¸ªäººï¼‰é‚£é‡Œè·å¾—è¾“å…¥ã€‚Wayland æœåŠ¡å™¨ç§°ä¸ºâ€œåˆæˆå™¨â€ã€‚åº”ç”¨ç¨‹åºæ˜¯ Wayland å®¢æˆ·ç«¯ã€‚ Wayland also refers to a system architecture. It is not just a server-client relationship between a compositor and applications. There is no single common Wayland server like Xorg is for X11, but every graphical environment brings with it one of many compositor implementations. Window management and the end user experience are often tied to the compositor rather than swappable components. Wayland è¿˜æŒ‡ç³»ç»Ÿæ¶æ„ã€‚å®ƒä¸ä»…ä»…æ˜¯åˆæˆå™¨å’Œåº”ç”¨ç¨‹åºä¹‹é—´çš„æœåŠ¡å™¨-å®¢æˆ·ç«¯å…³ç³»ã€‚æ²¡æœ‰åƒ Xorg é‚£æ ·ç”¨äº X11 çš„å•ä¸€é€šç”¨ Wayland æœåŠ¡å™¨ï¼Œä½†æ¯ä¸ªå›¾å½¢ç¯å¢ƒéƒ½å¸¦æ¥äº†è®¸å¤šåˆæˆå™¨å®ç°ä¹‹ä¸€ã€‚çª—å£ç®¡ç†å’Œæœ€ç»ˆç”¨æˆ·ä½“éªŒé€šå¸¸ä¸åˆæˆå™¨è€Œä¸æ˜¯å¯äº¤æ¢ç»„ä»¶ç›¸å…³è”ã€‚ A core part of Wayland architecture is libwayland: an inter-process communication library that translates a protocol definition in XML to a C language API. This library does not implement Wayland, it merely encodes and decodes Wayland messages. The actual implementations are in the various compositor and application toolkit projects. Wayland æ¶æ„çš„æ ¸å¿ƒéƒ¨åˆ†æ˜¯ libwaylandï¼šä¸€ä¸ªè¿›ç¨‹é—´é€šä¿¡åº“ï¼Œå¯å°† XML ä¸­çš„åè®®å®šä¹‰è½¬æ¢ä¸º C è¯­è¨€ APIã€‚è¯¥åº“ä¸å®ç° Waylandï¼Œå®ƒåªæ˜¯å¯¹ Wayland æ¶ˆæ¯è¿›è¡Œç¼–ç å’Œè§£ç ã€‚å®é™…å®ç°ä½äºå„ç§åˆæˆå™¨å’Œåº”ç”¨ç¨‹åºå·¥å…·åŒ…é¡¹ç›®ä¸­ã€‚ Wayland does not restrict where and how it is used. A Wayland compositor could be a standalone display server running on Linux kernel modesetting and evdev input devices or on many other operating systems, or a nested compositor that itself is an X11 or Wayland application (client). Wayland can even be used in application-internal communication as is done in some web browsers. Wayland ä¸é™åˆ¶å®ƒçš„ä½¿ç”¨åœ°ç‚¹å’Œæ–¹å¼ã€‚Wayland åˆæˆå™¨å¯ä»¥æ˜¯åœ¨ Linux å†…æ ¸æ¨¡å¼è®¾ç½®å’Œ evdev è¾“å…¥è®¾å¤‡æˆ–è®¸å¤šå…¶ä»–æ“ä½œç³»ç»Ÿä¸Šè¿è¡Œçš„ç‹¬ç«‹æ˜¾ç¤ºæœåŠ¡å™¨ï¼Œä¹Ÿå¯ä»¥æ˜¯æœ¬èº«æ˜¯ X11 æˆ– Wayland åº”ç”¨ç¨‹åºï¼ˆå®¢æˆ·ç«¯ï¼‰çš„åµŒå¥—åˆæˆå™¨ã€‚Wayland ç”šè‡³å¯ä»¥ç”¨äºåº”ç”¨ç¨‹åºå†…éƒ¨é€šä¿¡ï¼Œå°±åƒåœ¨æŸäº› Web æµè§ˆå™¨ä¸­æ‰€åšçš„é‚£æ ·ã€‚ Xwayland text Xwayland is an X server and a Wayland client. It plays the role of a proxy between legacy X clients which do not support the Wayland protocols and the Wayland server. Xwayland æ˜¯ä¸€ä¸ª X æœåŠ¡å™¨å’Œä¸€ä¸ª Wayland å®¢æˆ·ç«¯ã€‚å®ƒåœ¨ä¸æ”¯æŒ Wayland åè®®çš„é—ç•™ X å®¢æˆ·ç«¯å’Œ Wayland æœåŠ¡å™¨ä¹‹é—´æ‰®æ¼”ä»£ç†çš„è§’è‰²ã€‚ configure Debian 12 system to use Wayland for all components that support it Yes, you can configure your Debian 12 system to use Wayland for all components that support it. This might help resolve compatibility issues by ensuring everything is consistently running on Wayland without falling back to X11. Hereâ€™s how to do it: 1. Ensure GNOME is Running on Wayland By default, Debian 12 GNOME should be set to use Wayland unless itâ€™s explicitly disabled. Hereâ€™s how to confirm or switch to a Wayland session: Log Out of your current GNOME session. On the login screen, select your username, and before logging back in, look for a gear icon near the Sign In button. Click the gear icon and select GNOME or GNOME on Wayland (not GNOME on Xorg). Log back in. If you donâ€™t see the option for GNOME on Wayland, you may need to ensure that Wayland is enabled in the GNOME Display Manager (GDM) configuration file. 2. Enable Wayland in GDM (GNOME Display Manager) If Wayland is disabled in GDM, follow these steps to re-enable it: Open a terminal and edit the GDM configuration file: sudo nano /etc/gdm3/custom.conf Look for the line: #WaylandEnable=false Uncomment it and set it to true, or remove the line entirely to allow Wayland by default: WaylandEnable=true Save and close the file. Restart GDM to apply the changes:sudo systemctl restart gdm3 3. Set Applications to Prefer Wayland Most GNOME applications and modern GTK apps should automatically use Wayland if the system is in a Wayland session. However, some applications (especially older or custom ones) may default to X11. Hereâ€™s how to ensure that applications favor Wayland: Check environment variables: Wayland applications typically recognize WAYLAND_DISPLAY. To make sure applications use Wayland, you can set this variable globally: Open the global profile configuration:sudo nano /etc/environment Add the following line:WAYLAND_DISPLAY=wayland-0 Save and close the file. Log out and log back in for changes to take effect. Force specific applications to use Wayland: Some applications (like Firefox and Electron-based apps) have specific flags to prefer Wayland. Here are a few examples: Firefox: Run Firefox with: MOZ_ENABLE_WAYLAND=1 firefox Electron apps: For Electron apps (like Visual Studio Code), start them with: code --enable-features=UseOzonePlatform --ozone-platform=wayland 4. Verify that Everything is Running on Wayland Once youâ€™ve made these changes, you can verify that GNOME and your applications are running on Wayland: Check GNOME session: Open a terminal and run: echo $XDG_SESSION_TYPE If the output is wayland, then GNOME is running on Wayland. Check individual applications: For example, in gnome-control-center or Firefox, you can check which display protocol theyâ€™re using: In gnome-control-center: Run gnome-control-center from the terminal and see if there are any GdkX11-related warnings (which would indicate itâ€™s trying to use X11). If no warnings appear, itâ€™s likely running on Wayland. In Firefox: Type about:support in the address bar and look for Window Protocol under Graphics. It should say Wayland. 5. Restart the System To ensure all components pick up the changes, restart your computer: sudo reboot After this, your GNOME session and most applications should fully run on Wayland, which should help avoid issues related to mixed X11 and Wayland components. If you encounter specific applications that still donâ€™t work well with Wayland, you might need to run them with the GDK_BACKEND=x11 flag temporarily or wait for further compatibility improvements. second Yes, it is possible to configure your system to use Wayland for all components, which would resolve the problem where your GNOME desktop environment and applications are conflicting with X11. If you want to set Wayland as the default display protocol for all components on your Debian 12 system, follow these steps: 1. Ensure Wayland is Installed First, ensure that Wayland and the necessary components for GNOME are installed. This includes the Wayland compositor and the GNOME Wayland backend. Run the following command to check if the necessary Wayland components are installed: sudo apt install wayland-protocols gnome-shell wayland 2. Ensure GNOME is Running on Wayland By default, GNOME should run on Wayland on systems that support it, unless there is a configuration forcing it to run on X11. You can verify that GNOME is using Wayland by checking the GDK_BACKEND environment variable, which should be set to wayland. Step-by-Step to Force GNOME to Use Wayland: Check Current Session To check whether GNOME is running on Wayland or X11, open a terminal and run the following command: echo $XDG_SESSION_TYPE If the output is wayland, GNOME is already using Wayland. If the output is x11, GNOME is using X11, and youâ€™ll need to configure it to use Wayland. Log Out of the Current Session Log out of your current GNOME session. Choose GNOME on Wayland (at the Login Screen) On the login screen, after entering your username, you should see a settings icon or a gear icon (usually in the lower-right corner or near the session selection). Select GNOME on Wayland. Then log back in. This will start GNOME under Wayland rather than X11. 3. Disable X11 as a Fallback Option (Optional) To make sure that your system does not fall back to X11 automatically, you can disable the ability to use X11 for GNOME. Edit the GDM Configuration: Open the file /etc/gdm3/custom.conf in a text editor with superuser privileges. For example, use nano: sudo nano /etc/gdm3/custom.conf Disable Wayland and Ensure X11 is Not Available: Find the line: #WaylandEnable=false and make sure it is commented out (no # before it). This ensures that Wayland is enabled for GNOME. Now, find the line: #WaylandEnable=false and make sure it is disabled (no # before it). Restart GDM (GNOME Display Manager): After making the changes, restart the GDM service (this controls the graphical login): sudo systemctl restart gdm3 Reboot Your System: Finally, reboot your computer to make sure everything is set properly: sudo reboot 4. Verifying the System is Using Wayland After logging back in, you can confirm that all components are using Wayland by running: echo $XDG_SESSION_TYPE It should output wayland to confirm the system is running on Wayland. 5. Check for Potential Problems with Wayland While most modern GNOME applications and components should work well under Wayland, there might still be some legacy X11-specific issues or applications that might not fully support Wayland yet. In that case: Fallback to X11 for specific apps: If you encounter issues with specific applications, you can still run them under X11 by explicitly setting the GDK_BACKEND=x11 variable for those applications only. System-wide Wayland: If you want to use Wayland across all applications and ensure that they are compatible with it, consider looking into compatibility layers or tools that support running X11 applications under Wayland. For example, you could use XWayland, which allows X11 applications to run on Wayland. Conclusion Once you've configured GNOME to use Wayland and ensured that all components are set up to run under it, your system should no longer experience the issues related to X11-compatibility. However, always be prepared for occasional compatibility issues with legacy applications, although this is becoming less of a problem over time as more software supports Wayland natively. "},"Linux/Flashback.html":{"url":"Linux/Flashback.html","title":"Flashback","keywords":"","body":"If you can't open the Settings application in Debian 12, the issue could be due to several reasons, including a missing or broken package, or a problem with the desktop environment (usually GNOME on Debian). Here are some steps to troubleshoot and fix the issue: 1. Try Opening Settings from the Terminal Sometimes, running an application from the terminal provides error messages that can help diagnose the issue. Open a terminal. Type the following command to try launching Settings:gnome-control-center If there is an error message, note it down, as it can provide clues about what is going wrong. 2. Restart GNOME Shell If gnome-control-center fails to start, it might be related to the GNOME Shell. Restarting GNOME might help: Press Alt + F2. Type r and press Enter to reload the GNOME Shell. Then try opening the Settings app again. 3. Check and Reinstall the gnome-control-center Package The Settings app in GNOME is provided by the gnome-control-center package. If itâ€™s missing or corrupt, reinstalling it might fix the issue. Open a terminal. Run the following commands: sudo apt update sudo apt install --reinstall gnome-control-center After reinstalling, try launching the Settings app again. 4. Check for Pending Updates Outdated packages or system libraries can sometimes cause issues. Make sure your system is up-to-date: sudo apt update && sudo apt upgrade 5. Clear GNOME Settings Cache Sometimes, cache files for GNOME can get corrupted. Deleting them can reset configuration settings and fix problems. Open a terminal. Run these commands to clear the cache: rm -rf ~/.cache/gnome-control-center rm -rf ~/.config/gnome-control-center Try launching Settings again. 6. Check Logs for Errors If the above steps donâ€™t work, checking system logs can give further hints. Open a terminal. View recent log messages related to GNOME Control Center:journalctl -xe | grep gnome-control-center Look for any errors related to gnome-control-center in the output. 7. Reboot the System As a final step, reboot the system to clear any temporary issues: sudo reboot After rebooting, try opening the Settings app again. If the problem persists, the issue may be with GNOME itself or with deeper system settings. second gnome-control-center (gnome-control-center:4566): GLib-GObject-WARNING **: 10:08:38.727: invalid cast from 'GdkWaylandToplevel' to 'GdkX11Surface' (gnome-control-center:4566): GLib-GObject-WARNING **: 10:08:38.727: invalid cast from 'GdkWaylandDisplay' to 'GdkX11Display' [1] 4566 segmentation fault gnome-control-center ans: The error messages you're seeing indicate that gnome-control-center is attempting to cast Wayland-specific objects as X11 objects, which is causing it to crash with a segmentation fault. This is a common issue when there are conflicts between X11 and Wayland components, especially if the system is running Wayland but some applications are expecting X11. Here are several ways to potentially fix this issue: 1. Start GNOME on X11 Instead of Wayland If youâ€™re running GNOME with Wayland, you can switch to an X11 session to see if that resolves the issue. Log out of your current session. On the login screen, select your username, and before logging back in, look for a settings icon (usually a gear icon) near the login button. Choose GNOME on Xorg or GNOME on X11 instead of GNOME on Wayland. Log back in and try opening the Settings app again. 2. Force gnome-control-center to Use X11 Temporarily If you prefer to stay on Wayland but want to see if the issue is related to Wayland compatibility, you can try launching gnome-control-center with the GDK_BACKEND environment variable set to X11. Open a terminal and run: GDK_BACKEND=x11 gnome-control-center This command forces gnome-control-center to use X11, which may help it avoid the Wayland-related segmentation fault. 3. Update Your System and GNOME Packages This may be a known issue with your specific version of GNOME or Debian 12. Make sure your system and GNOME packages are fully updated. sudo apt update && sudo apt upgrade Then, try running the Settings app again. 4. Disable Wayland for GNOME (as a More Permanent Fix) If you find that gnome-control-center works well under X11, you may want to disable Wayland entirely for GNOME. Open the file /etc/gdm3/custom.conf in a text editor with superuser privileges, for example: sudo nano /etc/gdm3/custom.conf Look for the line: #WaylandEnable=false Uncomment it by removing the # so it reads: WaylandEnable=false Save the file and exit the editor. Reboot the system:sudo reboot This will disable Wayland, so GNOME will use X11 by default. After rebooting, try launching the Settings app again. 5. Reinstall Related GNOME and Wayland Packages Itâ€™s possible that some Wayland libraries or GNOME components are misconfigured or outdated. Try reinstalling them: sudo apt install --reinstall gnome-shell gnome-control-center libwayland-client0 libwayland-server0 Then restart your system and try opening Settings again. If the issue continues, it might be a deeper compatibility issue with the Wayland implementation on your system, and sticking with X11 for GNOME might be the most stable solution until updates fix the problem. "},"Linux/InputMethod.html":{"url":"Linux/InputMethod.html","title":"InputMethod","keywords":"","body":"Fcitx Setup_Fcitx_5 ç”±äºå¾ˆå¤šä¸åŒåœ°æ–¹çš„è¿‡æ¸¡é˜¶æ®µï¼Œæ²¡æœ‰é€‚åˆæ¯ä¸ªåœ°æ–¹çš„å®Œç¾è§£å†³æ–¹æ¡ˆã€‚è¯·æ ¹æ®æ‚¨çš„ç¯å¢ƒé€‰æ‹©æ‚¨è‡ªå·±çš„è§£å†³æ–¹æ¡ˆã€‚åŸºæœ¬ä¸Šï¼Œæ‚¨è¦åšçš„æ˜¯ä¸ºæ¡Œé¢ä¼šè¯è®¾ç½®ä»¥ä¸‹ç¯å¢ƒå˜é‡ã€‚ XMODIFIERS=@im=fcitx GTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx export XMODIFIERS=@im=fcitx export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx Useful commands: fcitx-diagnose # print diagnostic information fcitx-configtool # open the configuration tool # fcitx-remote CSDN: Debian Linux Input Method debianç³»ç»Ÿå¯¹ä¸­æ–‡è¾“å…¥æ³•çš„æ”¯æŒå°‘ä¹‹åˆå°‘ï¼Œå¾ˆå¤šäººä¼šé€‰æ‹©ä½¿ç”¨æœç‹—ï¼Œä½†æ˜¯å¯¹äºå¤§å¤šæ•°æ¥è¯´ï¼Œä¼šæœ‰å„ç§å„æ ·çš„é—®é¢˜ï¼Œæ‰€ä»¥è¿™é‡Œå°†ä¼šä»‹ç»ä½¿ç”¨ç³»ç»Ÿè‡ªå¸¦çš„fcitxè¾“å…¥æ³•ã€‚ é¦–å…ˆè½¯ä»¶æºæ›´æ–°ï¼ˆé€‰ï¼‰ï¼š 1.åœ¨ç»ˆç«¯ä¸­è¾“å…¥ï¼š sudo gedit /etc/apt/sources.list 2.åœ¨æ‰“å¼€çš„æ–‡æœ¬ä¸­åˆ é™¤å…¨éƒ¨å†…å®¹ï¼Œç²˜è´´ä¸Šä»¥ä¸‹æ–‡æœ¬ï¼š deb http://mirrors.163.com/debian/ jessie-updates main non-free contrib deb http://mirrors.163.com/debian/ jessie-backports main non-free contrib deb-src http://mirrors.163.com/debian/ jessie main non-free contrib deb-src http://mirrors.163.com/debian/ jessie-updates main non-free contrib deb-src http://mirrors.163.com/debian/ jessie-backports main non-free contrib deb http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib deb-src http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib deb http://ftp.cn.debian.org/debian wheezy main contrib non-free ï¼ˆæ­¤å¤„åŒ…å«163ä»¥åŠdebianå®˜æ–¹è½¯ä»¶æºï¼‰ 3.ç‚¹å‡»ä¿å­˜ï¼Œå¹¶å…³é—­ï¼Œå›åˆ°ç»ˆç«¯ï¼Œè¿›è¡Œè½¯ä»¶æºåŒæ­¥ è¾“å…¥æŒ‡ä»¤ï¼šsudo apt-get update apt-get install fcitx-ui-classic && apt-get install fcitx-ui-light 5.ç‚¹å‡»èœå•ï¼Œæ‰¾åˆ°åº”ç”¨: è¾“å…¥æ³•ï¼Œå¹¶æ‰“å¼€ã€‚ 6.åœ¨ç”¨æˆ·è®¾ç½®ä¸­ ç‚¹å‡» fctixé€‰é¡¹ ï¼Œå¹¶ç‚¹å‡»ç¡®å®šã€‚ 7.æ ¹æ®è¾“å…¥æ³•é…ç½®ä¸­çš„æç¤ºï¼Œæ‰“å¼€ç»ˆç«¯ï¼Œè¾“å…¥æŒ‡ä»¤ï¼ˆæ ¹æ®è‡ªèº«è¦æ±‚é€‰æ‹©ï¼‰ï¼š sudo apt-get install fcitx-sunpinyin fcitx-googlepinyin fcitx-pinyin ï¼ˆè¿™é‡Œæœ‰ä¸‰ç§æ‹¼éŸ³è¾“å…¥æ³•ï¼šfcitx-sunpinyin ï¼Œfcitx-googlepinyin å’Œ fcitx-pinyin ï¼Œä¸éœ€è¦çš„å¯ä»¥åˆ æ‰ï¼‰ sudo apt-get fcitx-table-wubi fcitx-table-wbpy (ä¸¤ç§äº”ç¬”è¾“å…¥æ³•ï¼šfcitx-table-wubi å’Œfcitx-table-wbpy) sudo apt-get fcitx-table-cangjie (ç¹ä½“ä¸­æ–‡è¾“å…¥ï¼Œåªæœ‰ä¸€ç§) 8.å®‰è£…é€šç”¨çš„è¾“å…¥æ³•ç è¡¨: fcitx-table* å¥—ä»¶ï¼ˆå¿…è£…ï¼ï¼‰ sudo apt-get fcitx-table* 9.åº”ç”¨ç¨‹åºæ”¯æŒï¼ˆå¿…è£…ï¼ï¼‰ sudo apt-get install fcitx-frontend-gtk2 fcitx-frontend-gtk3 fcitx-frontend-qt4 (fcitx-frontend-gtk2 å’Œ fcitx-frontend-gtk3 å¿…è£…ï¼ŒåŒæ—¶ fcitx-frontend-qt4 ä¹Ÿå»ºè®®ä¸€èµ·è£…ä¸Š) 10.æœ€åé‡å¯ï¼Œæ ¹æ®è‡ªå·±çš„å¿«æ·é”®å¯åŠ¨è¾“å…¥æ³•ï¼ˆé»˜è®¤ Ctrl+ç©ºæ ¼ ï¼‰ åœ¨å³ä¸‹è„šä¼šæœ‰å°é”®ç›˜ï¼Œå³é”® --é…ç½® å¯ä»¥é€‰æ‹©å„ç§è¾“å…¥é€‰é¡¹ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” ç‰ˆæƒå£°æ˜ï¼šæœ¬æ–‡ä¸ºåšä¸»åŸåˆ›æ–‡ç« ï¼Œéµå¾ª CC 4.0 BY-SA ç‰ˆæƒåè®®ï¼Œè½¬è½½è¯·é™„ä¸ŠåŸæ–‡å‡ºå¤„é“¾æ¥å’Œæœ¬å£°æ˜ã€‚ åŸæ–‡é“¾æ¥ï¼šhttps://blog.csdn.net/ieeso/article/details/105274943 "},"Linux/LSB.html":{"url":"Linux/LSB.html","title":"LSB","keywords":"","body":"LSB (Linux Standard Base) is a standardization effort by the Linux Foundation aimed at increasing compatibility among different Linux distributions. Its primary goal is to ensure that software applications can run on various distributions without requiring modification, promoting software interoperability. Key Concepts of LSB Standardization: LSB defines a set of standards for Linux distributions to follow, covering the core components of a Linux system, such as file system hierarchy, system libraries, and application programming interfaces (APIs). By adhering to these standards, developers can write applications that are more portable across compliant distributions. Compatibility: LSB aims to minimize the differences among distributions by providing a consistent environment. This includes defining package formats, directory structures, and other elements that help applications function uniformly across various distributions. Core Components: The LSB specification includes guidelines on system libraries, command-line utilities, file locations, and other core components necessary for application development. LSB Modules The LSB is divided into various modules, each addressing specific areas of the Linux environment. Some of the key modules include: Core Module: Defines essential libraries and utilities required for applications to run. Includes specifications for basic system libraries, such as glibc, and common command-line tools. Graphics Module: Focuses on graphics-related libraries and interfaces, ensuring compatibility for graphical applications. This module may include support for X Window System libraries and graphics rendering libraries. Desktop Module: Specifies standards for desktop environments, such as GNOME or KDE, to ensure applications can integrate seamlessly into the user interface. Includes guidelines for desktop files, menus, and application launchers. Printing Module: Addresses standards for printing in Linux, including common protocols and interfaces. Ensures that applications can interact with printers consistently across different distributions. Web Module: Defines standards for web applications, including required libraries and services. Aims to facilitate the development of web-based applications that run across various Linux environments. Implementation and Compliance Compliance Testing: Distributions that claim LSB compliance undergo testing to ensure they meet the established standards. This helps developers and users trust that their applications will work as intended on compliant systems. Packaging: Many distributions provide tools for packaging software that adheres to LSB standards, making it easier to distribute and install applications. Benefits of LSB Portability: Developers can write code that runs on any LSB-compliant distribution, reducing the need for separate versions of software. Easier Development: With a standardized environment, developers can focus on creating applications rather than dealing with the nuances of different distributions. Community Collaboration: LSB fosters collaboration among various Linux distributions, encouraging a unified approach to development and application deployment. Current Status While LSB was widely adopted in the past, its relevance has diminished somewhat as distributions have evolved and some developers have opted for alternative packaging methods (like Snap or Flatpak) that focus on containerization. Nevertheless, understanding LSB remains important for those working with Linux systems, especially in environments where compatibility and standardization are critical. "},"Linux/LinuxFamily/LinuxFamily.html":{"url":"Linux/LinuxFamily/LinuxFamily.html","title":"LinuxFamily","keywords":"","body":""},"Linux/LinuxFamily/ArchLinux.html":{"url":"Linux/LinuxFamily/ArchLinux.html","title":"ArchLinux","keywords":"","body":"text text Arch Linux æ˜¯ä¸€ä¸ªç‹¬ç«‹å¼€å‘çš„ x86-64 é€šç”¨ GNU/Linux å‘è¡Œç‰ˆï¼Œå®ƒè‡´åŠ›äºé€šè¿‡éµå¾ªæ»šåŠ¨å‘å¸ƒæ¨¡å‹æ¥æä¾›å¤§å¤šæ•°è½¯ä»¶çš„æœ€æ–°ç¨³å®šç‰ˆæœ¬ã€‚é»˜è®¤å®‰è£…æ˜¯ä¸€ä¸ªæœ€å°çš„åŸºæœ¬ç³»ç»Ÿï¼Œç”±ç”¨æˆ·é…ç½®ä¸ºä»…æ·»åŠ æœ‰æ„éœ€è¦çš„å†…å®¹ã€‚ "},"Linux/LinuxFamily/DebianFamily.html":{"url":"Linux/LinuxFamily/DebianFamily.html","title":"DebianFamily","keywords":"","body":"Debian12 bookworm Release Notes 5.1.5. Fcitx versions no longer co-installable 5.1.5. Fcitx ç‰ˆæœ¬ä¸å†å¯å…±åŒå®‰è£… The packages fcitx and fcitx5 provide version 4 and version 5 of the popular Fcitx Input Method Framework. Following upstream's recommendation, they can no longer be co-installed on the same operating system. Users should determine which version of Fcitx is to be kept if they had co-installed fcitx and fcitx5 previously. è½¯ä»¶åŒ… fcitx å’Œ fcitx5 æä¾›æµè¡Œçš„ Fcitx è¾“å…¥æ³•æ¡†æ¶çš„ç‰ˆæœ¬ 4 å’Œç‰ˆæœ¬ 5ã€‚æ ¹æ®ä¸Šæ¸¸çš„å»ºè®®ï¼Œå®ƒä»¬ä¸èƒ½å†å…±åŒå®‰è£…åœ¨åŒä¸€ä¸ªæ“ä½œç³»ç»Ÿä¸Šã€‚å¦‚æœç”¨æˆ·ä¹‹å‰å·²ç»å…±åŒå®‰è£…äº† fcitx å’Œ fcitx5ï¼Œåˆ™åº”ç¡®å®šè¦ä¿ç•™å“ªä¸ªç‰ˆæœ¬çš„ fcitxã€‚ Before the upgrade, users are strongly encouraged to purge all related packages for the unwanted Fcitx version (fcitx- for Fcitx 4, and fcitx5- for Fcitx 5). When the upgrade is finished, consider executing the im-config again to select the desired input method framework to be used in the system. åœ¨å‡çº§ä¹‹å‰ï¼Œå¼ºçƒˆå»ºè®®ç”¨æˆ·æ¸…é™¤ä¸éœ€è¦çš„ Fcitx ç‰ˆæœ¬çš„æ‰€æœ‰ç›¸å…³è½¯ä»¶åŒ…ï¼ˆFcitx 4 çš„ fcitx- å’Œ Fcitx 5 çš„ fcitx5-ï¼‰ã€‚å‡çº§å®Œæˆåï¼Œè€ƒè™‘å†æ¬¡æ‰§è¡Œ im-config é€‰æ‹©è¦åœ¨ç³»ç»Ÿä¸­ä½¿ç”¨çš„æ‰€éœ€è¾“å…¥æ³•æ¡†æ¶ã€‚ "},"Linux/LinuxFamily/GentooLinux.html":{"url":"Linux/LinuxFamily/GentooLinux.html","title":"GentooLinux","keywords":"","body":"text "},"Linux/LinuxFamily/RedHatFamily.html":{"url":"Linux/LinuxFamily/RedHatFamily.html","title":"RedHatFamily","keywords":"","body":"sudo yum install -y httpd sudo rpm -i httpd-2.4.6-80.el7.centos.x86_64.rpm Rocky Linux 8 How To Install and Use Docker on Rocky Linux 8 How To Install Nginx on Rocky Linux 8 "},"Linux/Nautilus.html":{"url":"Linux/Nautilus.html","title":"Nautilus","keywords":"","body":"Nautilus: Debian File Manager nautilus-tips-tweaks Enable quick file preview Quick preview is rather a handy feature for a file manager. KDEâ€™s Dolphin file manager provides it as a built-in feature. You can preview files such as PDF, text, images, audio, etc. You can scroll documents while in preview. In Nautilus, you need to install gnome-sushi to get this feature. sudo apt install gnome-sushi Now, close all instances of file manager and open it again. To see the preview, select a file and press the Space key. "},"Linux/PrintingDrivers.html":{"url":"Linux/PrintingDrivers.html","title":"PrintingDrivers","keywords":"","body":"Printing Drivers how to install hplip on ubuntu linux sudo apt install hplip hplip-data hplip-gui hplip-docDebian12 # hplip-gui: HP Linux Printing and Imaging - GUI utilities (Qt-based) sudo apt install hplip-gui # deps on: hplip: HP Linux Printing and Imaging cups: Common Unix Printing System - PPD/driver support, web interface. HPLIP is composed of: System services to handle communications with the printers HP CUPS backend driver (hp:) with bi-directional communication with HP printers (provides printer status feedback to CUPS and enhanced HPIJS functionality such as 4-side full-bleed printing support) HP CUPS backend driver for sending faxes (hpfax:) hpcups CUPS Raster driver to turn rasterized input from the CUPS filter chain into the printer's native format (PCL, LIDIL, ...). (hpcups is shipped in a separate package) HPIJS Ghostscript IJS driver to rasterize output from PostScript(tm) files or from any other input format supported by Ghostscript, and also for PostScript(tm) to fax conversion support (HPIJS is shipped in a separate package) Command line utilities to perform printer maintenance, such as ink-level monitoring or pen cleaning and calibration GUI and command line utility to download data from the photo card interfaces in MFP devices GUI and command line utilities to interface with the fax functions A GUI toolbox to access all these functions in a friendly way HPAIO SANE backend (hpaio) for flatbed and Automatic Document Feeder (ADF) scanning using MFP devices "},"Linux/UserManagement.html":{"url":"Linux/UserManagement.html","title":"UserManagement","keywords":"","body":"groups # to check groups of a user usermod -G # to add a user to a group usermod -G -d # to change the home directory of a user usermod -s # to change the shell of a user # give user sudo access sudo vim /etc/sudoers ALL=(ALL) ALL # add the line above to the end of the file # add user to sudo|wheel group sudo usermod -aG sudo su Switch shell to another user. More information: https://manned.org/su. - Switch to superuser (requires the root password): su - Switch to a given user (requires the user's password): su username - Switch to a given user and simulate a full login shell: su - username - Execute a command as another user: su - username -c \"command\" adduser User addition utility. More information: https://manned.org/adduser. - Create a new user with a default home directory and prompt the user to set a password: adduser username - Create a new user without a home directory: adduser --no-create-home username - Create a new user with a home directory at the specified path: adduser --home path/to/home username - Create a new user with the specified shell set as the login shell: adduser --shell path/to/shell username - Create a new user belonging to the specified group: adduser --ingroup group username users Display a list of logged in users. See also: useradd, userdel, usermod. More information: https://www.gnu.org/software/coreutils/users. - Print logged in usernames: users - Print logged in usernames according to a given file: users /var/log/wmtp usermod Modify a user account. See also: users, useradd, userdel. More information: https://manned.org/usermod. - Change a username: sudo usermod -l|--login new_username username - Change a user ID: sudo usermod -u|--uid id username - Change a user shell: sudo usermod -s|--shell path/to/shell username - Add a user to supplementary groups (mind the lack of whitespace): sudo usermod -a|--append -G|--groups group1,group2,... username - Change a user home directory: sudo usermod -m|--move-home -d|--home path/to/new_home username gpasswd Administer /etc/group and /etc/gshadow. More information: https://manned.org/gpasswd. - Define group administrators: sudo gpasswd -A user1,user2 group - Set the list of group members: sudo gpasswd -M user1,user2 group - Create a password for the named group: gpasswd group - Add a user to the named group: gpasswd -a user group - Remove a user from the named group: gpasswd -d user group (base) âœ ~ gpasswd Usage: gpasswd [option] GROUP Options: -a, --add USER add USER to GROUP -d, --delete USER remove USER from GROUP -h, --help display this help message and exit -Q, --root CHROOT_DIR directory to chroot into -r, --remove-password remove the GROUP's password -R, --restrict restrict access to GROUP to its members -M, --members USER,... set the list of members of GROUP -A, --administrators ADMIN,... set the list of administrators for GROUP Except for the -A and -M options, the options cannot be combined. delete user In Debian 12, the deluser and userdel commands are used to delete users. However, if you can't find these commands, it might be due to a missing package or a typo. Here's how you can delete a user in Debian 12: 1. Using deluser (Recommended) The deluser command is part of the passwd package and is the preferred method for removing users in Debian. Steps: Install the passwd package (if not already installed): sudo apt update sudo apt install passwd Delete the user: sudo deluser username Replace username with the actual username you want to delete. Delete the user's home directory and mail spool (optional): sudo deluser --remove-home username 2. Using userdel The userdel command is part of the shadow-utils package and is a lower-level tool for removing users. Steps: Install the shadow-utils package (if not already installed): sudo apt update sudo apt install shadow-utils Delete the user: sudo userdel username Delete the user's home directory and mail spool (optional): sudo rm -rf /home/username sudo rm -rf /var/mail/username Troubleshooting Command not found: If you get a \"command not found\" error, ensure that the passwd or shadow-utils package is installed. Typo: Double-check the spelling of the commands (deluser and userdel). Summary Use deluser for a more user-friendly experience. Use userdel for a more manual approach. Always ensure the necessary packages are installed. Let me know if you encounter any issues! "},"Linux/apt.html":{"url":"Linux/apt.html","title":"apt","keywords":"","body":"# /etc/apt/apt.conf.d/01proxy # /etc/apt/apt.conf Acquire::http::proxy \"http://user:password@host:port/\"; Acquire { HTTP::proxy \"http://proxy_server:port/\"; HTTPS::proxy \"http://proxy_server:port/\"; } apt search --names-only apt 2.6.1 (amd64) Usage: apt-get [options] command apt-get [options] install|remove pkg1 [pkg2 ...] apt-get [options] source pkg1 [pkg2 ...] apt-get is a command line interface for retrieval of packages and information about them from authenticated sources and for installation, upgrade and removal of packages together with their dependencies. Most used commands: update - Retrieve new lists of packages upgrade - Perform an upgrade install - Install new packages (pkg is libc6 not libc6.deb) reinstall - Reinstall packages (pkg is libc6 not libc6.deb) remove - Remove packages purge - Remove packages and config files autoremove - Remove automatically all unused packages dist-upgrade - Distribution upgrade, see apt-get(8) dselect-upgrade - Follow dselect selections build-dep - Configure build-dependencies for source packages satisfy - Satisfy dependency strings clean - Erase downloaded archive files autoclean - Erase old downloaded archive files check - Verify that there are no broken dependencies source - Download source archives download - Download the binary package into the current directory changelog - Download and display the changelog for the given package apt is a commandline package manager and provides commands for searching and managing as well as querying information about packages. It provides the same functionality as the specialized APT tools, like apt-get and apt-cache, but enables options more suitable for interactive use by default. Most used commands: list - list packages based on package names search - search in package descriptions show - show package details install - install packages reinstall - reinstall packages remove - remove packages autoremove - automatically remove all unused packages update - update list of available packages upgrade - upgrade the system by installing/upgrading packages full-upgrade - upgrade the system by removing/installing/upgrading packages edit-sources - edit the source information file satisfy - satisfy dependency strings apt-get purge docker-ce -y apt list --installed | grep docker "},"Linux/curl.html":{"url":"Linux/curl.html","title":"curl","keywords":"","body":"sudo curl -x \"http://127.0.0.1:7890\" https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc "},"Misc/Misc.html":{"url":"Misc/Misc.html","title":"Misc","keywords":"","body":""},"Misc/00_Links.html":{"url":"Misc/00_Links.html","title":"00_Links","keywords":"","body":"Useful Links Collection ä¸‡é’Ÿåˆ™ä¸è¾©ç¤¼ä¹‰è€Œå—ä¹‹ï¼Œä¸‡é’Ÿäºæˆ‘ä½•åŠ ç„‰ï¼^1 å¯¼èˆª s CS è‡ªå­¦æŒ‡å— ç½‘ç«™å¯¼èˆª linux.do ç½‘ç«™å¯¼èˆª Blogs honeybadger-blog linux.cn liaoxuefeng Andrej Karpathy blog - 2014 Why you (yes, you) should blog - 2017 Hacker News Daily Tools pdf-to-txt table to markdown Tutorials GDB è°ƒè¯•å¤šçº¿ç¨‹ç¨‹åºçš„æ€»ç»“ Linux 101 Courses CS615 -- System Administration Articles What Every Programmer Should Know About Memory - Traditional Chinese Misc gnu home zh The best free stock photos, royalty free images & videos shared by creators. alternativeto ToRead: zhihu - Performance and Compatibility in the HongMeng Production Microkernel zhihu - Programming Books to read Awesome Lists: Awesome-Selfhosted Radio to Txt blog: å‡ æ¬¾å…è´¹çš„è¯­éŸ³è½¬æ–‡å­—å·¥å…·æ¨è é£ä¹¦å¦™è®° buzz: Transcribe and translate audio offline on your personal computer. Powered by OpenAI's Whisper. Online Convert onlineconvertfree caj2pdf caj2pdf gentleltd github: caj2pdf text toolsra delete all enters doc zealdocs video download yt pkgs pkgs: Packages for Linux and Unix repology: the packaging hub translation: academic.chatwithpaper github: SUSYUSTC/MathTranslate github: PDFMathTranslate logo maker actual free logo maker: ucraft logoly text white board figma Figma is a powerful, collaborative design tool for teams. Explore ideas and gather feedback, build realistic prototypes, and streamline product development with design systems. make timeline: markwhen, github harvestapp note app heynote Debug The Debugging Book very useful for debugging in python!!! DataScience: Python for Data Science Python for Data Science "},"Misc/01_GitHubReps.html":{"url":"Misc/01_GitHubReps.html","title":"01_GitHubReps","keywords":"","body":"docling https://ds4sd.github.io/docling/ è¿™æ˜¯ä¸€ä¸ªç”± IBM å¼€æºçš„ Python å·¥å…·ï¼Œä¸“é—¨ç”¨äºå°†å„ç±»æ–‡æ¡£è½¬åŒ–ä¸ºé€‚åˆç”Ÿæˆå¼ AI ä½¿ç”¨çš„å·¥å…·ã€‚å®ƒèƒ½å¤Ÿå°† PDFã€DOCXã€PPTXã€å›¾ç‰‡ã€HTMLã€Markdown ç­‰å¤šç§æµè¡Œæ–‡æ¡£æ ¼å¼ï¼Œå¯¼å‡ºä¸º Markdown å’Œ JSON æ ¼å¼ï¼Œæ”¯æŒå¤šç§ OCR å¼•æ“ï¼ˆPDFï¼‰ã€ç»Ÿä¸€çš„æ–‡æ¡£å¯¹è±¡ï¼ˆDoclingDocumentï¼‰ï¼Œè½»æ¾é›†æˆæ£€ç´¢å¢å¼ºç”Ÿæˆï¼ˆRAGï¼‰å’Œé—®ç­”åº”ç”¨ï¼Œé€‚ç”¨äºéœ€è¦å°†æ–‡æ¡£ä½œä¸ºç”Ÿæˆå¼ AI æ¨¡å‹è¾“å…¥çš„åœºæ™¯ã€‚ best-of-ml-python è¯¥é¡¹ç›®æä¾›äº†ä¸€ä¸ªé«˜è´¨é‡çš„æœºå™¨å­¦ä¹  Python åº“åˆ—è¡¨ï¼ŒåŒ…å«è¶…è¿‡ 900 ä¸ªå¼€æºé¡¹ç›®ï¼Œå¹¶æŒ‰ç…§é¡¹ç›®è´¨é‡è¯„åˆ†è¿›è¡Œæ’åï¼Œæ¯å‘¨æ›´æ–°ä¸€æ¬¡ã€‚æ‰€æœ‰å¼€æºé¡¹ç›®è¢«åˆ†æˆäº† 30 å¤šä¸ªåˆ†ç±»ï¼ŒåŒ…æ‹¬æœºå™¨å­¦ä¹ æ¡†æ¶ã€æ•°æ®å¯è§†åŒ–ã€è‡ªç„¶è¯­è¨€å¤„ç†ã€OCRã€æ¨¡å‹åºéƒ¨ç½²ç­‰ï¼Œä¾¿äºä¸åŒåº”ç”¨é¢†åŸŸçš„å¼€å‘è€…å¿«é€Ÿæ‰¾åˆ°æ‰€éœ€çš„æœºå™¨å­¦ä¹ å·¥å…·å’Œèµ„æºã€‚ bananas: cross-platform screen sharing bananas å®˜ç½‘ï¼šhttps://getbananas.net äº‘æœµå¤‡ä»½å‘å¸ƒåœ°å€ï¼šhttps://github.com/likeflyme/cloudbak äº‘æœµå¤‡ä»½å®˜ç½‘ï¼šhttps://www.cloudbak.org/ ä½¿ç”¨æ•™ç¨‹ï¼šhttps://www.cloudbak.org/use/create-session.html é­”é•œï¼šé¡¹ç›®åœ°å€https://github.com/idootop/MagicMirror/blob/main/docs/cn/readme.md ä½œè€…æä¾›çš„å®‰è£…åŒ…ï¼Œæå–å¯†ç : 4ro2ï¼šhttps://del-wang.lanzout.com/b01qdt5nba ä¸€é”®é©¬èµ›å…‹ï¼šhttps://github.com/Ritr/publicTools Traymond å¢å¼ºç‰ˆï¼šhttps://github.com/tabris17/traymond å£¹å°ï¼šhttps://github.com/ggchivalrous/yiyin ä»¿ç”Ÿé˜…è¯»ï¼šhttps://github.com/yitong2333/Bionic-Reading/blob/main/README-CN.md ebook2audiobook error when building: No such file or directory: 'mecab-config' issue "},"Misc/Bochs.html":{"url":"Misc/Bochs.html","title":"Bochs","keywords":"","body":"Bochs æ¬¢è¿æ¥åˆ°Bochs IA-32ä»¿çœŸå™¨é¡¹ç›® Bochsæ˜¯ä¸€ä¸ªç”¨C++ç¼–å†™çš„é«˜åº¦å¯ç§»æ¤çš„å¼€æºIA-32(x86)PCä»¿çœŸå™¨ï¼Œå¯ä»¥åœ¨å¤§å¤šæ•°æµè¡Œçš„å¹³å°ä¸Šè¿è¡Œã€‚å®ƒåŒ…æ‹¬å¯¹è‹±ç‰¹å°”x86 CPUã€æ™®é€šI/Oè®¾å¤‡å’Œè‡ªå®šä¹‰BIOSçš„ä»¿çœŸã€‚Bochså¯ä»¥ç¼–è¯‘æ¨¡æ‹Ÿè®¸å¤šä¸åŒçš„x86 CPUï¼Œä»æ—©æœŸçš„386åˆ°æœ€æ–°çš„x86-64è‹±ç‰¹å°”å’ŒAMDå¤„ç†å™¨ï¼Œç”šè‡³å¯èƒ½è¿˜æ²¡æœ‰è¿›å…¥å¸‚åœºã€‚ Bochsèƒ½å¤Ÿåœ¨ä»¿çœŸä¸­è¿è¡Œå¤§å¤šæ•°æ“ä½œç³»ç»Ÿï¼ŒåŒ…æ‹¬Linuxã€DOSæˆ–Microsoft Windowsã€‚Bochsæœ€åˆç”±Kevin Lawtonç¼–å†™ï¼Œç›®å‰ç”±è¯¥é¡¹ç›®ç»´æŠ¤ã€‚ Bochså¯ä»¥è¢«ç¼–è¯‘å¹¶ä»¥å¤šç§æ¨¡å¼ä½¿ç”¨ï¼Œå…¶ä¸­ä¸€äº›æ¨¡å¼ä»åœ¨å¼€å‘ä¸­ã€‚bochsçš„ \"å…¸å‹ \"ç”¨é€”æ˜¯æä¾›å®Œæ•´çš„x86 PCä»¿çœŸï¼ŒåŒ…æ‹¬x86å¤„ç†å™¨ã€ç¡¬ä»¶è®¾å¤‡å’Œå†…å­˜ã€‚è¿™å…è®¸ä½ åœ¨å·¥ä½œç«™çš„æ¨¡æ‹Ÿå™¨ä¸­è¿è¡Œæ“ä½œç³»ç»Ÿå’Œè½¯ä»¶ï¼Œå°±åƒä½ åœ¨ä¸€å°æœºå™¨ä¸­æ‹¥æœ‰ä¸€å°æœºå™¨ä¸€æ ·ã€‚ä¾‹å¦‚ï¼Œå‡è®¾ä½ çš„å·¥ä½œç«™æ˜¯ä¸€ä¸ªUnix/X11å·¥ä½œç«™ï¼Œä½†ä½ æƒ³è¿è¡ŒWin'95åº”ç”¨ç¨‹åºã€‚Bochså°†å…è®¸ä½ åœ¨Unix/X11å·¥ä½œç«™ä¸Šè¿è¡ŒWin'95å’Œç›¸å…³è½¯ä»¶ï¼Œåœ¨ä½ çš„å·¥ä½œç«™ä¸Šæ˜¾ç¤ºä¸€ä¸ªçª—å£ï¼Œæ¨¡æ‹ŸPCä¸Šçš„æ˜¾ç¤ºå™¨ã€‚ Bochsæ˜¯ä¸€ä¸ªä»¿çœŸå™¨ï¼ˆemulatorï¼‰--ä¸æ˜¯è™šæ‹ŸåŒ–è½¯ä»¶ï¼ˆvirtualization softwareï¼‰ã€‚å®ƒå¯ä»¥åœ¨è®¸å¤šæ¶æ„ä¸Šç§»æ¤ï¼šX86ã€ARMã€MIPSç­‰ã€‚è¿™æ„å‘³ç€å®ƒå¿…é¡»èƒ½å¤Ÿæ¨¡æ‹Ÿæ¯ä¸€æ¡CPUæŒ‡ä»¤ã€‚ è¿™ä½¿BochsåŒºåˆ«äºè™šæ‹ŸåŒ–è§£å†³æ–¹æ¡ˆï¼Œä¾‹å¦‚VirtualBoxã€VMWareç­‰ã€‚é‚£äº›é¡¹ç›®æä¾›äº†å¾ˆå¥½çš„ç”¨æˆ·ä½“éªŒå’Œå¿«é€Ÿçš„æ€§èƒ½ï¼Œå…¶ä»£ä»·æ˜¯ç¡¬ä»¶é™åˆ¶ã€ä¸€äº›éç¡®å®šæ€§å’Œä¸€äº›å¿…è¦çš„é»‘å®¢æ”»å‡»æ¥ä½¿ç¨‹åºå·¥ä½œã€‚ Bochsçš„ä»¿çœŸæä¾›äº†ä¸€ä¸ªå¯æ§çš„ã€ç²¾ç¡®çš„æ‰§è¡Œç¯å¢ƒï¼Œä½†ä»£ä»·æ˜¯é€Ÿåº¦/æ€§èƒ½ã€‚è¿™åœ¨æŸäº›æƒ…å†µä¸‹å¯èƒ½æ˜¯æœ‰åˆ©çš„ï¼Œä¾‹å¦‚ï¼š åœ¨å¼€å‘æ“ä½œç³»ç»Ÿæˆ–å¼•å¯¼ç¨‹åºæ—¶ å½“å¤„ç†éå¸¸è€çš„ã€å…³é”®ä»»åŠ¡çš„è½¯ä»¶æ—¶ å½“å¯¹ç³»ç»Ÿçº§ä»£ç è¿›è¡Œé€†å‘å·¥ç¨‹æ—¶ æ¬²äº†è§£æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§ç”¨æˆ·æŒ‡å—ä¸­çš„ä»‹ç»éƒ¨åˆ† "},"Misc/Compression.html":{"url":"Misc/Compression.html","title":"Compression","keywords":"","body":"Compression Types of Compression ä»¥ä¸‹æ˜¯ä¸åŒç±»å‹çš„å‹ç¼©æ–‡ä»¶ï¼ˆzipã€gzã€tar.gzã€tar.bz2ã€tar.xzï¼‰çš„åŒºåˆ«å’Œç‰¹ç‚¹ï¼š 1. Zip æ–‡ä»¶ (.zip) æ ¼å¼ï¼šå•æ–‡ä»¶å½’æ¡£æ ¼å¼ï¼Œå¯åŒ…å«å¤šä¸ªæ–‡ä»¶å’Œç›®å½•ã€‚ å‹ç¼©ï¼šé»˜è®¤ä½¿ç”¨ DEFLATE ç®—æ³•ï¼Œä½†ä¹Ÿæ”¯æŒå…¶ä»–ç®—æ³•ã€‚ å¸¸è§ç”¨é€”ï¼šå¹¿æ³›ç”¨äºè·¨å¹³å°çš„æ–‡ä»¶å…±äº«å’Œåˆ†å‘ã€‚ ç‰¹ç‚¹ï¼š æ”¯æŒå‹ç¼©å’Œå½’æ¡£ä¸€æ­¥å®Œæˆã€‚ å…è®¸éšæœºè®¿é—®å•ä¸ªæ–‡ä»¶ï¼Œæ— éœ€è§£å‹æ•´ä¸ªå½’æ¡£æ–‡ä»¶ã€‚ æ”¯æŒå¯†ç ä¿æŠ¤å’ŒåŠ å¯†ã€‚ å·¥å…·ï¼šUnix ç±»ç³»ç»Ÿä¸Šçš„ zip å’Œ unzip å‘½ä»¤ï¼Œå„ç§å›¾å½¢å·¥å…·ï¼Œä»¥åŠè®¸å¤šæ“ä½œç³»ç»Ÿçš„åŸç”Ÿæ”¯æŒã€‚ 2. Gzip æ–‡ä»¶ (.gz) æ ¼å¼ï¼šå•æ–‡ä»¶å‹ç¼©æ ¼å¼ã€‚ å‹ç¼©ï¼šä½¿ç”¨ DEFLATE ç®—æ³•ã€‚ å¸¸è§ç”¨é€”ï¼šé€šå¸¸ç”¨äºå‹ç¼©å•ä¸ªæ–‡ä»¶æˆ–ä¸ tar ç»“åˆå‹ç¼©å¤šä¸ªæ–‡ä»¶/ç›®å½•ã€‚ ç‰¹ç‚¹ï¼š å‹ç¼©é€Ÿåº¦å¿«ï¼Œå‹ç¼©æ¯”å¥½ã€‚ ä¸èƒ½å•ç‹¬å½’æ¡£å¤šä¸ªæ–‡ä»¶æˆ–ç›®å½•ï¼Œé€šå¸¸ä¸ tar ä¸€èµ·ä½¿ç”¨ã€‚ å·¥å…·ï¼šgzip å’Œ gunzip å‘½ä»¤ã€‚ 3. å¸¦ Gzip å‹ç¼©çš„ Tar åŒ… (.tar.gz æˆ– .tgz) æ ¼å¼ï¼šç»“åˆ tarï¼ˆå½’æ¡£ï¼‰å’Œ gzipï¼ˆå‹ç¼©ï¼‰ã€‚ å‹ç¼©ï¼šä½¿ç”¨ gzip è¿›è¡Œå‹ç¼©ã€‚ å¸¸è§ç”¨é€”ï¼šUnix ç±»ç³»ç»Ÿä¸­å¸¸ç”¨äºè½¯ä»¶æ‰“åŒ…å’Œåˆ†å‘ã€‚ ç‰¹ç‚¹ï¼š å°†å¤šä¸ªæ–‡ä»¶å’Œç›®å½•å½’æ¡£ä¸ºä¸€ä¸ªæ–‡ä»¶ã€‚ é¡ºåºè®¿é—®ï¼Œéœ€è¦è§£å‹æ•´ä¸ªå½’æ¡£æ–‡ä»¶æ‰èƒ½è®¿é—®æ–‡ä»¶ã€‚ å¹¿æ³›æ”¯æŒå¹¶ç”¨äºè½¯ä»¶åˆ†å‘ã€‚ å·¥å…·ï¼šå¸¦æœ‰ -czvf å’Œ -xzvf é€‰é¡¹çš„ tar å‘½ä»¤ã€‚ 4. å¸¦ Bzip2 å‹ç¼©çš„ Tar åŒ… (.tar.bz2) æ ¼å¼ï¼šç»“åˆ tarï¼ˆå½’æ¡£ï¼‰å’Œ bzip2ï¼ˆå‹ç¼©ï¼‰ã€‚ å‹ç¼©ï¼šä½¿ç”¨ Burrows-Wheeler ç®—æ³•ï¼Œå‹ç¼©æ¯”æ›´å¥½ä½†å‹ç¼©é€Ÿåº¦è¾ƒæ…¢ã€‚ å¸¸è§ç”¨é€”ï¼šç”¨äºå‹ç¼©æ¯”æ¯”å‹ç¼©é€Ÿåº¦æ›´é‡è¦çš„åœºæ™¯ã€‚ ç‰¹ç‚¹ï¼š å°†å¤šä¸ªæ–‡ä»¶å’Œç›®å½•å½’æ¡£ä¸ºä¸€ä¸ªæ–‡ä»¶ã€‚ å‹ç¼©æ¯”æ¯” gzip æ›´å¥½ï¼Œä½†é€Ÿåº¦è¾ƒæ…¢ã€‚ é¡ºåºè®¿é—®ã€‚ å·¥å…·ï¼šå¸¦æœ‰ -cjvf å’Œ -xjvf é€‰é¡¹çš„ tar å‘½ä»¤ã€‚ 5. å¸¦ XZ å‹ç¼©çš„ Tar åŒ… (.tar.xz) æ ¼å¼ï¼šç»“åˆ tarï¼ˆå½’æ¡£ï¼‰å’Œ xzï¼ˆå‹ç¼©ï¼‰ã€‚ å‹ç¼©ï¼šä½¿ç”¨ LZMA2 ç®—æ³•ï¼Œæä¾›éå¸¸é«˜çš„å‹ç¼©æ¯”å’Œè‰¯å¥½çš„é€Ÿåº¦ã€‚ å¸¸è§ç”¨é€”ï¼šåœ¨éœ€è¦æœ€å¤§å‹ç¼©æ¯”çš„æƒ…å†µä¸‹è¶Šæ¥è¶Šå—æ¬¢è¿ï¼Œç”¨äºè½¯ä»¶åˆ†å‘å’Œå¤‡ä»½ã€‚ ç‰¹ç‚¹ï¼š å°†å¤šä¸ªæ–‡ä»¶å’Œç›®å½•å½’æ¡£ä¸ºä¸€ä¸ªæ–‡ä»¶ã€‚ åœ¨æåˆ°çš„æ ¼å¼ä¸­å‹ç¼©æ¯”æœ€é«˜ã€‚ é¡ºåºè®¿é—®ã€‚ å·¥å…·ï¼šå¸¦æœ‰ -cJvf å’Œ -xJvf é€‰é¡¹çš„ tar å‘½ä»¤ã€‚ ä¸»è¦åŒºåˆ« å‹ç¼©ç®—æ³•ï¼š Zipï¼šé»˜è®¤ä½¿ç”¨ DEFLATEã€‚ Gzipï¼šDEFLATEã€‚ Bzip2ï¼šBurrows-Wheelerã€‚ XZï¼šLZMA2ã€‚ å‹ç¼©æ¯”ï¼š Zipï¼šä¸­ç­‰ã€‚ Gzipï¼šä¸­ç­‰åˆ°å¥½ã€‚ Bzip2ï¼šé«˜ã€‚ XZï¼šéå¸¸é«˜ã€‚ å‹ç¼©é€Ÿåº¦ï¼š Zipï¼šå¿«ã€‚ Gzipï¼šå¿«ã€‚ Bzip2ï¼šè¾ƒæ…¢ã€‚ XZï¼šæ¯” gzip æ…¢ä½†æ¯” bzip2 å¿«ã€‚ å½’æ¡£èƒ½åŠ›ï¼š Zipï¼šæ˜¯ï¼ˆä¸€æ­¥å®Œæˆï¼‰ã€‚ Gzipï¼šå¦ï¼ˆä¸ tar ä¸€èµ·ä½¿ç”¨ï¼‰ã€‚ Bzip2ï¼šå¦ï¼ˆä¸ tar ä¸€èµ·ä½¿ç”¨ï¼‰ã€‚ XZï¼šå¦ï¼ˆä¸ tar ä¸€èµ·ä½¿ç”¨ï¼‰ã€‚ æ–‡ä»¶è®¿é—®ï¼š Zipï¼šéšæœºè®¿é—®ã€‚ Gzip/Tar.gzï¼šé¡ºåºè®¿é—®ã€‚ Bzip2/Tar.bz2ï¼šé¡ºåºè®¿é—®ã€‚ XZ/Tar.xzï¼šé¡ºåºè®¿é—®ã€‚ æ€»ç»“ Zipï¼šé€‚åˆé€šç”¨çš„ã€è·¨å¹³å°çš„æ–‡ä»¶å…±äº«ï¼Œæ”¯æŒéšæœºè®¿é—®ã€‚ Gzipï¼šå¸¸ç”¨äºå‹ç¼©å•ä¸ªæ–‡ä»¶æˆ–ä¸ tar ä¸€èµ·ç”¨äºå¤šä¸ªæ–‡ä»¶ï¼Œé€Ÿåº¦å’Œå‹ç¼©æ¯”å¹³è¡¡è‰¯å¥½ã€‚ Tar.gzï¼šUnix ç±»ç³»ç»Ÿä¸­å¸¸è§çš„è½¯ä»¶æ‰“åŒ…æ–¹å¼ï¼Œå‹ç¼©æ¯”ä¸­ç­‰ã€‚ Tar.bz2ï¼šå‹ç¼©æ¯”æ¯” gzip å¥½ä½†é€Ÿåº¦è¾ƒæ…¢ï¼Œé€‚åˆå¯¹å‹ç¼©æ¯”è¦æ±‚æ›´é«˜çš„åœºæ™¯ã€‚ Tar.xzï¼šå‹ç¼©æ¯”æœ€é«˜ï¼Œé€‚åˆéœ€è¦æœ€å¤§å‹ç¼©æ¯”çš„åœºæ™¯ï¼Œå°½ç®¡é€Ÿåº¦è¾ƒæ…¢ã€‚ æ ¹æ®ä½ çš„å…·ä½“éœ€æ±‚é€‰æ‹©å‹ç¼©æ¯”ã€é€Ÿåº¦å’Œæ–‡ä»¶è®¿é—®è¦æ±‚åˆé€‚çš„æ ¼å¼ã€‚ "},"Misc/ComputationForcePlatforms.html":{"url":"Misc/ComputationForcePlatforms.html","title":"ComputationForcePlatforms","keywords":"","body":"featurize autodl "},"Misc/Copy.html":{"url":"Misc/Copy.html","title":"Copy","keywords":"","body":"To use scp to copy a directory but exclude a specific subdirectory in Debian 12, you can achieve this by combining tar with SSH. The scp command itself does not directly support excluding files or directories, but you can use the following approach as a workaround: Command: tar --exclude='dir_father/dir_child1' -cf - dir_father | ssh user@remote_host 'cd /destination/path && tar -xf -' Explanation: tar on the local machine: --exclude='dir_father/dir_child1': Skips the dir_child1 directory during the tar process. -cf - dir_father: Creates a tar archive of dir_father but writes it to standard output (-). ssh: Connects to the remote host. tar on the remote machine: cd /destination/path: Ensures the extracted files are placed in the correct destination. tar -xf -: Reads the tar archive from standard input and extracts it. Replace the following placeholders with actual values: user: Your username on the remote host. remote_host: The hostname or IP of the remote machine. /destination/path: The desired destination directory on the remote machine. Notes: Ensure you have the necessary permissions on both the local and remote directories. If your dir_child1 contains sensitive data or large files, double-check the exclusion path to avoid accidental transfer. Let me know if you need further clarification! "},"Misc/Drawing.html":{"url":"Misc/Drawing.html","title":"Drawing","keywords":"","body":"Drawing ç¥ç»ç½‘ç»œç”»å›¾ gwding/draw_convnet (github.com) https://cbovar.github.io/ConvNetDraw/ Others canva: Visual Suite for Everyone can draw simple icons from words, e.g. \"NUDT SysY Compiler\" milanote: the tool for organizing creative projects "},"Misc/Flatpack.html":{"url":"Misc/Flatpack.html","title":"Flatpack","keywords":"","body":"Flatpack flatpak The future of apps on Linux. Change Sources: flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo flatpak remotes --show-details # æ˜¾ç¤ºflatpakå®˜æ–¹æº flatpak remote-modify flathub --url=https://mirror.sjtu.edu.cn/flathub # run gimp flatpak run org.gimp.GIMP//stable "},"Misc/Fonts.html":{"url":"Misc/Fonts.html","title":"Fonts","keywords":"","body":"serach font on google, download the font file and install. gui managers: sudo apt install font-manager fc-cache -fv fc-list | grep \"IBM Plex Serif\" "},"Misc/FuzzTesting/FuzzTesting.html":{"url":"Misc/FuzzTesting/FuzzTesting.html","title":"FuzzTesting","keywords":"","body":"Fuzz Testing wiki: Fuzz testing In programming and software development, fuzzing or fuzz testing is an automated software testing technique that involves providing invalid, unexpected, or random data as inputs to a computer program. The program is then monitored for exceptions such as crashes) \"Crash (computing)\"), failing built-in code assertions) \"Assertion (software development)\"), or potential memory leaks. Typically, fuzzers are used to test programs that take structured inputs. This structure is specified, such as in a file format or protocol and distinguishes valid from invalid input. An effective fuzzer generates semi-valid inputs that are \"valid enough\" in that they are not directly rejected by the parser, but do create unexpected behaviors deeper in the program and are \"invalid enough\" to expose corner cases that have not been properly dealt with. åœ¨ç¼–ç¨‹å’Œè½¯ä»¶å¼€å‘ä¸­ï¼Œæ¨¡ç³Šæµ‹è¯•æˆ–æ¨¡ç³Šæµ‹è¯•æ˜¯ä¸€ç§è‡ªåŠ¨åŒ–è½¯ä»¶æµ‹è¯•æŠ€æœ¯ï¼Œæ¶‰åŠæä¾›æ— æ•ˆã€æ„å¤–æˆ–éšæœºçš„æ•°æ®ä½œä¸ºè®¡ç®—æœºç¨‹åºçš„è¾“å…¥ã€‚ç„¶åï¼Œå°†ç›‘è§†ç¨‹åºæ˜¯å¦å­˜åœ¨å¼‚å¸¸ï¼Œä¾‹å¦‚å´©æºƒã€å†…ç½®ä»£ç æ–­è¨€å¤±è´¥æˆ–æ½œåœ¨çš„å†…å­˜æ³„æ¼ã€‚é€šå¸¸ï¼Œæ¨¡ç³Šæµ‹è¯•ç¨‹åºç”¨äºæµ‹è¯•é‡‡ç”¨ç»“æ„åŒ–è¾“å…¥çš„ç¨‹åºã€‚æ­¤ç»“æ„æ˜¯æŒ‡å®šçš„ï¼Œä¾‹å¦‚ä»¥æ–‡ä»¶æ ¼å¼æˆ–åè®®æŒ‡å®šï¼Œå¹¶åŒºåˆ†æœ‰æ•ˆè¾“å…¥å’Œæ— æ•ˆè¾“å…¥ã€‚æœ‰æ•ˆçš„æ¨¡ç³Šæµ‹è¯•å™¨ä¼šç”Ÿæˆâ€œè¶³å¤Ÿæœ‰æ•ˆâ€çš„åŠæœ‰æ•ˆè¾“å…¥ï¼Œå› ä¸ºå®ƒä»¬ä¸ä¼šè¢«è§£æå™¨ç›´æ¥æ‹’ç»ï¼Œä½†ç¡®å®ä¼šåœ¨ç¨‹åºçš„æ›´æ·±å¤„äº§ç”Ÿæ„æƒ³ä¸åˆ°çš„è¡Œä¸ºï¼Œå¹¶ä¸”â€œè¶³å¤Ÿæ— æ•ˆâ€ä»¥æš´éœ²æœªæ­£ç¡®å¤„ç†çš„æç«¯æƒ…å†µã€‚ afl AFL: American Fuzzy Lop afl aflplusplus afl.rs rust-fuzz: AFL for Rust American fuzzy lop is a security-oriented fuzzer that employs a novel type of compile-time instrumentation and genetic algorithms to automatically discover clean, interesting test cases that trigger new internal states in the targeted binary. This substantially improves the functional coverage for the fuzzed code. The compact synthesized corpora produced by the tool are also useful for seeding other, more labor- or resource-intensive testing regimes down the road. American fuzzy lop æ˜¯ä¸€ä¸ªä»¥å®‰å…¨ä¸ºå¯¼å‘çš„ æ¨¡ç³Šå™¨ï¼Œé‡‡ç”¨æ–°å‹ç¼–è¯‘æ—¶æ£€æµ‹å’Œé—ä¼ ç®—æ³•æ¥è‡ªåŠ¨å‘ç°å¹²å‡€ã€æœ‰è¶£çš„æµ‹è¯•ç”¨ä¾‹ï¼Œä»è€Œè§¦å‘ç›®æ ‡äºŒè¿›åˆ¶æ–‡ä»¶ä¸­çš„æ–°å†…éƒ¨çŠ¶æ€ã€‚è¿™å¤§å¤§æé«˜äº†æ¨¡ç³Šä»£ç çš„åŠŸèƒ½è¦†ç›–ç‡ã€‚è¯¥å·¥å…·ç”Ÿæˆçš„ç´§å‡‘çš„åˆæˆè¯­æ–™åº“ä¹Ÿå¯ç”¨äºä¸ºå°†æ¥çš„å…¶ä»–åŠ³åŠ¨æˆ–èµ„æºå¯†é›†å‹æµ‹è¯•åˆ¶åº¦å¥ å®šåŸºç¡€ã€‚ Compared to other instrumented fuzzers, afl-fuzz is designed to be practical: it has modest performance overhead, uses a variety of highly effective fuzzing strategies and effort minimization tricks, requires essentially no configuration, and seamlessly handles complex, real-world use cases - say, common image parsing or file compression libraries. ä¸å…¶ä»–ä»ªå™¨åŒ–æ¨¡ç³Šå™¨ç›¸æ¯”,afl-fuzzè¢«è®¾è®¡ä¸ºå®ç”¨:å®ƒå…·æœ‰é€‚åº¦çš„æ€§èƒ½å¼€é”€,ä½¿ç”¨å„ç§é«˜æ•ˆçš„æ¨¡ç³Šç­–ç•¥å’ŒåŠªåŠ›æœ€å°åŒ–æŠ€å·§,åŸºæœ¬ä¸Šä¸éœ€è¦é…ç½®,å¹¶ä¸”å¯ä»¥æ— ç¼å¤„ç†å¤æ‚çš„ç°å®ä¸–ç•Œç”¨ä¾‹ - ä¾‹å¦‚,å¸¸è§çš„å›¾åƒè§£ææˆ–æ–‡ä»¶å‹ç¼©åº“ã€‚ AFL.RS Fuzz testing is a software testing technique used to find security and stability issues by providing pseudo-random data as input to the software. AFLplusplus is a popular, effective, and modern fuzz testing tool based on AFL. This library, afl.rs, allows one to run AFLplusplus on code written in the Rust programming language. æ¨¡ç³Šæµ‹è¯•æ˜¯ä¸€ç§è½¯ä»¶æµ‹è¯•æŠ€æœ¯ï¼Œç”¨äºé€šè¿‡æä¾›ä¼ªéšæœºæ•°æ®ä½œä¸ºè½¯ä»¶çš„è¾“å…¥æ¥å‘ç°å®‰å…¨æ€§å’Œç¨³å®šæ€§é—®é¢˜ã€‚ AFLplusplus æ˜¯ä¸€ç§åŸºäº AFL çš„æµè¡Œã€æœ‰æ•ˆã€ç°ä»£çš„æ¨¡ç³Šæµ‹è¯•å·¥å…·ã€‚è¿™ä¸ªåº“ afl.rs å…è®¸äººä»¬åœ¨ç”¨ Rust ç¼–ç¨‹è¯­è¨€ç¼–å†™çš„ä»£ç ä¸Šè¿è¡Œ AFLplusplusã€‚ "},"Misc/FuzzTesting/AFL.RS.html":{"url":"Misc/FuzzTesting/AFL.RS.html","title":"AFL.RS","keywords":"","body":"AFL: American Fuzzy Lop Issue 1: Debian12 default python3.11, if use conda env python3.12, and build afl, afl need libpython3.12.so.1.0, .... solve: use python3.11 to build afl recommand: change conda base env python version to 3.11 "},"Misc/FuzzTesting/Issues_Solutions.html":{"url":"Misc/FuzzTesting/Issues_Solutions.html","title":"Issues_Solutions","keywords":"","body":"Issues and Solutions "},"Misc/GIS/GIS.html":{"url":"Misc/GIS/GIS.html","title":"GIS","keywords":"","body":"Geographic Information System GIS Software QIGS install on debian/ubuntu equatorstudios GIS Libs samgeo A Python package for segmenting geospatial data with the Segment Anything Model (SAM) doc: samgeo "},"Misc/GIS/OpenShp.html":{"url":"Misc/GIS/OpenShp.html","title":"OpenShp","keywords":"","body":"Shp File How to Open and Work with Shapefiles and GeoJSON Files To open and work with GeoJSON or Shapefiles using free and open-source software (FOSS), there are several excellent tools you can use. Here's a step-by-step guide: 1. QGIS (Quantum GIS) QGIS is one of the most popular open-source Geographic Information System (GIS) software. It fully supports Shapefiles and GeoJSON files. Steps: Download QGIS: Download and install QGIS from https://qgis.org. Open a Shapefile: Launch QGIS. Go to Layer > Add Layer > Add Vector Layer. Browse to the Shapefile (.shp) file (you'll also need its associated .dbf and .shx files). Click \"Add\" to display the Shapefile. Inspect and Edit: Use the \"Attributes Table\" to view data. Apply styling, run spatial analysis, or export the data. Open GeoJSON: Similarly, go to Layer > Add Layer > Add Vector Layer, and browse to the .geojson file. 2. GDAL/OGR Tools (Command-line) The GDAL library provides command-line tools to manipulate spatial data formats, including Shapefiles and GeoJSON. Steps: Install GDAL: For Windows, download the GDAL binaries from OSGeo4W. For Linux/Mac, use package managers (sudo apt install gdal-bin or brew install gdal). View Shapefile Info: Run ogrinfo to inspect the file:ogrinfo -al -so your_file.shp Convert Shapefile to GeoJSON: Use ogr2ogr to convert formats:ogr2ogr -f \"GeoJSON\" output.geojson input.shp 3. GeoServer GeoServer is a web-based server to visualize and share spatial data. Steps: Install GeoServer: Download it from http://geoserver.org. Run the GeoServer web interface. Upload Shapefile/GeoJSON: Create a workspace and data store. Upload the Shapefile or GeoJSON to the data store. View or Serve: Preview the data as a map. Serve it as a WMS/WFS for online use. 4. Python Libraries: GeoPandas and Fiona If you're comfortable with Python, libraries like GeoPandas and Fiona are excellent tools. Steps: Install GeoPandas and Fiona: pip install geopandas pip install fiona Read a Shapefile: import geopandas as gpd shapefile = gpd.read_file('your_file.shp') print(shapefile.head()) Read a GeoJSON: geojson = gpd.read_file('your_file.geojson') print(geojson) Plot or Analyze Data: shapefile.plot() 5. Online Tools You can use online FOSS tools like Mapshaper (for lightweight Shapefile and GeoJSON editing) at https://mapshaper.org. Steps: Visit the site and upload your file. Edit, simplify, or convert between formats directly in the browser. Summary QGIS: Best for comprehensive spatial data management. GDAL/OGR: Best for command-line and batch operations. GeoServer: Best for web-based visualization and sharing. GeoPandas/Fiona: Best for Python developers. Mapshaper: Lightweight and quick edits online. All of these options are free and open-source! "},"Misc/GRUB.html":{"url":"Misc/GRUB.html","title":"GRUB","keywords":"","body":"GRUB GRUB (GRand Unified Bootloader) is the default bootloader for most Linux distributions. It is responsible for loading the kernel and passing control to it. It can be customized to load different operating systems, different kernel versions, and even different boot configurations. To customize GRUB, you can edit the /etc/default/grub file. This file contains a list of configuration options for GRUB. You can add or remove options as needed. To make changes permanent, you can update the GRUB configuration using the update-grub command. This will generate a new /boot/grub/grub.cfg file that will be used by GRUB on the next boot. To see the current GRUB configuration, you can run the grub-editenv command. This will open an interactive shell where you can modify the GRUB environment variables. To add a new operating system to GRUB, you can create a new entry in the /etc/grub.d directory. This directory contains a series of shell scripts that are executed by GRUB in order to generate the GRUB configuration. Each script is responsible for adding a new entry to the GRUB menu. GRand Unified Bootloaderï¼ˆå¤§ä¸€ç»Ÿå¼•å¯¼ç¨‹åºï¼‰ GRUB è¯•å›¾ä¸º IBM PC å…¼å®¹æœºæä¾›ä¸€ä¸ªå¼•å¯¼åŠ è½½ç¨‹åºï¼Œå®ƒæ—¢èƒ½ä¸ºåˆå­¦è€…æˆ–å¯¹æŠ€æœ¯ä¸æ„Ÿå…´è¶£çš„ç”¨æˆ·æä¾›æ–¹ä¾¿ï¼Œåˆèƒ½çµæ´»åœ°å¸®åŠ©ä¸“å®¶åœ¨ä¸åŒçš„ç¯å¢ƒä¸­ä½¿ç”¨ã€‚ç›®å‰ï¼Œå®ƒæœ€é€‚ç”¨äºè‡³å°‘ä½¿ç”¨ä¸€ç§ç±»ä¼¼ UNIX çš„å…è´¹æ“ä½œç³»ç»Ÿçš„ç”¨æˆ·ï¼Œä½†ä¹Ÿå¯ç”¨äºå¤§å¤šæ•° PC æ“ä½œç³»ç»Ÿã€‚ è¿™ä¸ªé¡¹ç›®çš„èµ·å› å®é™…ä¸Šæ˜¯æˆ‘ä»¬æƒ³åœ¨ IBM PC å…¼å®¹ç³»ç»Ÿçš„ Mach4 ä¸Šä»¥ç¬¦åˆå¤šé‡å¼•å¯¼æ ‡å‡†çš„æ–¹å¼å¼•å¯¼ GNU HURD æ“ä½œç³»ç»Ÿã€‚ç„¶åï¼Œæˆ‘å°è¯•åœ¨ FreeBSD ä½¿ç”¨çš„æ ‡å‡†å¼•å¯¼åŠ è½½ç¨‹åºä¸­æ·»åŠ å¯¹é¢å¤–åŠŸèƒ½çš„æ”¯æŒã€‚ä¸ºäº†è®©æ‰€æœ‰åŠŸèƒ½éƒ½èƒ½æ­£å¸¸å·¥ä½œï¼Œæˆ‘å¿…é¡»åšçš„äº‹æƒ…è¶Šæ¥è¶Šå¤šï¼Œç›´åˆ°æ˜¾ç„¶æœ‰å¿…è¦ä»å¤´å¼€å§‹å¦èµ·ç‚‰ç¶ã€‚ GRUB ä»ä¸€å¼€å§‹çš„å¤šæ¨¡å—å¼•å¯¼åŠ è½½å™¨å‘å±•åˆ°ç°åœ¨å·²ç»æœ‰å¾ˆé•¿çš„è·¯è¦èµ°äº†ã€‚å®ƒæ‰€ä½¿ç”¨çš„ä¸€äº›æŠ€æœ¯åœ¨è‡ªç”±è½¯ä»¶ä¸–ç•Œä¸­æ˜¯ç‹¬ä¸€æ— äºŒçš„ï¼Œè¿˜æœ‰ä¸€äº›æŠ€æœ¯æ˜¾ç„¶ä¹Ÿä¼˜äºå¤§å¤šæ•°ä¸“æœ‰æ“ä½œç³»ç»Ÿã€‚è¿™é‡Œå’Œå¤šå¼•å¯¼å»ºè®®ä¸­çš„æ–‡æ¡£å¯¹æœªæ¥çš„æ“ä½œç³»ç»Ÿå’Œ PC å¼•å¯¼åŠ è½½ç¨‹åºç¼–å†™è€…åº”è¯¥éå¸¸æœ‰ç”¨ã€‚ grub å‘½ä»¤ grub å‘½ä»¤çš„åŠŸèƒ½æ˜¯ç”¨äºäº¤äº’å¼åœ°ç®¡ç† GRUB å¼•å¯¼ç¨‹åºã€‚GRUB æ˜¯ä¸€ä¸ªç³»ç»Ÿå¼•å¯¼ç¨‹åºï¼Œå¯ä»¥æœåŠ¡äº Linuxã€Windowsã€FreeBSD ç­‰å¸¸è§æ“ä½œç³»ç»Ÿï¼Œé…ç½®æ–¹å¼åˆ†ä¸ºäº¤äº’å¼å’Œéäº¤äº’å¼ä¸¤ç§æ¨¡å¼ï¼Œç”¨æˆ·åªéœ€è¦é”®å…¥ grub å‘½ä»¤å³å¯è¿›å…¥åˆ°â€œgrub>â€æç¤ºçŠ¶æ€ï¼Œç„¶åé€šè¿‡å¸¸ç”¨å‘½ä»¤åŠå‚æ•°è¿›è¡Œé…ç½®å·¥ä½œã€‚åŸæ–‡é“¾æ¥ï¼š https://www.linuxcool.com/grub Linux é»‘è¯è§£é‡Šï¼šLinux ä¸­çš„ GRUB æ˜¯ä»€ä¹ˆï¼Ÿ | Linux ä¸­å›½ - çŸ¥ä¹ (zhihu.com) GNU GRUB - GNU Project - Free Software Foundation (FSF) "},"Misc/GitBook.html":{"url":"Misc/GitBook.html","title":"GitBook","keywords":"","body":"GitBook Product documentation (your users will love) Forget building your own custom docs platform. With GitBook you get beautiful documentation for your users, and a branch-based Git workflow for your team. gitbook.com gitbook-ng.github.io gitbook-documentation zh gitbook-cli github: GitbookIO/gitbook GitbookIO/integrations Gitbook æ‰“é€ çš„ Gitbook è¯´æ˜æ–‡æ¡£ GitBook æ˜¯åŸºäº Node.js çš„å¼€æºå‘½ä»¤è¡Œå·¥å…·ï¼Œç”¨äºè¾“å‡ºæ¼‚äº®çš„ç”µå­ä¹¦ã€‚ é—æ†¾çš„æ˜¯ï¼ŒGitBookå¼€æºé¡¹ç›®å·²ç»åœæ­¢ç»´æŠ¤ï¼Œä¸“æ³¨æ‰“é€ çš„ gitbook.com ç½‘ç«™åœ¨å›½å†…è®¿é—®å—é™ã€‚ Extensions awesome-gitbook-plugins include-codeblock edit-link sharing terminull intopic-toc disqus github back-to-top-button download-pdf-link mermaid-newface # open base/Notes.pdf \"get-pdf\": { \"base\": \"https://github.com/houhuawei23/Notes/tree/gh-pages\", \"prefix\": \"Notes\", \"label\": \"Download PDF\" }, # open url \"my-toolbar\": { \"buttons\": [ { \"label\": \"ä¸‹è½½PDF\", \"icon\": \"fa fa-file-pdf-o\", \"url\": \"https://github.com/houhuawei23/Notes/tree/gh-pages/Notes.pdf\", \"position\": \"left\", \"text\": \"ä¸‹è½½PDF\", \"target\": \"_blank\" } ] } `` ## Install ```bash # install nvm curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash # install node version 10.24.1 nvm install 10.24.1 # install gitbook-cli (with change npm source) npm config set registry https://registry.npmmirror.com npm install gitbook-cli -g # install gitbook gitbook -V # ä¸‹è½½æ·»åŠ çš„æ’ä»¶ & build gitbook install gitbook build # generate static files under `_book` directory # start server: localhost:4000 gitbook serve æ ¼å¼ æ ¼å¼ä¸»è¦æ³¨é‡ç®€å•å’Œæ˜“è¯»æ€§ GitBook çº¦å®šäº†ä¸‹é¢è¿™äº›æ–‡ä»¶çš„ä½œç”¨ï¼š READMEï¼šä¹¦æœ¬çš„ä»‹ç» SUMMARYï¼šç« èŠ‚ç»“æ„, ç”¨æ¥ç”Ÿæˆä¹¦æœ¬å†…å®¹çš„é¢„è§ˆè¡¨ã€‚ LANGSï¼šå¤šè¯­è¨€ä¹¦ç± GLOSSARYï¼šæœ¯è¯­æè¿°çš„æ¸…å• è‡³å°‘éœ€è¦ä¸€ä¸ª README å’Œ SUMMARY æ–‡ä»¶æ¥æ„å»ºä¸€æœ¬ä¹¦ã€‚ Gitbook pdf gitbook pdf .pdf # gitbook-action.yml - name: Install Calibre (for ebook-convert) run: | sudo apt-get update sudo apt-get install -y calibre + Github Action # use prebuild image? coenvl/gitbook-calibre image: coenvl/gitbook-calibre pdf: script: - gitbook pdf ./ ./$CI_PROJECT_NAME.pdf artifacts: paths: - $CI_PROJECT_NAME.pdf # or install from scratch ... "},"Misc/Hyper-V.html":{"url":"Misc/Hyper-V.html","title":"Hyper-V","keywords":"","body":"Hyper-V æä¾›ç¡¬ä»¶è™šæ‹ŸåŒ– Windows 10 ä¸Šçš„ Hyper-V ç®€ä»‹ | Microsoft Learn åˆ›å»ºè™šæ‹Ÿç½‘ç»œ | Microsoft Learn Hyper-V æ˜¯å¾®è½¯å¼€å‘çš„ä¸€é¡¹è™šæ‹ŸåŒ–æŠ€æœ¯ï¼Œåœ¨ Windows Server å’Œ Windows 10 æ“ä½œç³»ç»Ÿä¸­å‡å¯ä½¿ç”¨ã€‚ç®€å•æ¥è¯´ï¼Œå®ƒå¯ä»¥è®©ä¸€ä¸ªç‰©ç†æœåŠ¡å™¨è¿è¡Œå¤šä¸ªè™šæ‹Ÿæœºï¼Œå¹¶å°†ç‰©ç†èµ„æºï¼ˆå¦‚ CPUã€å†…å­˜ã€ç£ç›˜ç©ºé—´ç­‰ï¼‰åˆ†é…ç»™è¿™äº›è™šæ‹Ÿæœºï¼Œä»è€Œå®ç°è™šæ‹ŸåŒ–ã€‚ ä½¿ç”¨ Hyper-V å¯ä»¥åœ¨åŒä¸€å°è®¡ç®—æœºä¸Šè¿è¡Œå¤šä¸ªæ“ä½œç³»ç»Ÿï¼Œè¿™äº›æ“ä½œç³»ç»Ÿå¯ä»¥æ˜¯ Windowsã€Linux æˆ–å…¶ä»–æ“ä½œç³»ç»Ÿã€‚æ¯ä¸ªè™šæ‹Ÿæœºå¯ä»¥ç‹¬ç«‹è¿è¡Œï¼Œå°±åƒåœ¨ç‰©ç†ç¡¬ä»¶ä¸Šè¿è¡Œä¸€æ ·ã€‚Hyper-V è¿˜æä¾›äº†ä¸€ä¸ªè™šæ‹Ÿæœºç®¡ç†å·¥å…·ï¼Œå¯ä»¥ç®¡ç†è™šæ‹Ÿæœºçš„é…ç½®ã€å¯åŠ¨ã€åœæ­¢ç­‰æ“ä½œã€‚ Hyper-V å…·æœ‰å¾ˆå¤šä¼˜ç‚¹ï¼Œå¦‚èµ„æºå…±äº«ã€å¿«é€Ÿéƒ¨ç½²ã€çµæ´»æ€§å’Œå¯æ‰©å±•æ€§ç­‰ã€‚å®ƒå¯ä»¥å¸®åŠ©ç»„ç»‡èŠ‚çœæˆæœ¬å¹¶æé«˜æ•ˆç‡ã€‚åŒæ—¶ï¼ŒHyper-V ä¹Ÿæ”¯æŒå¾ˆå¤šé«˜çº§åŠŸèƒ½ï¼Œå¦‚åŠ¨æ€å†…å­˜ã€è™šæ‹Ÿæœºå¿«ç…§ã€è¿œç¨‹ç®¡ç†ç­‰ï¼Œä½¿å…¶æ›´åŠ å¼ºå¤§å’Œä¾¿æ·ã€‚ æ€»çš„æ¥è¯´ï¼ŒHyper-V æ˜¯ä¸€é¡¹éå¸¸é‡è¦çš„è™šæ‹ŸåŒ–æŠ€æœ¯ï¼Œå®ƒä¸ºç»„ç»‡å’Œä¼ä¸šæä¾›äº†å¼ºå¤§çš„èµ„æºç®¡ç†å’Œåˆ©ç”¨èƒ½åŠ›ï¼Œå¯ä»¥å¸®åŠ©å®ç°æ›´åŠ é«˜æ•ˆçš„ IT è¿è¥ã€‚ è™šæ‹Ÿäº¤æ¢æœºï¼šHyper-V ä½¿ç”¨è™šæ‹Ÿäº¤æ¢æœºå°†è™šæ‹Ÿæœºè¿æ¥åˆ°ç‰©ç†ç½‘ç»œã€‚æ‚¨å¯ä»¥åˆ›å»ºæ–°çš„è™šæ‹Ÿäº¤æ¢æœºæˆ–ä½¿ç”¨ç°æœ‰çš„äº¤æ¢æœºã€‚ è™šæ‹Ÿæœºè®¾ç½®: æ‚¨å¯ä»¥é…ç½®è™šæ‹Ÿæœºçš„å„ç§è®¾ç½®ï¼Œä¾‹å¦‚å†…å­˜åˆ†é…ï¼Œå¤„ç†å™¨åˆ†é…å’Œç½‘ç»œé€‚é…å™¨è®¾ç½®ã€‚ é›†æˆæœåŠ¡: Hyper-V çš„é›†æˆæœåŠ¡å¯ä»¥æå‡è™šæ‹Ÿæœºçš„æ€§èƒ½å’ŒåŠŸèƒ½ã€‚æ‚¨å¯ä»¥æ ¹æ®éœ€è¦å¯ç”¨æˆ–ç¦ç”¨é›†æˆæœåŠ¡ã€‚ Virtual switch: Hyper-V uses a virtual switch to connect virtual machines to your physical network. You can create a new virtual switch or use an existing one. Virtual machine settings: You can configure various settings for your virtual machine, such as memory allocation, processor allocation, and network adapter settings. Integration services: Hyper-V integration services enhance the performance and functionality of virtual machines. You can enable or disable integration services as needed. "},"Misc/LLVM.html":{"url":"Misc/LLVM.html","title":"LLVM","keywords":"","body":"LLVM CN "},"Misc/Logics.html":{"url":"Misc/Logics.html","title":"Logics","keywords":"","body":"ã€Šé€»è¾‘çš„å¼•æ“ã€‹MartinDavis Turing,HisMachine and Computability Jurg Kohlas RegisterMachinesareTuringMachines ColinB.Price "},"Misc/Markdown.html":{"url":"Misc/Markdown.html","title":"Markdown","keywords":"","body":"Markdown John Gruber: Markdown syntax Markdown-Cheatsheet fullstackpython: markdown; some useful resources collections blog: python-markdown vscode extenssion Markdown All in One Key Command Ctrl/Cmd + B Toggle bold Ctrl/Cmd + I Toggle italic Alt+S (on Windows) Toggle strikethrough1 Ctrl + Shift + ] Toggle heading (uplevel) Ctrl + Shift + [ Toggle heading (downlevel) Ctrl/Cmd + M Toggle math environment Alt + C Check/Uncheck task list item Ctrl/Cmd + Shift + V Toggle preview Ctrl/Cmd + K V Toggle preview to side Tips Complete list of github markdown emoji markup developer-icons devicon Markdown Parser marked: js, ts markdown-it: js python: Python-Markdown: A Python implementation of John Gruberâ€™s Markdown with Extension support. mistune: py mistletoe: py; md -> html/latex/ast/md markdown-it-py marko: python markdown-worker-python: a versatile Python module for parsing, reading, and writing Markdown files. mrkdwn_analysis mrkdwn_analysis is a Python library for analyzing Markdown files. It extracts and categorizes Markdown elements like headers, sections, links, images, etc. Ideal for data analysis, content generation, and tool-building that requires Markdown parsing. mkreports Misc markdown-here: Google Chrome, Firefox, and Thunderbird extension that lets you write email in Markdown and render it before sending. "},"Misc/MemoryOrder.html":{"url":"Misc/MemoryOrder.html","title":"MemoryOrder","keywords":"","body":"text "},"Misc/NPM.html":{"url":"Misc/NPM.html","title":"NPM","keywords":"","body":"Node Package Manager (NPM) # change npm registry source npm config set registry https://registry.npmmirror.com # check in verbose mode npm install --verbose # clean cache and reinstall npm cache clean --force npm install # set proxy for npm npm config set proxy http://proxy.example.com:8080 npm config set https-proxy http://proxy.example.com:8080 # update npm npm install -g npm Node Version Manager (NVM) nvm PNPM (Fast, disk space efficient package manager) https://pnpm.io/installation "},"Misc/PowerShell.html":{"url":"Misc/PowerShell.html","title":"PowerShell","keywords":"","body":"PowerShell å¸¸ç”¨å‘½ä»¤ Proxy settings # C:\\Users\\ludiser\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 function set_proxy0 { $env:HTTP_PROXY=\"http://127.0.0.1:7890\" } function set_proxy1 { $env:HTTPS_PROXY=\"https://127.0.0.1:7890\" } function unset_proxy0 { $env:HTTP_PROXY=\"\" } function unset_proxy1 { $env:HTTPS_PROXY=\"\" } åˆ é™¤ # åˆ é™¤æŒ‡å®šæ–‡ä»¶ Remove-Item * -Include *.json -Recurse # åˆ é™¤æ–‡ä»¶è€Œä¿ç•™æ–‡ä»¶å¤¹ # ã€ŒThis example deletes all of the files that have names that include a dot (.) ã€ Remove-Item * -Include *.* -Exclude *.md -Recurse # åˆ é™¤åŒ…å«æŒ‡å®šå­—ç¬¦çš„æ–‡ä»¶å¤¹ # ä¸€å®šè¦æ³¨æ„åŠ ä¸Šé€šé…ç¬¦ã€Œ*bin*ã€ï¼Œå¦åˆ™åªä¼šåˆ é™¤binè¿™æ ·çš„æ–‡ä»¶å¤¹ Remove-Item * -Recurse -Include *bin* è·å–ç‰ˆæœ¬ä¿¡æ¯ $PSVersionTable.PSVersion è·å–ä¸»æœºä¿¡æ¯ Get-Host ä¸‹è½½æ–‡ä»¶ Invoke-WebRequest / iwr å‘½ä»¤ get-command è¿›ç¨‹ get-process æŒ‡ä»¤é‡å‘½å Set-Alias xxx0 xxx1 æ¸…å±cls æŸ¥æ‰¾ç¨‹åºè·¯å¾„ Get-Command -Name xxname "},"Misc/RegularExp.html":{"url":"Misc/RegularExp.html","title":"RegularExp","keywords":"","body":"Regular Expressions wikipedia runoob [^a-z] // é™¤äº†å°å†™å­—æ¯ä»¥å¤–çš„æ‰€æœ‰å­—ç¬¦ [^\\\\\\/\\^] // é™¤äº†(\\)(/)(^)ä¹‹å¤–çš„æ‰€æœ‰å­—ç¬¦ [^\\\"\\'] // é™¤äº†åŒå¼•å·(\")å’Œå•å¼•å·(')ä¹‹å¤–çš„æ‰€æœ‰å­—ç¬¦ a.*b // aåé¢å¯ä»¥æœ‰ä»»æ„å­—ç¬¦ï¼Œç›´åˆ°é‡åˆ°b "},"Misc/StorageTechs.html":{"url":"Misc/StorageTechs.html","title":"StorageTechs","keywords":"","body":"å­˜å‚¨æŠ€æœ¯æ¯”è¾ƒ ä»¥ä¸‹æ˜¯SDï¼ˆå®‰å…¨æ•°å­—ï¼‰ã€eMMCï¼ˆåµŒå…¥å¼å¤šåª’ä½“å¡ï¼‰å’ŒNVMeï¼ˆéæ˜“å¤±æ€§å­˜å‚¨å™¨å¿«è½¦ï¼‰è¿™ä¸‰ç§ä¸åŒå­˜å‚¨æŠ€æœ¯çš„æ¯”è¾ƒï¼š SDï¼ˆå®‰å…¨æ•°å­—ï¼‰ ç±»å‹ ï¼šå¯ç§»åŠ¨é—ªå­˜å¡ã€‚ å¸¸è§ç”¨é€” ï¼šç›¸æœºã€æ™ºèƒ½æ‰‹æœºã€å¹³æ¿ç”µè„‘åŠå…¶ä»–ä¾¿æºè®¾å¤‡ã€‚ å¤–å½¢å°ºå¯¸ ï¼šå°ï¼Œæœ‰æ ‡å‡†SDã€miniSDå’ŒmicroSDç­‰å¤šç§å°ºå¯¸ã€‚ é€Ÿåº¦ ï¼šæ ¹æ®ç±»åˆ«å’Œç±»å‹ï¼ˆå¦‚SDHCã€SDXCã€UHS-Iã€UHS-IIï¼‰è€Œæœ‰å¾ˆå¤§å·®å¼‚ã€‚ æ¥å£ ï¼šä½¿ç”¨SDæ¥å£ï¼Œé€Ÿåº¦æ¯”PCIeå’ŒSATAæ¥å£æ…¢ã€‚ å®¹é‡ ï¼šé€šå¸¸ä»å‡ GBåˆ°å‡ ç™¾GBä¸ç­‰ã€‚ æ€§èƒ½ ï¼šä¸€èˆ¬ä½äºeMMCå’ŒNVMeï¼Œé€‚åˆéœ€æ±‚è¾ƒä½çš„å­˜å‚¨ä»»åŠ¡ã€‚ eMMCï¼ˆåµŒå…¥å¼å¤šåª’ä½“å¡ï¼‰ ç±»å‹ ï¼šåµŒå…¥å¼ä¸å¯ç§»åŠ¨é—ªå­˜å­˜å‚¨ã€‚ å¸¸è§ç”¨é€” ï¼šæ™ºèƒ½æ‰‹æœºã€å¹³æ¿ç”µè„‘ã€ä½ç«¯ç¬”è®°æœ¬ç”µè„‘ã€ç‰©è”ç½‘è®¾å¤‡åŠä¸€äº›æ±½è½¦åº”ç”¨ã€‚ å¤–å½¢å°ºå¯¸ ï¼šç›´æ¥ç„Šæ¥åœ¨è®¾å¤‡ä¸»æ¿ä¸Šã€‚ é€Ÿåº¦ ï¼šæ¯”SDå¡å¿«ä½†æ¯”SSDï¼ˆå°¤å…¶æ˜¯NVMe SSDï¼‰æ…¢ï¼Œé€šå¸¸åœ¨200-400 MB/så·¦å³ã€‚ æ¥å£ ï¼šä½¿ç”¨ç±»ä¼¼SDçš„æ¥å£ï¼Œä½†ä¸ºåµŒå…¥å¼ä½¿ç”¨è¿›è¡Œäº†ä¼˜åŒ–ã€‚ å®¹é‡ ï¼šé€šå¸¸åœ¨16 GBåˆ°128 GBä¹‹é—´ï¼Œä½†ä¹Ÿæœ‰æ›´é«˜å®¹é‡çš„äº§å“ã€‚ æ€§èƒ½ ï¼šæä¾›é€‚ä¸­çš„æ€§èƒ½ï¼Œè¶³ä»¥æ»¡è¶³å¤§å¤šæ•°æ¶ˆè´¹ç±»ç§»åŠ¨åº”ç”¨çš„éœ€æ±‚ï¼Œä½†ä¸é€‚åˆé«˜æ€§èƒ½è®¡ç®—ä»»åŠ¡ã€‚ NVMeï¼ˆéæ˜“å¤±æ€§å­˜å‚¨å™¨å¿«è½¦ï¼‰ ç±»å‹ ï¼šé«˜æ€§èƒ½SSDå­˜å‚¨æŠ€æœ¯ã€‚ å¸¸è§ç”¨é€” ï¼šé«˜ç«¯ç¬”è®°æœ¬ç”µè„‘ã€å°å¼æœºã€æœåŠ¡å™¨åŠä¼ä¸šå­˜å‚¨è§£å†³æ–¹æ¡ˆã€‚ å¤–å½¢å°ºå¯¸ ï¼šå¤šç§ï¼ŒåŒ…æ‹¬M.2ã€U.2å’ŒPCIeæ‰©å±•å¡ã€‚ é€Ÿåº¦ ï¼šæ˜¾è‘—å¿«äºSDå’ŒeMMCï¼Œè¯»å†™é€Ÿåº¦è¶…è¿‡3000 MB/sã€‚ æ¥å£ ï¼šä½¿ç”¨PCIeæ¥å£ï¼Œæ”¯æŒæ›´é«˜çš„æ•°æ®ä¼ è¾“é€Ÿç‡å’Œæ›´ä½çš„å»¶è¿Ÿã€‚ å®¹é‡ ï¼šä»256 GBåˆ°æ•°TBä¸ç­‰ã€‚ æ€§èƒ½ ï¼šé«˜æ€§èƒ½ï¼Œé€‚ç”¨äºæ¸¸æˆã€è§†é¢‘ç¼–è¾‘å’ŒæœåŠ¡å™¨å·¥ä½œè´Ÿè½½ç­‰é«˜è¦æ±‚åº”ç”¨ã€‚ ä¸»è¦å·®å¼‚ å¤–å½¢å°ºå¯¸ ï¼š SD ï¼šå¯ç§»åŠ¨å¡ã€‚ eMMC ï¼šåµŒå…¥å¼ä¸”ä¸å¯ç§»åŠ¨ã€‚ NVMe ï¼šå¯ä»¥åµŒå…¥æˆ–ç”¨ä½œæ‰©å±•å¡ï¼Œæœ‰å¤šç§å¤–å½¢å°ºå¯¸ã€‚ æ€§èƒ½ ï¼š SD ï¼šæ€§èƒ½æœ€ä½ï¼Œé€‚ç”¨äºåŸºæœ¬å­˜å‚¨éœ€æ±‚ã€‚ eMMC ï¼šæ€§èƒ½é€‚ä¸­ï¼Œæ»¡è¶³å¤§å¤šæ•°ç§»åŠ¨å’Œæ¶ˆè´¹ç±»åº”ç”¨ã€‚ NVMe ï¼šæ€§èƒ½æœ€é«˜ï¼Œé€‚ç”¨äºé«˜è¦æ±‚åº”ç”¨å’Œé«˜é€Ÿæ•°æ®ä¼ è¾“ã€‚ æ¥å£ ï¼š SD ï¼šSDæ¥å£ã€‚ eMMC ï¼šç±»ä¼¼SDä½†ä¼˜åŒ–ç”¨äºåµŒå…¥å¼ä½¿ç”¨ã€‚ NVMe ï¼šPCIeæ¥å£ï¼Œé€Ÿåº¦æ›´å¿«ï¼Œå»¶è¿Ÿæ›´ä½ã€‚ ä½¿ç”¨åœºæ™¯ ï¼š SD ï¼šé€‚åˆç›¸æœºå’Œä¾¿æºè®¾å¤‡ç­‰å¯ç§»åŠ¨å­˜å‚¨éœ€æ±‚ã€‚ eMMC ï¼šé€‚åˆæˆæœ¬æ•ˆç›Šé«˜çš„æ¶ˆè´¹ç”µå­åµŒå…¥å¼å­˜å‚¨ã€‚ NVMe ï¼šæœ€ä½³é€‰æ‹©ç”¨äºè®¡ç®—æœºå’Œä¼ä¸šåº”ç”¨ä¸­çš„é«˜æ€§èƒ½å­˜å‚¨ã€‚ å®¹é‡ ï¼š SD ï¼šå®¹é‡é€šå¸¸ä½äºeMMCå’ŒNVMeã€‚ eMMC ï¼šå®¹é‡é€‚ä¸­ï¼Œå¸¸è§äºæ¶ˆè´¹ç”µå­äº§å“ã€‚ NVMe ï¼šå®¹é‡è¾ƒå¤§ï¼Œæ»¡è¶³æ›´é«˜çš„å­˜å‚¨éœ€æ±‚ã€‚ æ€»ç»“æ¥è¯´ï¼ŒSDå¡é€‚ç”¨äºå¯¹æ€§èƒ½è¦æ±‚è¾ƒä½çš„å¯ç§»åŠ¨å­˜å‚¨ï¼ŒeMMCé€‚åˆæ¶ˆè´¹ç”µå­äº§å“ä¸­çš„åµŒå…¥å¼åº”ç”¨ï¼ŒNVMeåˆ™æä¾›æœ€é«˜æ€§èƒ½ï¼Œé€‚ç”¨äºé«˜è¦æ±‚åº”ç”¨å’Œé«˜é€Ÿæ•°æ®ä¼ è¾“ã€‚ SD (Secure Digital), eMMC (embedded MultiMediaCard), and NVMe (Non-Volatile Memory Express) are different types of storage technologies used in various devices. Here's a detailed comparison of each: SD (Secure Digital) Type : Removable flash memory card. Common Uses : Cameras, smartphones, tablets, and other portable devices. Form Factor : Small, with various sizes including standard SD, miniSD, and microSD. Speed : Varies significantly by class and type (e.g., SDHC, SDXC, UHS-I, UHS-II). Interface : Uses the SD interface, which is slower compared to PCIe and SATA interfaces. Capacity : Typically ranges from a few GB to several hundred GB. Performance : Generally lower than eMMC and NVMe, suitable for less demanding storage tasks. eMMC (embedded MultiMediaCard) Type : Embedded non-removable flash storage. Common Uses : Smartphones, tablets, low-end laptops, IoT devices, and some automotive applications. Form Factor : Soldered directly onto the device's motherboard. Speed : Faster than SD cards but slower than SSDs (especially NVMe SSDs). Typically around 200-400 MB/s. Interface : Uses an interface similar to SD, but optimized for embedded use. Capacity : Usually ranges from 16 GB to 128 GB, though higher capacities are available. Performance : Provides moderate performance, sufficient for most consumer mobile applications but not for high-performance computing tasks. NVMe (Non-Volatile Memory Express) Type : High-performance SSD storage technology. Common Uses : High-end laptops, desktops, servers, and enterprise storage solutions. Form Factor : Various, including M.2, U.2, and PCIe add-in cards. Speed : Significantly faster than both SD and eMMC, with speeds exceeding 3,000 MB/s for reads and writes. Interface : Uses the PCIe interface, allowing for much higher data transfer rates and lower latency. Capacity : Ranges from 256 GB to several TB. Performance : High performance, suitable for demanding applications like gaming, video editing, and server workloads. Key Differences Form Factor : SD : Removable cards. eMMC : Embedded and non-removable. NVMe : Can be embedded or used as add-in cards, with various form factors. Performance : SD : Lowest performance, suitable for basic storage needs. eMMC : Moderate performance, sufficient for most mobile and consumer applications. NVMe : Highest performance, suitable for demanding applications and high-speed data transfer. Interface : SD : SD interface. eMMC : Similar to SD but optimized for embedded use. NVMe : PCIe interface, much faster and lower latency. Usage Scenarios : SD : Ideal for removable storage needs like cameras and portable devices. eMMC : Suitable for cost-effective embedded storage in consumer electronics. NVMe : Best for high-performance storage in computers and enterprise applications. Capacity : SD : Typically lower capacities compared to eMMC and NVMe. eMMC : Moderate capacities, often seen in consumer electronics. NVMe : Higher capacities, catering to more intensive storage requirements. In summary, SD cards are ideal for removable storage with moderate performance needs, eMMC is suitable for embedded applications with moderate performance, and NVMe offers the highest performance for demanding applications and high-speed data transfer. "},"Misc/TWRP.html":{"url":"Misc/TWRP.html","title":"TWRP","keywords":"","body":"TWRP: Team Win Recovery Project TeamWin - TWRP TWRPæ˜¯ä¸€ä¸ªå¼€æºçš„ç¬¬ä¸‰æ–¹Recoveryç³»ç»Ÿï¼Œç”¨äºæ›¿ä»£Androidè®¾å¤‡çš„åŸç”ŸRecoveryç³»ç»Ÿï¼Œæä¾›æ›´å¤šåŠŸèƒ½å’Œé€‰é¡¹ï¼Œå¦‚å¤‡ä»½ã€æ¢å¤ã€åˆ·æœºç­‰ï¼Œä¸ºç”¨æˆ·æä¾›æ›´çµæ´»å’Œå®šåˆ¶åŒ–çš„æ“ä½œä½“éªŒã€‚ TWRPæ”¯æŒå¤šç§Androidè®¾å¤‡ï¼Œæä¾›äº†ç›´è§‚çš„å›¾å½¢ç•Œé¢å’Œè§¦æ‘¸å±æ”¯æŒï¼Œä½¿ç”¨æˆ·èƒ½å¤Ÿè½»æ¾è¿›è¡Œæ‰¹é‡æ“ä½œï¼Œæ›´æ–¹ä¾¿åœ°ç®¡ç†å’Œç»´æŠ¤è‡ªå·±çš„è®¾å¤‡ã€‚ "},"Misc/TimeSeriesPrediction/ACF.html":{"url":"Misc/TimeSeriesPrediction/ACF.html","title":"ACF","keywords":"","body":"Autocorrelation Function (ACF) The Autocorrelation Function (ACF) is a statistical tool used to measure the correlation between a time series and its lagged versions. In other words, it quantifies how similar a time series is to itself at different points in time. The ACF is widely used in time series analysis, particularly in the context of identifying patterns, trends, and seasonality, as well as in model building for forecasting. Key Concepts: Lag: The lag $k$ represents the time difference between the observations in the time series. For example, if you have a monthly time series, a lag of 1 means you are comparing each month with the previous month, a lag of 2 means you are comparing each month with the month before the previous one, and so on. Correlation: The correlation between two variables measures how closely they are related. In the context of the ACF, the correlation is between the time series and its lagged versions. Autocorrelation Coefficient: The ACF at lag $k$ is the correlation coefficient between the time series and its lagged version at lag $k$. It is denoted as $\\rho_k$. Mathematical Definition: The autocorrelation function at lag $k$ is given by: Ïk=Cov(Xt,Xtâˆ’k)Var(Xt) \\rho_k = \\frac{\\text{Cov}(X_t, X_{t-k})}{\\text{Var}(X_t)} Ïkâ€‹=Var(Xtâ€‹)Cov(Xtâ€‹,Xtâˆ’kâ€‹)â€‹ where: $X_t$ is the value of the time series at time $t$. $X_{t-k}$ is the value of the time series at time $t-k$ (i.e., $k$ time periods earlier). $\\text{Cov}(Xt, X{t-k})$ is the covariance between $Xt$ and $X{t-k}$. $\\text{Var}(X_t)$ is the variance of the time series. Interpretation: Lag 0 (k=0): The autocorrelation at lag 0 is always 1 because it represents the correlation of the time series with itself, which is perfect. Positive Autocorrelation: If $\\rho_k > 0$, it indicates that the time series values at lag $k$ are positively correlated. This means that high values in the time series tend to be followed by high values, and low values tend to be followed by low values. Negative Autocorrelation: If $\\rho_k Zero Autocorrelation: If $\\rho_k \\approx 0$, it indicates that there is no significant linear relationship between the time series and its lagged version at lag $k$. Example: Consider a simple time series representing the monthly sales of a product over a year: Sales={100,120,110,130,140,150,160,170,180,190,200,210} \\text{Sales} = \\{100, 120, 110, 130, 140, 150, 160, 170, 180, 190, 200, 210\\} Sales={100,120,110,130,140,150,160,170,180,190,200,210} To calculate the ACF at lag 1, we compare each month's sales with the sales from the previous month: LagÂ 1:Â {120,110,130,140,150,160,170,180,190,200,210} \\text{Lag 1: } \\{120, 110, 130, 140, 150, 160, 170, 180, 190, 200, 210\\} LagÂ 1:Â {120,110,130,140,150,160,170,180,190,200,210} We then calculate the correlation coefficient between the original series and the lagged series. If the correlation coefficient is positive and close to 1, it indicates a strong positive autocorrelation at lag 1, meaning that sales in one month are highly correlated with sales in the previous month. Visual Representation: The ACF is often visualized using a plot called the Autocorrelation Plot or ACF Plot. This plot shows the autocorrelation coefficients for different lags on the y-axis and the lags on the x-axis. The plot typically includes a dashed line representing the significance level, which helps in determining whether the autocorrelation coefficients are statistically significant. Conclusion: The Autocorrelation Function is a powerful tool in time series analysis that helps in understanding the internal structure of the data, identifying patterns, and selecting appropriate models. By examining the ACF, analysts can determine whether a time series is stationary, has a trend, or exhibits seasonality, which are crucial steps in building accurate forecasting models. "},"Misc/TimeSeriesPrediction/ACF_vs_PACF.html":{"url":"Misc/TimeSeriesPrediction/ACF_vs_PACF.html","title":"ACF_vs_PACF","keywords":"","body":"Differences Between ACF and PACF The Autocorrelation Function (ACF) and the Partial Autocorrelation Function (PACF) are both essential tools in time series analysis, but they serve different purposes and provide different insights into the structure of the time series data. Here are the key differences between ACF and PACF: 1. Definition and Purpose Autocorrelation Function (ACF): Definition: The ACF measures the correlation between a time series and its lagged versions. It quantifies how similar the time series is to itself at different points in time. Purpose: The ACF helps in identifying the overall pattern of correlation in the time series, including both short-term and long-term dependencies. Partial Autocorrelation Function (PACF): Definition: The PACF measures the correlation between a time series and its lagged versions, after removing the effects of shorter lags. It isolates the relationship between the time series and a specific lag, controlling for the influence of other lags. Purpose: The PACF helps in identifying the direct relationship between the time series and a specific lag, after accounting for the effects of intermediate lags. It is particularly useful for determining the order of the autoregressive (AR) component in ARIMA models. 2. Mathematical Interpretation ACF: The ACF at lag $k$ is the correlation coefficient between the time series and its lagged version at lag $k$. It is given by: Ïk=Cov(Xt,Xtâˆ’k)Var(Xt) \\rho_k = \\frac{\\text{Cov}(X_t, X_{t-k})}{\\text{Var}(X_t)} Ïkâ€‹=Var(Xtâ€‹)Cov(Xtâ€‹,Xtâˆ’kâ€‹)â€‹ PACF: The PACF at lag $k$ is the coefficient $\\phi_{kk}$ in the autoregressive model of order $k$. It is given by: Xt=Ï•k1Xtâˆ’1+Ï•k2Xtâˆ’2+â‹¯+Ï•kkXtâˆ’k+Ïµt X_t = \\phi_{k1} X_{t-1} + \\phi_{k2} X_{t-2} + \\cdots + \\phi_{kk} X_{t-k} + \\epsilon_t Xtâ€‹=Ï•k1â€‹Xtâˆ’1â€‹+Ï•k2â€‹Xtâˆ’2â€‹+â‹¯+Ï•kkâ€‹Xtâˆ’kâ€‹+Ïµtâ€‹ The PACF at lag $k$ is the partial correlation between $Xt$ and $X{t-k}$, controlling for the effects of $X{t-1}, X{t-2}, \\ldots, X_{t-(k-1)}$. 3. Visual Interpretation ACF Plot: The ACF plot shows the autocorrelation coefficients for different lags on the y-axis and the lags on the x-axis. It helps in identifying the overall pattern of correlation in the time series, including both short-term and long-term dependencies. Significant spikes in the ACF plot indicate the presence of autocorrelation at those lags. PACF Plot: The PACF plot shows the partial autocorrelation coefficients for different lags on the y-axis and the lags on the x-axis. It helps in identifying the direct relationship between the time series and a specific lag, after accounting for the effects of intermediate lags. Significant spikes in the PACF plot indicate the presence of partial autocorrelation at those lags, which is particularly useful for determining the order of the AR component in ARIMA models. 4. Use in Model Identification ACF: The ACF is useful for identifying the order of the moving average (MA) component in ARIMA models. A rapidly decaying ACF suggests that the time series is dominated by the MA component. PACF: The PACF is useful for identifying the order of the autoregressive (AR) component in ARIMA models. A rapidly decaying PACF suggests that the time series is dominated by the AR component. Example Consider a time series with the following characteristics: ACF Plot: The ACF plot shows significant spikes at lags 1, 2, and 3, but the spikes decay rapidly after lag 3. PACF Plot: The PACF plot shows significant spikes at lags 1 and 2, but the spikes decay rapidly after lag 2. Interpretation: The significant spikes in the ACF plot at lags 1, 2, and 3 suggest that the time series has a moving average component of order 3 (i.e., MA(3)). The significant spikes in the PACF plot at lags 1 and 2 suggest that the time series has an autoregressive component of order 2 (i.e., AR(2)). Conclusion The ACF and PACF are complementary tools in time series analysis. The ACF helps in identifying the overall pattern of correlation in the time series, while the PACF helps in isolating the direct relationship between the time series and specific lags, after accounting for the effects of intermediate lags. Together, they are essential for identifying the appropriate ARIMA model for forecasting. "},"Misc/TimeSeriesPrediction/ARIMA.html":{"url":"Misc/TimeSeriesPrediction/ARIMA.html","title":"ARIMA","keywords":"","body":"ARIMA Time Series Prediction Model The ARIMA (AutoRegressive Integrated Moving Average) model is a widely used statistical method for time series forecasting. It combines three components: AutoRegressive (AR), Integrated (I), and Moving Average (MA). The ARIMA model is denoted as ARIMA(p, d, q), where $p$, $d$, and $q$ are parameters that need to be determined. Components of ARIMA AutoRegressive (AR) Component (p): The AR component models the relationship between an observation and a number of lagged observations (i.e., previous values in the time series). The parameter$p$represents the number of lag observations included in the model. For example, if$p = 2$, the model uses the two previous observations to predict the current value. Integrated (I) Component (d): The I component represents the degree of differencing (i.e., the number of times the data have had past values subtracted). The parameter$d$indicates the number of non-seasonal differences needed to make the time series stationary. Stationarity means that the statistical properties of the time series, such as mean and variance, are constant over time. Moving Average (MA) Component (q): The MA component models the relationship between an observation and a residual error from a moving average model applied to lagged observations. The parameter$q$represents the number of lag residual errors included in the model. For example, if$q = 1$, the model uses the error from the previous time step to predict the current value. Determining the Proper$p$,$d$, and$q$ Determining$d$(Differencing Order): The first step is to check if the time series is stationary. If not, differencing is applied to make it stationary. Use statistical tests like the Augmented Dickey-Fuller (ADF) test to check for stationarity. If the series is not stationary, apply differencing (i.e., subtract the previous value from the current value) and repeat the test. The number of times differencing is applied until the series becomes stationary is the value of$d$. Determining$p$(AR Order): Use the Autocorrelation Function (ACF) plot to identify the number of significant lags. The ACF plot shows the correlation between the time series and its lagged versions. The value of$p$is determined by the number of significant lags in the ACF plot. Determining$q$(MA Order): Use the Partial Autocorrelation Function (PACF) plot to identify the number of significant lags. The PACF plot shows the correlation between the time series and its lagged versions, after removing the effects of shorter lags. The value of$q$is determined by the number of significant lags in the PACF plot. Example Suppose you have a monthly sales time series and you want to build an ARIMA model. Here are the steps to determine$p$,$d$, and$q$: Check for Stationarity: Apply the ADF test. If the series is not stationary, apply differencing once (i.e.,$d = 1$) and check again. If the series becomes stationary after one differencing,$d = 1$. Determine$p$Using ACF Plot: Plot the ACF for the differenced series. If the ACF shows significant lags at lags 1 and 2, but not beyond, then$p = 2$. Determine$q$Using PACF Plot: Plot the PACF for the differenced series. If the PACF shows significant lags at lag 1, but not beyond, then$q = 1$. Thus, the ARIMA model for this time series would be ARIMA(2, 1, 1). Model Selection and Validation Model Selection: Once$p$,$d$, and$q$are determined, fit the ARIMA model to the data and evaluate its performance using metrics like Mean Absolute Error (MAE), Mean Squared Error (MSE), or Root Mean Squared Error (RMSE). Cross-Validation: Use techniques like rolling forecasting origin or time series cross-validation to validate the model's performance on out-of-sample data. Parameter Tuning: Experiment with different combinations of$p$,$d$, and$q$to find the model that minimizes the chosen error metric. Conclusion The ARIMA model is a versatile tool for time series forecasting, but its effectiveness depends on the proper selection of the parameters$p$,$d$, and$q$. By carefully analyzing the ACF and PACF plots and ensuring the series is stationary, you can determine the appropriate ARIMA model for your time series data. "},"Misc/TimeSeriesPrediction/PACF.html":{"url":"Misc/TimeSeriesPrediction/PACF.html","title":"PACF","keywords":"","body":"Partial Autocorrelation Function (PACF) The Partial Autocorrelation Function (PACF) is a statistical tool used in time series analysis to measure the correlation between a time series and its lagged versions, after removing the effects of shorter lags. In other words, the PACF helps to isolate the relationship between the time series and a specific lag, controlling for the influence of other lags. Key Concepts: Autocorrelation: As discussed earlier, autocorrelation measures the correlation between a time series and its lagged versions. However, this correlation can be influenced by other lags. Partial Autocorrelation: The partial autocorrelation at lag ( k ) (denoted as ( \\phi_{kk} )) is the correlation between the time series and its ( k )-th lag, after removing the effects of all shorter lags (i.e., lags 1 through ( k-1 )). PACF Plot: The PACF plot shows the partial autocorrelation coefficients for different lags on the y-axis and the lags on the x-axis. It helps in identifying the significant lags that are not explained by shorter lags. Mathematical Definition: The partial autocorrelation at lag ( k ) is the coefficient ( \\phi_{kk} ) in the following autoregressive model: [ Xt = \\phi{k1} X{t-1} + \\phi{k2} X{t-2} + \\cdots + \\phi{kk} X_{t-k} + \\epsilon_t ] where: ( X_t ) is the value of the time series at time ( t ). ( X_{t-k} ) is the value of the time series at time ( t-k ) (i.e., ( k ) time periods earlier). ( \\epsilon_t ) is the error term at time ( t ). ( \\phi_{kk} ) is the partial autocorrelation coefficient at lag ( k ). Interpretation: Lag 0 (k=0): The partial autocorrelation at lag 0 is always 1 because it represents the correlation of the time series with itself, which is perfect. Positive Partial Autocorrelation: If ( \\phi_{kk} > 0 ), it indicates that the time series values at lag ( k ) are positively correlated after controlling for shorter lags. Negative Partial Autocorrelation: If ( \\phi_{kk} Zero Partial Autocorrelation: If ( \\phi_{kk} \\approx 0 ), it indicates that there is no significant linear relationship between the time series and its lagged version at lag ( k ) after controlling for shorter lags. Example: Consider a simple time series representing the monthly sales of a product over a year: [ \\text{Sales} = {100, 120, 110, 130, 140, 150, 160, 170, 180, 190, 200, 210} ] To calculate the PACF at lag 2, we need to fit an autoregressive model of order 2 and extract the coefficient ( \\phi_{22} ): Fit the AR(2) Model: [ Xt = \\phi{21} X{t-1} + \\phi{22} X{t-2} + \\epsilon_t ] Using the sales data, estimate the coefficients ( \\phi{21} ) and ( \\phi_{22} ). Extract ( \\phi_{22} ): The coefficient ( \\phi_{22} ) represents the partial autocorrelation at lag 2, controlling for the effect of lag 1. Visual Representation: The PACF is often visualized using a plot called the Partial Autocorrelation Plot or PACF Plot. This plot shows the partial autocorrelation coefficients for different lags on the y-axis and the lags on the x-axis. The plot typically includes a dashed line representing the significance level, which helps in determining whether the partial autocorrelation coefficients are statistically significant. Conclusion: The Partial Autocorrelation Function (PACF) is a crucial tool in time series analysis, particularly in identifying the order of the autoregressive (AR) component in ARIMA models. By examining the PACF, analysts can determine which lags are significant after controlling for the effects of shorter lags, which is essential for building accurate forecasting models. "},"Misc/Typst.html":{"url":"Misc/Typst.html","title":"Typst","keywords":"","body":"Typst Links Typst polylux: package to create presentation slides. Reference #show rule #show \"ArtosFlow\": name => box[ #box(image( \"logo.svg\", height: 0.7em, )) #name ] This report is embedded in the ArtosFlow project. ArtosFlow is a project of the Artos Institute. With show rules, you can redefine how Typst displays certain elements. You specify which elements Typst should show differently and how they should look. Show rules can be applied to instances of text, many functions, and even the whole document. ä½¿ç”¨ show rulesï¼Œæ‚¨å¯ä»¥é‡æ–°å®šä¹‰ Typst æ˜¾ç¤ºæŸäº›å…ƒç´ çš„æ–¹å¼ã€‚æ‚¨å¯ä»¥æŒ‡å®š Typst åº”è¯¥ä»¥ä¸åŒçš„æ–¹å¼æ˜¾ç¤ºå“ªäº›å…ƒç´ ä»¥åŠå®ƒä»¬åº”è¯¥å¦‚ä½•æ˜¾ç¤ºã€‚æ˜¾ç¤ºè§„åˆ™å¯ä»¥åº”ç”¨äºæ–‡æœ¬å®ä¾‹ã€è®¸å¤šå‡½æ•°ï¼Œç”šè‡³æ•´ä¸ªæ–‡æ¡£ã€‚ There is a lot of new syntax in this example: We write the show keyword, followed by a string of text we want to show differently and a colon. Then, we write a function that takes the content that shall be shown as an argument. Here, we called that argument name. We can now use the name variable in the function's body to print the ArtosFlow name. Our show rule adds the logo image in front of the name and puts the result into a box to prevent linebreaks from occurring between logo and name. The image is also put inside of a box, so that it does not appear in its own paragraph. è¿™ä¸ªä¾‹å­ä¸­æœ‰å¾ˆå¤šæ–°çš„è¯­æ³•ï¼šæˆ‘ä»¬ç¼–å†™ show å…³é”®å­—ï¼Œåè·Ÿæˆ‘ä»¬æƒ³è¦ä»¥ä¸åŒæ–¹å¼æ˜¾ç¤ºçš„ä¸€ä¸²æ–‡æœ¬å’Œä¸€ä¸ªå†’å·ã€‚ç„¶åï¼Œæˆ‘ä»¬ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°å°†åº”æ˜¾ç¤ºä¸ºå‚æ•°çš„å†…å®¹ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†è¯¥å‚æ•°ç§°ä¸º nameã€‚æˆ‘ä»¬ç°åœ¨å¯ä»¥ä½¿ç”¨å‡½æ•°ä½“ä¸­çš„ name å˜é‡æ¥æ‰“å° ArtosFlow åç§°ã€‚æˆ‘ä»¬çš„ show è§„åˆ™å°† logo å›¾åƒæ·»åŠ åˆ°åç§°å‰é¢ï¼Œå¹¶å°†ç»“æœæ”¾å…¥ä¸€ä¸ªæ¡†ä¸­ï¼Œä»¥é˜²æ­¢ logo å’Œ name ä¹‹é—´å‡ºç°æ¢è¡Œã€‚å›¾åƒä¹Ÿè¢«æ”¾åœ¨ä¸€ä¸ªæ¡†å†…ï¼Œè¿™æ ·å®ƒå°±ä¸ä¼šå‡ºç°åœ¨è‡ªå·±çš„æ®µè½ä¸­ã€‚ "},"Misc/VScode.html":{"url":"Misc/VScode.html","title":"VScode","keywords":"","body":"VScode Shortcuts Ctrl+p å¿«é€Ÿæ‰“å¼€æ–‡ä»¶ Ctrl+shift+p æ‰“å¼€å‘½ä»¤é¢æ¿ Ctrl+w å…³é—­å½“å‰æ–‡ä»¶ Ctrl+k+w å…³é—­æ‰€æœ‰æ–‡ä»¶ Ctrl+f å¿«é€Ÿæœç´¢ Ctrl+g è·³è½¬åˆ°æŒ‡å®šè¡Œ Ctrl+Alt+f Find in Explorer Ctrl+R Run Recent Command Others æ–‡ä»¶æ¢å¤ åœ¨ vscode ç•Œé¢ï¼ŒæŒ‰ä½ Ctrl+shift+p æ‰“å¼€å‘½ä»¤é¢æ¿ï¼Œæ‰¾åˆ°æœ¬åœ°å†å²è®°å½• VScode server ç¡®è®¤ server commit_id # ~/.vscode-server/bin # ä¸‹è½½å¯¹åº”çš„serverç¨‹åº # ï¼ˆæ³¨æ„æŠŠ:${commit_id}æ›¿æ¢æˆå¯¹åº”çš„Commit IDï¼‰ https://update.code.visualstudio.com/commit:${commit_id}/server-linux-x64/stable # vscode-server-linux-x64.tar.gz # æ”¾åˆ° ~/.vscode-server/bin/${commit_id}/ æ–‡ä»¶å¤¹ä¸‹ # è§£å‹ tar -zxvf vscode-server-linux-x64.tar.gz --strip=1 https://update.code.visualstudio.com/commit:e7e037083ff4455cf320e344325dacb480062c3c/server-linux-x64/stable Debugging Launch Configuration Debugging Launch Configuration "},"Misc/Vitural-Card.html":{"url":"Misc/Vitural-Card.html","title":"Vitural-Card","keywords":"","body":" nobepay "},"Misc/WSL.html":{"url":"Misc/WSL.html","title":"WSL","keywords":"","body":"Windows Subsystem for Linux å·¥ä½œåŸç† é…ç½®æ–‡ä»¶ å¤‡ä»½è¿˜åŸ ç½‘ç»œ æ–‡ä»¶ç³»ç»Ÿ å†…æ ¸æ›¿æ¢ "},"Network/Network.html":{"url":"Network/Network.html","title":"Network","keywords":"","body":"Network ipcheck.ing: The best IP Toolbox., github: MyIP "},"Network/ChangeMac.html":{"url":"Network/ChangeMac.html","title":"ChangeMac","keywords":"","body":"Changing the MAC address of your laptop can help with privacy or troubleshooting network issues. Here's how to do it for different operating systems: For Windows Open Device Manager: Right-click on the Start button and select Device Manager. Locate Network Adapters: Find Network adapters and expand the section. Right-click on your Wi-Fi adapter and select Properties. Change MAC Address: Go to the Advanced tab. In the Property box, select Network Address or Locally Administered Address. In the Value box, enter your new MAC address (without colons or dashes). For example, 00AABBCCDDEE. Make sure the address is valid (it should be 12 hexadecimal digits). Restart Your Adapter: Disable and re-enable your network adapter for the changes to take effect. For Linux Open Terminal. Identify Your Network Interface: Run the command:ip link Note the name of your network interface (e.g., wlan0). Bring Down the Interface: Replace wlan0 with your interface name:sudo ip link set wlan0 down Change the MAC Address: Run:sudo ip link set wlan0 address XX:XX:XX:XX:XX:XX Replace XX:XX:XX:XX:XX:XX with your desired MAC address. Bring Up the Interface: Run:sudo ip link set wlan0 up Verify the Change: Check your new MAC address:ip link show wlan0 For macOS Open Terminal. Find Your Network Interface: Run the command:ifconfig Identify your Wi-Fi interface (usually en0). Change the MAC Address: Run the following command (replace en0 with your interface name and XX:XX:XX:XX:XX:XX with your desired MAC address):sudo ifconfig en0 ether XX:XX:XX:XX:XX:XX Verify the Change: Check your new MAC address:ifconfig en0 | grep ether Important Notes Temporary Change: The changes you make are temporary and will revert after a reboot. To make permanent changes, you would need to create scripts or use specific settings. Network Policies: Be cautious when changing your MAC address, as some networks have policies against this and may block access. Unique MAC Address: Ensure the new MAC address is unique on your local network to avoid conflicts. By following these steps, you can successfully change the MAC address on your laptop! "},"Network/DNS.html":{"url":"Network/DNS.html","title":"DNS","keywords":"","body":"Greate Article for DNS Server Config: The Sisyphean Task Of DNS Client Config on Linux DNS (Domain Name Service): turn names into IP addresses TimeLine/History/Development: 4.3 BSD: use /etc/resolv.conf to configure DNS servers but DHCP program need to determine the DNS servers in the network, it may edit and change the /etc/resolv.conf file. When more than one program what to edit the /etc/resolv.conf file, it may cause conflict and cause problems. resolvconf: a loose convention for managing DNS, common 2 versions are Deian and Openresolv. "},"Network/RandomMac.html":{"url":"Network/RandomMac.html","title":"RandomMac","keywords":"","body":"To use a random MAC address on Debian 12, you can utilize a few different methods, including temporary changes or setting it to generate random addresses automatically. Here's how you can do it: Method 1: Temporary Change Using macchanger Install macchanger: Open a terminal and install macchanger using the following command: sudo apt update sudo apt install macchanger Identify Your Network Interface: Find the name of your network interface (e.g., wlan0, eth0) by running: ip link Bring Down the Interface: Replace wlan0 with your interface name: sudo ip link set wlan0 down Change the MAC Address: Use macchanger to set a random MAC address: sudo macchanger -r wlan0 Bring Up the Interface: sudo ip link set wlan0 up Verify the Change: ip link show wlan0 Method 2: Permanent Random MAC Address on Startup To have a random MAC address every time you boot, you can modify the Network Manager configuration. Open NetworkManager Configuration: Edit the connection file for your network interface. The path may vary, but you can typically find it in /etc/NetworkManager/system-connections/. You can list the available connections with: sudo ls /etc/NetworkManager/system-connections/ Then open the specific connection file using a text editor (replace YourConnection with the actual connection name): sudo nano /etc/NetworkManager/system-connections/YourConnection Modify the Configuration: Look for the [802-11-wireless] section and add or modify the following lines: [connection] ... ethernet.cloned-mac-address=random or for Wi-Fi connections: [802-11-wireless] ... 802-11-wireless.cloned-mac-address=random Save and Exit: Save the file and exit the editor. Restart NetworkManager: Restart the NetworkManager to apply the changes: sudo systemctl restart NetworkManager Method 3: Manual Random MAC Address Generation If you want to generate a random MAC address manually, you can use a simple script or command. Generate a Random MAC Address: You can use the following command to generate a random MAC address: printf '02:%x:%x:%x:%x:%x:%x\\n' $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) Set the Random MAC Address: Use ip to change the MAC address as shown in Method 1, substituting XX:XX:XX:XX:XX:XX with the output of the above command. Notes Temporary Changes: The MAC address will revert to the original on reboot unless you use the NetworkManager method. Network Policies: Be aware that changing your MAC address may violate certain network policies. Conflict Avoidance: Ensure that the generated MAC address does not conflict with other devices on your network. By following these methods, you can effectively use a random MAC address on your Debian 12 system! "},"Network/Tailscale.html":{"url":"Network/Tailscale.html","title":"Tailscale","keywords":"","body":""},"Network/Wifi.html":{"url":"Network/Wifi.html","title":"Wifi","keywords":"","body":"In Debian 12's Wi-Fi identity management, here are the key terms and their meanings: SSID (Service Set Identifier): This is the name of the Wi-Fi network. It's what you see when you scan for available networks. Each SSID is unique within a given area. BSSID (Basic Service Set Identifier): This refers to the MAC address of the access point (AP) providing the network. While SSID is the name, BSSID identifies the actual hardware of the AP. MAC Address: The Media Access Control (MAC) address is a unique identifier assigned to network interfaces for communications on a network. Each device on a network has a distinct MAC address. Cloned Address Options: Preserve: This option keeps the device's original MAC address. Permanent: This sets a fixed MAC address for the device, which will remain the same across reboots and disconnections. Random: This generates a new, random MAC address each time the device connects to the network, enhancing privacy by making tracking more difficult. Stable: This generates a MAC address that remains consistent but is not the original. It's typically based on the device's original MAC but altered to provide some level of anonymity. These options help manage network identity and privacy in various scenarios. åœ¨ Debian 12 çš„ Wi-Fi èº«ä»½ç®¡ç†ä¸­ï¼Œä»¥ä¸‹æ˜¯å…³é”®æœ¯è¯­åŠå…¶å«ä¹‰ï¼š SSIDï¼ˆæœåŠ¡é›†æ ‡è¯†ç¬¦ï¼‰ï¼šè¿™æ˜¯ Wi-Fi ç½‘ç»œçš„åç§°ã€‚å½“ä½ æ‰«æå¯ç”¨ç½‘ç»œæ—¶ï¼Œä¼šçœ‹åˆ°è¿™ä¸ªåç§°ã€‚æ¯ä¸ª SSID åœ¨ç‰¹å®šåŒºåŸŸå†…æ˜¯å”¯ä¸€çš„ã€‚ BSSIDï¼ˆåŸºæœ¬æœåŠ¡é›†æ ‡è¯†ç¬¦ï¼‰ï¼šè¿™æŒ‡çš„æ˜¯æä¾›ç½‘ç»œçš„æ¥å…¥ç‚¹ï¼ˆAPï¼‰çš„ MAC åœ°å€ã€‚è™½ç„¶ SSID æ˜¯åç§°ï¼Œä½† BSSID è¯†åˆ«çš„æ˜¯å®é™…ç¡¬ä»¶çš„æ¥å…¥ç‚¹ã€‚ MAC åœ°å€ï¼šåª’ä½“è®¿é—®æ§åˆ¶ï¼ˆMACï¼‰åœ°å€æ˜¯åˆ†é…ç»™ç½‘ç»œæ¥å£çš„å”¯ä¸€æ ‡è¯†ç¬¦ï¼Œç”¨äºç½‘ç»œé€šä¿¡ã€‚ç½‘ç»œä¸Šçš„æ¯ä¸ªè®¾å¤‡éƒ½æœ‰ä¸€ä¸ªç‹¬ç‰¹çš„ MAC åœ°å€ã€‚ å…‹éš†åœ°å€é€‰é¡¹ï¼š ä¿ç•™ï¼šæ­¤é€‰é¡¹ä¿æŒè®¾å¤‡çš„åŸå§‹ MAC åœ°å€ã€‚ æ°¸ä¹…ï¼šè¿™ä¼šä¸ºè®¾å¤‡è®¾ç½®ä¸€ä¸ªå›ºå®šçš„ MAC åœ°å€ï¼Œè¯¥åœ°å€åœ¨é‡å¯å’Œæ–­å¼€è¿æ¥åå°†ä¿æŒä¸å˜ã€‚ éšæœºï¼šè¿™ä¼šåœ¨è®¾å¤‡è¿æ¥åˆ°ç½‘ç»œæ—¶ç”Ÿæˆä¸€ä¸ªæ–°çš„éšæœº MAC åœ°å€ï¼Œæé«˜éšç§æ€§ï¼Œä½¿è¿½è¸ªæ›´å›°éš¾ã€‚ ç¨³å®šï¼šè¿™ä¼šç”Ÿæˆä¸€ä¸ªä¿æŒä¸€è‡´çš„ MAC åœ°å€ï¼Œä½†ä¸æ˜¯åŸå§‹åœ°å€ã€‚é€šå¸¸æ˜¯åŸºäºè®¾å¤‡çš„åŸå§‹ MAC åœ°å€ä½†è¿›è¡Œäº†ä¿®æ”¹ï¼Œä»¥æä¾›ä¸€å®šç¨‹åº¦çš„åŒ¿åæ€§ã€‚ è¿™äº›é€‰é¡¹æœ‰åŠ©äºåœ¨ä¸åŒåœºæ™¯ä¸­ç®¡ç†ç½‘ç»œèº«ä»½å’Œéšç§ã€‚ "},"Papers/Papers.html":{"url":"Papers/Papers.html","title":"Papers","keywords":"","body":""},"Papers/AttentionIsTuringComplete.html":{"url":"Papers/AttentionIsTuringComplete.html","title":"AttentionIsTuringComplete","keywords":"","body":"Attention Is Turing Complete Not yet complete. Attention Is Turing Complete TLDR: æœ¬æ–‡è¯æ˜äº† Attention æœºåˆ¶æ˜¯å›¾çµå®Œå¤‡çš„ï¼Œæœ¬æ–‡æ„é€ äº†ä¸€ä¸ªæœ‰1å±‚Encoderå’Œ3å±‚Decoderçš„Transformerï¼Œç”¨å…¶æ¨¡æ‹Ÿäº†å›¾çµæœºçš„è®¡ç®—è¿‡ç¨‹ï¼ˆå³è®¡ç®—æ ¼å±€çš„å˜åŒ–ï¼‰ã€‚ Abstract Alternatives to recurrent neural networks, in particular, architectures based on self-attention, are gaining momentum for processing input sequences. In spite of their relevance, the computational properties of such networks have not yet been fully explored. We study the computational power of the Transformer, one of the most paradigmatic architectures exemplifying self-attention. We show that the Transformer with hard-attention is Turing complete exclusively based on their capacity to compute and access internal dense representations of the data. Our study also reveals some minimal sets of elements needed to obtain this completeness result. å¾ªç¯ç¥ç»ç½‘ç»œçš„æ›¿ä»£æ–¹æ¡ˆï¼Œç‰¹åˆ«æ˜¯åŸºäºè‡ªæ³¨æ„åŠ›çš„æ¶æ„ï¼Œåœ¨å¤„ç†è¾“å…¥åºåˆ—æ–¹é¢æ­£åœ¨è·å¾—åŠ¨åŠ›ã€‚å°½ç®¡å®ƒä»¬å…·æœ‰ç›¸å…³æ€§ï¼Œä½†æ­¤ç±»ç½‘ç»œçš„è®¡ç®—ç‰¹æ€§å°šæœªå¾—åˆ°å……åˆ†æ¢ç´¢ã€‚æˆ‘ä»¬ç ”ç©¶Transformerçš„è®¡ç®—èƒ½åŠ›ï¼Œå®ƒæ˜¯ä½“ç°è‡ªæˆ‘æ³¨æ„åŠ›çš„æœ€å…·èŒƒå¼çš„æ¶æ„ä¹‹ä¸€ã€‚æˆ‘ä»¬è¯æ˜ï¼Œå…·æœ‰ç¡¬æ³¨æ„åŠ›çš„Transformer å®Œå…¨åŸºäºå…¶è®¡ç®—å’Œè®¿é—®æ•°æ®å†…éƒ¨å¯†é›†è¡¨ç¤ºçš„èƒ½åŠ›ï¼Œæ˜¯å›¾çµå®Œå¤‡çš„ã€‚æˆ‘ä»¬çš„ç ”ç©¶è¿˜æ­ç¤ºäº†è·å¾—è¿™ç§å®Œæ•´æ€§ç»“æœæ‰€éœ€çš„ä¸€äº›æœ€å°å…ƒç´ é›†ã€‚ Introduction åºåˆ—åˆ°åºåˆ—ç¥ç»ç½‘ç»œ æˆ‘ä»¬å¯¹åºåˆ—åˆ°åºåˆ— (seq-to-seq) ç¥ç»ç½‘ç»œæ¶æ„æ„Ÿå…´è¶£,æˆ‘ä»¬æ¥ä¸‹æ¥å°†æ­£å¼åŒ–ã€‚å¯¹äºæŸäº› d > 0,seq-to-seq ç½‘ç»œ N æ¥æ”¶å‘é‡ xâˆˆ Q çš„åºåˆ— X = (x, . . . . , x) ä½œä¸ºè¾“å…¥,å¹¶ç”Ÿæˆå‘é‡ yâˆˆ Q çš„åºåˆ— Y = (y, . . . . , y) ä½œä¸ºè¾“å‡ºã€‚å¤§å¤šæ•°è¿™ç§ç±»å‹çš„æ¶æ„éƒ½éœ€è¦ä¸€ä¸ªç§å­å‘é‡ s å’Œä¸€äº›åœæ­¢æ ‡å‡†æ¥ç¡®å®šè¾“å‡ºçš„é•¿åº¦ã€‚åè€…é€šå¸¸åŸºäºç‰¹å®šè¾“å‡ºå‘é‡çš„ç”Ÿæˆ,ç§°ä¸ºåºåˆ—ç»“æŸæ ‡è®°ã€‚ç›¸å,åœ¨æˆ‘ä»¬çš„å½¢å¼åŒ–ä¸­,æˆ‘ä»¬å…è®¸ç½‘ç»œäº§ç”Ÿä¸€ä¸ªå›ºå®šæ•°é‡çš„ r â‰¥ 0 çš„è¾“å‡ºå‘é‡ã€‚å› æ­¤,ä¸ºæ–¹ä¾¿èµ·è§,æˆ‘ä»¬å°†ä¸€èˆ¬çš„ seq-to-seq ç½‘ç»œè§†ä¸ºå‡½æ•° N,ä½¿å¾—å€¼ N (X, s, r) å¯¹åº”äº Y = (y, y, . . . . , y) å½¢å¼çš„è¾“å‡ºåºåˆ—ã€‚é€šè¿‡æ­¤å®šä¹‰,æˆ‘ä»¬å¯ä»¥å°† seq-to-seq ç½‘ç»œè§£é‡Šä¸ºå­—ç¬¦ä¸²çš„è¯­è¨€è¯†åˆ«å™¨,å¦‚ä¸‹æ‰€ç¤ºã€‚ å®šä¹‰ 1 seq-to-seq è¯­è¨€è¯†åˆ«å™¨æ˜¯ä¸€ä¸ªå…ƒç»„ A = (Î£, f, N, s, F),å…¶ä¸­ Î£ æ˜¯æœ‰é™å­—æ¯è¡¨,f : Î£ â†’ Q æ˜¯åµŒå…¥å‡½æ•°,N æ˜¯ seq-to-seq ç½‘ç»œ,s âˆˆ Q æ˜¯ç§å­å‘é‡,F âŠ† Qæ˜¯ä¸€ç»„æœ€ç»ˆå‘é‡ã€‚æˆ‘ä»¬è¯´ A æ¥å—å­—ç¬¦ä¸² w âˆˆ Î£,å¦‚æœå­˜åœ¨ä¸€ä¸ªæ•´æ•° r âˆˆ N,ä½¿å¾— N (f (w), s, r) = (y, . . . , y) å’Œ yâˆˆ Fã€‚ A æ¥å—çš„è¯­è¨€(ç”¨ L(A) è¡¨ç¤º)æ˜¯ A æ¥å—çš„æ‰€æœ‰å­—ç¬¦ä¸²çš„é›†åˆã€‚ æˆ‘ä»¬å¯¹è¯†åˆ«å™¨æ–½åŠ äº†ä¸¤ä¸ªé¢å¤–çš„é™åˆ¶ã€‚ åµŒå…¥å‡½æ•° f : Î£ â†’ Qåº”è¯¥ç”±å›¾çµæœºä»¥ Î£ å¤§å°çš„å¤šé¡¹å¼æ—¶é—´è®¡ç®—ã€‚è¿™æ¶µç›–äº†è®¡ç®—ç¬¦å·çš„ input åµŒå…¥çš„ä¸¤ç§æœ€å…¸å‹æ–¹æ³•:one-hot ç¼–ç å’Œç”±å›ºå®šå‰é¦ˆç½‘ç»œè®¡ç®—çš„åµŒå…¥ã€‚ æ­¤å¤–,é›†åˆ F ä¹Ÿåº”è¯¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…å¯è¯†åˆ«;ç»™å®šä¸€ä¸ªå‘é‡ f ,éš¶å±åº¦ F âˆˆ F åº”è¯¥ç”±åœ¨å¤šé¡¹å¼æ—¶é—´å†…ç›¸å¯¹äº f çš„å¤§å°(ä»¥ä½ä¸ºå•ä½)å·¥ä½œçš„å›¾çµæœºå†³å®šã€‚è¿™æ¶µç›–äº†ä½¿ç”¨å›ºå®šåºåˆ—ç»“æŸå‘é‡æ£€æŸ¥ç›¸ç­‰æ€§çš„å¸¸ç”¨æ–¹æ³•ã€‚ æˆ‘ä»¬æ–½åŠ è¿™äº›é™åˆ¶æ˜¯ä¸ºäº†é˜²æ­¢é€šè¿‡åœ¨ input embedding æˆ– stopping æ¡ä»¶ä¸­ç¼–ç ä»»æ„è®¡ç®—æ¥ä½œå¼Šçš„å¯èƒ½æ€§,åŒæ—¶è¶³å¤Ÿå®½å®¹åœ°æ„å»ºæœ‰æ„ä¹‰çš„ embeddings å’Œ stopping criterionsã€‚ å›¾çµæœºè®¡ç®— è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹,(ç¡®å®šæ€§çš„)å›¾çµæœºæ˜¯ M = (Q, Î£, Î´, q, F ) å½¢å¼çš„å…ƒç»„,å…¶ä¸­: seq-to-seq ç¥ç»ç½‘ç»œæ¶æ„çš„å›¾çµå®Œå¤‡æ€§ seq-to-seq ç¥ç»ç½‘ç»œæ¶æ„çš„ N ç±»å®šä¹‰äº†ç±» L,è¯¥ç±»ç”±ä½¿ç”¨ N ä¸­çš„ç½‘ç»œçš„è¯­è¨€è¯†åˆ«å™¨æ¥å—çš„æ‰€æœ‰è¯­è¨€ç»„æˆã€‚ä»è¿™äº›æ¦‚å¿µä¸­,N ç±»çš„å›¾çµå®Œå¤‡æ€§çš„å½¢å¼åŒ–è‡ªç„¶è€Œç„¶åœ°éšä¹‹è€Œæ¥ã€‚ å®šä¹‰ 2 å¦‚æœ L åŒ…å«æ‰€æœ‰å¯åˆ¤å®šè¯­è¨€(å³å›¾çµæœºå¯è¯†åˆ«çš„æ‰€æœ‰è¯­è¨€),åˆ™ seq-to-seq ç¥ç»ç½‘ç»œæ¶æ„çš„ N ç±»ä¸ºå›¾çµå®Œå¤‡ã€‚ The Transformer architecture åœ¨æœ¬èŠ‚ä¸­,æˆ‘ä»¬æå‡ºäº† Transformer æ¶æ„çš„å½¢å¼åŒ–(Vaswani et al., 2017),ä»å‡½æ•°å’Œå‚æ•°çš„ä¸€äº›å…·ä½“é€‰æ‹©ä¸­æŠ½è±¡å‡ºæ¥ã€‚æˆ‘ä»¬çš„å½¢å¼åŒ–å¹¶ä¸æ˜¯ä¸ºäº†äº§ç”Ÿ Transformer çš„æœ‰æ•ˆå®ç°,è€Œæ˜¯æä¾›ä¸€ä¸ªç®€å•çš„è®¾ç½®,é€šè¿‡è¯¥è®¾ç½®å¯ä»¥ä»¥æ­£å¼çš„æ–¹å¼å»ºç«‹å…¶æ•°å­¦å±æ€§ã€‚ Transformer åœ¨å¾ˆå¤§ç¨‹åº¦ä¸ŠåŸºäºæ¥ä¸‹æ¥ä»‹ç»çš„æ³¨æ„åŠ›æœºåˆ¶ã€‚è€ƒè™‘è¯„åˆ†å‡½æ•° score : QÃ— Qâ†’ Q å’Œå½’ä¸€åŒ–å‡½æ•° Ï : Qâ†’ Q,å¯¹äº dã€n > 0ã€‚å‡è®¾ q âˆˆ Q,å¹¶ä¸” K = (k, . . . , k) å’Œ V = (v, . . . , v) æ˜¯ Q ä¸­å…ƒç´ çš„å…ƒç»„ã€‚ç”± Att(q, K, V) è¡¨ç¤ºçš„ q-attention over (K, V) æ˜¯ Q âˆˆå‘é‡ a,å®šä¹‰å¦‚ä¸‹ã€‚ (s1,â€¦,sn)=Ï(scoreâ¡(q,k1),scoreâ¡(q,k2),â€¦,scoreâ¡(q,kn)) \\left(s_{1}, \\ldots, s_{n}\\right) =\\rho\\left(\\operatorname{score}\\left(\\boldsymbol{q}, \\boldsymbol{k}_{1}\\right), \\operatorname{score}\\left(\\boldsymbol{q}, \\boldsymbol{k}_{2}\\right), \\ldots, \\operatorname{score}\\left(\\boldsymbol{q}, \\boldsymbol{k}_{n}\\right)\\right) (s1â€‹,â€¦,snâ€‹)=Ï(score(q,k1â€‹),score(q,k2â€‹),â€¦,score(q,knâ€‹)) a=s1v1+s2v2+â‹¯+snvn \\boldsymbol{a} =s_{1} \\boldsymbol{v}_{1}+s_{2} \\boldsymbol{v}_{2}+\\cdots+s_{n} \\boldsymbol{v}_{n} a=s1â€‹v1â€‹+s2â€‹v2â€‹+â‹¯+snâ€‹vnâ€‹ é€šå¸¸,q ç§°ä¸ºæŸ¥è¯¢,K ç§°ä¸ºé”®,V ç§°ä¸ºå€¼ã€‚æˆ‘ä»¬å¯¹è¯„åˆ†å‡½æ•°æ²¡æœ‰ä»»ä½•é™åˆ¶,ä½†æˆ‘ä»¬ç¡®å®å¯¹å½’ä¸€åŒ–å‡½æ•°æ–½åŠ äº†ä¸€äº›é™åˆ¶,ä»¥ç¡®ä¿å®ƒåœ¨æŒä»“ä¸Šäº§ç”Ÿæ¦‚ç‡åˆ†å¸ƒã€‚æˆ‘ä»¬è¦æ±‚å½’ä¸€åŒ–å‡½æ•°æ»¡è¶³ä»¥ä¸‹æ¡ä»¶:å¯¹äºæ¯ä¸ª x = (x, . . . , x) âˆˆ Q,æœ‰ä¸€ä¸ªå‡½æ•° fä» Q åˆ° Q,ä½¿å¾— Ï(x) çš„ç¬¬ i ä¸ªåˆ†é‡ Ï(x) ç›¸ç­‰ j=1 f(x) çš„ f(x) ã€‚æˆ‘ä»¬æ³¨æ„åˆ°,ä¾‹å¦‚,å¯ä»¥é€šè¿‡ç®€å•åœ°é€‰æ‹© f(x) ä½œä¸ºæŒ‡æ•°å‡½æ•° e æ¥ä»¥è¿™ç§æ–¹å¼å®šä¹‰ softmax å‡½æ•°,ä½†æˆ‘ä»¬å…è®¸å…¶ä»–å¯èƒ½æ€§,æ¥ä¸‹æ¥æˆ‘ä»¬å°†è§£é‡Šã€‚ åœ¨è¯æ˜å¯èƒ½æ€§ç»“æœæ—¶,æˆ‘ä»¬éœ€è¦é€‰æ‹©ç‰¹å®šçš„è¯„åˆ†å’Œå½’ä¸€åŒ–å‡½æ•°ã€‚è¯„åˆ†å‡½æ•°çš„é€šå¸¸é€‰æ‹©æ˜¯ç”±å…·æœ‰è¾“å…¥ (q, k) çš„å‰é¦ˆç½‘ç»œå®šä¹‰çš„éçº¿æ€§å‡½æ•°,æœ‰æ—¶ç§°ä¸ºåŠ æ€§æ³¨æ„åŠ› (Bahdanau et al., 2014)ã€‚å¦ä¸€ç§å¯èƒ½æ€§æ˜¯ä½¿ç”¨ç‚¹ç§¯ ã€ˆq, kã€‰,ç§°ä¸ºä¹˜æ³•æ³¨æ„åŠ› (Vaswani et al., 2017)ã€‚ æˆ‘ä»¬å®é™…ä¸Šä½¿ç”¨äº†ä¸¤è€…çš„ç»„åˆ:ä¹˜æ³•æ³¨æ„åŠ›åŠ ä¸Šå®šä¹‰ä¸º Ïƒ(g(Â·)) å½¢å¼çš„å‡½æ•°ç»„æˆçš„å‰é¦ˆç½‘ç»œ,å…¶ä¸­ g æ˜¯ä»¿å°„å˜æ¢,Ïƒ æ˜¯æ–¹ç¨‹ (1) ä¸­å®šä¹‰çš„åˆ†æ®µçº¿æ€§ S å½¢æ¿€æ´»ã€‚å¯¹äºå½’ä¸€åŒ–å‡½æ•°,softmax æ˜¯ä¸€ä¸ªæ ‡å‡†é€‰é¡¹ã€‚å°½ç®¡å¦‚æ­¤,åœ¨æˆ‘ä»¬çš„è¯æ˜ä¸­,æˆ‘ä»¬ä½¿ç”¨ hardmax å‡½æ•°,å¦‚æœ xæ˜¯ x ä¸­çš„æœ€å¤§å€¼,åˆ™é€šè¿‡è®¾ç½® f(x) = 1 æ¥è·å¾—,å¦åˆ™è®¾ç½® f(x) = 0ã€‚å› æ­¤,å¯¹äºæœ€å¤§å€¼å‡ºç° r æ¬¡çš„å‘é‡ x,å¦‚æœ xæ˜¯ x çš„æœ€å¤§å€¼,åˆ™ hardmax(x) = ,å¦åˆ™ä¸º hardmax(x) = 0ã€‚æ¯å½“ hardmax ç”¨ä½œå½’ä¸€åŒ–å‡½æ•°æ—¶,æˆ‘ä»¬éƒ½ç§°å…¶ä¸º hard attentionã€‚ è®©æˆ‘ä»¬è§‚å¯Ÿä¸€ä¸‹,hardmax çš„é€‰æ‹©å¯¹äºæˆ‘ä»¬çš„è¯æ˜ä»¥å½“å‰å½¢å¼å·¥ä½œè‡³å…³é‡è¦,å› ä¸ºå®ƒå…è®¸æ¨¡æ‹Ÿ â€œè®¿é—®â€ å‘é‡åºåˆ—ä¸­ç‰¹å®šä½ç½®çš„è¿‡ç¨‹ã€‚Hard attention ä»¥å‰ä¸“é—¨ç”¨äºå¤„ç†å›¾åƒ(Xu et al., 2015;Elsayed et al., 2019),ä½†æ˜¯,æ®æˆ‘ä»¬æ‰€çŸ¥,å®ƒå°šæœªåœ¨è‡ªæˆ‘æ³¨æ„æ¶æ„çš„ä¸Šä¸‹æ–‡ä¸­ç”¨äºå¤„ç†åºåˆ—ã€‚æœ‰å…³æˆ‘ä»¬å¯¹æ­£ç»“æœå‡½æ•°çš„é€‰æ‹©çš„è¿›ä¸€æ­¥è®¨è®º,è¯·å‚è§ç¬¬ 5 èŠ‚ã€‚æŒ‰ç…§æƒ¯ä¾‹,å¯¹äºå‡½æ•° F : Qâ†’ Q å’Œåºåˆ— X = (x, x, . . . , x),å…¶ä¸­ xâˆˆ Q,æˆ‘ä»¬å†™ F (X) æ¥è¡¨ç¤ºåºåˆ— (F (x), . . . , F (x))ã€‚ Transformer ç¼–ç å™¨å’Œè§£ç å™¨ Transformer çš„å•å±‚ç¼–ç å™¨æ˜¯ä¸€ä¸ªå‚æ•°å‡½æ•° Enc(Î¸),å…¶ä¸­ Î¸ æ˜¯å‚æ•°,å®ƒæ¥æ”¶ Q ä¸­å‘é‡çš„åºåˆ— X = (x, . . . , x) ä½œä¸ºè¾“å…¥,è¿”å›ä¸€ä¸ªåºåˆ— Enc(X; Î¸) = (z, . . . . , z) Qä¸­ä¸ X é•¿åº¦ç›¸åŒçš„å‘é‡ã€‚ä¸€èˆ¬æ¥è¯´,æˆ‘ä»¬è®¤ä¸º Î¸ ä¸­çš„å‚æ•°æ˜¯å‚æ•°åŒ–å‡½æ•° Q(Â·)ã€K(Â·)ã€V (Â·) å’Œ O(Â·),å®ƒä»¬éƒ½ä» Qåˆ° Qã€‚ç„¶å,å•å±‚ç¼–ç å™¨å®šä¹‰å¦‚ä¸‹ a= Att(Q(x), K(X), V (X)) + x (4) z= O(a) + a (5) è¯·æ³¨æ„,åœ¨ç­‰å¼ 4 ä¸­,æˆ‘ä»¬å°†å‡½æ•° Q å’Œ V åˆ†åˆ«åº”ç”¨äº X ä¸­çš„æ¯ä¸ªæ¡ç›®ã€‚åœ¨å®è·µä¸­,Q(Â·)ã€K(Â·)ã€V (Â·) é€šå¸¸æ˜¯æŒ‡å®šä¸ºç»´åº¦ (d Ã— d) çŸ©é˜µçš„çº¿æ€§å˜æ¢,è€Œ O(Â·) æ˜¯å‰é¦ˆç½‘ç»œã€‚+ xand + asummands é€šå¸¸ç§°ä¸ºæ®‹å·®è¿æ¥(He et al., 2016;ä»–ç­‰äºº)ã€‚å½“ç”¨ä½œå‚æ•°çš„ç‰¹å®šå‡½æ•°ä¸é‡è¦æ—¶,æˆ‘ä»¬åªéœ€ç¼–å†™ Z = Enc(X)ã€‚ Transformer ç¼–ç å™¨è¢«ç®€å•åœ°å®šä¹‰ä¸ºå•å±‚ç¼–ç å™¨(å…·æœ‰ç‹¬ç«‹å‚æ•°)çš„é‡å¤åº”ç”¨,åŠ ä¸Šä¸¤ä¸ªæœ€ç»ˆå˜æ¢å‡½æ•° K(Â·) å’Œ V (Â·) åº”ç”¨äºæœ€ç»ˆå±‚è¾“å‡ºåºåˆ—ä¸­çš„æ¯ä¸ªå‘é‡ã€‚å› æ­¤,L å±‚ Transformer ç¼–ç å™¨ç”±ä»¥ä¸‹é€’å½’å®šä¹‰(1 â‰¤ ' â‰¤ Lâˆ’1 ä¸” X= X): X= Enc(X; Î¸), K = K(X), V = V (X).(6) V = V (X) æˆ‘ä»¬å†™ (K, V ) = TEnc(X) æ¥è¡¨ç¤º (K, V ) æ˜¯ L å±‚å˜å‹å™¨ç¼–ç å™¨åœ¨è¾“å…¥åºåˆ— X ä¸Šçš„ç»“æœã€‚ è§£ç å™¨ å•å±‚è§£ç å™¨ç±»ä¼¼äºå•å±‚ç¼–ç å™¨,ä½†éœ€è¦é¢å¤–æ³¨æ„ä¸€å¯¹å¤–éƒ¨é”®å€¼å‘é‡ (K, V )ã€‚å•å±‚è§£ç å™¨çš„è¾“å…¥æ˜¯åºåˆ— Y = (y, . . . , y) åŠ ä¸Šå¤–éƒ¨å¯¹ (K, V ),è¾“å‡ºæ˜¯ä¸ Y é•¿åº¦ç›¸åŒçš„åºåˆ— Z = (z, . . . . , z) ã€‚åœ¨å®šä¹‰è§£ç å™¨å±‚æ—¶,æˆ‘ä»¬ç”¨ Y è¡¨ç¤ºåºåˆ— (y, . . . , y),ä¸º 1 â‰¤ i â‰¤ kã€‚è¯¥å±‚çš„è¾“å‡º Z = (z, . . . . , z) ä¹Ÿè¢«å‚æ•°åŒ–,è¿™æ¬¡ç”±å››ä¸ªå‡½æ•° Q(Â·)ã€K(Â·)ã€V (Â·) å’Œ O(Â·) ä» Q to Q ç»„æˆ,å¹¶ä¸”å¯¹äºæ¯ä¸ª 1 â‰¤ i â‰¤ k å®šä¹‰å¦‚ä¸‹: p= Att(Q(y), K(Y), V (Y)) + y (7) a= Att(p, K, V ) + p (8) z= O(a) + a (9) è¯·æ³¨æ„,å¯¹ (K(Y), V (Y)) çš„ç¬¬ä¸€ä¸ª(è‡ªæˆ‘)å…³æ³¨ä»…åœ¨ç´¢å¼• i ä¹‹å‰è€ƒè™‘ Y çš„å­åºåˆ—,å¹¶ç”¨äºç”ŸæˆæŸ¥è¯¢ pto å…³æ³¨å¤–éƒ¨å¯¹ (K, V)ã€‚æˆ‘ä»¬å°† Y å’Œ (K, V ) ä¸Šçš„å•è§£ç å™¨å±‚çš„è¾“å‡ºè¡¨ç¤ºä¸º Dec((K, V ), Y ; Î¸)ã€‚ Transformer è§£ç å™¨æ˜¯å•å±‚è§£ç å™¨çš„é‡å¤åº”ç”¨,åŠ ä¸Šä¸€ä¸ªè½¬æ¢å‡½æ•° F : Qâ†’ Qåº”ç”¨äºè§£ç åºåˆ—çš„æœ€ç»ˆå‘é‡ã€‚å› æ­¤,è§£ç å™¨çš„è¾“å‡ºæ˜¯ Q âˆˆå•ä¸ªå‘é‡ zã€‚æ­£å¼åœ°,L å±‚ Transformer è§£ç å™¨å®šä¹‰ä¸º Y = Dec((K, V ), Y ; Î¸), z = F (y) (1 â‰¤ ' â‰¤ L âˆ’ 1 å’Œ Y = Y ).(10) æˆ‘ä»¬ä½¿ç”¨ z = TDec((K, V ), Y ) æ¥è¡¨ç¤º z æ˜¯è¿™ä¸ª L å±‚å˜å‹å™¨è§£ç å™¨åœ¨è¾“å…¥ Y å’Œ (K, V) ä¸Šçš„è¾“å‡ºã€‚ Transformer çš„ä¸€ä¸ªé‡è¦é™åˆ¶æ˜¯ Transformer è§£ç å™¨çš„è¾“å‡ºæ€»æ˜¯å¯¹åº”äºæŸäº›æœ‰é™å­—æ¯Î“ä¸­çš„å­—æ¯ç¼–ç ã€‚ä»å½¢å¼ä¸Šè®²,éœ€è¦å­˜åœ¨ä¸€ä¸ªæœ‰é™å­—æ¯Î“å’Œä¸€ä¸ªåµŒå…¥å‡½æ•° g : Î“ â†’ Q,ä½¿å¾— Transformer è§£ç å™¨çš„æœ€ç»ˆå˜æ¢å‡½æ•° F å°† Q ä¸­çš„ä»»ä½•å‘é‡æ˜ å°„åˆ° Î“ ä¸­å­—æ¯åµŒå…¥çš„æœ‰é™é›† g(Î“) ä¸­çš„å‘é‡ã€‚ å®Œæ•´çš„ Transformer Transformer ç½‘ç»œæ¥æ”¶ä¸€ä¸ªè¾“å…¥åºåˆ— Xã€ä¸€ä¸ªç§å­å‘é‡ y å’Œä¸€ä¸ªå€¼ r âˆˆ Nã€‚å®ƒçš„è¾“å‡ºæ˜¯ä¸€ä¸ªåºåˆ— Y = (y, . . . , y),å®šä¹‰ä¸º y= TDec(TEnc(X), (y, y, . . . , y)), å¯¹äº 0 â‰¤ t â‰¤ r âˆ’ 1ã€‚(11) yt+1=TDecâ¡(TEncâ¡(X),(y0,y1,â€¦,yt)),forÂ 0â‰¤tâ‰¤râˆ’1. \\boldsymbol{y}_{t+1}=\\operatorname{TDec}\\left(\\operatorname{TEnc}(\\boldsymbol{X}),\\left(\\boldsymbol{y}_{0}, \\boldsymbol{y}_{1}, \\ldots, \\boldsymbol{y}_{t}\\right)\\right), \\quad for ~ 0 \\leq t \\leq r-1. yt+1â€‹=TDec(TEnc(X),(y0â€‹,y1â€‹,â€¦,ytâ€‹)),forÂ 0â‰¤tâ‰¤râˆ’1. æˆ‘ä»¬å°†å˜å‹å™¨çš„è¾“å‡ºåºåˆ—è¡¨ç¤ºä¸º Y = (y, y, . . . . , y) = Trans(X, y, r)ã€‚ 3.1 æ¯”ä¾‹ä¸‹çš„ä¸å˜æ€§ å¦‚ä¸Šæ‰€è¿°,Transformer ç½‘ç»œåœ¨æ•è·è¯­è¨€çš„èƒ½åŠ›æ–¹é¢ç›¸å½“å¼±ã€‚è¿™æ˜¯å› ä¸º Transformer æ˜¯é¡ºåºä¸å˜çš„,å³å®ƒä»¬æ— æ³•è®¿é—® input ä¸­å…ƒç´ çš„ç›¸å¯¹é¡ºåºã€‚æ›´æ­£å¼åœ°è¯´,ä¸¤ä¸ªç›¸äº’æ’åˆ—çš„ Importing åºåˆ—ä¼šäº§ç”Ÿå®Œå…¨ç›¸åŒçš„è¾“å‡ºã€‚è¿™æ˜¯æ³¨æ„åŠ›å‡½æ•°çš„ä»¥ä¸‹å±æ€§çš„ç»“æœ:å¦‚æœ K = (k, . . . . , k), V = (v, . . . , v) ä¸” Ï€ : {1, . . . . , n} â†’ {1, . . . , n} æ˜¯æ’åˆ—,åˆ™å¯¹äºæ¯ä¸ªæŸ¥è¯¢ q,Att(q, K, V ) = Att(q, Ï€(K), Ï€(V ))ã€‚ ai=Attâ¡(Q(xi),K(X),V(X))+xi \\boldsymbol{a}_{i} =\\operatorname{Att}\\left(Q\\left(\\boldsymbol{x}_{i}\\right), K(\\boldsymbol{X}), V(\\boldsymbol{X})\\right)+\\boldsymbol{x}_{i} aiâ€‹=Att(Q(xiâ€‹),K(X),V(X))+xiâ€‹ zi=O(ai)+ai \\boldsymbol{z}_{i} =O\\left(\\boldsymbol{a}_{i}\\right)+\\boldsymbol{a}_{i} ziâ€‹=O(aiâ€‹)+aiâ€‹ 4. Transformer çš„ä½ç½®ç¼–ç çš„å›¾çµå®Œå¤‡æ€§ å®šç† 6 å…·æœ‰ä½ç½®ç¼–ç çš„ Transformer ç½‘ç»œç±»æ˜¯å›¾çµå®Œå¤‡çš„ã€‚æ­¤å¤–,å›¾çµå®Œå¤‡æ€§å³ä½¿åœ¨å—é™è®¾ç½®ä¸­ä¹Ÿæˆç«‹,å…¶ä¸­ n âˆˆ N çš„ä½ç½®åµŒå…¥ posï¼ˆnï¼‰ ä¸­å”¯ä¸€çš„éæ’å®šå€¼æ˜¯ nã€1/n å’Œ 1/n,å¹¶ä¸” Transformer ç½‘ç»œå…·æœ‰å•ä¸ªç¼–ç å™¨å±‚å’Œä¸‰ä¸ªè§£ç å™¨å±‚ã€‚ å®é™…ä¸Š,è¿™ä¸ªç»“æœçš„è¯æ˜æ˜¾ç¤ºäº†æ›´æœ‰åŠ›çš„ä¸œè¥¿:ä¸ä»… Transformers å¯ä»¥è¯†åˆ«å›¾çµæœºæ¥å—çš„æ‰€æœ‰è¯­è¨€,å³æ‰€è°“çš„å¯è¯†åˆ«æˆ–å¯åˆ¤å®šè¯­è¨€;å®ƒä»¬å¯ä»¥è¯†åˆ«æ‰€æœ‰é€’å½’å¯æšä¸¾æˆ–åŠå¯åˆ¤å®šçš„è¯­è¨€,è¿™äº›è¯­è¨€ L å­˜åœ¨æšä¸¾ L ä¸­æ‰€æœ‰å­—ç¬¦ä¸²çš„ TMã€‚ æˆ‘ä»¬ç°åœ¨æä¾›å®šç† 6 çš„å®Œæ•´è¯æ˜ã€‚ä¸ºäº†å¯è¯»æ€§,ä¸€äº›ä¸­é—´å¼•ç†çš„è¯æ˜è¢«å½’å…¥é™„å½•ã€‚ è®¾ M = ï¼ˆQ, Î£, Î´, q, F ï¼‰ æ˜¯ä¸€ä¸ªå›¾çµæœº,å…¶ç£å¸¦å‘å³æ˜¯æ— é™çš„,å¹¶å‡è®¾ç‰¹æ®Šç¬¦å· # âˆˆ Î£ ç”¨äºæ ‡è®°ç£å¸¦ä¸­çš„ç©ºç™½ä½ç½®ã€‚ æˆ‘ä»¬å¯¹ M åœ¨å¤„ç† Importing å­—ç¬¦ä¸²æ—¶çš„å·¥ä½œåŸç†åšå‡ºä»¥ä¸‹å‡è®¾: M ä»çŠ¶æ€ q å¼€å§‹,æŒ‡å‘ç£å¸¦çš„ç¬¬ä¸€ä¸ªè¯»å–ç©ºç™½ç¬¦å· #çš„å•å…ƒæ ¼ã€‚è¾“å…¥å°†ç«‹å³å†™å…¥ç¬¬ä¸€ä¸ªå•å…ƒæ ¼çš„å³ä¾§ã€‚ Q å…·æœ‰ç‰¹æ®ŠçŠ¶æ€ qused æ¥è¯»å–å®Œæ•´çš„è¾“å…¥ã€‚ æœ€åˆï¼ˆæ­¥éª¤ 0ï¼‰,M è¿‡æ¸¡åˆ°çŠ¶æ€ q,å¹¶å°†å…¶å¤´éƒ¨å‘å³ç§»åŠ¨ã€‚ å½“å¤„äºçŠ¶æ€æ—¶,qit å‘å³ç§»åŠ¨,ç›´åˆ°è¯»å–ç¬¦å· #ã€‚ ä¸æ¥å—çŠ¶æ€ï¼ˆF ä¸­çš„çŠ¶æ€ï¼‰æ²¡æœ‰è½¬æ¢ã€‚ å¾ˆå®¹æ˜“è¯æ˜,æ¯ä¸ªé€šç”¨çš„å›¾çµæœºéƒ½ç­‰åŒäºæ»¡è¶³ä¸Šè¿°å‡è®¾çš„å›¾çµæœºã€‚æˆ‘ä»¬è¯æ˜äº†å¯ä»¥æ„å»ºä¸€ä¸ª transformer ç½‘ç»œ Transthat èƒ½å¤Ÿåœ¨æ¯ä¸ªå¯èƒ½çš„è¾“å…¥å­—ç¬¦ä¸²ä¸Šæ¨¡æ‹Ÿ M;æˆ–è€…,æ›´æ­£å¼åœ°è¯´,Lï¼ˆM ï¼‰ = Lï¼ˆTransï¼‰ã€‚ æ„é€ ä»¥æŸç§æ–¹å¼å‚ä¸å…¶ä¸­,å¹¶ä½¿ç”¨äº†å‡ ä¸ªè¾…åŠ©å®šä¹‰å’Œä¸­é—´ç»“æœã€‚ä¸ºäº†ä¾¿äºé˜…è¯»,æˆ‘ä»¬å°†æ„é€ å’Œè¯æ˜åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ã€‚æˆ‘ä»¬é¦–å…ˆç»™å‡ºæˆ‘ä»¬ä½¿ç”¨çš„ç­–ç•¥çš„é«˜çº§è§†å›¾ã€‚ç„¶å,æˆ‘ä»¬è¯¦ç»†ä»‹ç»äº†å®ç°æˆ‘ä»¬çš„ç­–ç•¥æ‰€éœ€çš„ç¼–ç å™¨å’Œè§£ç å™¨çš„æ¶æ„,æœ€åæˆ‘ä»¬æ­£å¼è¯æ˜æˆ‘ä»¬æ¶æ„çš„æ¯ä¸ªéƒ¨åˆ†éƒ½å¯ä»¥å®é™…å®ç°ã€‚ åœ¨ Transwe çš„ç¼–ç å™¨éƒ¨åˆ†æ¥æ”¶å­—ç¬¦ä¸² w = ssÂ· Â· Â·s.æˆ‘ä»¬é¦–å…ˆä½¿ç”¨åµŒå…¥å‡½æ•°å°†æ¯ä¸ª sas è¡¨ç¤ºä¸º one-hot å‘é‡,å¹¶ä¸ºæ¯ä¸ªç´¢å¼•æ·»åŠ ä½ç½®ç¼–ç ã€‚ç¼–ç å™¨äº§ç”Ÿè¾“å‡º ï¼ˆK, Vï¼‰,å…¶ä¸­ K= ï¼ˆk, . . . , kï¼‰ å’Œ V = ï¼ˆv, . . . , vï¼‰ æ˜¯é”®å’Œå€¼çš„åºåˆ—,ä½¿å¾— våŒ…å«æ²™å­çš„ä¿¡æ¯ kåŒ…å«ç¬¬ i ä¸ªä½ç½®ç¼–ç çš„ä¿¡æ¯ã€‚æˆ‘ä»¬ç¨åä¼šè¯æ˜,è¿™å…è®¸æˆ‘ä»¬å…³æ³¨æ¯ä¸ªç‰¹å®šä½ç½®,å¹¶å°†æ¯ä¸ªè¾“å…¥ç¬¦å·ä»ç¼–ç å™¨å¤åˆ¶åˆ°è§£ç å™¨ï¼ˆå‚è§å¼•ç† 7ï¼‰ã€‚ åœ¨ Transwe çš„è§£ç å™¨éƒ¨åˆ†æ¨¡æ‹Ÿ M åœ¨ w = ssÂ· Â· Â· Â·s.ä¸ºæ­¤,æˆ‘ä»¬å®šä¹‰ä»¥ä¸‹åºåˆ—ï¼ˆå¯¹äº i â‰¥ 0ï¼‰: q:è®¡ç®—æ­¥éª¤ i ä¸­ M çš„çŠ¶æ€ s:æ­¥éª¤ i ä¸­ M å¤´éƒ¨è¯»å–çš„ç¬¦å· v:æ­¥éª¤ i ä¸­ M å†™å…¥çš„ç¬¦å· m:æ­¥éª¤ i ä¸­ M å¤´éƒ¨åœ¨è¿‡æ¸¡ä¸­ç§»åŠ¨çš„æ–¹å‘ v = [ q1, s1, x1, q2, s2, x2, x3, x4, x5, s3, x6, s4, x7 x8, x9, x10, x11 ], "},"Papers/Spatially varying nanophotonic neural networks.html":{"url":"Papers/Spatially varying nanophotonic neural networks.html","title":"Spatially varying nanophotonic neural networks","keywords":"","body":"ç©ºé—´å˜åŒ–çš„çº³ç±³å…‰å­ç¥ç»ç½‘ç»œ Spatially varying nanophotonic neural networks Abstract The explosive growth in computation and energy cost of artificial intelligence has spurred interest in alternative computing modalities to conventional electronic processors. Photonic processors, which use photons instead of electrons, promise optical neural networks with ultralow latency and power consumption. However, existing optical neural networks, limited by their designs, have not achieved the recognition accuracy of modern electronic neural networks. In this work, we bridge this gap by embedding parallelized optical computation into flat camera optics that perform neural network computations during capture, before recording on the sensor. We leverage large kernels and propose a spatially varying convolutional network learned through a low-dimensional reparameterization. We instantiate this network inside the camera lens with a nanophotonic array with angle-dependent responses. Combined with a lightweight electronic back-end of about 2K parameters, our reconfigurable nanophotonic neural network achieves 72.76% accuracy on CIFAR-10, surpassing AlexNet (72.64%), and advancing optical neural networks into the deep learning era. äººå·¥æ™ºèƒ½çš„è®¡ç®—å’Œèƒ½æºæˆæœ¬çš„çˆ†ç‚¸å¼å¢é•¿æ¿€å‘äº†äººä»¬å¯¹ä¼ ç»Ÿç”µå­å¤„ç†å™¨çš„æ›¿ä»£è®¡ç®—æ¨¡å¼çš„å…´è¶£ã€‚å…‰å­å¤„ç†å™¨ä½¿ç”¨å…‰å­è€Œä¸æ˜¯ç”µå­ï¼Œæœ‰æœ›å®ç°å…·æœ‰è¶…ä½å»¶è¿Ÿå’Œä½åŠŸè€—çš„å…‰å­¦ç¥ç»ç½‘ç»œã€‚ç„¶è€Œï¼Œç°æœ‰çš„å…‰å­¦ç¥ç»ç½‘ç»œå—å…¶è®¾è®¡çš„é™åˆ¶ï¼Œå°šæœªè¾¾åˆ°ç°ä»£ç”µå­ç¥ç»ç½‘ç»œçš„è¯†åˆ«ç²¾åº¦ã€‚åœ¨è¿™é¡¹å·¥ä½œä¸­ï¼Œæˆ‘ä»¬é€šè¿‡å°†å¹¶è¡Œå…‰å­¦è®¡ç®—åµŒå…¥åˆ°å¹³é¢ç›¸æœºå…‰å­¦å…ƒä»¶ä¸­æ¥å¼¥åˆè¿™ä¸€å·®è·ï¼Œè¿™äº›å…‰å­¦å…ƒä»¶åœ¨æ•è·æœŸé—´æ‰§è¡Œç¥ç»ç½‘ç»œè®¡ç®—ï¼Œç„¶åå†åœ¨ä¼ æ„Ÿå™¨ä¸Šè®°å½•ã€‚æˆ‘ä»¬åˆ©ç”¨å¤§å‹å†…æ ¸ï¼Œå¹¶æå‡ºäº†ä¸€ä¸ªé€šè¿‡ä½ç»´é‡æ–°å‚æ•°åŒ–å­¦ä¹ çš„ç©ºé—´å˜åŒ–å·ç§¯ç½‘ç»œã€‚æˆ‘ä»¬åœ¨ç›¸æœºé•œå¤´å†…ä½¿ç”¨å…·æœ‰è§’åº¦ç›¸å…³å“åº”çš„çº³ç±³å…‰å­é˜µåˆ—æ¥å®ä¾‹åŒ–è¿™ä¸ªç½‘ç»œã€‚ç»“åˆçº¦ 2K å‚æ•°çš„è½»é‡çº§ç”µå­åç«¯ï¼Œæˆ‘ä»¬çš„å¯é‡æ„çº³ç±³å…‰å­ç¥ç»ç½‘ç»œåœ¨ CIFAR-10 ä¸Šå®ç°äº† 72.76% çš„å‡†ç¡®ç‡ï¼Œè¶…è¿‡äº† AlexNetï¼ˆ72.64%ï¼‰ï¼Œå°†å…‰å­¦ç¥ç»ç½‘ç»œå¸¦å…¥äº†æ·±åº¦å­¦ä¹ æ—¶ä»£ã€‚ INTRODUCTION ä»‹ç» Increasing demands for high-performance artificial intelligence (AI) in the last decade have levied immense pressure on computing architectures across domains, including robotics, transportation, personal devices, medical imaging and scientific imaging. Although electronic microprocessors have undergone drastic evolution over the past 50 years (1), providing us with general-purpose central processing units and custom accelerator platforms (e.g., graphical processing unit and Digital Signal Processor (DSP) ASICs), this growth rate is far outpaced by the explosive growth of AI models. Specifically, the Mooreâ€™s law delivers a doubling in transistor counts every 2 years (2), whereas deep neural networks (DNNs) (3), arguably the most influential algorithms in AI, have doubled in size every 6 months (4). However, the end of voltage scaling has made the power consumption, and not the number of transistors, the principal factor limiting further improvements in computing performance (5). Overcoming this limitation and radically reducing compute latency and power consumption could drive unprecedented applications from low-power edge computation in the camera, potentially enabling computation in thin eyeglasses or microrobots and reducing power consumption in data centers used for training of neural network architectures. åœ¨è¿‡å»åå¹´ä¸­ï¼Œå¯¹é«˜æ€§èƒ½äººå·¥æ™ºèƒ½ ï¼ˆAIï¼‰ çš„éœ€æ±‚ä¸æ–­å¢é•¿ï¼Œè¿™ç»™æœºå™¨äººã€è¿è¾“ã€ä¸ªäººè®¾å¤‡ã€åŒ»å­¦æˆåƒå’Œç§‘å­¦æˆåƒç­‰å„ä¸ªé¢†åŸŸçš„è®¡ç®—æ¶æ„å¸¦æ¥äº†å·¨å¤§å‹åŠ›ã€‚å°½ç®¡ç”µå­å¾®å¤„ç†å™¨åœ¨è¿‡å» 50 å¹´ä¸­ç»å†äº†å·¨å¤§çš„å‘å±• ï¼ˆ1ï¼‰ï¼Œä¸ºæˆ‘ä»¬æä¾›äº†é€šç”¨çš„ä¸­å¤®å¤„ç†å™¨å’Œè‡ªå®šä¹‰åŠ é€Ÿå™¨å¹³å°ï¼ˆä¾‹å¦‚å›¾å½¢å¤„ç†å•å…ƒå’Œæ•°å­—ä¿¡å·å¤„ç†å™¨ ï¼ˆDSPï¼‰ ASICï¼‰ï¼Œä½†è¿™ä¸€å¢é•¿ç‡è¿œè¿œè¶…è¿‡äº† AI æ¨¡å‹çš„çˆ†ç‚¸å¼å¢é•¿ã€‚å…·ä½“æ¥è¯´ï¼Œæ‘©å°”å®šå¾‹çš„æ™¶ä½“ç®¡æ•°é‡æ¯ 2 å¹´ç¿»ä¸€ç•ª ï¼ˆ2ï¼‰ï¼Œè€Œæ·±åº¦ç¥ç»ç½‘ç»œ ï¼ˆDNNï¼‰ ï¼ˆ3ï¼‰ å¯ä»¥è¯´æ˜¯ AI é¢†åŸŸæœ€æœ‰å½±å“åŠ›çš„ç®—æ³•ï¼Œå…¶å¤§å°æ¯ 6 ä¸ªæœˆç¿»ä¸€ç•ª ï¼ˆ4ï¼‰ã€‚ç„¶è€Œï¼Œç”µå‹ç¼©æ”¾çš„ç»“æŸä½¿åŠŸè€—è€Œä¸æ˜¯æ™¶ä½“ç®¡æ•°é‡æˆä¸ºé™åˆ¶è®¡ç®—æ€§èƒ½è¿›ä¸€æ­¥æé«˜çš„ä¸»è¦å› ç´  ï¼ˆ5ï¼‰ã€‚å…‹æœè¿™ä¸€é™åˆ¶å¹¶ä»æ ¹æœ¬ä¸Šé™ä½è®¡ç®—å»¶è¿Ÿå’ŒåŠŸè€—ï¼Œå¯ä»¥æ¨åŠ¨ç›¸æœºä¸­çš„ä½åŠŸè€—è¾¹ç¼˜è®¡ç®—å¸¦æ¥å‰æ‰€æœªæœ‰çš„åº”ç”¨ï¼Œæœ‰å¯èƒ½åœ¨è–„çœ¼é•œæˆ–å¾®å‹æœºå™¨äººä¸­å®ç°è®¡ç®—ï¼Œå¹¶é™ä½ç”¨äºç¥ç»ç½‘ç»œæ¶æ„è®­ç»ƒçš„æ•°æ®ä¸­å¿ƒçš„åŠŸè€—ã€‚ Optical computing has been proposed as a potential avenue to alleviate several inherent limitations of digital electronics, e.g., compute speed, heat dissipation, and power, and could potentially boost computational throughput, processing speed, and energy efficiency by orders of magnitude (6â€“10). Such optical computers leverage several advantages of photonics to achieve high throughput, low latency, and low power consumption (11). These performance improvements are achieved by sacrificing reconfigurability. Thus, although general-purpose optical computing has yet to be practically realized due to obstacles such as larger physical footprints and inefficient optical switches (12, 13), several notable advances have already been made toward optical/photonic processors tailored specifically for AI (14, 15). Representative examples include optical computers that perform widely used signal processing operators (16â€“22), e.g., spatial/temporal differentiation, integration, and convolution with performance far beyond those of contemporary electronic processors. Most notably, optical neural networks (ONNs) (6, 23â€“38) can perform AI inference tasks such as image recognition when implemented as fully optical or hybrid opto-electronical computers. å…‰å­¦è®¡ç®—å·²è¢«æè®®ä½œä¸ºä¸€ç§æ½œåœ¨çš„é€”å¾„æ¥ç¼“è§£æ•°å­—ç”µå­å­¦çš„å‡ ä¸ªå›ºæœ‰é™åˆ¶ï¼Œä¾‹å¦‚è®¡ç®—é€Ÿåº¦ã€æ•£çƒ­å’ŒåŠŸç‡ï¼Œå¹¶å¯èƒ½å°†è®¡ç®—ååé‡ã€å¤„ç†é€Ÿåº¦å’Œèƒ½æºæ•ˆç‡æé«˜å‡ ä¸ªæ•°é‡çº§ ï¼ˆ6â€“10ï¼‰ã€‚è¿™ç§å…‰å­¦è®¡ç®—æœºåˆ©ç”¨å…‰å­å­¦çš„å‡ ä¸ªä¼˜åŠ¿æ¥å®ç°é«˜ååé‡ã€ä½å»¶è¿Ÿå’Œä½åŠŸè€— ï¼ˆ11ï¼‰ã€‚è¿™äº›æ€§èƒ½æ”¹è¿›æ˜¯é€šè¿‡ç‰ºç‰²å¯é‡æ–°é…ç½®æ€§æ¥å®ç°çš„ã€‚å› æ­¤ï¼Œå°½ç®¡ç”±äºè¾ƒå¤§çš„ç‰©ç†å ç”¨ç©ºé—´å’Œä½æ•ˆçš„å…‰å¼€å…³ç­‰éšœç¢ï¼Œé€šç”¨å…‰è®¡ç®—å°šæœªå®é™…å®ç° ï¼ˆ12ï¼Œ 13ï¼‰ï¼Œä½†ä¸“é—¨ä¸º AI é‡èº«å®šåˆ¶çš„å…‰/å…‰å­å¤„ç†å™¨å·²ç»å–å¾—äº†ä¸€äº›æ˜¾ç€è¿›å±• ï¼ˆ14ï¼Œ 15ï¼‰ã€‚ä»£è¡¨æ€§ç¤ºä¾‹åŒ…æ‹¬æ‰§è¡Œå¹¿æ³›ä½¿ç”¨çš„ä¿¡å·å¤„ç†è¿ç®—ç¬¦ ï¼ˆ16-22ï¼‰ çš„å…‰å­¦è®¡ç®—æœºï¼Œä¾‹å¦‚ç©ºé—´/æ—¶é—´å¾®åˆ†ã€ç§¯åˆ†å’Œå·ç§¯ï¼Œå…¶æ€§èƒ½è¿œè¿œè¶…è¿‡å½“ä»£ç”µå­å¤„ç†å™¨ã€‚æœ€å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå…‰å­¦ç¥ç»ç½‘ç»œ ï¼ˆONNï¼‰ ï¼ˆ6ï¼Œ 23â€“38ï¼‰ åœ¨ä½œä¸ºå…¨å…‰å­¦æˆ–æ··åˆå…‰ç”µè®¡ç®—æœºå®ç°æ—¶å¯ä»¥æ‰§è¡Œ AI æ¨ç†ä»»åŠ¡ï¼Œä¾‹å¦‚å›¾åƒè¯†åˆ«ã€‚ Existing ONNs can be broadly classified into two categories based on either integrated photonics (24â€“30) [e.g., Mach-Zehnder interferometers (23, 26), phase change materials (24), microring resonators (29), multimode fibers (30)] for physically realizing multiply-adds floating point operations (FLOPs), or with free-space optics (6, 31â€“37) that implement convolutional layers with light propagation through diffractive elements [e.g., 3D-printed surfaces (6), 4F optical correlators (37), optical masks (35), and meta-surfaces (36)]. The design of these ONN architectures has been fundamentally restricted by the underlying network design, including the challenge of scaling to large numbers of neurons (within integrated photonic circuits) and the lack of scalable energy-efficient nonlinear optical operators. As a result, even the most successful ensemble ONNs (31) that use dozens of ONNs in parallel, have only achieved LeNet (39)â€“level accuracy on image classification, which was achieved by their electronic counterparts over 30 years ago. Moreover, most high-performance ONNs can only operate under coherent illumination, prohibiting the integration into the camera optics under natural lighting conditions. Although hybrid opto-electronic networks (35, 36, 40) working on incoherent light do exist, most of them do not yield favorable results as their optical front-end is designed for small-kernel spatially uniform convolutional layers, which this work finds does not fully exploit the design space available for optical convolution. ç°æœ‰çš„ ONN å¤§è‡´å¯åˆ†ä¸ºä¸¤ç±»ï¼ŒåŸºäºé›†æˆå…‰å­å­¦ ï¼ˆ24-30ï¼‰ [ä¾‹å¦‚ï¼Œé©¬èµ«-æ›¾å¾·å°”å¹²æ¶‰ä»ª ï¼ˆ23ï¼Œ 26ï¼‰ã€ç›¸å˜ææ–™ ï¼ˆ24ï¼‰ã€å¾®ç¯è°æŒ¯å™¨ ï¼ˆ29ï¼‰ã€å¤šæ¨¡å…‰çº¤ ï¼ˆ30ï¼‰] ç”¨äºç‰©ç†å®ç°ä¹˜åŠ æµ®ç‚¹è¿ç®— ï¼ˆFLOPï¼‰ï¼Œæˆ–å…·æœ‰è‡ªç”±ç©ºé—´å…‰å­¦å™¨ä»¶ ï¼ˆ6ï¼Œ31-37ï¼‰ï¼Œå®ƒä»¬å®ç°äº†å·ç§¯å±‚ï¼Œå…‰é€šè¿‡è¡å°„å…ƒä»¶ä¼ æ’­ [ä¾‹å¦‚ï¼Œ3D æ‰“å°è¡¨é¢ ï¼ˆ6ï¼‰ã€4F å…‰å­¦ç›¸å…³å™¨ ï¼ˆ37ï¼‰ã€å…‰å­¦æ©æ¨¡ ï¼ˆ35ï¼‰ å’Œè¶…è¡¨é¢ ï¼ˆ36ï¼‰]ã€‚è¿™äº› ONN æ¶æ„çš„è®¾è®¡ä»æ ¹æœ¬ä¸Šå—åˆ°åº•å±‚ç½‘ç»œè®¾è®¡çš„é™åˆ¶ï¼ŒåŒ…æ‹¬æ‰©å±•åˆ°å¤§é‡ç¥ç»å…ƒï¼ˆåœ¨é›†æˆå…‰å­ç”µè·¯å†…ï¼‰çš„æŒ‘æˆ˜ä»¥åŠç¼ºä¹å¯æ‰©å±•çš„èŠ‚èƒ½éçº¿æ€§å…‰å­¦è¿ç®—ç¬¦ã€‚å› æ­¤ï¼Œå³ä½¿æ˜¯æœ€æˆåŠŸçš„é›†æˆ ONN ï¼ˆ31ï¼‰ å¹¶è¡Œä½¿ç”¨æ•°åä¸ª ONNï¼Œä¹Ÿåªèƒ½è¾¾åˆ° LeNet ï¼ˆ39ï¼‰ çº§çš„å›¾åƒåˆ†ç±»ç²¾åº¦ï¼Œè€Œè¿™æ˜¯ 30 å¤šå¹´å‰ç”µå­åŒç±»äº§å“å®ç°çš„ã€‚æ­¤å¤–ï¼Œå¤§å¤šæ•°é«˜æ€§èƒ½ ONN åªèƒ½åœ¨ç›¸å¹²ç…§æ˜ä¸‹å·¥ä½œï¼Œå› æ­¤æ— æ³•åœ¨è‡ªç„¶å…‰æ¡ä»¶ä¸‹é›†æˆåˆ°ç›¸æœºå…‰å­¦å…ƒä»¶ä¸­ã€‚ å°½ç®¡ç¡®å®å­˜åœ¨å¤„ç†éç›¸å¹²å…‰çš„æ··åˆå…‰ç”µç½‘ç»œ ï¼ˆ35ï¼Œ 36ï¼Œ 40ï¼‰ï¼Œä½†å®ƒä»¬ä¸­çš„å¤§å¤šæ•°å¹¶æ²¡æœ‰äº§ç”Ÿæœ‰åˆ©çš„ç»“æœï¼Œå› ä¸ºå®ƒä»¬çš„å…‰å­¦å‰ç«¯æ˜¯ä¸ºå°æ ¸ç©ºé—´å‡åŒ€çš„å·ç§¯å±‚è®¾è®¡çš„ï¼Œè¿™é¡¹å·¥ä½œå‘ç°è¿™å¹¶æ²¡æœ‰å……åˆ†åˆ©ç”¨å¯ç”¨äºå…‰å­¦å·ç§¯çš„è®¾è®¡ç©ºé—´ã€‚ In this work, we report a novel nanophotonic neural network that lifts the aforementioned limitations, allowing us to close the gap to the first modern DNN architectures (41) with optical compute in a flat form factor of only 4 mm length, akin to performing computation on the sensor cover glass, in lieu of the bulky compound 4-f systemâ€“based Fourier filter setup (40). We leverage the ability of a lens system to perform large-kernel spatially varying (LKSV) convolutions tailored specifically for image recognition and semantic segmentation. These operations are performed during the capture before the sensor makes a measurement. We learn large kernels via low-dimensional reparameterization techniques, which circumvent spurious local extremum caused by direct optimization. To physically realize the ONN, we develop a differentiable spatially varying inverse design framework that solves for metasurfaces (42â€“46) that can produce the desired angle-dependent responses under spatially incoherent illumination. Because of the compact footprint and complementary metal-oxide semiconductor (CMOS) sensor compatibility, the resulting optical system is not only a photonic accelerator but also an ultracompact computational camera that directly operates on the ambient light from the environment before the analog to digital conversion. We find that this approach facilitates generalization and transfer learning to other tasks, such as semantic segmentation, reaching performance comparable to AlexNet (41) in 1000-category ImageNet (47) classification and PASCAL VOC (48) semantic segmentation. åœ¨è¿™é¡¹å·¥ä½œä¸­ï¼Œæˆ‘ä»¬æŠ¥é“äº†ä¸€ç§æ–°é¢–çš„çº³ç±³å…‰å­ç¥ç»ç½‘ç»œï¼Œå®ƒæ¶ˆé™¤äº†ä¸Šè¿°é™åˆ¶ï¼Œä½¿æˆ‘ä»¬èƒ½å¤Ÿç¼©å°ä¸ç¬¬ä¸€ä¸ªç°ä»£ DNN æ¶æ„ ï¼ˆ41ï¼‰ çš„å·®è·ï¼Œå…‰å­¦è®¡ç®—é‡‡ç”¨ä»… 4 mm é•¿åº¦çš„æ‰å¹³å¤–å½¢å°ºå¯¸ï¼Œç±»ä¼¼äºåœ¨ä¼ æ„Ÿå™¨ç›–ç»ç’ƒä¸Šæ‰§è¡Œè®¡ç®—ï¼Œè€Œä¸æ˜¯ç¬¨é‡çš„åŸºäºåŒ–åˆç‰© 4-f ç³»ç»Ÿçš„å‚…é‡Œå¶æ»¤æ³¢å™¨è®¾ç½® ï¼ˆ40).æˆ‘ä»¬åˆ©ç”¨é•œå¤´ç³»ç»Ÿçš„èƒ½åŠ›æ¥æ‰§è¡Œä¸“ä¸ºå›¾åƒè¯†åˆ«å’Œè¯­ä¹‰åˆ†å‰²é‡èº«å®šåˆ¶çš„å¤§å†…æ ¸ç©ºé—´å˜åŒ– ï¼ˆLKSVï¼‰ å·ç§¯ã€‚è¿™äº›æ“ä½œæ˜¯åœ¨ä¼ æ„Ÿå™¨è¿›è¡Œæµ‹é‡ä¹‹å‰åœ¨æ•è·æœŸé—´æ‰§è¡Œçš„ã€‚æˆ‘ä»¬é€šè¿‡ä½ç»´é‡æ–°å‚æ•°åŒ–æŠ€æœ¯å­¦ä¹ å¤§å†…æ ¸ï¼Œè¯¥æŠ€æœ¯è§„é¿äº†ç›´æ¥ä¼˜åŒ–å¼•èµ·çš„ä¼ªå±€éƒ¨æå€¼ã€‚ä¸ºäº†ç‰©ç†å®ç° ONNï¼Œæˆ‘ä»¬å¼€å‘äº†ä¸€ä¸ªå¯å¾®åˆ†ç©ºé—´å˜åŒ–é€†å‘è®¾è®¡æ¡†æ¶ï¼Œè¯¥æ¡†æ¶æ±‚è§£è¶…è¡¨é¢ ï¼ˆ42-46ï¼‰ï¼Œè¯¥è¶…è¡¨é¢å¯ä»¥åœ¨ç©ºé—´éç›¸å¹²ç…§æ˜ä¸‹äº§ç”Ÿæ‰€éœ€çš„è§’åº¦ç›¸å…³å“åº”ã€‚ç”±äºç´§å‡‘çš„å°è£…å’Œäº’è¡¥çš„é‡‘å±æ°§åŒ–ç‰©åŠå¯¼ä½“ ï¼ˆCMOSï¼‰ ä¼ æ„Ÿå™¨å…¼å®¹æ€§ï¼Œæœ€ç»ˆçš„å…‰å­¦ç³»ç»Ÿä¸ä»…æ˜¯ä¸€ä¸ªå…‰å­åŠ é€Ÿå™¨ï¼Œè€Œä¸”è¿˜æ˜¯ä¸€ä¸ªè¶…ç´§å‡‘çš„è®¡ç®—ç›¸æœºï¼Œåœ¨æ¨¡æ•°è½¬æ¢ä¹‹å‰ç›´æ¥å¯¹æ¥è‡ªç¯å¢ƒçš„ç¯å¢ƒå…‰è¿›è¡Œæ“ä½œã€‚æˆ‘ä»¬å‘ç°è¿™ç§æ–¹æ³•æœ‰åŠ©äºæ³›åŒ–å’Œå°†å­¦ä¹ è½¬ç§»åˆ°å…¶ä»–ä»»åŠ¡ï¼Œå¦‚è¯­ä¹‰åˆ†å‰²ï¼Œåœ¨1000ä¸ªç±»åˆ«çš„ImageNetï¼ˆ47ï¼‰åˆ†ç±»å’ŒPASCAL VOCï¼ˆ48ï¼‰è¯­ä¹‰åˆ†å‰²ä¸­è¾¾åˆ°ä¸AlexNetï¼ˆ41ï¼‰ç›¸å½“çš„æ€§èƒ½ã€‚ Recent work (49) concurrent to ours reported a novel metasurface doublet that implements a multichannel optical convolution via angular and polarization multiplexing under spatially incoherent illuminance, and extensions (50, 51) leverage large convolutional kernels for image classification and semantic segmentation. While this work shares advantages with ours, such as multichannel operation, high performance, and the use of incoherent light, our method uses a single metasurface and relies on LKSV convolution instead of uniform convolutions increasing the parameter space by an order of magnitude. ä¸æˆ‘ä»¬åŒæ—¶è¿›è¡Œçš„æœ€æ–°å·¥ä½œ ï¼ˆ49ï¼‰ æŠ¥é“äº†ä¸€ç§æ–°çš„è¶…è¡¨é¢åŒåˆä½“ï¼Œå®ƒåœ¨ç©ºé—´éç›¸å¹²ç…§åº¦ä¸‹é€šè¿‡è§’åº¦å’ŒåæŒ¯å¤šè·¯å¤ç”¨å®ç°å¤šé€šé“å…‰å­¦å·ç§¯ï¼Œè€Œæ‰©å±• ï¼ˆ50ï¼Œ 51ï¼‰ åˆ©ç”¨å¤§å‹å·ç§¯æ ¸è¿›è¡Œå›¾åƒåˆ†ç±»å’Œè¯­ä¹‰åˆ†å‰²ã€‚è™½ç„¶è¿™é¡¹å·¥ä½œä¸æˆ‘ä»¬çš„å·¥ä½œå…·æœ‰å…±åŒçš„ä¼˜åŠ¿ï¼Œä¾‹å¦‚å¤šé€šé“æ“ä½œã€é«˜æ€§èƒ½å’Œéç›¸å¹²å…‰çš„ä½¿ç”¨ï¼Œä½†æˆ‘ä»¬çš„æ–¹æ³•ä½¿ç”¨å•ä¸ªè¶…è¡¨é¢ï¼Œå¹¶ä¾èµ–äº LKSV å·ç§¯è€Œä¸æ˜¯å‡åŒ€å·ç§¯ï¼Œå°†å‚æ•°ç©ºé—´å¢åŠ äº†ä¸€ä¸ªæ•°é‡çº§ã€‚ Hence, by on-chip integration of the flat-optics front-end (>99% FLOPs) with an extremely lightweight electronic back-end (99% FLOPsï¼‰ ä¸æè½»çš„ç”µå­åç«¯ ï¼ˆ41ï¼‰ ä¸º 72.64% ï¼ˆ52ï¼‰ æµ‹è¯•é›†]ï¼ŒåŒæ—¶å°†ç”µå­å‚æ•°çš„æ•°é‡å‡å°‘äº†å››ä¸ªæ•°é‡çº§ï¼Œä»è€Œå°† ONN å¸¦å…¥äº†ç°ä»£æ·±åº¦å­¦ä¹ æ—¶ä»£ã€‚ RESULTS ç»“æœ LKSV parameterization LKSV å‚æ•°åŒ– The working principle and optoelectronic implementation of the proposed spatially varying nanophotonic neural network (SVN3) are illustrated in Fig. 1A. The SVN3 is an optoelectronic neuromorphic computer that comprises a metalens array nanophotonic front-end and a lightweight electronic back-end (embedded in a low-cost microcontroller unit) for image classification or semantic segmentation. The metalens array front-end consists of 50 metalens elements that are made of 390-nm pitch nano-antennas and are optimized for incoherent light in a band around 525 nm. The wavefront modulation induced by each metalens can be represented by the optical convolution of the incident field and the point spread functions (PSFs) of the individual device. Therefore, the nanophotonic front-end performs parallel multichannel convolutions, at the speed of light, without any power consumption. We also refer to texts S1 and S3 for additional details on the physical forward model and the neural network design, respectively. æ‰€æå‡ºçš„ç©ºé—´å˜åŒ–çº³ç±³å…‰å­ç¥ç»ç½‘ç»œ ï¼ˆSVN3ï¼‰ çš„å·¥ä½œåŸç†å’Œå…‰ç”µå®ç°å¦‚å›¾ 1A æ‰€ç¤ºã€‚SVN3 æ˜¯ä¸€ç§å…‰ç”µç¥ç»å½¢æ€è®¡ç®—æœºï¼ŒåŒ…æ‹¬ä¸€ä¸ªè¶…é€é•œé˜µåˆ—çº³ç±³å…‰å­å‰ç«¯å’Œä¸€ä¸ªç”¨äºå›¾åƒåˆ†ç±»æˆ–è¯­ä¹‰åˆ†å‰²çš„è½»é‡çº§ç”µå­åç«¯ï¼ˆåµŒå…¥åœ¨ä½æˆæœ¬å¾®æ§åˆ¶å™¨å•å…ƒä¸­ï¼‰ã€‚è¶…é€é•œé˜µåˆ—å‰ç«¯ç”± 50 ä¸ªè¶…é€é•œå…ƒä»¶ç»„æˆï¼Œè¿™äº›å…ƒä»¶ç”± 390 nm é—´è·çº³ç±³å¤©çº¿åˆ¶æˆï¼Œå¹¶é’ˆå¯¹ 525 nm å·¦å³æ³¢æ®µçš„éç›¸å¹²å…‰è¿›è¡Œäº†ä¼˜åŒ–ã€‚æ¯ä¸ªè¶…é€é•œè¯±å¯¼çš„æ³¢å‰è°ƒåˆ¶å¯ä»¥ç”¨å…¥å°„åœºçš„å…‰å­¦å·ç§¯å’Œå•ä¸ªå™¨ä»¶çš„ç‚¹æ‰©æ•£å‡½æ•° ï¼ˆPSFï¼‰ æ¥è¡¨ç¤ºã€‚å› æ­¤ï¼Œçº³ç±³å…‰å­å‰ç«¯ä»¥å…‰é€Ÿæ‰§è¡Œå¹¶è¡Œå¤šé€šé“å·ç§¯ï¼Œæ— éœ€ä»»ä½•åŠŸè€—ã€‚æˆ‘ä»¬è¿˜å‚è€ƒäº†æ–‡æœ¬ S1 å’Œ "},"Programming/Programming.html":{"url":"Programming/Programming.html","title":"Programming","keywords":"","body":""},"Programming/CRTP.html":{"url":"Programming/CRTP.html","title":"CRTP","keywords":"","body":"CRTP: Compile-Time-Reflection-Programming wiki // The Curiously Recurring Template Pattern (CRTP) template class Base { // methods within Base can use template to access members of Derived }; class Derived : public Base { // ... }; Why? Polymorphic chaining // Base class template class Printer { public: Printer(ostream& pstream) : m_stream(pstream) {} template ConcretePrinter& print(T&& t) { m_stream (*this); } template ConcretePrinter& println(T&& t) { m_stream (*this); } private: ostream& m_stream; }; // Derived class class CoutPrinter : public Printer { public: CoutPrinter() : Printer(cout) {} CoutPrinter& SetConsoleColor(Color c) { // ... return *this; } }; // usage CoutPrinter().print(\"Hello \").SetConsoleColor(Color.red).println(\"Printer!\"); Polymorphic copy construction å¤šæ€å¤åˆ¶æ„é€  When using polymorphism, one sometimes needs to create copies of objects by the base class pointer. A commonly used idiom for this is adding a virtual clone function that is defined in every derived class. The CRTP can be used to avoid having to duplicate that function or other similar functions in every derived class. ä½¿ç”¨å¤šæ€æ€§æ—¶ï¼Œæœ‰æ—¶éœ€è¦é€šè¿‡åŸºç±»æŒ‡é’ˆåˆ›å»ºå¯¹è±¡çš„å‰¯æœ¬ã€‚ä¸ºæ­¤ï¼Œå¸¸ç”¨çš„ä¹ æƒ¯ç”¨æ³•æ˜¯æ·»åŠ åœ¨æ¯ä¸ªæ´¾ç”Ÿç±»ä¸­å®šä¹‰çš„è™šæ‹Ÿå…‹éš†å‡½æ•°ã€‚ CRTP å¯ç”¨äºé¿å…åœ¨æ¯ä¸ªæ´¾ç”Ÿç±»ä¸­é‡å¤è¯¥å‡½æ•°æˆ–å…¶ä»–ç±»ä¼¼å‡½æ•°ã€‚ // Base class has a pure virtual function for cloning class AbstractShape { public: virtual ~AbstractShape() = default; virtual std::unique_ptr clone() const = 0; }; // This CRTP class implements clone() for Derived template class Shape : public AbstractShape { public: std::unique_ptr clone() const override { return std::make_unique(static_cast(*this)); } protected: // We make clear Shape class needs to be inherited Shape() = default; Shape(const Shape&) = default; Shape(Shape&&) = default; }; // Every derived class inherits from CRTP class instead of abstract class class Square : public Shape {}; class Circle : public Shape {}; This allows obtaining copies of squares, circles or any other shapes by shapePtr->clone(). è¿™å…è®¸é€šè¿‡shapePtr->clone()è·å–æ­£æ–¹å½¢ã€åœ†å½¢æˆ–ä»»ä½•å…¶ä»–å½¢çŠ¶çš„å‰¯æœ¬ã€‚ "},"PythonLibs/PythonLibs.html":{"url":"PythonLibs/PythonLibs.html","title":"PythonLibs","keywords":"","body":"Python Libs Misc Pylint: Static Code Analyser Additional tools in pylint pyreverse(standalone tool that generates package and class diagrams.) symilar(duplicate code finder that is also integrated in pylint) pyreverse pyreverse [options] # eg. # generate classes.dot and packages.dot of marko lib pyreverse marko 01_Misc dot -Tsvg classes.dot > classes.svg 01_Misc dot -Tsvg packages.dot > packages.svg "},"PythonLibs/ArgParse.html":{"url":"PythonLibs/ArgParse.html","title":"ArgParse","keywords":"","body":"ArgParse in Python unexpected parser.add_argument(\"--train\", type=bool) åœ¨ä½¿ç”¨ argparse æ—¶ï¼Œparser.add_argument(\"--train\", type=bool) çš„ç”¨æ³•å¯èƒ½ä¼šå¯¼è‡´ä¸€äº›æ„å¤–è¡Œä¸ºï¼Œå› ä¸º type=bool å¹¶ä¸ä¼šå°†è¾“å…¥çš„å­—ç¬¦ä¸²è‡ªåŠ¨è½¬æ¢ä¸ºå¸ƒå°”å€¼ã€‚ç›¸åï¼Œå®ƒä¼šå°è¯•å°†è¾“å…¥çš„å­—ç¬¦ä¸²ä½œä¸º Python çš„ bool() å‡½æ•°çš„å‚æ•°ï¼Œè¿™é€šå¸¸ä¼šå¯¼è‡´è¾“å…¥çš„å€¼è¢«è§£é‡Šä¸º True æˆ– Falseï¼Œä½†ç»“æœå¯èƒ½ä¸ç¬¦åˆé¢„æœŸã€‚ é—®é¢˜åˆ†æ bool(\"True\") è¿”å› Trueï¼Œä½† bool(\"False\") ä¹Ÿè¿”å› Trueï¼Œå› ä¸ºéç©ºå­—ç¬¦ä¸²åœ¨ Python ä¸­è¢«è§†ä¸º Trueã€‚ å› æ­¤ï¼Œç›´æ¥ä½¿ç”¨ type=bool æ— æ³•æ­£ç¡®è§£æå¸ƒå°”å€¼å‚æ•°ã€‚ æ­£ç¡®çš„ç”¨æ³• ä¸ºäº†æ­£ç¡®è§£æå¸ƒå°”å€¼å‚æ•°ï¼Œå¯ä»¥ä½¿ç”¨ action='store_true' æˆ– action='store_false'ï¼Œæˆ–è€…è‡ªå®šä¹‰ç±»å‹è½¬æ¢å‡½æ•°ã€‚ æ–¹æ³• 1ï¼šä½¿ç”¨ action='store_true' æˆ– action='store_false' è¿™æ˜¯æœ€å¸¸ç”¨çš„æ–¹æ³•ï¼Œé€‚ç”¨äºå¸ƒå°”å€¼å‚æ•°çš„é»˜è®¤è¡Œä¸ºã€‚ import argparse parser = argparse.ArgumentParser() parser.add_argument(\"--train\", action='store_true', help=\"æ˜¯å¦å¯ç”¨è®­ç»ƒæ¨¡å¼\") args = parser.parse_args() print(f\"è®­ç»ƒæ¨¡å¼: {args.train}\") ä½¿ç”¨ç¤ºä¾‹ python script.py --train è¾“å‡ºï¼š è®­ç»ƒæ¨¡å¼: True å¦‚æœä¸ä¼ é€’ --train å‚æ•°ï¼š python script.py è¾“å‡ºï¼š è®­ç»ƒæ¨¡å¼: False æ–¹æ³• 2ï¼šè‡ªå®šä¹‰ç±»å‹è½¬æ¢å‡½æ•° å¦‚æœä½ å¸Œæœ›ç”¨æˆ·æ˜ç¡®ä¼ é€’ True æˆ– Falseï¼Œå¯ä»¥ä½¿ç”¨è‡ªå®šä¹‰ç±»å‹è½¬æ¢å‡½æ•°ã€‚ import argparse def str_to_bool(value): if value.lower() in ['true', '1', 't', 'y', 'yes']: return True elif value.lower() in ['false', '0', 'f', 'n', 'no']: return False else: raise argparse.ArgumentTypeError(\"å¸ƒå°”å€¼å¿…é¡»æ˜¯ 'True' æˆ– 'False'\") parser = argparse.ArgumentParser() parser.add_argument(\"--train\", type=str_to_bool, help=\"æ˜¯å¦å¯ç”¨è®­ç»ƒæ¨¡å¼\") args = parser.parse_args() print(f\"è®­ç»ƒæ¨¡å¼: {args.train}\") ä½¿ç”¨ç¤ºä¾‹ python script.py --train True è¾“å‡ºï¼š è®­ç»ƒæ¨¡å¼: True python script.py --train False è¾“å‡ºï¼š è®­ç»ƒæ¨¡å¼: False å¦‚æœä¼ é€’äº†æ— æ•ˆçš„å€¼ï¼š python script.py --train maybe è¾“å‡ºï¼š usage: script.py [-h] [--train TRAIN] script.py: error: argument --train: å¸ƒå°”å€¼å¿…é¡»æ˜¯ 'True' æˆ– 'False' æ€»ç»“ å¦‚æœå¸Œæœ›å‚æ•°é»˜è®¤æ˜¯å¸ƒå°”å€¼ï¼Œæ¨èä½¿ç”¨ action='store_true' æˆ– action='store_false'ã€‚ å¦‚æœéœ€è¦ç”¨æˆ·æ˜ç¡®ä¼ é€’ True æˆ– Falseï¼Œå¯ä»¥ä½¿ç”¨è‡ªå®šä¹‰ç±»å‹è½¬æ¢å‡½æ•°ã€‚ ç›´æ¥ä½¿ç”¨ type=bool å¯èƒ½ä¼šå¯¼è‡´æ„å¤–è¡Œä¸ºï¼Œä¸æ¨èä½¿ç”¨ã€‚ "},"PythonLibs/AsyncSSH.html":{"url":"PythonLibs/AsyncSSH.html","title":"AsyncSSH","keywords":"","body":"AsyncSSH doc "},"PythonLibs/Dask.html":{"url":"PythonLibs/Dask.html","title":"Dask","keywords":"","body":"Dask Easy Parallel Python that does what you need "},"PythonLibs/Dlib/DlibPythonBindings.html":{"url":"PythonLibs/Dlib/DlibPythonBindings.html","title":"DlibPythonBindings","keywords":"","body":"Dlib Dlib C++ Library Dlib is a modern C++ toolkit containing machine learning algorithms and tools for creating complex software in C++ to solve real world problems. It is used in both industry and academia in a wide range of domains including robotics, embedded devices, mobile phones, and large high performance computing environments. Dlib's open source licensing allows you to use it in any application, free of charge. Dlib æ˜¯ä¸€ä¸ªç°ä»£ C++ å·¥å…·åŒ…ï¼ŒåŒ…å«æœºå™¨å­¦ä¹ ç®—æ³•å’Œå·¥å…·ï¼Œç”¨äºç”¨ C++ åˆ›å»ºå¤æ‚çš„è½¯ä»¶æ¥è§£å†³ç°å®ä¸–ç•Œçš„é—®é¢˜ã€‚å®ƒåœ¨å·¥ä¸šç•Œå’Œå­¦æœ¯ç•Œå¹¿æ³›ä½¿ç”¨ï¼ŒåŒ…æ‹¬æœºå™¨äººã€åµŒå…¥å¼è®¾å¤‡ã€ç§»åŠ¨ç”µè¯å’Œå¤§å‹é«˜æ€§èƒ½è®¡ç®—ç¯å¢ƒã€‚ Dlibçš„å¼€æºè®¸å¯ å…è®¸æ‚¨åœ¨ä»»ä½•åº”ç”¨ç¨‹åºä¸­å…è´¹ä½¿ç”¨å®ƒã€‚ pkg-config --cflags --libs dlib-1 -I/usr/local/include -L/usr/local/lib -ldlib /usr/lib/x86_64-linux-gnu/libsqlite3.so local build and install: apt install: get_frontal_face_detector() This function returns an object_detector that is configured to find human faces that are looking more or less towards the camera. It is created using the scan_fhog_pyramid object. python bindings class dlib.image_window This is a GUI window capable of showing images on the screen. add_overlay(rectangles, color=rgb_pixel(255,0,0)) -> None add_overlay(rectangle, color=rgb_pixel(255,0,0)) -> None add_overlay(full_object_detection, color=rgb_pixel(255,0,0)) -> None clear_overlay() get_next_double_click(self: dlib.image_window) -> object get_next_keypress() is_closed() -> bool set_image(img: numpy.ndarray[(rows, cols), int]) -> None set_title(title: str) -> None wait_until_closed() -> None wait_for_keypress(key: str) -> int Blocks until the user presses the given key or closes the window. class dlib.face_recognition_model_v1 This object maps human faces into 128D vectors where pictures of the same person are mapped near to each other and pictures of different people are mapped far apart. The constructor loads the face recognition model from a file. defcompute_face_descriptor( img: numpy.ndarray[(rows, cols, 3), uint8], face: full_object_detection, num_jitters: int=0, padding: float=0.25), -> dlib.vector Takes an image and a full_object_detection that references a face in that image and converts it into a 128D face descriptor. If num_jitters>1 then each face will be randomly jittered slightly num_jitters times, each run through the 128D projection, and the average used as the face descriptor. Optionally allows to override default padding of 0.25 around the face. dlib.vector This object is an array of vector objects. shape_predictor_68_face_landmarks facial-point-annotations shape_predictor One Millisecond Face Alignment with an Ensemble of Regression Trees, CVPR 2014 è¿™ç¯‡è®ºæ–‡è§£å†³äº†å•å¼ å›¾åƒçš„äººè„¸å¯¹é½é—®é¢˜ã€‚æˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨å›å½’æ ‘é›†æˆç›´æ¥ä»åƒç´ å¼ºåº¦çš„ç¨€ç–å­é›†ä¼°è®¡äººè„¸çš„å…³é”®ç‚¹ä½ç½®ï¼Œä»è€Œå®ç°è¶…å®æ—¶çš„é«˜è´¨é‡é¢„æµ‹ã€‚æˆ‘ä»¬æå‡ºäº†ä¸€ç§åŸºäºæ¢¯åº¦æå‡çš„é€šç”¨æ¡†æ¶ï¼Œç”¨äºå­¦ä¹ å›å½’æ ‘é›†æˆï¼Œä¼˜åŒ–å¹³æ–¹è¯¯å·®æŸå¤±å’Œè‡ªç„¶å¤„ç†ç¼ºå¤±æˆ–éƒ¨åˆ†æ ‡æ³¨çš„æ•°æ®ã€‚æˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•åˆ©ç”¨é€‚å½“çš„å…ˆéªŒä¿¡æ¯ï¼Œåˆ©ç”¨å›¾åƒæ•°æ®çš„ç»“æ„æ¥å¸®åŠ©é«˜æ•ˆçš„ç‰¹å¾é€‰æ‹©ã€‚æˆ‘ä»¬è¿˜ç ”ç©¶äº†ä¸åŒçš„æ­£åˆ™åŒ–ç­–ç•¥åŠå…¶åœ¨é˜²æ­¢è¿‡æ‹Ÿåˆä¸­çš„é‡è¦æ€§ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬åˆ†æäº†è®­ç»ƒæ•°æ®é‡å¯¹é¢„æµ‹ç²¾åº¦çš„å½±å“ï¼Œå¹¶æ¢è®¨äº†ä½¿ç”¨åˆæˆæ•°æ®è¿›è¡Œæ•°æ®å¢å¼ºçš„æ•ˆæœã€‚ "},"PythonLibs/LearnPyQt5/PyQt5.html":{"url":"PythonLibs/LearnPyQt5/PyQt5.html","title":"PyQt5","keywords":"","body":"PyQt5 doc QtCore âˆ’ å…¶ä»–æ¨¡å—ä½¿ç”¨çš„æ ¸å¿ƒé GUI ç±» QtGui âˆ’ å›¾å½¢ç”¨æˆ·ç•Œé¢ç»„ä»¶ QtMultimedia âˆ’ ä½çº§å¤šåª’ä½“ç¼–ç¨‹ç±» QtNetwork âˆ’ ç½‘ç»œç¼–ç¨‹ç±» QtOpenGL âˆ’ OpenGL æ”¯æŒç±» QtScript âˆ’ è¯„ä¼° Qt è„šæœ¬çš„ç±» QtSql âˆ’ ä½¿ç”¨ SQL è¿›è¡Œæ•°æ®åº“é›†æˆçš„ç±» QtSvg âˆ’ æ˜¾ç¤º SVG æ–‡ä»¶å†…å®¹çš„ç±» QtWebKit âˆ’ æ¸²æŸ“å’Œç¼–è¾‘ HTML çš„ç±» QtXml âˆ’ å¤„ç† XML çš„ç±» QtWidgets âˆ’ åˆ›å»ºç»å…¸æ¡Œé¢é£æ ¼ UI çš„ç±» QtDesigner âˆ’ æ‰©å±• Qt Designer çš„ç±» QWidgetæ´¾ç”Ÿè‡ª QObject å’Œ QPaintDevice ç±»çš„ç±»æ˜¯æ‰€æœ‰ç”¨æˆ·ç•Œé¢å¯¹è±¡çš„åŸºç±»ã€‚QDialogå’ŒQFrameç±»ä¹Ÿæ´¾ç”Ÿè‡ª QWidget ç±»ã€‚ä»–ä»¬æœ‰è‡ªå·±çš„å­ç±»ç³»ç»Ÿã€‚ è¿™æ˜¯å¸¸ç”¨å°éƒ¨ä»¶çš„é€‰æ‹©åˆ—è¡¨ åºå· å°éƒ¨ä»¶å’Œè¯´æ˜ 1 QLabelç”¨äºæ˜¾ç¤ºæ–‡æœ¬æˆ–å›¾åƒ 2 QLineEditå…è®¸ç”¨æˆ·è¾“å…¥ä¸€è¡Œæ–‡æœ¬ 3 QTextEditå…è®¸ç”¨æˆ·è¾“å…¥å¤šè¡Œæ–‡æœ¬ 4 QPushButtonè°ƒç”¨æ“ä½œçš„å‘½ä»¤æŒ‰é’® 5 QRadioButtonå…è®¸ä»å¤šä¸ªé€‰é¡¹ä¸­é€‰æ‹©ä¸€ä¸ª 6 QCheckBoxå…è®¸é€‰æ‹©å¤šä¸ªé€‰é¡¹ 7 QSpinBoxå…è®¸å¢åŠ /å‡å°‘æ•´æ•°å€¼ 8 QScrollBarå…è®¸è®¿é—®è¶…å‡ºæ˜¾ç¤ºå­”å¾„çš„å°éƒ¨ä»¶å†…å®¹ 9 QSliderå…è®¸çº¿æ€§æ”¹å˜è¾¹ç•Œå€¼ã€‚ 10 QComboBoxæä¾›å¯ä¾›é€‰æ‹©çš„é¡¹ç›®çš„ä¸‹æ‹‰åˆ—è¡¨ 11 QMenuBaråŒ…å« QMenu å¯¹è±¡çš„å•æ  12 QStatusBaré€šå¸¸åœ¨ QMainWindow çš„åº•éƒ¨ï¼Œæä¾›çŠ¶æ€ä¿¡æ¯ã€‚ 13 QToolBaré€šå¸¸åœ¨ QMainWindow é¡¶éƒ¨æˆ–æµ®åŠ¨ã€‚åŒ…å«æ“ä½œæŒ‰é’® 14 QListViewåœ¨ ListMode æˆ– IconMode ä¸­æä¾›å¯é€‰æ‹©çš„é¡¹ç›®åˆ—è¡¨ 15 QPixmapæ˜¾ç¤ºåœ¨ QLabel æˆ– QPushButton å¯¹è±¡ä¸Šçš„å±å¹•å¤–å›¾åƒè¡¨ç¤º 16 QDialogå¯ä»¥å‘çˆ¶çª—å£è¿”å›ä¿¡æ¯çš„æ¨¡æ€æˆ–éæ¨¡æ€çª—å£ ä¸€ä¸ªå…¸å‹çš„åŸºäº GUI çš„åº”ç”¨ç¨‹åºçš„é¡¶å±‚çª—å£æ˜¯ç”±QMainWindowå°éƒ¨ä»¶å¯¹è±¡ã€‚ä¸Šé¢åˆ—å‡ºçš„ä¸€äº›å°éƒ¨ä»¶åœ¨æ­¤ä¸»çª—å£ä¸­å æ®æŒ‡å®šä½ç½®ï¼Œè€Œå…¶ä»–å°éƒ¨ä»¶åˆ™ä½¿ç”¨å„ç§å¸ƒå±€ç®¡ç†å™¨æ”¾ç½®åœ¨ä¸­å¤®å°éƒ¨ä»¶åŒºåŸŸã€‚ QDialog å°éƒ¨ä»¶å‘ˆç°ä¸€ä¸ªé¡¶çº§çª—å£ï¼Œä¸»è¦ç”¨äºæ”¶é›†ç”¨æˆ·çš„å“åº”ã€‚ å®ƒå¯ä»¥é…ç½®ä¸º Modalï¼ˆå®ƒä¼šé˜»æ­¢å…¶çˆ¶çª—å£ï¼‰æˆ– Modelessï¼ˆå¯ä»¥ç»•è¿‡å¯¹è¯çª—å£ï¼‰ã€‚ PyQt API æœ‰è®¸å¤šé¢„é…ç½®çš„ Dialog å°éƒ¨ä»¶ï¼Œä¾‹å¦‚ InputDialogã€FileDialogã€FontDialog ç­‰ã€‚ QMessageBox æ˜¯ä¸€ç§å¸¸ç”¨çš„æ¨¡å¼å¯¹è¯æ¡†ï¼Œç”¨äºæ˜¾ç¤ºä¸€äº›ä¿¡æ¯æ€§æ¶ˆæ¯ï¼Œå¹¶å¯é€‰æ‹©è¦æ±‚ç”¨æˆ·é€šè¿‡å•å‡»å…¶ä¸Šçš„ä»»ä½•ä¸€ä¸ªæ ‡å‡†æŒ‰é’®æ¥åšå‡ºå“åº”ã€‚ æ¯ä¸ªæ ‡å‡†æŒ‰é’®éƒ½æœ‰ä¸€ä¸ªé¢„å®šä¹‰çš„æ ‡é¢˜ã€ä¸€ä¸ªè§’è‰²å¹¶è¿”å›ä¸€ä¸ªé¢„å®šä¹‰çš„åå…­è¿›åˆ¶æ•°å­—ã€‚ å¤šæ–‡æ¡£ç•Œé¢ ä¸€ä¸ªå…¸å‹çš„ GUI åº”ç”¨ç¨‹åºå¯èƒ½æœ‰å¤šä¸ªçª—å£ã€‚ é€‰é¡¹å¡å¼å’Œå †å å¼å°éƒ¨ä»¶å…è®¸ä¸€æ¬¡æ¿€æ´»ä¸€ä¸ªè¿™æ ·çš„çª—å£ã€‚ ç„¶è€Œï¼Œå¾ˆå¤šæ—¶å€™è¿™ç§æ–¹æ³•å¯èƒ½æ²¡æœ‰ç”¨ï¼Œå› ä¸ºå…¶ä»–çª—å£çš„è§†å›¾è¢«éšè—äº†ã€‚ åŒæ—¶æ˜¾ç¤ºå¤šä¸ªçª—å£çš„ä¸€ç§æ–¹æ³•æ˜¯å°†å®ƒä»¬åˆ›å»ºä¸ºç‹¬ç«‹çš„çª—å£ã€‚ è¿™ç§°ä¸º SDI ï¼ˆå•æ–‡æ¡£æ¥å£ï¼‰ã€‚ è¿™éœ€è¦æ›´å¤šçš„å†…å­˜èµ„æºï¼Œå› ä¸ºæ¯ä¸ªçª—å£å¯èƒ½æœ‰è‡ªå·±çš„èœå•ç³»ç»Ÿã€å·¥å…·æ ç­‰ã€‚ MDI ï¼ˆå¤šæ–‡æ¡£æ¥å£ï¼‰ åº”ç”¨ç¨‹åºæ¶ˆè€—è¾ƒå°‘çš„å†…å­˜èµ„æºã€‚ å­çª—å£ç›¸å¯¹äºå½¼æ­¤æ”¾ç½®åœ¨ä¸»å®¹å™¨å†…ã€‚ å®¹å™¨å°éƒ¨ä»¶ç§°ä¸º QMdiAreaã€‚ QMdiArea å°éƒ¨ä»¶ä¸€èˆ¬å æ® QMainWondow å¯¹è±¡çš„ä¸­å¿ƒå°éƒ¨ä»¶ã€‚ è¯¥åŒºåŸŸä¸­çš„å­çª—å£æ˜¯ QMdiSubWindow ç±»çš„å®ä¾‹ã€‚ å¯ä»¥å°†ä»»ä½• QWidget è®¾ç½®ä¸º subWindow å¯¹è±¡çš„å†…éƒ¨å°éƒ¨ä»¶ã€‚ MDI åŒºåŸŸçš„å­çª—å£å¯ä»¥å±‚å æˆ–å¹³é“ºæ’åˆ—ã€‚ PyQt5 - æ‹–æ”¾ æ‹–æ”¾çš„æä¾›å¯¹ç”¨æˆ·æ¥è¯´éå¸¸ç›´è§‚ã€‚ å®ƒå­˜åœ¨äºè®¸å¤š æ¡Œé¢åº”ç”¨ç¨‹åºä¸­ï¼Œç”¨æˆ·å¯ä»¥åœ¨å…¶ä¸­å°†å¯¹è±¡ä»ä¸€ä¸ªçª—å£å¤åˆ¶æˆ–ç§»åŠ¨åˆ°å¦ä¸€ä¸ªçª—å£ã€‚ åŸºäº MIME çš„æ‹–æ”¾æ•°æ®ä¼ è¾“åŸºäº QDrag ç±»ã€‚ QMimeData å¯¹è±¡å°†æ•°æ®ä¸å…¶å¯¹åº”çš„ MIME ç±»å‹ç›¸å…³è”ã€‚ å®ƒå­˜å‚¨åœ¨å‰ªè´´æ¿ä¸Šï¼Œç„¶ååœ¨æ‹–æ”¾è¿‡ç¨‹ä¸­ä½¿ç”¨ã€‚ ä¸‹é¢çš„ QMimeData ç±»å‡½æ•°å¯ä»¥æ–¹ä¾¿åœ°æ£€æµ‹å’Œä½¿ç”¨ MIME ç±»å‹ã€‚ æ•°æ®åº“å¤„ç† PyQt5 åº“åŒ…å« QtSql æ¨¡å—ã€‚ å®ƒæ˜¯ä¸€ä¸ªå¤æ‚çš„ç±»ç³»ç»Ÿï¼Œå¯ä»¥ä¸è®¸å¤šåŸºäº SQL çš„æ•°æ®åº“è¿›è¡Œé€šä¿¡ã€‚ å®ƒçš„ QSqlDatabase é€šè¿‡ Connection å¯¹è±¡æä¾›è®¿é—®ã€‚ ä»¥ä¸‹æ˜¯å½“å‰å¯ç”¨çš„ SQL é©±åŠ¨ç¨‹åºåˆ—è¡¨ QGraphicsScene Create a QGraphicsScene : This serves as the container for the graphical elements. åˆ›å»º QGraphicsSceneï¼šç”¨ä½œå›¾å½¢å…ƒç´ çš„å®¹å™¨ã€‚ Load the Image with QPixmap : Use QPixmap to load the image. Load the Image with QPixmapï¼šç”¨äº QPixmap åŠ è½½å›¾åƒã€‚ Add the Image to the Scene : Create a QGraphicsPixmapItem from the QPixmap and add it to the scene. å°†å›¾åƒæ·»åŠ åˆ°åœºæ™¯ï¼š QGraphicsPixmapItem ä» åˆ›å»ºä¸€ä¸ª QPixmap å¹¶å°†å…¶æ·»åŠ åˆ°åœºæ™¯ä¸­ã€‚ Display the Scene in a QGraphicsView : Use QGraphicsView to display the contents of the scene. åœ¨ QGraphicsView ä¸­æ˜¾ç¤ºåœºæ™¯ï¼šç”¨äº QGraphicsView æ˜¾ç¤ºåœºæ™¯çš„å†…å®¹ã€‚ A QRadioButton class object presents a selectable button with a text label. It is commonly used when the user need to choose one option from a list of options. This widget is represented by a small circular button that can be toggled on (checked) or off (unchecked). This class is derived from QAbstractButton class. QRadioButton ç±»å¯¹è±¡è¡¨ç¤ºå¸¦æœ‰æ–‡æœ¬æ ‡ç­¾çš„å¯é€‰æŒ‰é’®ã€‚å½“ç”¨æˆ·éœ€è¦ä»é€‰é¡¹åˆ—è¡¨ä¸­é€‰æ‹©ä¸€ä¸ªé€‰é¡¹æ—¶ï¼Œé€šå¸¸ä½¿ç”¨å®ƒã€‚æ­¤å°éƒ¨ä»¶ç”±ä¸€ä¸ªå°çš„åœ†å½¢æŒ‰é’®è¡¨ç¤ºï¼Œè¯¥æŒ‰é’®å¯ä»¥æ‰“å¼€ï¼ˆé€‰ä¸­ï¼‰æˆ–å…³é—­ï¼ˆå–æ¶ˆé€‰ä¸­ï¼‰ã€‚æ­¤ç±»æ´¾ç”Ÿè‡ª QAbstractButton ç±»ã€‚ "},"PythonLibs/LearnPyQt5/QtStyleSheets.html":{"url":"PythonLibs/LearnPyQt5/QtStyleSheets.html","title":"QtStyleSheets","keywords":"","body":"Qt Style Sheets stylesheet-examples Customizing Qt Widgets Using Style Sheets Qt Style Sheets Reference blog: ä½¿ç”¨ QSS ç¾åŒ– PyQt5 ç•Œé¢ qt-material Qt-Meterial: pip install qt-material import sys from PySide6 import QtWidgets # from PySide2 import QtWidgets # from PyQt5 import QtWidgets from qt_material import apply_stylesheet # create the application and the main window app = QtWidgets.QApplication(sys.argv) window = QtWidgets.QMainWindow() # setup stylesheet apply_stylesheet(app, theme='dark_teal.xml') # run window.show() app.exec_() "},"ReadingNotes/ReadingNotes.html":{"url":"ReadingNotes/ReadingNotes.html","title":"ReadingNotes","keywords":"","body":"Reading Notes è®ºé’å¹´çš„ä¿®å…»-å¼ é—»å¤©-1938 è®ºé’å¹´ä¿®å…»-å¼ ç”³åºœ-1946 ç ”ç©¶ä¸å­¦é£-å¼ ç”³åºœ-1948 é’å¹´åœ¨é€‰æ‹©èŒä¸šæ—¶çš„è€ƒè™‘-é©¬å…‹æ€ è¯­å½• è®¡ç®—ä¹‹é­‚ References jyywiki.cn/Letter.md ã€Šæ¸…ååå¸ˆè°ˆå­¦é£ã€‹-æ¸…åå¤§å­¦æ ¡å²é¦† "},"ReadingNotes/A_Brief_History_of_Humankind.html":{"url":"ReadingNotes/A_Brief_History_of_Humankind.html","title":"A_Brief_History_of_Humankind","keywords":"","body":"A Brief History of Humankind å†…å®¹ç®€ä»‹ ã€Šäººç±»ç®€å²ï¼šä»åŠ¨ç‰©åˆ°ä¸Šå¸ã€‹æ˜¯å°¤ç“¦å°”Â·èµ«æ‹‰åˆ©åˆ›ä½œçš„å†å²ç±»è‘—ä½œï¼Œè®²è¿°äº†äººç±»ä»çŸ³å™¨æ—¶ä»£è‡³ 21 ä¸–çºªçš„æ¼”åŒ–ä¸å‘å±•å²ï¼Œå¹¶å°†äººç±»å†å²åˆ†ä¸ºå››ä¸ªé˜¶æ®µï¼šè®¤çŸ¥é©å‘½ã€å†œä¸šé©å‘½ã€äººç±»çš„èåˆç»Ÿä¸€ä¸ç§‘å­¦é©å‘½ã€‚ ä½œè€… å°¤ç“¦å°”Â·èµ«æ‹‰åˆ©ï¼Œ1976 å¹´ç”Ÿï¼Œç‰›æ´¥å¤§å­¦å†å²å­¦åšå£«ï¼Œç°ä¸ºè€¶è·¯æ’’å†·å¸Œä¼¯æ¥å¤§å­¦çš„å†å²ç³»æ•™æˆï¼Œé’å¹´æ€ªæ‰ï¼Œå…¨çƒç©ç›®çš„æ–°é”å†å²å­¦å®¶ã€‚ä»–æ“…é•¿ä¸–ç•Œå†å²å’Œå®è§‚å†å²è¿›ç¨‹ç ”ç©¶ã€‚åœ¨å­¦æœ¯é¢†åŸŸå’Œå¤§ä¼—å‡ºç‰ˆé¢†åŸŸéƒ½æœ‰å¾ˆå¤§çš„å…´è¶£ã€‚ å†…å®¹æ‘˜å½• æ— è®ºæ˜¯ç°ä»£å›½å®¶ã€ä¸­ä¸–çºªçš„æ•™å ‚ã€å¤è€çš„åŸå¸‚ï¼Œæˆ–è€…å¤è€çš„éƒ¨è½ï¼Œä»»ä½•å¤§è§„æ¨¡äººç±»åˆä½œçš„æ ¹åŸºï¼Œéƒ½åœ¨äºæŸç§åªå­˜åœ¨äºé›†ä½“æƒ³è±¡ä¸­çš„è™šæ„æ•…äº‹ã€‚ä¾‹å¦‚æ•™ä¼šçš„æ ¹åŸºå°±åœ¨äºå®—æ•™æ•…äº‹ã€‚ æ­£å› å¦‚æ­¤ï¼Œäººç±»æ‰ä¸€èµ·æƒ³å‡ºäº†â€œæœ‰é™å…¬å¸â€è¿™ç§æ¦‚å¿µã€‚åœ¨æ³•å¾‹ä¸Šï¼Œè¿™ç§å…¬å¸æ˜¯ç‹¬ç«‹çš„ä¸ªä½“ï¼Œè€Œä¸ç­‰äºè®¾ç«‹è€…ã€æŠ•èµ„è€…æˆ–ç®¡ç†è€…ã€‚åœ¨è¿‡å»å‡ ä¸–çºªé—´ï¼Œè¿™ç§å…¬å¸å·²ç»æˆä¸ºç»æµä¸»æµï¼Œæˆ‘ä»¬å¤ªä¹ æƒ¯äºè¿™ç§æ¦‚å¿µï¼Œè€Œå¿˜äº†è¿™åªå­˜åœ¨äºæˆ‘ä»¬çš„æƒ³è±¡ä¹‹ä¸­ã€‚â€œæœ‰é™å…¬å¸â€çš„è‹±æ–‡ç§°ä¸ºâ€œcorporationâ€ï¼Œè¿™ç‚¹é¢‡ä¸ºè®½åˆºï¼Œå› ä¸ºè¿™ä¸ªå­—çš„è¯­æºæ˜¯â€œcorpusâ€ï¼ˆæ‹‰ä¸æ–‡çš„â€œèº«ä½“â€ï¼‰ï¼Œè€Œè¿™æ­£æ˜¯æœ‰é™å…¬å¸æ‰€æ²¡æœ‰çš„ã€‚è™½ç„¶å…¬å¸å¹¶æ²¡æœ‰çœŸæ­£çš„å®ä½“ï¼Œä½†åœ¨æ³•å¾‹ä¸Šæˆ‘ä»¬å´å°†å®ƒç§°ä¸ºâ€œæ³•äººâ€ï¼Œå¥½åƒå®ƒçœŸçš„æ˜¯æœ‰è¡€æœ‰è‚‰çš„äººä¸€èˆ¬ã€‚ å¦‚æœè¦è¡¡é‡æŸç§ç‰©ç§æ¼”åŒ–æˆåŠŸä¸å¦ï¼Œè¯„æ–­æ ‡å‡†å°±åœ¨äºä¸–ç•Œä¸Šå…¶ DNA èºæ—‹çš„æ‹·è´æ•°çš„å¤šå¯¡ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹ç¾å›½ã€Šç‹¬ç«‹å®£è¨€ã€‹æ”¹ç”¨ç”Ÿç‰©å­¦ã€ç§‘å­¦çš„è§’åº¦æ¥å†™è¯¥æ˜¯å¦‚ä½•ï¼š æˆ‘ä»¬è®¤ä¸ºä¸‹é¢è¿™äº›çœŸç†æ˜¯ä¸è¨€è€Œå–»çš„ï¼šäººäººæ¼”åŒ–å„æœ‰ä¸åŒï¼Œå‡ºç”Ÿå°±æœ‰æŸäº›å¯å˜çš„ç‰¹æ€§ï¼Œå…¶ä¸­åŒ…æ‹¬ç”Ÿå‘½å’Œè¿½æ±‚å¿«æ„Ÿã€‚ æ³¨ï¼šæœ‰ä¸€ä¸ªç¬‘è¯è¯´ï¼Œç‹¬ç«‹å®£è¨€æ‰€è¯´çš„ä¸è¨€è‡ªæ˜çš„çœŸç†â€œAll men are created equal.â€è¿™å¥è¯ä¸­ï¼Œåªæœ‰â€œareâ€æ˜¯å«ä¹‰æ˜ç¡®ä¸”çœŸæ­£ä¸ºçœŸçš„ã€‚All æ˜¯å¦åŒ…æ‹¬å¥´éš¶ï¼ŒMen æ˜¯å¦åŒ…æ‹¬å¥³äººï¼Œcreated æ˜¯ç¥åˆ›è¿˜æ˜¯æ¼”åŒ–ï¼Œequal æ˜¯å…¬å¹³è¿˜æ˜¯å¹³ç­‰ï¼Ÿ è¯»ä¹¦å¿ƒå¾— å…¶å®åœ¨çœ‹ã€Šäººç±»ç®€å²ã€‹ä¹‹å‰ï¼Œæˆ‘ä¹Ÿçœ‹è¿‡å¾ˆå¤šå…³äºäººç±»æˆ–è€…è‡ªç„¶å†å²çš„ä¹¦ï¼Œä½†ã€Šäººç±»ç®€å²ã€‹è¿˜æ˜¯è®©æˆ‘å¯¹äººç±»ç¤¾ä¼šçš„å†å²æ€è€ƒä¸è§‚å¯Ÿçš„çš„è§’åº¦äº§ç”Ÿäº†å¾ˆå¤§çš„å˜åŒ–â€¦â€¦ "},"ReadingNotes/Feynman.html":{"url":"ReadingNotes/Feynman.html","title":"Feynman","keywords":"","body":"Feynman wikiquote: Richard_Feynman \"What I cannot create, I do not understand\" ^1 When Feynman said \"create\", he did not literally mean that in order to understand particle physics, he had to go Tony Stark on us and build his own accelerator. Instead, he meant that, starting with a blank piece of paper and the knowledge already in his mind, he could take any theoretical result and re-derive it. (\"Any\" is probably an exaggeration, but he could likely derive whatever he was interested in.) Feynman thought that ability was the true marker of understanding something because the only way to be able to work something out yourself is to have a firm understanding of each step of the reasoning involved. Further, if you try this, even with relatively simple concepts you think you understand well already, you'll find that you frequently come away from the process with a much deeper appreciation for the problem. An even more extreme position from Feynman was1 Once, I [David Goodstein] said to him, \"Dick, explain to me, so that I can understand it, why spin one-half particles obey Fermi-Dirac statistics.\" Sizing up his audience perfectly, Feynman said, \"I'll prepare a freshman lecture on it.\" But he came back a few days later to say, \"I couldn't do it. I couldn't reduce it to the freshman level. That means we don't really understand it.\" Feynman meant here that understanding something is not just about working through advanced mathematics. One must also have a notion that is intuitive enough to explain to an audience that cannot follow the detailed derivation. I've seen a few more sources that spell out Feynman's position on this in detail. The spinning plate story describes how Feynman felt that curiosity about simple things, and working them out for himself, helped him retain an attitude of play towards his professional work that got him out of a slump. Feynman's Tips on Physics, an extension to the Feynman lectures, has a chapter about how to learn physics, emphasizing that memorizing formulas is hopeless in the long run, and that by knowing a few key things and understanding the principles, you can work out whatever details you need. I can't find this chapter online, though. Finally, Feynman's Lost Lecture is a fantastic example of precisely what Feynman meant. In it, he describes his own elementary proof that the inverse square law for gravity leads to elliptical orbits. å½“è´¹æ›¼è¯´â€œåˆ›é€ â€æ—¶ï¼Œä»–å¹¶ä¸æ˜¯è¯´ï¼šè¦ç†è§£ç²’å­ç‰©ç†ï¼Œå°±å¿…é¡»åƒæ‰˜å°¼Â·æ–¯å¡”å…‹é‚£æ ·äº²è‡ªé€ ä¸€ä¸ªåŠ é€Ÿå™¨ã€‚è€Œæ˜¯ä»–è®¤ä¸ºï¼Œä»ä¸€å¼ ç™½çº¸å’Œå¤´è„‘ä¸­å·²æœ‰çš„çŸ¥è¯†å‡ºå‘ï¼Œä»–å¯ä»¥é‡æ–°æ¨å¯¼å‡ºä»»ä½•ç†è®ºç»“æœã€‚ï¼ˆâ€œä»»ä½•â€å¯èƒ½æœ‰äº›å¤¸å¼ ï¼Œä½†å¾ˆå¯èƒ½ä¼šæ¨å¯¼å‡ºä»–æ„Ÿå…´è¶£çš„ä¸œè¥¿ã€‚ï¼‰ è´¹æ›¼è®¤ä¸ºï¼Œè¿™ç§èƒ½åŠ›æ˜¯çœŸæ­£ç†è§£æŸä»¶äº‹çš„æ ‡å¿—ï¼Œå› ä¸ºå”¯ä¸€èƒ½è®©ä½ è‡ªå·±è§£å‡ºé—®é¢˜çš„æ–¹æ³•æ˜¯ï¼Œå¯¹æ¨ç†è¿‡ç¨‹ä¸­çš„æ¯ä¸€æ­¥éƒ½æœ‰ä¸€ä¸ªåšå®šçš„ç†è§£ã€‚æ­¤å¤–ï¼Œå¦‚æœä½ å°è¯•è¿™æ ·åšï¼Œå³ä½¿æ˜¯å¯¹ä½ å·²ç»è®¤ä¸ºç†è§£å¾—å¾ˆç®€å•çš„æ¦‚å¿µï¼Œä½ ä¹Ÿä¼šå‘ç°ï¼Œä½ ç»å¸¸ä»è¿‡ç¨‹ä¸­è·å¾—æ›´æ·±çš„è®¤è¯†ã€‚ è´¹æ›¼ç”šè‡³æ›´æç«¯çš„è§‚ç‚¹æ˜¯1ï¼š æœ‰ä¸€æ¬¡ï¼Œæˆ‘å¯¹ä»–è¯´ï¼Œâ€œè¿ªå…‹ï¼Œè§£é‡Šç»™æˆ‘å¬ï¼Œä»¥ä¾¿æˆ‘èƒ½ç†è§£ï¼Œä¸ºä»€ä¹ˆåŠè‡ªæ—‹ç²’å­éµå®ˆè´¹ç±³-ç‹„æ‹‰å…‹ç»Ÿè®¡è§„å¾‹ï¼Ÿâ€ä»–å®Œç¾åœ°è¯„ä¼°äº†ä»–çš„å¬ä¼—ï¼Œç„¶åè¯´ï¼šâ€œæˆ‘å‡†å¤‡ä¸€ä¸ªç»™æ–°ç”Ÿçš„è®²åº§ã€‚â€ä½†æ˜¯å‡ å¤©åä»–å›æ¥è¯´ï¼Œâ€œæˆ‘åšä¸åˆ°ã€‚æˆ‘æ— æ³•é™åˆ°æ–°ç”Ÿæ°´å¹³ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å®é™…ä¸Šå¹¶ä¸äº†è§£ã€‚â€ åœ¨è¿™é‡Œï¼Œè´¹æ›¼çš„æ„æ€æ˜¯ï¼Œç†è§£æŸä»¶äº‹ä¸ä»…ä»…æ˜¯é€šè¿‡é«˜çº§æ•°å­¦æ¥è§£å†³é—®é¢˜ã€‚è¿˜å¿…é¡»æœ‰ä¸€ä¸ªè¶³å¤Ÿç›´è§‚çš„æ¦‚å¿µï¼Œä»¥ä¾¿å‘ä¸€ä¸ªæ— æ³•è·Ÿéšè¯¦ç»†æ¨å¯¼çš„å¬ä¼—è§£é‡Šã€‚ æˆ‘æ‰¾åˆ°äº†ä¸€äº›è¯¦ç»†é˜è¿°è´¹æ›¼åœ¨è¿™ä¸ªé—®é¢˜ä¸Šçš„è§‚ç‚¹çš„èµ„æ–™ã€‚ æ—‹è½¬ç›˜çš„æ•…äº‹æè¿°äº†è´¹æ›¼å¦‚ä½•è®¤ä¸ºï¼Œå¯¹ç®€å•äº‹ç‰©çš„å¥½å¥‡å¿ƒä»¥åŠä»–è‡ªå·±è§£å†³é—®é¢˜çš„èƒ½åŠ›ï¼Œå¸®åŠ©ä»–ä¿æŒä¸€ç§å¯¹èŒä¸šå·¥ä½œçš„ç©è€æ€åº¦ï¼Œä½¿ä»–ä»å›°å¢ƒä¸­èµ°å‡ºæ¥ã€‚ ã€Šè´¹æ›¼ç‰©ç†å­¦æŒ‡å—ã€‹æ˜¯ä¸€æœ¬æ‰©å±•è´¹æ›¼è®²åº§çš„ä¹¦ç±ï¼Œå…¶ä¸­ä¸€ç« è®²è¿°äº†å¦‚ä½•å­¦ä¹ ç‰©ç†å­¦ï¼Œå¼ºè°ƒé•¿æœŸæ¥çœ‹è®°å¿†å…¬å¼æ˜¯å¾’åŠ³çš„ï¼Œè€Œé€šè¿‡äº†è§£ä¸€äº›å…³é”®ç‚¹ä»¥åŠç†è§£åŸåˆ™ï¼Œä½ å¯ä»¥è§£å†³æ‰€éœ€çš„ä»»ä½•ç»†èŠ‚ã€‚ä¸è¿‡ï¼Œæˆ‘åœ¨ç½‘ä¸Šæ‰¾ä¸åˆ°è¿™ä¸€ç« ã€‚ æœ€åï¼Œã€Šè´¹æ›¼çš„è¿·å¤±è®²åº§ã€‹æ­£æ˜¯è´¹æ›¼è§‚ç‚¹çš„ä¸€ä¸ªç»ä½³ä¾‹è¯ã€‚åœ¨å…¶ä¸­ï¼Œä»–æè¿°äº†ä»–è‡ªå·±ç”¨åˆç­‰æ–¹æ³•è¯æ˜ä¸‡æœ‰å¼•åŠ›åæ¯”å®šå¾‹å¯¼è‡´æ¤­åœ†è½¨é“çš„è¿‡ç¨‹ã€‚ "},"ReadingNotes/math_philosiphy.html":{"url":"ReadingNotes/math_philosiphy.html","title":"math_philosiphy","keywords":"","body":"æ•°å­¦å…·æœ‰æ— å¯æ€€ç–‘çš„çœŸç†æ€§å—ï¼Ÿ æ•°å­¦ï¼Ÿæ•°å­¦çš„çœŸç†æ€§ã€æ­£ç¡®æ€§æºäºä»€ä¹ˆï¼Ÿ ä»€ä¹ˆæ˜¯æ•°å­¦ï¼Ÿ å®é™…ä¸­æœŸä»¥å‰ï¼šæ•°å­¦å“²å­¦ä½œä¸ºä¸€èˆ¬å“²å­¦çš„ä¸€ä¸ªä¾§é¢ ç°ä»£æ•°å­¦å“²å­¦ ä»€ä¹ˆæ˜¯æ•°å­¦çš„å¯é æ€§åŸºç¡€ï¼Ÿ æ˜¯æ•°å­¦å¤–éƒ¨çš„æŸç§æˆåˆ†ã€è¿˜æ˜¯æ•°å­¦å†…éƒ¨çš„æŸç§åŸºæœ¬ç†è®ºï¼Ÿ æ€æ ·æŠŠæ•°å­¦å»ºç«‹åœ¨ä¸€ä¸ªå¯é çš„åŸºç¡€ä¹‹ä¸Šï¼Ÿ æ•°å­¦åŸºç¡€çš„ç ”ç©¶ foundations of mathematics é€»è¾‘ä¸»ä¹‰è€…ï¼šæ•°å­¦çš„åŸºç¡€åœ¨äºé€»è¾‘ï¼Œè±å¸ƒå°¼èŒ¨ ç›´è§‰ä¸»ä¹‰è€…ï¼šæ•°å­¦çš„åŸºç¡€åœ¨äºäººç±»æ‰€å›ºæœ‰çš„ç›´è§‰èƒ½åŠ›ï¼Œåº·å¾· å¸Œå°”ä¼¯ç‰¹ï¼šæ•°å­¦ä¸éœ€è¦ä»»ä½•é™„åŠ çš„å‰æï¼Œæ•°å­¦æœ¬èº«å°±åŒ…å«äº†ç»å¯¹å¯é çš„æˆåˆ†-æœ‰é™çš„æ•°å­¦ï¼Ÿï¼Ÿ æ•°å­¦åŸºç¡€ç ”ç©¶çš„ä¸»è¦ä»»åŠ¡åœ¨äºï¼š é€šè¿‡ç»™éæœ‰é™çš„æ•°å­¦ä»¥å½¢å¼çš„è§£é‡Šï¼ŒæŠŠå…¨éƒ¨æ•°å­¦å¥ åŸºäºæœ‰é™çš„æ•°å­¦ å¸Œå°”ä¼¯ç‰¹çš„å½¢å¼ä¸»ä¹‰ æ•°å­¦çš„ç‘•ç–µ-æ‚–è®º æ•°å­¦ä¸­çš„æ‚–è®º-æ•°å­¦ä¸æ˜¯å®Œå…¨å¯é çš„ï¼Ÿ æ•°å­¦ç ”ç©¶å¯¹è±¡çš„å®åœ¨æ€§é—®é¢˜-æ•°å­¦æœ¬ä½“è®ºé—®é¢˜ å®åœ¨è®ºï¼šæ•°å­¦çš„ç ”ç©¶å¯¹è±¡æ˜¯ä¸€ç§ç‹¬ç«‹çš„ã€ä¸ä¾èµ–äººç±»æ€ç»´çš„å®¢è§‚å­˜åœ¨ å½¢å¼ä¸»ä¹‰ï¼šæ•°å­¦çš„ç ”ç©¶å¯¹è±¡çŸ¥è¯†ä¸€ç§æ— æ„ä¹‰çš„ç¬¦å·ï¼Œå¯¹æ­¤æ²¡æœ‰ã€ä¹Ÿä¸å¿…è¦ä½œå‡ºè§£é‡Š ç¬¦å·å’Œè§„åˆ™ä¸­ï¼Œä½•ä»¥è•´å«å¦‚æ­¤åºæ‚ã€ä¸°å¯Œçš„å¯èƒ½ï¼Ÿ é›†ä¸­åœ¨æ— é™æ€§å¯¹è±¡çš„å®åœ¨æ€§é—®é¢˜ä¸Šï¼š å®æ— é™è®º æ½œæ— é™è®º æ–¹æ³•è®ºçš„å®æ— é™è®º æ•°å­¦çš„ç ”ç©¶å¯¹è±¡æ˜¯å¦æ˜¯ä¸€ç§çœŸå®çš„å­˜åœ¨ï¼Ÿ â€œåœ†â€ï¼Œâ€œæ­£æ–¹å½¢â€ï¼Œâ€œæ­£å¼¦å‡½æ•°â€æ˜¯çœŸå®çš„å­˜åœ¨å—ï¼Ÿ ä»€ä¹ˆå«çœŸå®çš„å­˜åœ¨ï¼Ÿä»€ä¹ˆæ˜¯å­˜åœ¨ï¼Ÿ è¿™äº›æ¦‚å¿µå­˜åœ¨äºæˆ‘ä»¬çš„â€œè„‘æµ·â€ä¸­ï¼Ÿæˆ‘ä»¬è§‚å¯Ÿåˆ°çš„â€œåœ†å½¢â€çš„ä¸œè¥¿ï¼Œå¦‚ä¸€å…ƒç¡¬å¸ï¼Œå¤ªé˜³ï¼Œåœ†å½¢äº•ç›–ï¼Œå’Œæ¦‚å¿µä¸­çš„â€œåœ†å½¢â€æ˜¯ä»€ä¹ˆå…³ç³»ï¼Ÿ æ•°å­¦çš„çœŸç†æ€§é—®é¢˜ 19ä¸–çºª20å¹´ä»£å‰ï¼Œæ•°å­¦çœŸç†æ™®éåœ°è¢«è®¤ä¸ºæ˜¯ä¸€ç§ç»å¯¹çœŸç† ç”±äºéæ¬§å‡ ä½•çš„å»ºç«‹ï¼Œå…³äºæ•°å­¦ç»å¯¹çœŸç†æ€§çš„ä¼ ç»Ÿè§‚å¿µå´©æºƒäº† æ—¢ç„¶ä¸¤ç§äº’ä¸ç›¸å®¹çš„å‡ ä½•ç†è®ºéƒ½åº”è¢«çœ‹æˆåˆç†çš„æ•°å­¦ç†è®ºï¼Œé‚£æ•°å­¦å‘½é¢˜å½“ç„¶å°±ä¸å…·æœ‰ç»å¯¹çœŸç†æ€§ï¼Ÿï¼Ÿ "},"ReadingNotes/philosiphy.html":{"url":"ReadingNotes/philosiphy.html","title":"philosiphy","keywords":"","body":"æœ¯ä¸é“ è€å­æ›°ï¼šæœ‰é“æ— æœ¯ï¼Œæœ¯å°šå¯æ±‚ä¹Ÿã€‚æœ‰æœ¯æ— é“ï¼Œæ­¢äºæœ¯ã€‚ åº„å­æ›°ï¼šä»¥é“é©­æœ¯ï¼Œæœ¯å¿…æˆã€‚ç¦»é“ä¹‹æœ¯ï¼Œæœ¯å¿…è¡°ã€‚ å­™å­æ›°ï¼šé“ä¸ºæœ¯ä¹‹çµï¼Œæœ¯ä¸ºé“ä¹‹ä½“ã€‚ä»¥é“ç»Ÿæœ¯ï¼Œä»¥æœ¯å¾—é“ã€‚ å¤äººæ›°ï¼šä¸Šäººç”¨é“ï¼Œä¸­äººç”¨æœ¯ï¼Œä¸‹äººç”¨åŠ›ã€‚ éŸ©æ„ˆæ›°ï¼šé—»é“æœ‰å…ˆåï¼Œæœ¯ä¸šæœ‰ä¸“æ”»ã€‚ "},"ReadingNotes/ç ”ç©¶ä¸å­¦é£-å¼ ç”³åºœ-1948.html":{"url":"ReadingNotes/ç ”ç©¶ä¸å­¦é£-å¼ ç”³åºœ-1948.html","title":"ç ”ç©¶ä¸å­¦é£-å¼ ç”³åºœ-1948","keywords":"","body":"ç ”ç©¶ä¸å­¦é£-å¼ ç”³åºœ åœ¨å­¦é—®ä¸Šï¼Œä»Šæ—¥ä¸€å®šè¦åŠ å¼ºç ”ç©¶ï¼Œå¿…éæ·±é€ è‡ªå¾—ä¸å¯ï¼Œå¿…é¡»å…»æˆå¤§å™¨ï¼Œå†ä¸å¯æµ…å°è¾„æ­¢ï¼Œçš®æ¯›è‚¤æµ…ã€‚ æœ‰äººè¯´ï¼Œæˆ‘ä¸è¦åšå­¦è€…ä¸“å®¶ï¼Œæˆ‘ä¸ºä½•è¦ç ”ç©¶ï¼Ÿä½†ä½ åªè¦æ˜¯ä¸€ä¸ªäººï¼Œä¸ºç¤¾ä¼šåšä¸€ç‚¹äº‹ï¼Œä½ æ€»è¦æœ‰ä¸€äº›ä¸œè¥¿ï¼Œæ€»è¦æœ‰ä¸€ä¸ªä¸“é•¿ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨å­¦æ ¡é‡Œçš„æ—¶å€™å°±è¦æ·±åšï¼›è”å¸¦ç€æ¥çš„å°±è¦è„šè¸å®åœ°ï¼Œå®æ˜¯æ±‚æ˜¯ï¼Œå°±è¦è®¤çœŸï¼Œå°±è¦å®å®åœ¨åœ¨ï¼›å†ä¸€ç‚¹å°±è¦ç²¾æ ¸ï¼Œè¦ä¸€ä¸ä¸è‹Ÿï¼Œç»ä¸ç­‰äºæ¼ å¿½ç¬¼ç»Ÿã€‚ ç°åœ¨æ‰€è°“ç ”ç©¶åœ¨è‹±æ–‡å°±æ˜¯Researchï¼Œæ³•æ–‡ï¼Œæ„å¤§åˆ©æ–‡ï¼Œè¥¿ç­ç‰™æ–‡ï¼Œä»¥è‡³ä¿„æ–‡éƒ½ä¹Ÿå·®ä¸å¤šã€‚è¿™ä¹Ÿå¯ç¿»è¯‘æˆè€ƒç´¢ï¼Œæ™®é€šéƒ½ä»¥ä¸ºç ”ç©¶å¾ˆé«˜æ·±å¾ˆéš¾ï¼Œå…¶å®ï¼Œä¹Ÿå¾ˆå¹³å¸¸ï¼Œè‚¯ä½œå°±ä¸éš¾ã€‚å…ˆçœ‹å­—é¢ï¼šä»Researchï¼Œè¿™ä¸ªå­—çœ‹ï¼Œä¸è¿‡æ˜¯æ‰¾äº†åˆæ‰¾ã€‚ä½ è‚¯å»æ‰¾ï¼Œæ‰¾äº†åˆæ‰¾ï¼Œè¿™æ˜¯ä¸éš¾çš„ï¼Œåªè¦ä½ è‚¯å»æ‰¾å°±è¡Œã€‚å„ç§å­¦é—®å…¨æ˜¯æ‰¾æ¥çš„ï¼Œå„ç§çœŸç†å…¨æ˜¯æ‰¾æ¥çš„ã€‚ç ”ç©¶å¤ä¹¦ï¼Œç ”ç©¶æ–°å­¦ï¼Œå…¨è¦è‚¯æ‰¾ï¼Œè‚¯æ‰¾æ‰èƒ½å¾—ã€‚æ‰€è°“ â€œæ±‚åˆ™å¾—ä¹‹â€ è¿™ä¸æ˜¯ç©ºè¯ã€‚è¾Ÿå¦‚æœ‰ä¸€ç®—å­¦éš¾é¢˜ï¼Œåˆ«äººè§£ç­”ä¸å‡ºï¼Œæˆ‘è‚¯å»æ‰¾ï¼Œå°±æœ‰æ‰¾å‡ºæ¥çš„å¸Œæœ›ã€‚åä¹ä¸–çºªåˆï¼Œæ³•å›½æœ‰ä¸€é’å¹´åå«è‘›å½•äºšï¼ˆGaloisï¼‰ï¼Œæœªæˆå¹´å°±æ­»äº†ã€‚ä»–å¯¹ç®—å­¦æœ‰å…´è¶£ï¼Œè‚¯å»æ‰¾ï¼ŒäºŒä¸‰å¹´é—´ä¾¿æˆä¸ºä¸–ç•Œä¸Šç¬¬ä¸€æµçš„ç®—å­¦å®¶äº†ã€‚ç°åœ¨ä¸–ç•Œæœ€ä¼Ÿå¤§çš„å­¦è€…æ˜¯çˆ±å› æ–¯å¦ï¼Œä½œæˆç›¸å¯¹è®ºï¼Œä»–çš„æˆåŠŸï¼Œä¹Ÿæ˜¯æ‰¾æ¥çš„ã€‚æ‰¾çš„å¦ä¸€ä¸ªåå­—å¯å«è°ƒæŸ¥ã€‚æˆ‘å›½çš„è€ƒå¤å­¦å®¶å»æ‰¾ï¼Œä¸æ˜¯æ‰¾å‡ºåŒ—äº¬äººæ¥å—ï¼Ÿç ”ç©¶ä¸è¿‡å¦‚æ­¤ï¼Œè¿™å¹¶ä¸éš¾ï¼Œä¸è¦æ€•ï¼Œä»»ä½•äººéƒ½èƒ½åšã€‚å†æ¢ä¸ªè¯´æ³•ï¼Œä¸­å›½äººæ™®é€šä¸è¯´ç ”ç©¶ï¼Œä»–è¯´æˆ‘æ‰æ‘¸æ‰æ‘¸ï¼Œå› æ­¤ï¼Œç ”ç©¶ä¹Ÿå°±å¯ä»¥è¯´æ˜¯æ‰æ‘¸ã€‚æ‰æ‘¸æ˜¯è¦åŠ¨æ‰‹åŠ¨è„šçš„ï¼Œæ‰€ä»¥ç ”ç©¶ä¸ä½†è¦ç”¨è„‘ï¼Œè¦ä¹Ÿç”¨æ‰‹ï¼Œç”¨è„šã€‚ä¸­å›½å­—åŒéŸ³çš„å¸¸åŒä¹‰ï¼Œè€Œä¸”ä¸€ä¸ªå­—å¸¸æœ‰åé¢çš„æ„æ€ã€‚æœ‰ä¸¤ä¸ªå’Œæ‰æ‘¸éŸ³ç›¸è¿‘ä¹‰ç›¸ä¼¼çš„ï¼Œå°±æ˜¯ç¢ç£¨ï¼Œè¿™å°±æ˜¯è¯´ç ”ç©¶è¦ä¸€ç‚¹ä¸€ç‚¹æ¥ã€‚å¦‚ç ”ç©¶æ”¿æ²»ï¼Œç ”ç©¶ç»æµï¼Œä½ éƒ½è¦ä¸€ç‚¹ä¸€ç‚¹å»æ‰æ‘¸æˆ–ç¢ç£¨ï¼Œæ¢å¥è¯è¯´ï¼Œå°±æ˜¯è¦é’»ã€‚å‰è¾¹è¯´ä¸“å®¶ï¼Œä¸“å®¶å°±æ˜¯è‚¯é’»ã€‚è‚¯å»é’»ï¼Œè‚¯å»æ‰æ‘¸ï¼Œè‚¯å»ç¢ç£¨ï¼Œè¿™å°±æ˜¯ç ”ç©¶ã€‚åˆšæ‰æˆ‘è¯´ä¸­å›½å­—å¸¸æœ‰åŒéŸ³åŒä¹‰ï¼Œè€Œä¸”ä¸€ä¸ªå­—å¸¸æœ‰ç›¸åçš„æ„æ€ï¼Œé’»å’Œä¸“ä¹Ÿå°±å¦‚æ­¤ã€‚å¦å¦‚å¿å­—ã€‚å¿æ˜¯å¿è€ï¼Œè¿™ä¸åã€‚ä½†ç”±å¿è€å˜æˆæ®‹å¿è¿™å°±åäº†ã€‚å¿äºå·±æ˜¯å¿è€ï¼Œå¿äºäººå°±å˜æˆæ®‹å¿äº†ã€‚åˆå¦‚åˆ›å’Œæ’ä¹Ÿå¦‚æ­¤ï¼Œè¿™å‘Šè¯‰äººè¦åˆ›é€ éæ’ä¸å¯ã€‚è¿™éƒ½æ˜¯ä»å­—é¢ä¸Šå¾—åˆ°çš„æ„æ€ã€‚å…³äºè¿™äº›ï¼Œä¸å†è¯´äº†ã€‚æˆ‘ä¸»è¦çš„æ„æ€å°±æ˜¯è¯´ç ”ç©¶ä¸éš¾ï¼Œåªè¦è‚¯æ‰¾äº†åˆæ‰¾ï¼Œåªè¦ä¸€æ­¥ä¸€æ­¥ä½œå»ï¼Œå°±èƒ½æˆåŠŸã€‚ä½†ç ”ç©¶ä¸æ˜¯studyï¼Œé‚£æ˜¯ä»ä¹¦æœ¬ä¸Šæ±‚çŸ¥è¯†ï¼›è€Œæ˜¯Researchï¼Œå°±æ˜¯è¦å‘ç°çœŸç†ï¼ é™„å¸¦è¦è®²è®²ç ”ç©¶å®¤çš„ä»»åŠ¡ã€‚æ‰€è°“ç ”ç©¶å®¤è‹±æ–‡ä½œ Seminaryï¼Œå®ƒçš„å­—æºä¸ç§å­ï¼Œç²¾åŒä¹‰ï¼Œæ‰€ä»¥å®ƒçš„æœ¬ä¹‰å°±æ˜¯åˆ©äºäº§ç”Ÿæ–°å“ç§ï¼Œæ–°æ€§è´¨çš„åœ°æ–¹ï¼Œä¹Ÿå°±æ˜¯å¯ä»¥äº§ç”Ÿæ–°ä¸œè¥¿çš„åœ°æ–¹ã€‚æˆ‘ä»¬çš„ç ”ç©¶å®¤å°±è¦æœ¬ç€è¿™ä¸ªæ„æ—¨å»åšã€‚æœ‰æ–°å­¦é—®å°±æœ‰æ–°è¡ŒåŠ¨ï¼Œæœ‰æ–°è¡ŒåŠ¨å°±èƒ½åˆ›é€ æ–°äº‹ç‰©ã€‚ç ”ç©¶æ–°é“ç†ä¸ä»…æ˜¯çŸ¥çš„ï¼Œè€Œä¸”æ˜¯è¡Œçš„ï¼Œæ˜¯ç”¨çš„ã€‚è‡ªç„¶ç§‘å­¦æœ‰ç¤¾ä¼šåŠŸç”¨ï¼Œç¤¾ä¼šç§‘å­¦ï¼Œç»æµå­¦ï¼Œæ”¿æ²»å­¦â€¦â€¦æ›´æœ‰ç¤¾ä¼šåŠŸç”¨ï¼Œæˆ‘ä»¬åº”æœ¬æ­¤ç²¾ç¥ä½¿æ•´ä¸ªå­¦æœ¯ï¼Œæ•´ä¸ªå­¦æœ¯ç•Œéƒ½æœåŠ¡äºäººæ°‘ï¼Œéƒ½æœåŠ¡äººç±»ï¼ æˆ‘åäºŒå¹´ä¸æ•™ä¹¦ï¼Œä¸€ä¸ªåŸå› ä¹Ÿè®¸æ˜¯å› ä¸ºæœ‰äººè®¤æˆ‘ä¸€æ•™ä¹¦å°±ä¼šè°ˆåˆ°æ”¿æ²»ã€‚å…¶å®ï¼Œè¿™æ˜¯ä¸€ç§è¯¯ä¼šï¼Œåœ¨å­¦æˆ‘è‡ªè¦è¨€å­¦ã€‚è¿‘å¹´æˆ‘æ·±æ·±æ„Ÿè§‰ä¸­å›½éœ€è¦ä¸€ç§æ–°å­¦é£ã€‚å°¤å…¶æ˜¯å¤§å­¦æˆ–å­¦é™¢æ›´è¦æ³¨æ„ç ”ç©¶ã€‚æˆ‘æ‰€è°“æ–°çš„å­¦é£å°±æ˜¯æ·±åšï¼Œç¬ƒå®ï¼Œç²¾æ ¸çš„å­¦é£ï¼Œè¿™ä¸ç ”ç©¶æœ‰å¯†åˆ‡å…³ç³»ã€‚ ä¸­å›½ä»å…«åå¹´å‰èµ·åŠæ–°æ•™è‚²ï¼Œå…¶ä¸­æœ‰æŠ„è‹±å›½çš„ï¼Œæœ‰æŠ„æ—¥æœ¬çš„ï¼Œä»¥è‡³å¾·å›½çš„ï¼Œç¾å›½çš„ï¼Œä½†æŠ„çš„å…¨æ˜¯çš®æ¯›ã€‚ä»Šæ—¥é™¤éä¸åŠæ•™è‚²ï¼Œè¦åŠæ•™è‚²å°±åº”æ ¹æ®è‡ªå·±çš„å®å†µï¼Œè‡ªå·±çš„éœ€è¦ï¼Œç‹¬ç«‹åœ°æ¥åŠã€‚åœ¨å­¦é—®ä¸Šï¼Œä»Šæ—¥ä¸€å®šè¦åŠ å¼ºç ”ç©¶ï¼Œå¿…éæ·±é€ è‡ªå¾—ä¸å¯ï¼Œå¿…é¡»å…»æˆå¤§å™¨ï¼Œå†ä¸å¯æµ…å°è¾„æ­¢ï¼Œçš®æ¯›è‚¤æµ…ã€‚ æœ‰äººè¯´ï¼Œæˆ‘ä¸è¦åšå­¦è€…ä¸“å®¶ï¼Œæˆ‘ä¸ºä½•è¦ç ”ç©¶ï¼Ÿä½†ä½ åªè¦æ˜¯ä¸€ä¸ªäººï¼Œä¸ºç¤¾ä¼šåšä¸€ç‚¹äº‹ï¼Œä½ æ€»è¦æœ‰ä¸€äº›ä¸œè¥¿ï¼Œæ€»è¦æœ‰ä¸€ä¸ªä¸“é•¿ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬åœ¨å­¦æ ¡é‡Œçš„æ—¶å€™å°±è¦æ·±åšï¼›è”å¸¦ç€æ¥çš„å°±è¦è„šè¸å®åœ°ï¼Œå®æ˜¯æ±‚æ˜¯ï¼Œå°±è¦è®¤çœŸï¼Œå°±è¦å®å®åœ¨åœ¨ï¼›å†ä¸€ç‚¹å°±è¦ç²¾æ ¸ï¼Œè¦ä¸€ä¸ä¸è‹Ÿï¼Œç»ä¸ç­‰äºæ¼ å¿½ç¬¼ç»Ÿã€‚ æˆ‘è®¤ä¸ºå­¦æ ¡åº”è¯¥å¦‚æ­¤ï¼Œåº”è¯¥é€ æˆè¿™æ ·çš„å­¦é£ï¼Œåº”è¯¥åŸ¹æ¤è¿™æ ·çš„å­¦ç”Ÿï¼Œè¿™å°±éœ€è¦å¤§å®¶å…±åŒåŠªåŠ›ã€‚ ï¼ˆåŸè½½1948å¹´4æœˆ20æ—¥ã€Šå¤©ç´ã€‹åˆ›åˆŠå·ã€‚é€‰è‡ªæ²³åŒ—äººæ°‘å‡ºç‰ˆç¤¾2005å¹´ç‰ˆã€Šå¼ ç”³åºœæ–‡é›†ã€‹ç¬¬äºŒå·ï¼Œæœ‰åˆ èŠ‚ã€‚ï¼‰ "},"ReadingNotes/è®¡ç®—ä¹‹é­‚-å´å†›/cp0.html":{"url":"ReadingNotes/è®¡ç®—ä¹‹é­‚-å´å†›/cp0.html","title":"cp0","keywords":"","body":"ã€Šè®¡ç®—ä¹‹é­‚ã€‹å´å†› äººæ°‘é‚®ç”µå‡ºç‰ˆç¤¾ è®¡ç®—çš„æœ¬è´¨â€”â€”ä»æœºæ¢°åˆ°ç”µå­ ç­–åˆ’äººé«˜åšä»‹ç»ï¼š æ·±åº¦+å¹¿åº¦ ç›®æ ‡ï¼š ç†è§£è®¡ç®—ç§‘å­¦çš„ç²¾é«“å’Œçµé­‚ åšå®šé•¿æœŸæŠ•å…¥å’Œå‘å±•çš„ä¿¡å¿ƒ â€”â€”èŒä¸šæ½œåŠ›ï¼ŒèŒä¸šé“è·¯ï¼Œå‘å±•å‰æ™¯å¹¿é˜”è¦æ½œä¸‹å¿ƒæ¥ï¼Œæ‰æ‰å®å®æŠ•å…¥ å…¨ä¹¦ç»“æ„ï¼šCP1: ç®—æ³•çº§è¡¡é‡ç®—æ³•ä¼˜åŠ£CP2: CP3: æŠ½è±¡ä¸è¡¨ç¤º è®¡ç®—æœºå­˜å‚¨ä¸å¤„ç†æ•°æ®çš„åŸç†CP4: åˆ†ç±»ä¸ç»„åˆCP5: å›¾è®ºåŠåº”ç”¨CP6: åˆ†æ²» ç»“åˆ4CP7: å­˜å‚¨ æ—¶ç©ºçš„æƒè¡¡CP8: å¹¶è¡Œä¸ä¸²è¡Œ CP9: çŠ¶æ€ä¸æµç¨‹ CP10: æ¦‚ç‡ç®—æ³•åŠåº”ç”¨ å¦‚ä½•å¯¹å¾…ä¹ é¢˜ä¸æ€è€ƒé¢˜ï¼š è¾…åŠ©ç†è§£ä¹¦ä¸­å†…å®¹ï¼Œåœ¨å¯¹ä¹ é¢˜çš„æ€è€ƒä¸è§£ç­”ä¸­è¿›ä¸€æ­¥æ·±åŒ–å¯¹ä¹¦ä¸­å†…å®¹çš„ç†è§£ é—®é¢˜ï¼š é¢å¯¹ä¼—å¤šçš„è®¡ç®—æœºç§‘å­¦ç ”ç©¶æ–¹å‘ï¼Œå¯¹é€‰æ‹©ä»€ä¹ˆæ„Ÿåˆ°å›°æƒ‘ï¼Ÿæ¯”å¦‚è¯´ç°åœ¨ç«çš„äººå·¥æ™ºèƒ½ï¼Œæ·±åº¦å­¦ä¹ ......å‘å±•æ½œåŠ›å¾ˆå¤§çš„è®¡ç®—æœºä½“ç³»ç»“æ„æ€æ ·åˆ†è¾¨ï¼Œæ€æ ·é€‰æ‹© å·¥ç¨‹å¸ˆçš„åˆ†çº§ï¼šæ¯ä¸€çº§çš„è´¡çŒ®å·®åå€ä»¥ä¸Š å…­çº§ï¼š~ç å†œäº”çº§ï¼šèƒ½ç‹¬ç«‹è§£å†³é—®é¢˜ï¼Œå®Œæˆå·¥ç¨‹å·¥ä½œã€‚ ç†Ÿç»ƒæŒæ¡ç¼–ç¨‹è¯­è¨€ï¼Œå¿…å¤‡çš„åŸºæœ¬æŠ€èƒ½å››çº§ï¼š ä»€ä¹ˆæ˜¯è®¡ç®—æœº è®¡ç®— è®¡ç®—æœº1+1=2 æ•°ï¼ˆæ¦‚å¿µorâ€œçŠ¶æ€â€çš„æŠ½è±¡orç¼–ç ï¼‰ è¿ç®—ç¬¦ï¼ˆè§„åˆ™ï¼Œè§„åˆ™ä¸æ•°çš„æ¦‚å¿µæ— å…³ï¼Œä½†è§„åˆ™çš„ç»„åˆå´èƒ½å®ç°â€œè®¡ç®—â€ï¼‰ è®¡ç®—æœºï¼ˆæ‰§è¡Œè®¡ç®—çš„æœºå™¨-æœºæ¢°è¿åŠ¨ï¼‰è½¯ä»¶ä¸ç¡¬ä»¶çš„åˆ†é‡ â€”â€” æ•°ä¸æ•°çš„ç‰©ç†è¡¨ç¤º ç®—ç›˜ï¼šä¸ºä»€ä¹ˆå¤ä»£ä¸­å›½çš„ç®—ç›˜æ˜¯æœ€æ—©çš„ â€œè®¡ç®—æœºâ€ï¼Ÿç®—ç›˜åŠç®—ç›˜çš„ä½¿ç”¨åŒ…å«äº†è®¡ç®—æœºä¸è®¡ç®—çš„å†…æ ¸ï¼šç®—ç›˜ç å­ï¼šæ•°çš„è¡¨ç¤ºä¸‰ä¸‹äº”é™¤äºŒï¼šè®¡ç®—çš„è§„åˆ™äººæ‹¨åŠ¨ç®—ç ï¼šè®¡ç®—æœºçš„æœºæ¢°è¿åŠ¨å¯¹è°åšè¿ç®—å’Œå®ç°ä»€ä¹ˆæ ·çš„è¿ç®—ï¼šç¨‹åº æ•°çš„è¡¨ç¤ºä¸è¿›åˆ¶çš„é€‰æ‹©ï¼šä¸ºä»€ä¹ˆé€‰æ‹©äºŒè¿›åˆ¶æ¥è¡¨ç¤ºæ•°ï¼Ÿå·´æ¯”å¥‡ï¼š æƒ³ç”¨å¤æ‚çš„ç‰©ç†è®¡ç®—è£…ç½®ï¼Œå®ç°å¤æ‚çš„è®¡ç®—ã€‚æ€è·¯çš„æ”¹å˜ï¼šåœ¨å¸ƒå°”ä»£æ•°ä¸é¦™å†œçš„å¸ƒå°”ä»£æ•°å®ç°è¿ç®—è¿›è€Œå®ç°é€»è¾‘æ§åˆ¶ç®€å•çš„åŸºæœ¬è®¡ç®—è£…ç½®ï¼ŒæŒ‰ç…§ç®€å•çš„è§„åˆ™ï¼Œè¿›è¡Œäº†å¤æ‚çš„ç»„åˆï¼Œå®ç°äº†å¤æ‚çš„è®¡ç®— å›¾çµä¸å›¾çµæœºï¼šä»€ä¹ˆæ˜¯è®¡ç®—ï¼Ÿè®¡ç®—çš„è·¨è¶Š çº¸å¸¦ï¼šçŠ¶æ€ä¸â€œç¨‹åºâ€è¯»å†™å¤´ï¼šè¯»å–ä¸è¾“å‡ºè¯»å†™å¤´éµå¾ªçš„è§„åˆ™ï¼šè®¡ç®—çš„è§„åˆ™ èƒ½å¤Ÿå®ç°ä¸€åˆ‡æˆ‘ä»¬æ‰€å®šä¹‰çš„â€œè®¡ç®—â€ â€”â€” é€šç”¨è®¡ç®— å†¯è¯ºä¾æ›¼ç»“æ„ æ•°æ®å’ŒæŒ‡ä»¤çš„ç»Ÿä¸€è¡¨ç¤ºï¼Œä¸åŒè§£é‡Šæ•°æ®å’ŒæŒ‡ä»¤çš„ç­‰ä»·è®¤è¯†ï¼Œè®¤è¯†çš„çªç ´ æè‡´çš„ç®€å•æ‰èƒ½æ„ç­‘å¤§è§„æ¨¡çš„å¤æ‚ ä»ç®—ç›˜åˆ°èŠ¯ç‰‡ï¼šææ–™å­¦ï¼Œå·¥ç¨‹ä¸Šçš„æ”¹è¿› è®¡ç®—çš„è¾¹ç•Œï¼š å¯è®¡ç®—å°±æ˜¯å›¾çµæœºèƒ½è¿›è¡Œçš„è®¡ç®—ç°ä»£è®¡ç®—æœºï¼šéæ— é™å­˜å‚¨çº¸å¸¦ï¼Œå›¾çµæœºçš„ç‰©ç†è¿‘ä¼¼ã€Šå“¥å¾·å°”ã€è‰¾èˆå°”ã€å·´èµ«ï¼šé›†å¼‚ç’§ä¹‹å¤§æˆã€‹ è¾¹ç•Œï¼šæ•°å­¦çš„è¾¹ç•Œï¼šè®¡ç®—çš„è¾¹ç•Œï¼šå·¥ç¨‹çš„è¾¹ç•Œï¼šï¼ˆå¯æ¥å—çš„æ—¶ç©ºæˆæœ¬ï¼‰ æ—¥å¸¸é—®é¢˜æ±‚è§£çš„ä¸€èˆ¬æ€è·¯ é—®é¢˜å»ºæ¨¡ "},"ReadingNotes/è®¡ç®—ä¹‹é­‚-å´å†›/cp1.html":{"url":"ReadingNotes/è®¡ç®—ä¹‹é­‚-å´å†›/cp1.html","title":"cp1","keywords":"","body":"ç¬¬ä¸€ç«  æ¯«å˜åƒé‡Œä¹‹å·®â€”â€”â€”å¤§Oæ¦‚å¿µ 1.1 ç®—æ³•çš„è§„èŒƒåŒ–å’Œé‡åŒ–åº¦é‡ è®¡ç®—æœºç®—æ³•åŸºç¡€åˆ†æé¼»ç¥–ï¼šé«˜å¾·çº³ ç¼–ç¨‹çš„è‡ªæˆ‘è¦æ±‚ï¼š åŠ›äº‰ä¸€æ¬¡å…¨å¯¹ï¼Œæ²¡æœ‰é”™è¯¯ï¼Œç®—æ³•åœ¨è®¾è®¡æ—¶å°±è¾¾åˆ°æœ€ä½³ã€‚é‡åˆ°é—®é¢˜æ—¶è§£å†³é—®é¢˜çš„ç§¯ææ€åº¦ã€‚ æ€è€ƒé¢˜1.1ï¼š ä»€ä¹ˆäº§å“å’Œè®¡ç®—æœºç±»ä¼¼ï¼Œæ˜¯è½¯ç¡¬ä»¶åˆ†ç¦»çš„ï¼Ÿ è§£ç­”ï¼šä¹å™¨ï¼Œæ±½è½¦... 1.2 å¤§æ•°å’Œæ•°é‡çº§çš„æ¦‚å¿µ æˆ‘ä»¬å¯¹å¤§æ•°æ²¡æœ‰æ¦‚å¿µâ€”â€”>å¯¹è®¡ç®—æœºèµ„æºæ²¡æœ‰æ¦‚å¿µï¼š åœ¨è‡ªå·±ä½¿ç”¨è®¡ç®—æœºæ—¶ï¼Œç»å¤§éƒ¨åˆ†æ—¶å€™ï¼Œéƒ½æ„Ÿè§‰é€Ÿåº¦è¶…çº§å¿«ï¼Œå†…å­˜ç”¨ä¸å®Œï¼Œæ ¹æœ¬ä¸ä¼šåœ¨æ„è®¡ç®—èµ„æºçš„è€—è´¹ã€‚ è¦é€æ­¥çš„åŸ¹å…»èµ·å¯¹è¿ç®—é‡ã€è¿ç®—é€Ÿåº¦ã€è¿ç®—ç©ºé—´çš„â€œæ„Ÿè§‰â€æ¥ã€‚è¿™è¦æ±‚å¯¹ç®—æ³•åšç©ºé—´å’Œæ—¶é—´çš„å¤æ‚åº¦åˆ†æï¼Œæ ¹æ®é™åˆ¶æ¡ä»¶ï¼Œè®¡ç®—é‡è¿›è¡Œé¢„ä¼°ã€‚ é«˜å¾·çº³ç®—æ³•åˆ†ææ€æƒ³ï¼š1.åªè€ƒè™‘æ•°æ®é‡å¤§åˆ°æ¥è¿‘æ— ç©·çš„æƒ…å†µã€‚2.å°†å†³å®šç®—æ³•å¿«æ…¢çš„å› ç´ åˆ’åˆ†ä¸º ä¸éšæ•°æ®é‡å˜åŒ–çš„å› ç´  ä¸ éšæ•°æ®é‡å˜åŒ–çš„å› ç´ ã€‚ æ€è€ƒé¢˜1.2ï¼š å¦‚æœä¸€ä¸ªç¨‹åºåªè¿è¡Œä¸€æ¬¡ï¼Œåœ¨ç¼–å†™å®ƒçš„æ—¶å€™ï¼Œä½ æ˜¯é‡‡ç”¨æœ€ç›´è§‚ä½†æ˜¯æ•ˆç‡è¾ƒä½çš„ç®—æ³•ï¼Œè¿˜æ˜¯ä¾ç„¶å¯»æ‰¾å¤æ‚åº¦æœ€ä¼˜çš„ç®—æ³•ï¼Ÿ å¯»æ‰¾æœ€ä¼˜çš„ç®—æ³•ï¼Œå› ä¸ºæ­¤ç®—æ³•å¯èƒ½åœ¨å…¶ä»–åœ°æ–¹å¤ç”¨ã€‚ 1.3 æ€æ ·å¯»æ‰¾æœ€å¥½çš„ç®—æ³• ä¾‹é¢˜1.3 æ€»å’Œæœ€å¤§åŒºé—´é—®é¢˜ ç»™å®šä¸€ä¸ªå®æ•°åºåˆ—ï¼Œè®¾è®¡ä¸€ä¸ªæœ€æœ‰æ•ˆçš„ç®—æ³•ï¼Œæ‰¾åˆ°ä¸€ä¸ªæ€»å’Œæœ€å¤§çš„åŒºé—´ è¾“å…¥æ ¼å¼ï¼š ç¬¬ä¸€è¡Œï¼šä¸€ä¸ªæ­£æ•´æ•°Nï¼Œè¡¨ç¤ºåºåˆ—é•¿åº¦ç¬¬äºŒè¡Œï¼šNä¸ªå®æ•°ï¼Œä»¥ç©ºæ ¼ä¸ºåˆ†éš” 1. ä¸‰é‡å¾ªç¯ O(N^3) ç¡®å®šä¸€ä¸ªå­åŒºé—´éœ€è¦èµ·ç‚¹på’Œç»ˆç‚¹qï¼Œå†ç”±påˆ°qéå†æ±‚å’Œï¼Œå…±ä¸‰é‡å¾ªç¯ã€‚ #include using namespace std; vector arr; int N; double tmp; int p, q, mp, mq; //è®°å½•å·¦å³ä¸‹æ ‡ double maxSum, sum; //è®°å½•å½“å‰æœ€å¤§å­åºå’Œä¸å­åºå’Œ int main(){ cin>>N; for(int i=0; i>tmp; arr.push_back(tmp); } for(p=0; pmaxSum){ maxSum=sum; mp=p; mq=q; } } } } printf(\"maxSum:%.2f\\nmp:%d\\nmq:%d\\n\", maxSum, mp, mq); for(int i=mp; i 2. ä¸¤é‡å¾ªç¯ O(N^2) å­åºåˆ—å’Œæ²¡å¿…è¦æ¯æ¬¡ä»å¤´å¼€å§‹éå†ç´¯åŠ ï¼Œåªéœ€è¦åœ¨å‰ä¸€ä¸ªå­åºåˆ—å’Œä¹‹ä¸ŠåŠ å‡å³å¯ã€‚ åœ¨ä¸‰é‡å¾ªç¯çš„ä»£ç ä¸Šç¨ä½œä¿®æ”¹ #include using namespace std; vector arr; int N; double tmp; int p, q, mp, mq; double maxSum, sum; int main(){ cin>>N; for(int i=0; i>tmp; arr.push_back(tmp); } maxSum=arr[0]; for(p=0; pmaxSum){ maxSum=sum; mp=p; mq=q; } } } printf(\"maxSum:%.2f\\nmp:%d\\nmq:%d\\n\", maxSum, mp, mq); for(int i=mp; i 3. åˆ†æ²»æ³• O(NlogN) åºåˆ—Sçš„æœ€å¤§å’Œå­åºåˆ—åˆ†å¦‚ä¸‹ä¸‰ç§æƒ…å†µï¼š å®Œå…¨ä½äºå·¦åŠåŒºé—´ [p1, q1] å®Œå…¨ä½äºå³åŠåŒºé—´ [p2, q2] æ¨ªè·¨ä¸­é—´ [p1, q2] 1å’Œ2å¯é€’å½’è°ƒç”¨ï¼Œ3ç»ç®€å•åˆ†æå¯çŸ¥ï¼Œå…¶åŒºé—´ä¸º [p1, q2] ç¬¬ä¸‰ç§æƒ…å†µæœ‰é—®é¢˜ï¼Œä¹¦ä¸Šç§°ï¼š 2ï¼å‰åä¸¤ä¸ªå­åºåˆ—çš„æ€»å’Œæœ€å¤§åŒºé—´ä¸­é—´æœ‰é—´éš”ï¼Œæˆ‘ä»¬å‡å®šè¿™ä¸¤ä¸ªå­åºåˆ—çš„æ€»å’Œæœ€å¤§åŒºé—´åˆ†åˆ«æ˜¯[p1,q1]å’Œ[p2,q2]ã€‚è¿™æ—¶ï¼Œæ•´ä¸ªåºåˆ—çš„æ€»å’Œæœ€å¤§åŒºé—´æ˜¯ä¸‹é¢ä¸‰è€…ä¸­æœ€å¤§çš„é‚£ä¸€ä¸ªï¼šï¼ˆ1ï¼‰[p1,q1]ï¼ˆ2ï¼‰[p2,q2]ï¼›ï¼ˆ3ï¼‰[p1,q2]ã€‚è‡³äºä¸ºä»€ä¹ˆï¼Œè¿™æ˜¯æœ¬èŠ‚çš„æ€è€ƒé¢˜ã€‚ Page: 037 ä½†æ˜¯ï¼Œæ¨ªè·¨ä¸­é—´çš„å¯èƒ½çš„æœ€å¤§å­åŒºé—´ï¼Œä¸ä¸€å®šä¸º[p1,q2]ã€‚ä¸¾ä¾‹æ¥è¯´æ˜ï¼š åºåˆ—ï¼š [-2, 1, -3, 4, -1, 2, 1, -5, 4] mid = (0+8)/2 = 4åˆ’åˆ†ä¸º: å·¦åŠå­åºåˆ—ï¼š[-2, 1, -3, 4, -1]å…¶æœ€å¤§å’Œå­åºåˆ—ä¸ºï¼š[4]ï¼Œå¯¹åº”ä¸‹æ ‡åŒºé—´ä¸ºï¼š[3,3]ï¼Œ å³p1=q1=3ï¼Œlmsum = 4 å³åŠå­åºåˆ—ï¼š[2, 1, -5, 4]ï¼Œå…¶æœ€å¤§å’Œå­åºåˆ—ä¸ºï¼š[4]ï¼Œå…¶å¯¹åº”ä¸‹æ ‡åŒºé—´ä¸ºï¼š[8,8]ï¼Œ å³p2=q2=8ï¼Œ rmsum = 4 è¿›è€Œï¼Œ[p1,q2]å¯¹åº”çš„åŒºé—´ä¸º[3,8]ï¼Œå¯¹åº”å­åºåˆ—å’Œä¸º5 ç„¶è€Œï¼Œå¯çŸ¥å®é™…æœ€å¤§å’Œå­åºåˆ—ä¸º[4, -1, 2, 1]ï¼Œå¯¹åº”ä¸‹æ ‡åŒºé—´ä¸º[3, 6]ï¼Œå¯¹åº”å­åºå’Œä¸º6å¹¶ä¸æ˜¯[p1,q2] æŒ‰ä¹¦ä¸­æè¿°çš„ä»£ç ï¼š #include using namespace std; void maxSubSum(vector arr, int p, int q, int &mp, int &mq, double &maxSum); vector arr; int N=0; int mp=0, mq=0; double tmp=0, maxSum=0; int main(){ cin>>N; for(int i=1; i>tmp; arr.push_back(tmp); } maxSubSum(arr, 0, N-1, mp, mq, maxSum); printf(\"maxSum:%.2f\\nmp:%d\\nmq:%d\\n\",maxSum, mp, mq); for(int i=mp; i arr, int p, int q, int &mp, int &mq, double &maxSum){ //è¾¹ç•Œæƒ…å†µ if(p>=q){ mp=mq=p; maxSum=arr[p]; return ; } int mid = p+(q-p)/2; //mid = (p+q)/2; int lmp, lmq, rmp, rmq; double lmsum, rmsum, midsum=0; double tmpsum=0; //é€’å½’æƒ…å†µ maxSubSum(arr, p, mid, lmp, lmq, lmsum); maxSubSum(arr, mid+1, q, rmp, rmq, rmsum); /* midsumé”™è¯¯ï¼ŒåŸæœ¬æƒ³midsumåº”è¯¥èµ·æ­¢äºmpï¼Œ mqï¼Œæƒ³å½“ç„¶ä»¥ä¸ºè¦åŒ…å«lmsumï¼Œrmsumäº†ï¼› åº”è¯¥æŒ‰ç…§ä»ä¸­é—´å‘ä¸¤è¾¹æ‰©å±• */ for(int i=lmp; irmsum && lmsum>midsum){ mp=lmp; mq=lmq; maxSum=lmsum; } else if(rmsum >lmsum && rmsum>midsum){ mp=rmp; mq=rmq; maxSum=rmsum; } else{ mp=lmp; mq=rmq; maxSum=midsum; } return ; } è¾“å…¥ï¼š9-2 1 -3 4 -1 2 1 -5 4 è¾“å‡ºï¼šmaxSum:5.00mp:3mq:84.00 -1.00 2.00 1.00 -5.00 4.00 æœŸæœ›è¾“å‡ºï¼šmaxSum:6.00mp:3mq:64.00 -1.00 2.00 1.00 ä¿®æ­£ï¼š é‡æ–°è€ƒè™‘è·¨è¶Šä¸­é—´(mid)çš„çš„æƒ…å†µï¼šä»midå¼€å§‹ï¼Œå‘åºåˆ—å·¦å³æ‰©å±•ï¼Œä¿ç•™æœ€å¤§å€¼åŠå¯¹åº”ä¸‹æ ‡ å¯¹åº”ä»£ç ä¸ºï¼š #include using namespace std; void maxSubSum(vector arr, int p, int q, int &mp, int &mq, double &maxSum); vector arr; int N=0; int mp=0, mq=0; double tmp=0, maxSum=0; int main(){ cin>>N; for(int i=1; i>tmp; arr.push_back(tmp); } maxSubSum(arr, 0, N-1, mp, mq, maxSum); printf(\"maxSum:%.2f\\nmp:%d\\nmq:%d\\n\",maxSum, mp, mq); for(int i=mp; i arr, int p, int q, int &mp, int &mq, double &maxSum){ //è¾¹ç•Œæƒ…å†µ if(p>=q){ mp=mq=p; maxSum=arr[p]; return ; } int mid = p+(q-p)/2; //mid = (p+q)/2; int lmp, lmq, rmp, rmq; double lmsum, rmsum, midrsum=0, midlsum=0; double tmprsum=0, tmplsum=0; //é€’å½’æƒ…å†µ maxSubSum(arr, p, mid, lmp, lmq, lmsum); maxSubSum(arr, mid+1, q, rmp, rmq, rmsum); /* midsumé”™è¯¯ï¼ŒåŸæœ¬æƒ³midsumåº”è¯¥èµ·æ­¢äºmpï¼Œ mqï¼Œæƒ³å½“ç„¶ä»¥ä¸ºè¦åŒ…å«lmsumï¼Œrmsumäº†ï¼› åº”è¯¥æŒ‰ç…§ä»ä¸­é—´å‘ä¸¤è¾¹æ‰©å±• */ int midp=mid, midq=mid+1; for(int j=mid; j>=p; j--){ tmplsum+=arr[j]; if(tmplsum>midlsum){ midlsum=tmplsum; midp=j; } } for(int i=mid+1; imidrsum){ midrsum=tmprsum; midq=i; } } double midsum=midlsum+midrsum; if(lmsum>rmsum && lmsum>midsum){ mp=lmp; mq=lmq; maxSum=lmsum; } else if(rmsum >lmsum && rmsum>midsum){ mp=rmp; mq=rmq; maxSum=rmsum; } else{ mp=midp; mq=midq; maxSum=midsum; } return ; } 4. æ­£åä¸¤éæ‰«ææ³• O(N) ç±»ä¼¼äºå‰ç¼€å’Œï¼Ÿ #include using namespace std; double maxSubSum(vector arr, int l, int r); vector arr; int N; double tmp; int main(){ cin>>N; for(int i=1; i>tmp; arr.push_back(tmp); } maxSubSum(arr, 0, N-1); return 0; } double maxSubSum(vector arr, int l, int r){ int mp,mq, p, q; mp=mq=p=q=l; int i; double maxsum=0, foresum=0, maxforesum=0; for(p=l; p0){//æ‰¾åˆ°å¤§äº0çš„é¡¹ //printf(\"p: %.2f\\n\",arr[p]); //sum=arr[p]; foresum=0; maxforesum=0; for(i=p; imaxforesum){ maxforesum=foresum; q=i; //printf(\"maxforesum: %.2f\\n\",maxforesum); } if(foresummaxsum){ maxsum=maxforesum; mp=p; mq=q; } break; } } p=i; } } printf(\"maxSum:%.2f\\nmp:%d\\nmq:%d\\n\",maxsum, mp, mq); for(int i=mp; i 5. åŠ¨æ€è§„åˆ’dp O(N) å°†é—®é¢˜åˆ†è§£è€ƒå¯Ÿï¼Œé¦–å…ˆï¼Œæœ€å¤§å­åºå’Œå¯¹åº”çš„åŒºé—´ä¸º[p, q]ï¼Œç›´è§‚ä¸Šæ„Ÿè§‰åˆ°ï¼Œä¸‹æ ‡å¯ä»¥ä½œä¸ºæŸç§â€œçŠ¶æ€â€çš„æ ‡è¯†ã€‚çŠ¶æ€å®šä¹‰ï¼šdp[i]æ—¶ä»¥ä¸‹æ ‡iä¸ºç»“å°¾çš„æœ€å¤§å­åºåˆ—çŠ¶æ€è½¬ç§»å…³ç³»/æ–¹ç¨‹ï¼š å½“dp[i-1] > 0æ—¶ï¼Œdp[i] = dp[i-1]+arr[i]å½“dp[i-1] åˆå§‹åŒ–ï¼šdp[0]=arr[0]; ä»£ç å®ç°å¦‚ä¸‹ï¼š #include using namespace std; template elemType maxSubSum(vector arr, int r, int l); int N; int main(){ cin>>N; vector arr; double tmp; for(int i=0; i>tmp; arr.push_back(tmp); } double maxsum=maxSubSum(arr, 0, N-1); return 0; } template//ä½¿ç”¨æ¨¡æ¿æ¥æä¾›æ›´å¥½çš„å¯ç§»æ¤æ€§ elemType maxSubSum(vector arr, int r, int l){ int size = arr.size(); //ä¸‹æ ‡ä¸ºiå¤„çš„dpï¼Œä»£è¡¨ï¼šä»¥iä¸ºæœ€åä¸€ä¸ªå…ƒç´ çš„æœ€å¤§å­åºåˆ—å’Œ //å½“dp[i-1] > 0æ—¶ï¼Œdp[i] = dp[i-1]+arr[i] //å½“dp[i-1]0){ dp+=arr[i]; } else{ dp=arr[i]; } if(dp>maxdp){ maxdp=dp; } } //printf(\"maxdp: %.\") cout 6. ç®€å•æ‰«æ O(N) é¦–å…ˆæ‰«æåˆ°ä¸€ä¸ªå¤§äºé›¶çš„æ•°ï¼Œä»¥å®ƒä¸ºèµ·ç‚¹ï¼Œå‘åç´¯åŠ å¾—åˆ°thisSumï¼Œæ¯æ¬¡ç´¯åŠ å¾—åˆ°çš„hisSumä¸maxSumæ¯”è¾ƒå¹¶å»ç•™ï¼Œå› ä¸ºmaxSumå¯¹åº”çš„å­åºåˆ—ä¸èƒ½ä»¥è´Ÿæ•°å¼€å¤´ï¼Œæ‰€ä»¥ï¼Œå½“thisSumé‡ç½®ç´¯åŠ èµ·ç‚¹å’ŒthisSumï¼Œé‡å¤ä¸Šé¢çš„æµç¨‹ã€‚ #include using namespace std; double maxSubsequenceSum(vector a, int &start, int &end); int N; double maxsum; int p, q; int main(){ cin>>N; vector arr; double tmp; for(int i=0; i>tmp; arr.push_back(tmp); } double maxsum=maxSubsequenceSum(arr, p, q); printf(\"maxSum:%.2f\\nmp:%d\\nmq:%d\\n\",maxsum, p, q); return 0; } //æšä¸¾åˆ†ææ”¹è¿› /* é¦–å…ˆæ‰«æåˆ°ä¸€ä¸ªå¤§äºé›¶çš„æ•°ï¼Œä»¥å®ƒä¸ºèµ·ç‚¹ï¼Œå‘åç´¯åŠ å¾—åˆ°thisSumï¼Œ æ¯æ¬¡ç´¯åŠ å¾—åˆ°çš„hisSumä¸maxSumæ¯”è¾ƒå¹¶å»ç•™ï¼Œ å› ä¸ºmaxSumå¯¹åº”çš„å­åºåˆ—ä¸èƒ½ä»¥è´Ÿæ•°å¼€å¤´ï¼Œæ‰€ä»¥ï¼Œå½“thisSum a, int &start, int &end){ int maxSum=0, thisSum=0, starttmp=0; start=end=0; int size= a.size(); for(int i=0; imaxSum){ maxSum=thisSum; start=starttmp;//åªæœ‰thisSum>maxSumæ—¶æ‰æ›´æ–°start end=i; } } if(start==size){start=end=0;} return maxSum; } æ€è€ƒé¢˜1.3 Q1ï¼å°†ä¾‹é¢˜1.3çš„çº¿æ€§å¤æ‚åº¦ç®—æ³•å†™æˆä¼ªä»£ç ã€‚ Q2ï¼åœ¨ä¸€ä¸ªæ•°ç»„ä¸­å¯»æ‰¾ä¸€ä¸ªåŒºé—´ï¼Œä½¿å¾—åŒºé—´å†…çš„æ•°å­—ä¹‹å’Œç­‰äºæŸä¸ªäº‹å…ˆç»™å®šçš„æ•°å­—ã€‚ Q3ï¼åœ¨ä¸€ä¸ªäºŒç»´çŸ©é˜µä¸­ï¼Œå¯»æ‰¾ä¸€ä¸ªçŸ©å½¢çš„åŒºåŸŸï¼Œä½¿å…¶ä¸­çš„æ•°å­—ä¹‹å’Œè¾¾åˆ°æœ€å¤§å€¼ã€‚ è§£ç­”ï¼š Q2ï¼šå‚è€ƒâ€œä¸¤æ•°ä¹‹å’Œâ€é—®é¢˜æ±‚è§£çš„æ€è·¯ï¼š procedure twoSum(list, target) map: list[i]->i for e, i in list, listindex: if target - e not in map : map[e] = i; else if target - e in map : print(map[e], map[target-e]) //æ‰¾åˆ°äº† è§£ç­”ï¼š step1: å»ºç«‹å­—å…¸/å“ˆå¸Œè¡¨mapï¼šæ•°ç»„listçš„å‰ç¼€å’Œ -> å‰ç¼€å’Œå¯¹åº”çš„ä¸‹æ ‡qå› ä¸ºï¼Œè‹¥S(p,q)==targetï¼Œ å°±æœ‰S(1, p-1) = S(1, q) - S(p,q) = S(1, q) - target step2: éå†åˆ°qï¼Œå¾—åˆ°S(1,q)ï¼ŒæŸ¥è¯¢mapä¸­æœ‰æ— key=S(1, q) - target å¦‚æœæœ‰ï¼Œåˆ™è¿”å›p=map[key]+1 å…¶ä¸­ï¼Œmapçš„å»ºç«‹å¯ä¸éå†åŒæ—¶è¿›è¡Œ 1.4 å…³äºæ’åºçš„è®¨è®º æ€è€ƒé¢˜1.4 Q1ï¼èµ›è·‘é—®é¢˜ï¼ˆGSï¼‰ã€‚ å‡å®šæœ‰25åçŸ­è·‘é€‰æ‰‹æ¯”èµ›äº‰å¤ºå‰ä¸‰åï¼Œèµ›åœºä¸Šæœ‰äº”æ¡èµ›é“ï¼Œä¸€æ¬¡å¯ä»¥æœ‰äº”åé€‰æ‰‹åŒæ—¶æ¯”èµ›ã€‚æ¯”èµ›å¹¶ä¸è®¡æ—¶ï¼Œåªçœ‹ç›¸åº”çš„åæ¬¡ã€‚å‡è®¾é€‰æ‰‹çš„å‘æŒ¥æ˜¯ç¨³å®šçš„ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æœçº¦ç¿°æ¯”å¼ ä¸‰è·‘å¾—å¿«ï¼Œå¼ ä¸‰æ¯”å‡¯åˆ©è·‘å¾—å¿«ï¼Œçº¦ç¿°ä¸€å®šæ¯”å‡¯åˆ©è·‘å¾—å¿«ã€‚æœ€å°‘éœ€è¦å‡ æ¬¡æ¯”èµ›æ‰èƒ½å†³å‡ºå‰ä¸‰åï¼Ÿ Q2ï¼åŒºé—´æ’åºã€‚ å¦‚æœæœ‰Nä¸ªåŒºé—´[l1,r1],[l2,r2],â€¦,[lN,rN]ï¼Œåªè¦æ»¡è¶³ä¸‹é¢çš„æ¡ä»¶æˆ‘ä»¬å°±è¯´è¿™äº›åŒºé—´æ˜¯æœ‰åºçš„ï¼šå­˜åœ¨xiâˆˆ[li,ri]ï¼Œå…¶ä¸­i=1,2,â€¦,Nã€‚ æ¯”å¦‚ï¼Œ[1, 4]ã€[2, 3]å’Œ[1.5, 2.5]æ˜¯æœ‰åºçš„ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥ä»è¿™ä¸‰ä¸ªåŒºé—´ä¸­é€‰æ‹©1.1ã€2.1å’Œ2.2ä¸‰ä¸ªæ•°ã€‚åŒæ—¶[2, 3]ã€[1, 4]å’Œ[1.5, 2.5]ä¹Ÿæ˜¯æœ‰åºçš„ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥é€‰æ‹©2.1ã€2.2å’Œ2.4ã€‚ä½†æ˜¯[1, 2]ã€[2.7, 3.5]å’Œ[1.5, 2.5]ä¸æ˜¯æœ‰åºçš„ã€‚ å¯¹äºä»»æ„ä¸€ç»„åŒºé—´ï¼Œå¦‚ä½•å°†å®ƒä»¬è¿›è¡Œæ’åºï¼Ÿ "},"ReadingNotes/è®¡ç®—ä¹‹é­‚-å´å†›/cp2.html":{"url":"ReadingNotes/è®¡ç®—ä¹‹é­‚-å´å†›/cp2.html","title":"cp2","keywords":"","body":""},"ReadingNotes/è®¡ç®—ä¹‹é­‚-å´å†›/":{"url":"ReadingNotes/è®¡ç®—ä¹‹é­‚-å´å†›/","title":"index","keywords":"","body":" å¼•å­ è®¡ç®—çš„æœ¬è´¨-ä»æœºæ¢°åˆ°ç”µå­ ç¬¬ä¸€ç«  æ¯«å˜åƒé‡Œä¹‹å·®-å¤§ O æ¦‚å¿µ ç¬¬äºŒç«  é€†å‘æ€è€ƒ-ä»é€’æ¨åˆ°é€’å½’ "},"ReadingNotes/è®ºé’å¹´ä¿®å…»-å¼ ç”³åºœ-1946.html":{"url":"ReadingNotes/è®ºé’å¹´ä¿®å…»-å¼ ç”³åºœ-1946.html","title":"è®ºé’å¹´ä¿®å…»-å¼ ç”³åºœ-1946","keywords":"","body":"è®ºé’å¹´ä¿®å…»-å¼ ç”³åºœ-1946 å¿ƒä¸é™ï¼Œå†™ä¸å‡ºç³»ç»Ÿæ·±åˆ»çš„ä¸œè¥¿æ¥ã€‚æ— å¯å¦‚ä½•ï¼Œè¿™æ˜¯éšä¾¿è°ˆè°ˆç½¢ã€‚ä½†è¿™æ ·å­ï¼Œä¹Ÿè®¸æ¯”èµ·è£…è…”ä½œåŠ¿ï¼Œæ¿èµ·é¢å­”æ¥è¯´è¯ï¼Œè¯»è€…å¯ä»¥æ„Ÿç€æ›´äº²åˆ‡ä¸€ç‚¹å„¿ã€‚ å…³äºé’å¹´ä¿®å…»ï¼Œæˆ‘ç°åœ¨æœ‰ä¸‰äº”ç‚¹æ„æ€æ¶Œä¸Šå¿ƒå¤´ã€‚ç°åœ¨å°±ä»¥æ¬¡åˆ†åˆ«å†™åœ¨ä¸‹è¾¹ã€‚ ç¬¬ä¸€ï¼Œæˆ‘ä¹Ÿä¸è®¸å¤šå¤äººä¸€æ ·ï¼Œæ€»è§‰ç€ä¸€ä¸ªé’å¹´ï¼Œä¸ºå­¦å¿…å…ˆç«‹å¿—ã€‚å°±ä»¤ä¸€ä¸ªäººï¼Œä¸å¿…ä¸“é—¨è¯»ä¹¦ï¼Œæœ‰ä¸€ä¸ªå¤§å¿—å‘ï¼Œä¹Ÿæ˜¯éå¸¸ä¹‹è¦ç´§ã€‚ä¸€ä¸ªäººä½†ä»¤å¤šå°‘æœ‰ç‚¹å„¿çŸ¥è¯†ï¼Œå¤šå°‘æœ‰ç‚¹å„¿è‡ªè§‰ï¼Œé‚£å°±è¦æœ‰ä¸€ä¸ªå¿—å‘ï¼Œè¿™æ ·å­æ‰å¯ä»¥å…å¾—éº»éº»èƒ¡èƒ¡è¿‡ä¸€è¾ˆå­ã€‚ è‡³äºç«‹å¿—ä½œä»€ä¹ˆï¼Œé‚£å´æœ‰ç‚¹å„¿éš¾è¯´ï¼Œä½†è‡³ä½é™åº¦ï¼Œæœ€ä¸€èˆ¬åœ°æ¥è¯´ï¼Œä½ è¦ç«‹å¿—ä½œä¸€ä¸ªå¥½äººã€‚è¿™è¯ä¹Ÿè®¸å¤§ç©ºï¼Œé‚£å°±åè¿‡æ¥è¯´ä¹Ÿå¯ï¼šä½ æ€»è¦ç«‹å¿—ä¸ä¸ºæ¶ã€‚å‡¡ä½ å¹³å¸¸éª‚äººçš„äº‹ï¼Œä½ æ€»è¦ä¸‹å†³å¿ƒä¸€ä»¶ä¹Ÿä¸ä½œã€‚è¿™ä¸€ç‚¹åœ¨ä»Šæ—¥å®åœ¨æœ€æœ€è¦ç´§ã€‚è®¸å¤šäººä¸¤é¢ä½œé£ï¼Œè®¸å¤šäººå£æ˜¯å¿ƒéï¼Œè®¸å¤šäººå£ç§°æ°‘ä¸»è€Œè¡Œåæ°‘ä¸»ï¼Œè®¸å¤šäººå¤©å¤©éª‚å½“å±€ï¼Œè€Œä»–çš„è¡Œä¸ºæ²¡æœ‰ä¸€ç‚¹ä¸ä¸å½“å±€ä¸€æ ·ï¼Œé™¤äº†åœ°ä½ä¸åŒä»¥å¤–ã€‚è¯¸å¦‚æ­¤ç±»ï¼Œéƒ½å› ä»–æ²¡æœ‰åšå®šå¿—å‘çš„ç¼˜æ•…ã€‚ è¯´å¾—æ›´å…·ä½“ä¸€ç‚¹ï¼Œä¸€ä¸ªäººæ€»è¦ä½œä¸€ä¸ªåˆä¹æ—¶ä»£çš„äººï¼Œå› æ­¤åº”è¯¥å¯¹äºè‡ªå·±çš„æ—¶ä»£ä¸å¯ä¸æœ‰ä¸€ç‚¹åˆ‡å®çš„è®¤è¯†ã€‚ä½†è¿™åœ°æ–¹å¾ˆå®¹æ˜“çŠ¯ä¸€ä¸ªæ¯›ç—…ï¼Œé‚£å°±æ˜¯éšæ³¢é€æµã€‚ä¸€ä¸ªäººçŸ¥è¯†è¡ŒåŠ¨åˆä¹æ—¶ä»£æ˜¯å¿…è¦çš„ï¼Œä½†éšæ³¢é€æµå¯å°±å¤§è¦ä¸å¾—ã€‚æ€æ ·å…æ‰è¿™ç§æ¯›ç—…ï¼Œé‚£å°±è¦æ³¨æ„è‡ªè§‰ï¼Œä½œå¾—äº†è‡ªå·±çš„ä¸»å®°ï¼Œæœ‰è‡ªå¾—ä¹‹å¤„ï¼Œå°½é‡é˜²å¤‡è™šè£ï¼Œå¹¶ä¸”å¯¹æ—¶ä»£æœ‰æ·±åˆ»çš„è®¤è¯†ã€‚ äººæ€æ ·æ‰èƒ½æœ‰å¿—ï¼Œå°¤å…¶æ€æ ·æ‰èƒ½æœ‰å¤§å¿—ï¼Œè¿™åŸå› é¢‡ä¸ç®€å•ã€‚ä»å¤–æ¥åŸå› è¯´ï¼Œè¿™ä¸€ç§è¦é çˆ¶å…„å¸ˆé•¿çš„å‘Šè¯­æ•™å¯¼ã€‚è¿™ä¸æ˜¯äººäººæ‰€å¯å¾—ã€‚ä¸€ç§é åŒå­¦æœ‹å‹çš„åˆ‡ç£‹é¼“åŠ±ã€‚è¿™ä¹Ÿå¯é‡ä¸å¯æœŸã€‚å¦ä¸€ç§å°±æ˜¯é é˜…åäººä¼ è®°ï¼Œè¯»å¤§å®¶è‘—ä½œï¼›ç”šè‡³çœ‹åå®¶å°è¯´ã€æˆå‰§ã€ç”µå½±ï¼Œä¹Ÿéƒ½ä¼šæœ‰å¥½å¤„ã€‚è¿™æ˜¯äººäººéƒ½å¯ä½œå¾—åˆ°çš„ã€‚ä½†æ˜¯ä½ è¿™æ ·å­ä½œæ—¶ï¼Œä½ å¿…æ‡‚å¾—ä½“å¯Ÿï¼Œæ‡‚å¾—ä¸å¥½äººçœ‹é½ã€‚æ¢è¨€ä¹‹ï¼Œè¦ä½œä¸€ä¸ªå¥½äººï¼Œé€‚å½“çš„è‡ªè§‰æ€»æ˜¯å¿…è¦çš„ã€‚ å†è¿›ä¸€æ­¥è¯´ï¼Œåœ¨ä»Šæ—¥è¿™ä¸ªæ—¶ä»£ï¼Œè¦ä½œä¸€ä¸ªå¥½äººï¼Œæ‹¿æ—§è¯è¯´ï¼Œâ€œæ°‘èƒç‰©ä¸â€æ€»æ˜¯ä¸€ä¸ªå¿…è¦çš„å‡ºå‘ç‚¹ã€‚è¯´å¾—é€šä¿—ä¸€ç‚¹ï¼Œä½ è¦æœ‰ä¸€ç§æ²»ç—…æ•‘äººçš„æ„è¶£ã€‚ä½ ä¸è¦æŠŠè‡ªå·±å­¤ç«‹ï¼Œä½ è¦ä½¿ä¸–ç•Œå› æœ‰ä½ è€Œä¸åŒï¼Œä½†ä½ éƒ½ä¸å¯æ€»è§‰ç€ä½ ä¸ä¸€èˆ¬äººä¸åŒã€‚ ç¬¬äºŒï¼Œå…³äºä¸ºå­¦è¯»ä¹¦ï¼Œæˆ‘ç‰¹åˆ«æ„¿æ„å‘Šè¯‰ä½ ä¸€ä¸ªâ€œä¸“â€å­—ã€‚æœ¬æ¥ï¼Œå‡¡äº‹ï¼Œâ€œä¸“â€éƒ½æ˜¯æœ€é¦–è¦çš„æˆåŠŸè¯€ã€‚è¯»ä¹¦ä¸ºå­¦ï¼Œä¹Ÿä¸å¤–æ˜¯ã€‚ä¸€ä¸ªäººè¦å®¹æ˜“æœ‰æˆï¼Œé‚£å°±æœ€å¥½åªå¹²ä¸€æ ·äº‹ã€‚å¤äººè®²å­¦ï¼Œå¸¸è¯´åšä¸çº¦ã€‚ä½†åšå¦‚æ²¡æœ‰ä¸­å¿ƒï¼Œå¿…è‡³æ³›æ»¥æ— å½’ï¼Œäº‹å€åŠŸåŠï¼Œè´¹åŠ›è€Œä¸è®¨å¥½ã€‚ä¸€ä¸ªäººè¯»ä¹¦ï¼Œä¸å…¶å¯¹ä¸€åˆ‡çŸ¥é“ä¸€ç‚¹ï¼Œç¡®ä¸å¦‚å¯¹ä¸€ç‚¹çŸ¥é“ä¸€åˆ‡ã€‚ç­‰åˆ°ä½ æœ‰äº†ä¸­å¿ƒï¼Œæœ‰äº†ä¸»å®°ï¼Œæœ‰äº†ä¸“é•¿ä¹‹åï¼Œå†å¯¹ä¸€åˆ‡éƒ½çŸ¥é“ä¸€ç‚¹ï¼Œé‚£å°±æ­£å¯ä»¥ä½œä½ åŸæ¥ä¸€ç‚¹çš„å¿…è¦è¡¥åŠ©ã€‚æ‰€è°“ç”±åšè¿”çº¦ï¼Œèƒ½çº¦ï¼Œä¹Ÿå°±ä¸å¦¨åšã€‚ å‰å·²è¯´è¿‡ï¼Œè¦è¯»å¤§å®¶çš„åè‘—ã€‚è¿™ä¹Ÿæ˜¯ä¸ºå­¦è¯»ä¹¦ä¸Šçš„ä¸€ä¸ªå¿…è¦çš„è¦è¯€ã€‚ä»¥ä¸“è€Œè¨€ï¼Œä¸å…¶æ³›è§ˆç¾¤ç±ï¼Œä¸å¦‚ç²¾è¯»ä¸€ä¹¦ã€‚ä½†è¿™ä¸€ä¹¦å¿…é¡»æ˜¯å¤§å®¶åè‘—ï¼Œä¸åˆŠçš„ç»å…¸ï¼Œæ„å‘³æ·±é•¿ï¼Œä½¿ä½ ç ”å¯»ä¸å°½è€…ã€‚è¿™ç§ä¹¦ï¼Œä¸æ‹˜é‚£ä¸ªæ–‡æ˜å›½å®¶ï¼Œè‡ªå¤ä»¥æ¥éƒ½æ˜¯æœ‰çš„ã€‚ä¸€ä¸ªäººè¯»ä¹¦ï¼Œæœ€å¥½è¯»åˆ°æ·±é€ è‡ªå¾—ã€‚å¤§å®¶çš„åå…¸å½“ç„¶éƒ½æ˜¯æ·±é€ è‡ªå¾—çš„ä¹¦ã€‚ä¸æ·±é€ è€Œæœ‰è‡ªå¾—å¤„ï¼Œå¿…ä¸ä¼šå¼€è¾Ÿæ–°çºªå…ƒã€åˆ›å‘æ–°æ—¶ä»£ã€‚å¤§å®¶åè‘—å¿…æœ‰ä¸åŒæ°”å‘³ï¼Œæ­£ä¸åä¹ä¸€èˆ¬ã€‚ä½ å¦‚ä¸å®ƒåŒ–äº†ï¼Œä½ è‡ªä¹Ÿå¯ä»¥ä¸åŒã€‚ æˆ‘ä»¥å‰å°ä¸ºé’å¹´è¯»è€…å†™è¿‡ä¸€ç¯‡ä»¥â€œåˆ‡å®ï¼Œæ·±å…¥ï¼Œä¸“â€ä¸ºé¢˜çš„ä¸œè¥¿ã€‚æ·±å…¥ä¸ä¸“ï¼Œå½“ç„¶æœ‰è”å¸¦å…³ç³»ã€‚æ­¤å¤–ï¼Œæœ€è¦ç´§ä¹Ÿç›¸å…³çš„ï¼Œé‚£å°±è¦è¯´åˆ°åˆ‡å®ã€‚ä¸€ä¸ªäººä½œäººï¼Œæœ€æ€•ä½œåˆ°é£˜é£˜ç„¶ã€‚ä¸€ä¸ªäººåœ¨æœ‰äº›åœ°æ–¹èƒ½å¤Ÿé£˜é£˜è‹¥ä»™ï¼Œæœªå°æ²¡æœ‰å¥½å¤„ã€‚ä½†å¦‚å…¨ä¸ç€å®ï¼Œå…¨ä¸å®åœ¨ï¼Œå…¨ä¸å…¥é‡Œï¼Œå°½æ˜¯è‚¤é¢è¡¨æ¯›ï¼Œæ²¹è…”æ»‘è°ƒï¼ŒèŠ±è¨€å·§è¯­ï¼Œé‚£å°±åªèƒ½è¯´ä»–åœ¨ä½œäººä¸Šå·²ç»å¤±è´¥ã€‚è¯»ä¹¦ä¸ºå­¦ä¹Ÿå¦‚æ­¤ã€‚ä¸æ‹˜æ€æ ·æŠ½è±¡çš„å­¦é—®ï¼Œæœ€åä¹Ÿä¸èƒ½ä¸åˆ‡å®é™…ã€‚æœ‰çš„äººè®²å­¦å°šâ€œç©ºçµâ€ï¼Œå…¶å®æ­£æ˜¯ä¸ºçš„â€œå¦‚å®â€è€Œä¸æ‰§ç€ã€‚å‡ä½¿ä¸€ä¸ªäººä¸€ç”Ÿä¸ºå­¦ï¼Œè€Œå´å…¨ä¸å®é™…ä¸ç›¸å¹²ï¼Œé‚£å°±æ˜¯æ—¶åŠ›ç²¾ç¥ç™½è´¹äº†ã€‚å‰è¯´è¯»ä¹¦è¦è¯»å¤§å®¶åè‘—ï¼Œå‡ä½¿è¿™ç§ä¹¦æ˜¯ç°ä»£çš„æˆ–è®²ç°ä»£çš„ï¼Œé‚£å°±æ›´å¥½ã€‚å½“ç„¶æˆ‘å¹¶ä¸æ˜¯è¯´å¤ä¹¦å°±ä¸åˆ‡å®é™…ã€‚ å†è¡¥å……ä¸€å¥ã€‚ä¸€ä¸ªäººè¯»ä¹¦è¦ä¸“ï¼Œè¦è¯»åè‘—ï¼Œè¿™éƒ½è¯´è¿‡äº†ã€‚ä½†ä¸€ä¸ªäººæœ‰ä¸°å¯Œçš„äººç”Ÿå¸¸è¯†ä¹Ÿæœ‰å…¶å¿…è¦ï¼Œç‰¹åˆ«æ˜¯å…³äºä½ çš„æ—¶ä»£ï¼Œä½ çš„ä¸–ç•Œï¼Œä½ çš„å›½å®¶ï¼Œä½ çš„ç¤¾ä¼šï¼Œä»¥åŠä½ çš„èº«ä½“ç²¾ç¥çš„å¸¸è¯†ã€‚ä¸€ä¸ªäººå¦‚æœæ²¡æœ‰å…³äºç”Ÿç†ã€å¿ƒç†ã€å«ç”Ÿçš„å¸¸è¯†ï¼Œå¿…ä¼šå¸¸åœ¨è‹¦æ¼ä¸­ã€‚ ç¬¬ä¸‰ï¼Œå‰è¾¹å·²ç»æåˆ°è‡ªè§‰ï¼Œæˆ‘ç°åœ¨è¦æ›´è¿›ä¸€æ­¥ï¼Œå†åŠ ä¸Šåçœã€‚ä¸€ä¸ªäººä¸è¯†ä¸çŸ¥çš„ç”Ÿæ´»æ˜¯ä¸€ç§æ— æ„æ€çš„ç”Ÿæ´»ï¼›ä¸€ä¸ªäººä¸é•¿è¿›çš„ç”Ÿæ´»ä¹Ÿå¯è¯´æ˜¯ä¸æ­»å·®ä¸å¤šçš„ç”Ÿæ´»ã€‚äººæ€æ ·æ‰èƒ½ä¸æ–­é•¿è¿›ï¼Ÿæ¡ä»¶ä¹‹ä¸€å°±æ˜¯æ—¶æ—¶åçœã€‚æ€æ ·åçœï¼Ÿå°±æ˜¯ä½ è¦æ—¶æ—¶è‡ªå·±æ£€è®¨ï¼šè¿™ä»¶äº‹æˆ‘ä¸ºä»€ä¹ˆä½œå¾—å¾ˆæˆåŠŸï¼Ÿé‚£ä»¶äº‹æˆ‘ä¸ºä»€ä¹ˆå¤±è´¥äº†ï¼Ÿæ˜¨å¤©æˆ‘èº«ä½“é‚£æ ·å¥½ï¼Œä»Šå¤©æˆ‘ä¸ºä»€ä¹ˆç—…äº†ï¼Ÿä»¥å‰æˆ‘è¿™æ ·ä½œå¾ˆé¡ºåˆ©ï¼Œç°åœ¨ä¸ºä»€ä¹ˆè¡Œä¸é€šäº†ï¼Ÿä¸€ä¸ªæœ‰ç†æ€§çš„äººï¼Œä¸ä½†è¦äº‹äº‹è‡ªè§‰ï¼Œäº‹äº‹è¦ä½œå¾—æœ‰ç†ç”±ï¼Œè€Œä¸”ä¹Ÿè¦æˆåŠŸçŸ¥é“ç†ç”±ï¼Œå¤±è´¥ä¹ŸçŸ¥é“ç†ç”±ã€‚åçœäº†ä»¥åï¼Œæ›´ä¸æƒ®äºè´¥ï¼Œè¿™ä¾¿æ˜¯è¿›æ­¥æ‰€ç”±æˆã€‚ æˆ‘è¿‘æ¥å¾ˆæ„Ÿåˆ°åçœçš„å¿…è¦ã€‚ç°åœ¨è®¸å¤šäººä½œäº‹ï¼Œå¦‚æœ‰é”™è¿‡ï¼Œæ€»æ˜¯åŠ åœ¨åˆ«äººèº«ä¸Šï¼Œæˆ–åŠ åœ¨ä¸èƒ½è‡ªè¡¨çš„å®¢è§‚ç¯å¢ƒèº«ä¸Šï¼Œç»ä¸è‚¯å›å¤´çœ‹çœ‹è‡ªå·±ã€‚è¿™æ ·çš„åšå†³ä¿¡å¿ƒï¼Œè¿™æ ·çš„å‹‡å¾€æ°”æ¦‚å¹¶ä¸æ˜¯æ²¡æœ‰æ˜¯å¤„ï¼Œä½†æ˜¯äº‹æƒ…å¼„å¾—ä¸å¥½ï¼Œå‰é€”ä¹Ÿä¼šå¼„å¾—ä¸å ªè®¾æƒ³ã€‚å› æ­¤ï¼Œé™¤äº†ç›¸åç›¸æˆï¼Œä¸è¦è¿‡åˆ†ä»¥å¤–ï¼Œæˆ‘æ€»æ„¿æ•™äººå›å¤´çœ‹çœ‹ï¼Œä¹Ÿæ„¿æ•™äººæœ‰æ—¶ä¹Ÿä½œä¸€ä½œé€€ä¸€æ­¥æƒ³ã€‚ä¹Ÿè®¸æœ‰äººè¦æ„Ÿç€æ‰“äº†ä»–ä»¬çš„é«˜å…´ã€‚å…¶å®æˆ‘ä¸è¿‡æ„¿ä»–åœ¨ä¸€å¾€ç›´å‰ä¸ŠåŒæ—¶ä¹Ÿè¦è„šæ­¥æ”¾å¾—ç¨³ä¸€äº›ï¼Œä¸è¦å¤±è¶³ï¼Œå¤±æ‰ä¸å¿…è¦çš„ç‰ºç‰²è€Œå·²ã€‚ ä¸­å›½è¿‡å»æœ‰è®¸å¤šåœ¨äººçš„ä¿®å…»ä¸Šç‰¹åˆ«æ³¨æ„çš„äº‹ï¼Œä¹Ÿè®¸å› ä¸ºæœ‰äº†æµå¼Šï¼Œç°åœ¨é‚å› å™åºŸé£Ÿï¼Œå†ä¸å¤æçš„ã€‚è¿™å…¶ä¸­ä¸€ä¸ªå°±æ˜¯ä¸€ä¸ªæ•¬å­—ã€‚æˆ‘è¿‘å¹´å¤§å¤§æ„Ÿåˆ°æ•¬å­—çš„è¦ç´§ã€‚æ•¬ä¸å¿…å¯¹äººï¼Œå°¤å…¶è¦ç´§çš„è¿˜åœ¨å¯¹äº‹ã€‚æˆ‘æ‰€è°“æ•¬ï¼Œå·®ä¸å¤šå°±æ˜¯å°å¿ƒæ…é‡çš„æ„æ€ï¼Œä½†æ›´åŠ äº†ä¸€ç•ªåº„ä¸¥éƒ‘é‡ã€‚æˆ‘è¿‘å¹´æ¯é€¢ä»€ä¹ˆå¼„åäº†ï¼Œå³è‡ªè°“ä¸æ•¬ä¸æ•¬ï¼Œä»¥è‡ªè­¦æƒ•ï¼Œä»¥è‡ªæ”¹æ­£ã€‚è¿™æ˜¯ä¸åçœç›¸è”çš„ã€‚æˆ‘ç›¸ä¿¡ï¼Œå‡ä½¿äººå¸¸èƒ½å¦‚æ­¤ï¼Œä¸€å®šä¹Ÿå¯å‡å°‘äº›è¿‡å¤±ã€‚æˆ‘æ·±æ„¿ä»Šæ—¥é’å¹´éƒ½èƒ½æ—©ç‚¹å…»æˆè¿™ä¸ªä¹ æƒ¯ã€‚æ‰€è°“ä¿®å…»ï¼Œä¹Ÿä¸è¿‡å°±æ˜¯å…»æˆäº›å¥½ä¹ æƒ¯ï¼Œå°¤å…¶æ˜¯æ²‰ç€æ…é‡ä¸è½»æµ®çš„ä¹ æƒ¯ã€‚ æœ‰å¤§å¿—ï¼Œè¯»åå…¸ï¼Œæ—¶è‡ªåçœï¼Œå¯¹äº‹ä¸“è€Œæ•¬ã€‚é’å¹´çš„åº”æœ‰ä¿®å…»ï¼Œå½“ç„¶è¿˜ä¸æ­¢ã€‚è¿™ä¸‰äº”ç‚¹å´æ˜¯æˆ‘è¿‘æ¥æ—¶åœ¨æ„Ÿåˆ°ä¹‹ç‚¹ã€‚å‹‰å¼ºæŠ½ç©ºå†™å‡ºæ¥ï¼Œä½†æ„¿å¤§å®¶ä¸åï¼Œè¯•è¯•çœ‹ï¼ ï¼ˆå››æœˆå»¿å…­å¤œï¼‰ å¼ ç”³åºœï¼ˆ1893ï¼1986ï¼‰ï¼Œåå´§å¹´ï¼Œæ²³åŒ—çŒ®å¿äººã€‚å“²å­¦å®¶ã€‚1920å¹´åˆå‚ä¸ä¸­å›½å…±äº§å…šçš„å»ºå…šæ´»åŠ¨ï¼Œæ˜¯å‘¨æ©æ¥çš„å…¥å…šä»‹ç»äººã€‚1931å¹´è‡³1936å¹´ä»»æ¸…åå¤§å­¦å“²å­¦ç³»æ•™æˆã€‚ ï¼ˆä½œäº1946å¹´4æœˆ26æ—¥ã€‚åŸè½½1946å¹´5æœˆ4æ—¥ã€Šå”¯æ°‘å‘¨åˆŠã€‹ç¬¬1å·ç¬¬5æœŸã€‚ï¼‰ "},"ReadingNotes/è®ºé’å¹´çš„ä¿®å…»-å¼ é—»å¤©-1938.html":{"url":"ReadingNotes/è®ºé’å¹´çš„ä¿®å…»-å¼ é—»å¤©-1938.html","title":"è®ºé’å¹´çš„ä¿®å…»-å¼ é—»å¤©-1938","keywords":"","body":"è®ºé’å¹´çš„ä¿®å…»-å¼ é—»å¤©ï¼ˆ1938å¹´4æœˆ28æ—¥ï¼‰ åŒå¿—ä»¬!ä½ ä»¬éƒ½æ˜¯ä»å…¨å›½å„æ–¹é¢æ¥çš„é’å¹´ï¼Œæ‰€ä»¥æˆ‘ä»Šå¤©å°±åŒä½ ä»¬è®¨è®ºè®¨è®ºå…³äºé’å¹´çš„é—®é¢˜ã€‚ ä»å…¨å›½æ°‘æ—æŠ—æˆ˜å¼€å§‹åˆ°ç°åœ¨è¿™ä¸ªæ—¶æœŸå†…ï¼Œé’å¹´çš„ç¡®å ç€ä¸€ä¸ªå¾ˆé‡è¦çš„åœ°ä½ã€‚æˆ‘ä»¬æ— è®ºä»å“ªä¸€æ–¹é¢æ¥çœ‹ï¼Œä¸è®ºæ˜¯å†›äº‹æ–¹é¢ä¹Ÿå¥½ï¼Œæ”¿æ²»æ–¹é¢ä¹Ÿå¥½ï¼Œæ–‡åŒ–æ•™è‚²æ–¹é¢ä¹Ÿå¥½ï¼Œéƒ½å¯ä»¥çœ‹åˆ°å¹¿å¤§é’å¹´ç¾¤ä¼—çš„æ´»è·ƒã€‚ä»–ä»¬æ€»æ˜¯ç«™åœ¨æŠ—æˆ˜çš„æœ€å‰çº¿ï¼Œä¸ºä¸­åæ°‘æ—çš„è§£æ”¾è€Œç‰ºç‰²å¥‹æ–—ã€‚åŒæ—¶ï¼Œç”±äºæŠ—æˆ˜è§„æ¨¡æ‰©å¤§å’Œå±•å¼€ï¼Œé’å¹´çš„è´£ä»»ä¹Ÿæ›´åŠ é‡è¦äº†ã€‚æ€æ ·ä½¿æˆ‘ä»¬çš„é’å¹´æ›´èƒ½åœ¨æŠ—æˆ˜ä¸­å°½ä»–ä»¬çš„è´£ä»»ï¼Œæ˜¯æˆ‘ä»¬å¤§å®¶æ‰€è¦å•†è®¨çš„é—®é¢˜ã€‚æˆ‘ä»Šå¤©æ‰€è¦è®²çš„é’å¹´çš„ä¿®å…»é—®é¢˜ï¼Œå³æ˜¯æƒ³åœ¨è¿™æ–¹é¢å‘å¤§å®¶è´¡çŒ®ä¸€ç‚¹æ„è§ã€‚ æˆ‘è®¤ä¸ºä¸­å›½ç°ä»£çš„é’å¹´ï¼Œæœ‰å¾ˆå¤šå…±åŒçš„ä¼˜ç‚¹ï¼ŒåŒæ—¶ä¹Ÿæœ‰ä¸€äº›å…±åŒçš„å¼±ç‚¹ã€‚æ€æ ·å‘æŒ¥è¿™äº›ä¼˜ç‚¹ï¼Œå…‹æœé‚£äº›å¼±ç‚¹ï¼Œå³æ˜¯é’å¹´çš„ä¿®å…»é—®é¢˜çš„å†…å®¹ã€‚æˆ‘ç°åœ¨å°±æ ¹æ®æˆ‘ä»¬çš„ç»éªŒä¸è€ƒå¯Ÿæ¥å…·ä½“è®²å‡ ç‚¹ï¼Œå¸Œæœ›å¤§å®¶æ¥è®¨è®ºã€‚ ä¸€ã€è¦æœ‰åšå®šçš„é«˜å°šçš„ç†æƒ³ é’å¹´æœ‰ä¸€ä¸ªå¾ˆå¤§çš„ä¼˜ç‚¹ï¼Œè¿™å°±æ˜¯ä»–ä»¬æœ‰é«˜å°šçš„ç†æƒ³ï¼Œä¸è®ºè¿™ä¸ªç†æƒ³æ˜¯æŠ—æ—¥æ•‘å›½ä¹Ÿå¥½ï¼Œå…±äº§ä¸»ä¹‰ä¹Ÿå¥½ã€‚ä»–ä»¬å¯¹äºç°ç¤¾ä¼šæ˜¯ä¸æ»¡è¶³çš„ï¼Œä»–ä»¬å¸Œæœ›ç€ä¸€ä¸ªç†æƒ³çš„ç¤¾ä¼šçš„å‡ºç°ã€‚é’å¹´çš„è¿™ç§ç†æƒ³æ˜¯æœ€å¯å®è´µçš„ä¸œè¥¿ã€‚æ­£æ˜¯è¿™ç§ç†æƒ³ä¸æ–­åœ°é¼“èˆç€æˆ‘ä»¬çš„é’å¹´å‘å‰è¿›æ­¥ã€‚æ­£æ˜¯è¿™ç§ç†æƒ³ä½¿ä»–ä»¬ä¸æ„¿åœ¨ç°ç¤¾ä¼šä¸­é†‰ç”Ÿæ¢¦æ­»ï¼Œè€Œæ„¿æ„ä¸ºç†æƒ³ç¤¾ä¼šçš„å®ç°ç‰ºç‰²å¥‹æ–—ã€‚æ­£æ˜¯è¿™ç§ç†æƒ³ï¼Œä½¿æˆ‘ä»¬çš„é’å¹´ï¼Œåœ¨è¿‡å»ï¼Œåœ¨ç°åœ¨ï¼Œåˆ›é€ äº†è®¸å¤šæƒŠå¤©åŠ¨åœ°ä¸å¯æ­Œå¯æ³£çš„ä¼Ÿå¤§äº‹ä¸šã€‚çœ¼å‰çš„ä¾‹å­ï¼Œä¹Ÿå¯è¯æ˜è¿™ä¸€ç‚¹ã€‚æ¯”å¦‚ä½ ä»¬ï¼Œé™•åŒ—å…¬å­¦çš„åŒå­¦ï¼Œç©¶ç«Ÿä¸ºäº†ä»€ä¹ˆä¸è¿œåƒé‡Œè€Œæ¥é™•åŒ—è¿™ä¸ªæ¯”è¾ƒè’å‡‰çš„åœ°åŒºå‘¢?é™•åŒ—å…¬å­¦çš„ç‰©è´¨æ¡ä»¶æ˜¯å¾ˆå›°éš¾çš„ã€‚ä½çš„æ˜¯çª‘æ´ï¼Œåƒçš„æ˜¯å°ç±³é¥­ã€‚æ•™è‚²è®¾å¤‡éƒ½å¾ˆç®€é™‹ã€‚ç„¶è€Œä½ ä»¬ä¸ºä»€ä¹ˆä¸æ€•ä¸€åˆ‡å›°éš¾è€Œæ¥å‘¢?å¦‚æœä½ ä»¬ä¸æ˜¯ä¸ºäº†å¯»æ‰¾é«˜å°šçš„ç†æƒ³ï¼Œæˆ‘æƒ³ä½ ä»¬æ˜¯ä¸ä¼šæ¥çš„ã€‚æ‰€ä»¥é«˜å°šçš„ç†æƒ³å¯¹äºé’å¹´æ˜¯æœ€å¯å®è´µçš„ä¸œè¥¿ã€‚æˆ‘ä»¬å¯¹äºé’å¹´çš„ç†æƒ³ï¼Œä¸ä½†ä¸åº”è¯¥é„™è§†ï¼Œè€Œä¸”åº”è¯¥æå¤§åœ°çˆ±æŠ¤ã€‚æ—§ç¤¾ä¼šé‡Œçš„äººï¼Œå¸¸å¸¸éª‚é’å¹´ä¸ºâ€œç†æƒ³å¤ªé«˜â€ã€‚è¿™ç§éª‚æ³•ï¼Œæˆ‘ä»¬è®¤ä¸ºæ˜¯æ ¹æœ¬é”™è¯¯çš„ã€‚è¿™åªæ˜¯è¯æ˜é‚£äº›éª‚é’å¹´çš„äººçš„æ— ç†æƒ³ä¹‹å¯é„™è€Œå·²ã€‚å­™ä¸­å±±å…ˆç”Ÿä¸‰æ°‘ä¸»ä¹‰çš„ç†æƒ³ï¼Œä¸æ˜¯ä¹Ÿç»™äººå®¶éª‚ä¸ºâ€œå¤§ç‚®â€å—?é©¬å…‹æ€ã€æ©æ ¼æ–¯ã€åˆ—å®ã€æ–¯å¤§æ—çš„å…±äº§ä¸»ä¹‰ç†æƒ³ï¼Œä¸æ˜¯ç»™äººå®¶éª‚ä¸ºâ€œç©ºè°ˆâ€å—?ç„¶è€Œæˆ‘ä»¬çŸ¥é“é©¬å…‹æ€ã€æ©æ ¼æ–¯ã€åˆ—å®ã€æ–¯å¤§æ—ã€å­™ä¸­å±±çš„ä¼Ÿå¤§ï¼Œä¹Ÿæ­£æ˜¯åœ¨äºä»–ä»¬æœ‰é«˜å°šçš„ç†æƒ³ã€‚æ‰€ä»¥é’å¹´æœ‰é«˜å°šçš„ç†æƒ³ï¼Œæ­£æ˜¯é’å¹´çš„ä¼˜ç‚¹ã€‚ ä½†æ˜¯å¦‚æœæˆ‘ä»¬æŠŠé’å¹´äººçš„æŸäº›ç†æƒ³ç ”ç©¶ä¸€ä¸‹ï¼Œé‚£æˆ‘ä»¬å³å¯å‘ç°æœ‰äº›é’å¹´äººçš„ç†æƒ³ä¸æ˜¯ç†æƒ³è€Œæ˜¯ç©ºæƒ³ã€‚ç©ºæƒ³å¯èƒ½å¸¸å¸¸æ˜¯ç¾ä¸½çš„ä¸œè¥¿ï¼Œç„¶è€Œç©¶ç«Ÿæ˜¯ç©ºæƒ³è€Œä¸æ˜¯ç†æƒ³ã€‚é‚£ä¹ˆï¼Œç†æƒ³ä¸ç©ºæƒ³çš„åŒºåˆ«ç©¶ç«Ÿåœ¨å“ªé‡Œå‘¢? é¦–å…ˆï¼Œæˆ‘ä»¬åº”è¯¥è¯´ï¼Œæˆ‘ä»¬çš„ç†æƒ³æ˜¯å»ºç­‘åœ¨ç°ç¤¾ä¼šçš„ç‰©è´¨åŸºç¡€ä¹‹ä¸Šçš„ä¸œè¥¿ã€‚ ç©ºä¸­æ¥¼é˜ï¼Œç©¶ç«Ÿæ˜¯å¹»æƒ³è€Œä¸æ˜¯ç†æƒ³ï¼Œå› ä¸ºå®ƒæ˜¯è„±ç¦»ç°ç¤¾ä¼šçš„ç‰©è´¨åŸºç¡€è€Œå»ºç«‹åœ¨ç©ºä¸­çš„ã€‚ä¸€åˆ‡ä¼Ÿå¤§çš„ç†æƒ³ï¼Œéƒ½ä»ç°ç¤¾ä¼šçš„å…·ä½“åˆ†æå¾—æ¥ã€‚é—­æˆ·é€ è½¦ç©¶ç«Ÿåªèƒ½æ˜¯å¹»æƒ³è€Œä¸æ˜¯ç†æƒ³ï¼Œå› ä¸ºå®ƒæ˜¯ä¸ªäººå¤´è„‘ä¸­é—´éšä¾¿æƒ³å‡ºæ¥çš„ï¼Œè€Œä¸åˆäºå…·ä½“çš„ä¸å®é™…çš„ç‰©è´¨æ¡ä»¶ã€‚å…±äº§ä¸»ä¹‰çš„ç†æƒ³ï¼Œæ˜¯äººç±»æœ‰å²ä»¥æ¥æœ€å´‡é«˜çš„æœ€ä¼Ÿå¤§çš„ç†æƒ³ï¼Œç„¶è€Œè¿™ä¸ªç†æƒ³ï¼Œåªèƒ½ä»èµ„æœ¬ä¸»ä¹‰ç¤¾ä¼šçš„ç‰©è´¨åŸºç¡€ä¸Šäº§ç”Ÿå‡ºæ¥ã€‚è„±ç¦»å¯¹äºèµ„æœ¬ä¸»ä¹‰ç¤¾ä¼šçš„ç§‘å­¦åˆ†æçš„â€œå¤§åŒä¸–ç•Œâ€çš„æ€æƒ³ï¼Œç©¶ç«Ÿæ˜¯å¹»æƒ³è€Œä¸æ˜¯ç†æƒ³ã€‚ å…¶æ¬¡ï¼Œæˆ‘ä»¬çš„ç†æƒ³åº”è¯¥é€‚åˆäºäººç±»ç¤¾ä¼šå‘å±•çš„å¿…ç„¶è¶‹åŠ¿ã€‚ æˆ‘ä»¬è¯´æ°‘æ—ç‹¬ç«‹ã€æ°‘æƒè‡ªç”±ï¼Œæ°‘ç”Ÿå¹¸ç¦çš„ä¸‰æ°‘ä¸»ä¹‰å¯ä»¥æ˜¯æˆ‘ä»¬ä»Šå¤©çš„ç†æƒ³ï¼Œå› ä¸ºä¸­å›½ç¤¾ä¼šä»Šå¤©æ­£æ˜¯å‘ç€è¿™ä¸ªæ–¹å‘å‘å±•ç€çš„ã€‚æˆ‘ä»¬è¯´å…±äº§ä¸»ä¹‰ç¤¾ä¼šæ˜¯æˆ‘ä»¬å°†æ¥çš„ç†æƒ³ï¼Œå› ä¸ºäººç±»ç¤¾ä¼šç»ˆç©¶æ˜¯è¦å‘ç€è¿™ä¸ªæ–¹å‘å‘å±•å‰å»çš„ã€‚å¦‚æœä»Šå¤©æœ‰äººè¦æ¢å¤åŸå§‹å…±äº§ç¤¾ä¼šæˆ–æ¢å¤å¥´éš¶ç¤¾ä¼šã€‚æˆ–ä»¿æ•ˆå›ä¸»ä¸“åˆ¶æˆ–æ³•è¥¿æ–¯ç‹¬è£çš„ç»Ÿæ²»ã€‚é‚£è¿™ç§æ€æƒ³å°±ä¸æ˜¯çœŸæ­£çš„ç†æƒ³ï¼Œå› ä¸ºè¿™ç§æ€æƒ³æ˜¯è¿åäºäººç±»ç°ä»£ç¤¾ä¼šå‘å±•çš„è¶‹åŠ¿çš„ã€‚è¿™ç§æ€æƒ³ï¼Œæˆ‘ä»¬ä¸å«å®ƒç†æƒ³ï¼Œè€Œå«å®ƒåšååŠ¨æ€æƒ³ã€‚å› ä¸ºè¿™ç§æ€æƒ³ä¸æ˜¯è¦ä½¿ç¤¾ä¼šèµ°å‘å‰è¿›ï¼Œè€Œæ˜¯è¦å®ƒè½¬å‘åé€€ï¼Œå°±æ˜¯æ‰€è°“â€œå¼€å€’è½¦â€ã€‚ä¸€åˆ‡ä¸åˆäºäººç±»ç¤¾ä¼šå‘å±•è¶‹åŠ¿çš„æ€æƒ³ï¼Œåªèƒ½æ˜¯ä¸€ç§ç©ºæƒ³ã€‚ ç¬¬ä¸‰ï¼Œç†æƒ³ä¸ç©ºæƒ³ä¸åŒï¼Œå°±æ˜¯ç†æƒ³æ˜¯èƒ½å¤Ÿå®ç°çš„ï¼Œç©ºæƒ³åˆ™æ˜¯æ°¸è¿œä¸å¾—å®ç°çš„ã€‚ è€Œç†æƒ³çš„å®ç°ï¼Œéœ€è¦æœ‰åœ¨ä¸€å®šçš„ç‰©è´¨æ¡ä»¶ä¸‹æ‰€äº§ç”Ÿçš„ç¤¾ä¼šåŠ›é‡ã€‚æ²¡æœ‰è¿™ç§åŠ›é‡ï¼Œç†æƒ³ä¹Ÿå°±ä¸èƒ½å®ç°ã€‚æˆ˜èƒœæ—¥æœ¬å¸å›½ä¸»ä¹‰ã€äº‰å–æ°‘æ—ç‹¬ç«‹çš„ç†æƒ³ï¼Œå°±è¦ä¾é åœ¨å…¨å›½ä¸€åˆ‡ä¸æ„¿æ„å½“äº¡å›½å¥´çš„å„é˜¶çº§ã€å„å…šæ´¾ã€å„å›¢ä½“çš„æ°‘æ—ç»Ÿä¸€æˆ˜çº¿çš„åŠ›é‡ä¹‹ä¸Šã€‚ç¦»å¼€å®ç°è‡ªå·±ç†æƒ³çš„ç¤¾ä¼šåŠ›é‡è€Œè°ˆç†æƒ³ã€‚é‚£ä¹Ÿæ˜¯ä¸€ç§ç©ºæƒ³è€Œä¸æ˜¯ç†æƒ³ã€‚å…±äº§ä¸»ä¹‰çš„æœ€é«˜ç†æƒ³ï¼Œç¦»å¼€å·¥äººé˜¶çº§çš„ç¤¾ä¼šåŠ›é‡ï¼Œå°±æˆä¸ºä¹Œæ‰˜é‚¦ï¼Œæˆä¸ºç©ºæƒ³ã€‚ ç¬¬å››ï¼Œç†æƒ³ä¹‹ä¸ºç†æƒ³ï¼Œé™¤ä¸Šè¿°æ¡ä»¶å¤–ï¼Œè¿˜éœ€æœ‰å®ç°ç†æƒ³çš„å…·ä½“åŠæ³•ã€‚ æ¯”å¦‚ï¼Œå®ç°æ°‘æ—è§£æ”¾çš„ç†æƒ³ï¼Œå°±è¦æœ‰å»ºç«‹ã€æ‰©å¤§ä¸å·©å›ºæŠ—æ—¥æ°‘æ—ç»Ÿä¸€æˆ˜çº¿çš„åŠæ³•ã€‚å®ç°å…±äº§ä¸»ä¹‰ï¼Œå°±è¦æœ‰ä¸€å®šçš„çº²é¢†ä¸æ­¥éª¤ï¼Œä¸€å®šçš„ç­–ç•¥ä¸æˆ˜ç•¥ã€‚é©¬å…‹æ€åˆ—å®ä¸»ä¹‰çš„ç­–ç•¥ä¸æˆ˜ç•¥æ˜¯æ¯ä¸€å…±äº§ä¸»ä¹‰è€…æ‰€å¿…é¡»å­¦ä¹ çš„ç§‘å­¦ï¼Œå› ä¸ºç¦»å¼€äº†å®ƒä»¬ï¼Œç†æƒ³è™½æ˜¯å¾ˆå¥½ï¼Œç„¶è€Œä»ç„¶æˆä¸ºç©ºè°ˆè€Œä¸èƒ½å®ç°ï¼Œä½¿ç†æƒ³æˆä¸ºç©ºæƒ³ã€‚ è¿™å°±æ˜¯ç†æƒ³ä¸ç©ºæƒ³çš„åŸºæœ¬åŒºåˆ«ã€‚æˆ‘ä»¬çš„é’å¹´å¦‚æœèµæˆæˆ‘æ‰€è¯´çš„è¿™äº›åŒºåˆ«ï¼Œé‚£æœ«è¯·ä½ ä»¬å°±æ‹¿è¿™å‡ ä¸ªæ ‡å‡†ï¼Œæ¥æ£€æŸ¥ä¸€ä¸‹è‡ªå·±çš„ç†æƒ³ï¼šç©¶ç«Ÿä½ ä»¬è¿‡å»æ‰€æŠ±çš„ç†æƒ³ï¼Œæ˜¯ç†æƒ³è¿˜æ˜¯ç©ºæƒ³?å¦‚æœæ˜¯ç©ºæƒ³ï¼Œé‚£å°±åº”è¯¥å†³ç„¶æŠ›å¼ƒã€‚å¦‚æœæ˜¯ç†æƒ³ï¼Œä½†åˆä¸å®Œå…¨ï¼Œé‚£å°±åº”è¯¥ä¿®æ­£ä¸å……å®ï¼Œæˆ–é‡æ–°åŠ ä»¥æ£€è®¨ä¸æ•´ç†ã€‚æˆ‘ä»¬åº”è¯¥ä¸å®¢æ°”åœ°è¯´ï¼Œåœ¨æˆ‘ä»¬é’å¹´çš„ç†æƒ³ä¸­ï¼Œå¸¸å¸¸ä¸å…æœ‰äº›ç©ºæƒ³çš„æˆåˆ†ï¼Œå› æ­¤ï¼Œä»–ä»¬æœ‰æ—¶å¯¹äºè‡ªå·±çš„ç†æƒ³æŠŠæ¡ä¸å®šï¼Œè€Œå‘ç”Ÿä¸€äº›æœä¸‰æš®å››çš„æ‘‡æ‘†ç°è±¡ã€‚è¦å…å»è¿™ç§ç°è±¡ï¼Œå°±å¿…é¡»æŠŠè‡ªå·±çš„ç†æƒ³å»ºç­‘åœ¨ç»“å®åšå›ºçš„ç§‘å­¦çš„åŸºç¡€ä¹‹ä¸Šã€‚è¿™æ˜¯æˆ‘æ‰€è¦è¯´çš„ç¬¬ä¸€ä¸ªé—®é¢˜ã€‚ äºŒã€è¦ä¸ºå®ç°è‡ªå·±çš„ç†æƒ³å¥‹æ–—åˆ°åº• é’å¹´äººåœ¨ä¸€æ—¦è§‰é†’ï¼Œæ‰¾åˆ°äº†è‡ªå·±çš„ç†æƒ³ä¹‹åï¼Œéƒ½èƒ½å¤Ÿä¸é¡¾ä¸€åˆ‡ä¸ºè‡ªå·±çš„ç†æƒ³å¥‹æ–—ã€‚è¿™ç§ä¸ºå®ç°è‡ªå·±çš„ç†æƒ³è€Œç‰ºç‰²å¥‹æ–—çš„ç²¾ç¥ï¼Œæ˜¯æˆ‘ä»¬é’å¹´çš„ä¸€ä¸ªå¾ˆå¤§ä¼˜ç‚¹ã€‚æˆ‘ä»¬åœ¨ç¤¾ä¼šä¸­çœ‹åˆ°ä¸å°‘è¿™æ ·çš„äººï¼Œä»–ä»¬ä¹Ÿä¸æ»¡æ„äºç°çŠ¶ï¼Œä»–ä»¬ä¹Ÿå¸Œæœ›æœ‰ä¸ªè¾ƒå¥½çš„ç¤¾ä¼šå‡ºç°ï¼Œä»–ä»¬ç”šè‡³åŒæƒ…å…±äº§ä¸»ä¹‰ï¼Œä½†æ˜¯ä»–ä»¬è‡ªå·±ä¸æ„¿æ„ä¸ºæ”¹é€ ç¤¾ä¼šè€Œå¥‹æ–—ã€‚ä»–ä»¬èˆä¸å¾—è‡ªå·±çš„å¦»å­å„¿å¥³ï¼Œä»–ä»¬èˆä¸å¾—è‡ªå·±çš„å®¶ä¹¡æ•…åœŸï¼Œä»–ä»¬èˆä¸å¾—è‡ªå·±çš„ç”Ÿå‘½è´¢äº§ï¼Œä»–ä»¬ä¸å¾—ä¸â€œé©¬é©¬è™è™â€åœ°ç”Ÿæ´»ï¼Œä¸å¾—ä¸â€œåšä¸€å¤©å’Œå°šæ’ä¸€å¤©é’Ÿâ€ã€‚ä½†é’å¹´å°±ä¸æ˜¯è¿™æ ·ã€‚ä»–ä»¬ä¸äº†è§£åˆ°è‡ªå·±çš„ç†æƒ³åˆ™å·²ï¼Œä¸€æ—¦ä»–ä»¬äº†è§£åˆ°äº†è‡ªå·±çš„ç†æƒ³ï¼Œä»–ä»¬å°±ä¼šæŠ›å¼ƒä¸€åˆ‡ï¼Œå¥”èµ´è‡ªå·±çš„ç†æƒ³ï¼Œå»ä¸ºè‡ªå·±çš„ç†æƒ³è€Œå¥‹æ–—ã€‚è¿™ç§ä¸é¡¾ä¸ªäººåˆ©å®³è€Œç‰ºç‰²å¥‹æ–—çš„ç²¾ç¥ï¼Œæ˜¯å€¼å¾—é’¦ä½©ä¸æ­Œé¢‚çš„ã€‚ ä½†æ˜¯ï¼Œå®ç°ç†æƒ³ï¼Œå®åœ¨ä¸æ˜¯ä¸€ä»¶å®¹æ˜“çš„äº‹ã€‚ç†æƒ³è™½æ˜¯å»ºç­‘åœ¨ç°ç¤¾ä¼šçš„ç‰©è´¨åŸºç¡€ä¹‹ä¸Šï¼Œä½†ç†æƒ³æ˜¯è¶…è¿‡ç°ç¤¾ä¼šçš„ä¸œä¸¤ã€‚ç†æƒ³å¥½æ¯”æ³¥åœŸä¸­ç”Ÿé•¿å‡ºæ¥çš„èŠ±ã€‚å®ƒè™½ç”Ÿé•¿åœ¨æ³¥åœŸä¸­ï¼Œä½†å®ƒåˆä¸æ˜¯æ³¥åœŸã€‚æ‰€ä»¥ç†æƒ³çœ‹æ¥å¸¸å¸¸æ˜¯ç¾ä¸½çš„ï¼Œè€Œç°ç¤¾ä¼šåˆ™çœ‹æ¥æ˜¯ä¸‘æ¶çš„ã€‚è¦æŠŠè¿™ä¸ªä¸‘æ¶çš„ç°ç¤¾ä¼šå˜ä¸ºç¾ä¸½çš„ç†æƒ³ç¤¾ä¼šï¼Œé‚£å†³ä¸æ˜¯ä¸€å¤©ä¸¤å¤©ä»¥è‡³ä¸€å¹´ä¸¤å¹´çš„äº‹ï¼Œè€Œéœ€è¦å‡ åå¹´ä»¥è‡³ä¸Šç™¾å¹´çš„å¥‹æ–—ä¸å·¥ä½œã€‚ä¸ä½†è¿™æ ·ï¼Œåœ¨å¥‹æ–—ä¸å·¥ä½œçš„è¿‡ç¨‹ä¸­è¿˜å¿…ç„¶è¦ç¢°åˆ°æ— æ•°çš„å›°éš¾ä¸æ³¢æŠ˜ï¼Œæœ‰æ—¶ç”šè‡³çœ‹æ¥ä¼¼ä¹æ˜¯ä¸èƒ½å…‹æœä»¥è‡³ç»æœ›çš„å›°éš¾ã€‚æ‰€ä»¥ä¸è®ºåœ¨ä»»ä½•å›°éš¾ä¹‹ä¸‹ï¼ŒåšæŒè‡ªå·²çš„ç†æƒ³ï¼ŒåšæŒä¸ºè‡ªå·±ç†æƒ³çš„å®ç°è€Œå¥‹æ–—ï¼Œæ˜¯ç»å¯¹å¿…è¦çš„ã€‚æ²¡æœ‰è¿™ç§åšæŒæ€§ï¼Œä»»ä½•çš„ç†æƒ³ä¹Ÿéƒ½ä¸èƒ½å®ç°ã€‚ ä¸€åˆ‡ä¼Ÿå¤§çš„é©å‘½å®¶ä¹‹æ‰€ä»¥ä¼Ÿå¤§ï¼Œä¸ä½†å› ä¸ºä»–ä»¬æœ‰ç€ä¼Ÿå¤§çš„ç†æƒ³ï¼Œè€Œä¸”è¿˜å› ä¸ºä»–ä»¬å§‹ç»ˆèƒ½å¤Ÿä¸ºäº†è‡ªå·²çš„ç†æƒ³å¥‹æ–—åˆ°åº•ã€‚å­™ä¸­å±±å…ˆç”Ÿâ€œè‡´åŠ›å›½æ°‘é©å‘½å‡¡å››åå¹´â€ã€‚è™½æ˜¯åœ¨ä»–å¥‹æ–—çš„è¿‡ç¨‹ä¸­ç¢°åˆ°äº†æ— æ•°çš„å›°éš¾ï¼Œç„¶è€Œä»–å§‹ç»ˆåšæŒä»–çš„ç†æƒ³ï¼Œä¸ºä»–çš„ç†æƒ³å¥‹æ–—åˆ°æœ€åã€‚ä¸–ç•Œæ— äº§é˜¶çº§çš„å¯¼å¸ˆé©¬å…‹æ€ã€æ©æ ¼æ–¯ã€åˆ—å®ã€æ–¯å¤§æ—ï¼Œä»–ä»¬çš„ä¼Ÿå¤§ï¼Œå°±æ˜¯ä»–ä»¬é‚£ç§ä¸ºè‡ªå·±çš„ç†æƒ³è€ŒåšæŒå¥‹æ–—åˆ°åº•çš„ç²¾ç¥ã€‚ä»–ä»¬åœ¨ä¸‘æ¶çš„æ—§ç¤¾ä¼šä¸­çœ‹åˆ°ç¾ä¸½ï¼Œä»–ä»¬åœ¨é»‘æš—ä¸­çœ‹åˆ°å…‰æ˜ï¼Œä»–ä»¬æ’é™¤ä¸‡éš¾ã€å…‹æœä¸€åˆ‡å›°éš¾è€Œå‰è¿›ã€‚ ä¸­å›½å…±äº§å…šäººæ›¾ç»å®Œæˆäº†äºŒä¸‡äº”åƒé‡Œé•¿å¾ã€‚è¿™ä»¶äº‹éœ‡åŠ¨äº†å…¨ä¸–ç•Œã€‚ä¸ºä»€ä¹ˆäºŒä¸‡äº”åƒé‡Œé•¿å¾èƒ½å¤Ÿæœ‰è¿™æ ·ä¼Ÿå¤§çš„å½±å“å‘¢?åŸå› å°±åœ¨äºä¸­å›½å…±äº§å…šåœ¨è¿™æ¬¡é•¿å¾ä¸­å……åˆ†åœ°è¡¨ç°å‡ºäº†å®ƒä¸ºäº†è‡ªå·±çš„ç†æƒ³è€Œç‰ºç‰²å¥‹æ–—ä¸åšæŒåˆ°åº•çš„ç²¾ç¥ã€‚æ²¡æœ‰è¿™ç§ç²¾ç¥ï¼Œå°±æ˜¯ä¸€åƒé‡Œçš„é•¿å¾ä¹Ÿæ˜¯ä¸å¯èƒ½çš„ã€‚åœ¨è¿™æ¬¡é•¿å¾ä¸­ï¼Œæˆ‘ä»¬çš„ç¡®æ›¾ç»ç¢°åˆ°äº†æ— æ•°çš„å›°éš¾ã€‚æˆ‘ä»¬æ›¾ç»ç¢°åˆ°äº†å‡ ä¹ä¸èƒ½æ¸¡è¿‡çš„å¤©é™©é‡‘æ²™æ±Ÿä¸å¤§æ¸¡æ²³ï¼Œæˆ‘ä»¬æ›¾ç»ç¢°åˆ°äº†äººç±»å‡ ä¹æ²¡æœ‰åˆ°è¿‡çš„é›ªå±±ä¸è‰åœ°ï¼Œæˆ‘ä»¬å¤„åœ¨æ•Œå†›çš„å››é¢åŒ…å›´ä¹‹ä¸­ã€‚å›°éš¾å‡ ä¹æ˜¯ä¸èƒ½å…‹æœçš„ï¼Œç„¶è€Œæˆ‘ä»¬é‚£æ—¶åªæœ‰ä¸€ä¸ªæ€æƒ³ï¼Œå°±æ˜¯æ— è®ºå¦‚ä½•è¦å…‹æœè¿™äº›å›°éš¾ï¼Œè¦ä¸ºè‡ªå·±çš„ç†æƒ³å¥‹æ–—åˆ°åº•ã€‚æœ€åï¼Œæˆ‘ä»¬è¿˜æ˜¯å®Œæˆäº†æˆ‘ä»¬å½“æ—¶çš„ä»»åŠ¡ï¼Œåˆ°è¾¾äº†å½“æ—¶çš„ç›®çš„åœ°ã€‚ å°±ä»¥ä»Šå¤©çš„æŠ—æˆ˜ä¸ºä¾‹å§ï¼Œä¸­å›½çš„æ°‘æ—æŠ—æˆ˜æ˜¯ä¸€ä¸ªæŒä¹…çš„æˆ˜äº‰ï¼Œå›°éš¾ä¹Ÿæ˜¯å¾ˆå¤šçš„ï¼Œæ³¢æŠ˜ä¹Ÿæ˜¯å¾ˆå¤šçš„ã€‚å¦‚æœæˆ‘ä»¬ç¢°åˆ°ä¸€äº›å›°éš¾ï¼Œé­å—ä¸€äº›æŒ«æŠ˜ï¼Œå°±æ‚²è§‚å¤±æœ›ï¼Œå°±å‡†å¤‡åŒæ•Œäººå¦¥åï¼Œé‚£ä¸­å›½å°±æœ‰äº¡å›½çš„å±é™©ã€‚æ˜¾ç„¶åœ°ï¼Œå¦‚æœæˆ‘ä»¬ä¸èƒ½åšæŒæŠ—æˆ˜åˆ°åº•ï¼Œåˆ™æœ€åæˆ˜èƒœæ—¥å¯‡ã€å®ç°æ°‘æ—ç‹¬ç«‹çš„ç†æƒ³æ˜¯ä¸å¯èƒ½çš„ã€‚ æ­£æ˜¯åœ¨è¿™ä¸ªé—®é¢˜ä¸Šï¼Œåœ¨ä¸ºäº†è‡ªå·±ç†æƒ³çš„å®ç°è€Œå¥‹æ–—åˆ°åº•çš„è¿™ä¸ªé—®é¢˜ä¸Šï¼Œæˆ‘ä»¬æœ‰äº›é’å¹´å¸¸å¸¸è¡¨ç¤ºä¸€äº›å¼±ç‚¹ã€‚ä»–ä»¬ä¸€å¼€å§‹å¾€å¾€ä»¥æ— é™çš„çƒ­æƒ…ä¸å…´å¥‹å»å¥”èµ´è‡ªå·±çš„ç†æƒ³ï¼Œä½†æ˜¯ä¸€æ—¦ä»–ä»¬ç¢°åˆ°å›°éš¾ï¼Œç¢°åˆ°æ³¢æŠ˜ï¼Œä»–ä»¬å¾€å¾€ä¸èƒ½åšæŒåˆ°åº•ï¼Œä»¥è‡³åŠé€”è€ŒåºŸã€‚è¿‡å»å¸¸å¸¸æœ‰äººä»¥â€œäº”åˆ†é’Ÿçƒ­åº¦â€è®¥ç¬‘é’å¹´å­¦ç”Ÿã€‚è¿™ç§è®¥ç¬‘åœ¨ç°åœ¨è¯´æ¥å·²ç»ä¸å¯¹äº†ï¼Œå› ä¸ºä¸­å›½é’å¹´å­¦ç”Ÿç»è¿‡æ— æ•°çš„æ–—äº‰ï¼Œç°åœ¨å·²ç»æœ‰äº†æå¤§çš„è¿›æ­¥ã€‚ç„¶è€Œåœ¨æŸäº›éƒ¨åˆ†çš„é’å¹´ä¸­ç¼ºä¹æ–—äº‰çš„åšæŒæ€§ï¼Œåˆ™ä¾ç„¶æ˜¯ä¸å¯å¦è®¤çš„äº‹å®ã€‚ ä¸ºä»€ä¹ˆåœ¨æˆ‘ä»¬éƒ¨åˆ†é’å¹´ä¸­å‘ç”Ÿè¿™ç§ç°è±¡å‘¢?æˆ‘ä»¥ä¸ºæœ‰ä»¥ä¸‹å‡ ä¸ªåŸå› ã€‚ ç¬¬ä¸€ï¼Œæˆ‘ä»¬çš„é’å¹´å¾€å¾€å¯¹äºé©å‘½çš„æŒä¹…æ€§ä¼°è®¡ä¸è¶³ã€‚ è¦æŠŠäººç±»çš„é«˜å°šç†æƒ³å®ç°å‡ºæ¥çš„é©å‘½ï¼Œåƒæˆ‘åœ¨å‰é¢è¯´è¿‡çš„ï¼Œä¸æ˜¯ä¸€å¤©ä¸¤å¤©ä»¥è‡³ä¸€å¹´ä¸¤å¹´çš„äº‹ï¼Œè€Œæ˜¯å‡ åå¹´ä»¥è‡³ä¸Šç™¾å¹´çš„äº‹ã€‚è¿™æ˜¯ä¸€ä¸ªæŒä¹…çš„æ–—äº‰ã€‚ä¸ä½†å®ç°å…±äº§ä¸»ä¹‰ç†æƒ³æ˜¯å¦‚æ­¤ï¼Œå³æœ€åæˆ˜èƒœæ—¥å¯‡ä¹Ÿä¸æ˜¯ä¸€å¹´ä¸¤å¹´çš„äº‹ï¼Œè€Œæ˜¯ä¸€ä¸ªæŒä¹…æˆ˜ã€‚åŒå¿—ä»¬å¤§å¤šæ•°æ˜¯ä»è¥¿å®‰æ­¥è¡Œåˆ°å»¶å®‰çš„ã€‚ä½ ä»¬å¯¹äºèµ°é™•åŒ—çš„å±±åœ°ï¼Œå¤§æ¦‚å·²ç»æœ‰äº†ç›¸å½“çš„ç»éªŒã€‚é©å‘½å°±å¥½åƒèµ°é™•åŒ—çš„å±±åœ°ä¸€æ ·ï¼Œç¿»è¿‡äº†ä¸€åº§å±±åˆä¸€åº§å±±ã€‚ä½ ä»¬åœ¨è·¯ä¸Šä¸æ˜¯å¸¸å¸¸æƒ³ï¼Œç¿»è¿‡äº†å‰é¢ä¸€ä¸ªå±±å¤´ä¸€å®šå†æ²¡æœ‰å±±äº†å§ï¼Œä¸€å®šå¯ä»¥åˆ°å»¶å®‰äº†å§ã€‚ç„¶è€Œäº‹å®å¸¸å¸¸æ˜¯ç›¸åçš„ï¼Œå±±æ¥è¿ç€å±±ï¼Œè€Œå»¶å®‰æ€»æ˜¯è¿˜åœ¨å‰é¢ã€‚è¿™æ ·ä½ ä»¬åœ¨è·¯ä¸Šå°±è¦èµ°åå¤©ï¼Œæ‰å¾—åˆ°è¾¾å»¶å®‰ã€‚è¿™å¯¹äºä½ ä»¬ï¼Œå°±æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„å…¥å­¦è€ƒè¯•ã€‚ç„¶è€Œé©å‘½ç©¶ç«Ÿæ¯”ç¿»å±±è¦æŒä¹…å¾—å¤šï¼Œå›°éš¾å¾—å¤šã€‚å¦‚æœæˆ‘ä»¬é’å¹´å‚åŠ åˆ°é©å‘½ä¸­æ¥ï¼Œæ²¡æœ‰æŒä¹…æ–—äº‰çš„å‡†å¤‡ï¼Œç»“æœæ˜¯ä¸€å®šè¦å¤±æœ›ä¸åŠé€”è€ŒåºŸçš„ã€‚æ­£åƒä½ ä»¬åˆ°å»¶å®‰æ¥ï¼Œå¦‚æœä½ ä»¬æ²¡æœ‰è¿™æ ·ä¸€å®šè¦åˆ°å»¶å®‰çš„å†³å¿ƒï¼Œä½ ä»¬ä¸€å®šä¼šåŠé€”è€Œè¿”çš„ã€‚ ç¬¬äºŒï¼Œæˆ‘ä»¬çš„é’å¹´å¾€å¾€å¯¹äºé©å‘½çš„å›°éš¾æ€§ä¼°è®¡ä¸è¶³ã€‚ è¦æŠŠäººç±»é«˜å°šçš„ç†æƒ³å®ç°å‡ºæ¥çš„é©å‘½ï¼Œä¸å…‹æœæ— æ•°çš„å›°éš¾æ˜¯ä¸å¯èƒ½çš„ã€‚é©å‘½å†³ä¸åƒä¸Šæµ·çš„å¤§é©¬è·¯é‚£æ ·å¹³å¦å¥½èµ°ï¼Œå†³ä¸åƒåƒé¥­ç¡è§‰é‚£æ ·å®¹æ˜“ç®€ä¾¿ã€‚è¿™ç®€ç›´åŒçˆ¬ç€æ²¡æœ‰äººè¿¹åˆ°è¿‡çš„å´å²–çš„é«˜å±±ä¸€æ ·ï¼Œå±±ä¸Šæ²¡æœ‰è·¯ï¼Œæ²¡æœ‰äººå®¶ï¼Œåˆ°å¤„æ˜¯è†æ£˜ä¸æµ“å¯†çš„æ£®æ—ï¼Œåˆ°å¤„æœ‰æ¯’è›‡çŒ›å…½çš„å¨èƒï¼Œæœ‰äº›åœ°æ–¹ç®€ç›´æ˜¯ä¸èƒ½è¶Šè¿‡çš„ç»å£ã€‚ä½†æ˜¯æˆ‘ä»¬å¿…é¡»å‰è¿›ï¼Œå¿…é¡»å…‹æœä¸€åˆ‡å›°éš¾å‰è¿›ã€‚æˆ‘ä»¬æœ‰æ—¶ä¼šè¢«è†æ£˜æ ‘ææ‰€åˆºä¼¤ï¼Œæœ‰æ—¶ä¼šè¢«æ¯’è›‡çŒ›å…½æ‰€å’¬ä¼¤ï¼Œæˆ‘ä»¬å‰é¢çš„ä¼™ä¼´æœ‰æ—¶ä¼šç”¨å°½äº†ä¸€åˆ‡æ°”åŠ›é¢å€’æ¯™ï¼Œä½†æ˜¯æˆ‘ä»¬å¿…é¡»å‰è¿›ã€‚å¦‚æœæˆ‘ä»¬çš„é’å¹´å‚åŠ åˆ°é©å‘½ä¸­æ¥ï¼Œä¸é¢„å…ˆçœ‹åˆ°è¿™ç§å›°é›…ï¼Œæ²¡æœ‰å…‹æœä¸€åˆ‡å›°éš¾çš„å‡†å¤‡ï¼Œé‚£ç»“æœå¿…ç„¶æ˜¯â€œçŸ¥éš¾è€Œé€€â€ã€‚ ç¬¬ä¸‰ï¼Œæ—§ç¤¾ä¼šçš„æ€æƒ³ä¹ æƒ¯ä»¥åŠä¸€åˆ‡ç‰©è´¨ä¸Šçš„è¯±æƒ‘ï¼Œä¹Ÿå¾€å¾€æ˜¯ä½¿é’å¹´åŠé€”è€ŒåºŸçš„ä¸€ç§æå¤§çš„åŠ›é‡ã€‚ æˆ‘ä»¬å¸¸å¸¸çœ‹åˆ°ä¸€æœ‰å¿—çš„é’å¹´ï¼Œå—ä¸èµ·è¿™ç§åŠ›é‡çš„å‹è¿«è€Œé€€å´äº†ï¼Œè€Œæ”¾å¼ƒäº†è‡ªå·±çš„ç†æƒ³ã€‚æ—§ç¤¾ä¼šå¯¹äºé’å¹´çš„ç†æƒ³ï¼Œæ€»æ˜¯å–ç€æ•Œè§†çš„æ€åº¦ã€‚ä»–ä»¬ç”¨å„ç§æ€æƒ³ä¸Šçš„æ¯’ç´ ï¼Œè®¥ç¬‘é’å¹´ï¼Œé™·å®³é’å¹´ï¼Œä½¿é’å¹´â€œè€å¤§â€ï¼Œâ€œé¢“ä¸§â€ï¼Œâ€œæ¶ˆæ²‰â€ã€‚ä»–ä»¬ç”¨åœ°ä½ã€é‡‘é’±ã€ç¾å¥³è…åŒ–é’å¹´ï¼Œç¬¼ç»œé’å¹´ï¼Œæ¶ˆç£¨é’å¹´çš„â€œæœæ°”â€ã€‚ä½ ä»¬çœ‹åˆ°è¿‡æ— æ•°è¿™ç±»çš„ä¾‹å­å§ã€‚å½“é’å¹´å­¦ç”Ÿåœ¨å­¦æ ¡è¯»ä¹¦çš„æ—¶å€™ï¼Œå¾€å¾€â€œå¿—å‘è¿œå¤§â€ï¼Œæƒ³â€œç»™å›½å®¶æ°‘æ—è°‹ç‚¹å¹¸ç¦â€ï¼Œâ€œä¸ºäººç±»è§£æ”¾åšç•ªäº‹ä¸šâ€ï¼Œç„¶è€Œä¸€å‡ºå­¦æ ¡åˆ°æ—§ç¤¾ä¼šä¸­æ··ä¸Šå‡ å¹´ï¼Œå¾€å¾€æŠŠè¿‡å»çš„ä¸€åˆ‡å®Œå…¨æŠ›å¼ƒäº†ã€‚æ—§ç¤¾ä¼šåæ²¡äº†ä»–ä»¬ï¼Œæ—§ç¤¾ä¼šèåŒ–äº†ä»–ä»¬ã€‚æ‰€ä»¥ï¼Œå¦‚æœæˆ‘ä»¬çš„é’å¹´ä¸èƒ½åŒè¿™ç§æ—§åŠ¿åŠ›å¥‹æ–—ï¼ŒåšæŒè‡ªå·±çš„ç†æƒ³ï¼Œä¸ä¸ºè¿™äº›åŠ›é‡æ‰€åŠ¨æ‘‡ï¼Œé‚£ç»“æœä¹Ÿå¿…ç„¶æ˜¯åŠé€”è€ŒåºŸã€‚ ç¬¬å››ï¼Œæˆ‘ä»¬çš„æœ‰äº›é’å¹´æœ¬èº«å¸¸å¸¸æœ‰ä¸€ç§â€œåŠ¨æ‘‡æ€§â€ï¼Œç¼ºä¹è¶³å¤Ÿçš„å¿è€ä¸åšå®šã€‚ æˆ‘ä»¬å¸¸å¸¸ç§°è¿™ç§ç‰¹ç‚¹ä¸ºâ€œå°èµ„äº§é˜¶çº§æ€§â€ã€‚ä»–ä»¬å¾€å¾€ä»Šå¤©å‚åŠ é©å‘½å·¥ä½œï¼Œå°±å¸Œæœ›é©å‘½åœ¨æ˜å¤©èƒœåˆ©ã€‚å¦‚æœæ˜å¤©é©å‘½ä¸èƒ½èƒœåˆ©ï¼Œé‚£ä»–ä»¬å°±å¤±æœ›è€Œæ¶ˆæäº†ã€‚ä»–ä»¬åœ¨é©å‘½å½¢åŠ¿é«˜æ¶¨çš„æ—¶å€™ï¼Œå¸¸å¸¸è¶‹å‘ç‹‚çƒ­ä¸ç›²åŠ¨ï¼Œè€Œåœ¨é©å‘½å½¢åŠ¿ä½è½çš„æ—¶å€™ï¼Œåˆ™åˆè½¬åˆ°æ¶ˆæ²‰ä¸ç»æœ›çš„æ·±æ¸Šã€‚ä»–ä»¬èƒœåˆ©æ—¶å¸¸å¸¸ä¸ºèƒœåˆ©å†²æ˜å¤´è„‘ï¼Œå¤±è´¥æ—¶åˆ™åˆå› å¤±è´¥è€Œå‚å¤´ä¸§æ°”ã€‚ä»–ä»¬ä¸ä¼šæŠŠä»Šå¤©ä¸€ç‚¹ä¸€æ»´çš„åˆ‡å®çš„å·¥ä½œï¼ŒåŒä»–ä»¬è¿œå¤§çš„ç†æƒ³è”ç³»èµ·æ¥ï¼›ä»–ä»¬ä¸èƒ½ç©·å¹´ç´¯æœˆåœ°å»ä¸ºè‡ªå·±çš„è¿œå¤§çš„ç†æƒ³è€Œè¿›è¡Œä»Šå¤©çœ‹æ¥å¥½åƒæ˜¯æ²¡æœ‰ç»“æœçš„å·¥ä½œï¼›ä»–ä»¬å¸¸å¸¸è®¨åŒè¿™ç§â€œçç¢â€ä¸â€œéº»çƒ¦â€çš„å·¥ä½œï¼›ä»–ä»¬ä¸èƒ½æ¸…æ¥šäº†è§£ï¼Œä¸€åˆ‡é©å‘½çš„å·¥ä½œï¼Œåªè¦èƒ½å¤ŸåšæŒåœ°å¹²ä¸‹å»ï¼Œä¸€å®šå¯ä»¥å¾—åˆ°ä¸€å®šçš„æˆç»©ã€‚å·¨å¤§çš„å»ºç­‘å·¥ç¨‹æ²¡æœ‰ä¸€ç –ä¸€ç“¦çš„ç Œç­‘ï¼Œæ˜¯æ°¸è¿œä¸èƒ½æˆåŠŸçš„ã€‚ä¼Ÿå¤§çš„ç†æƒ³ä¸ç»è¿‡è®¸å¤šèƒœåˆ©ä¸å¤±è´¥ï¼Œæ˜¯æ°¸è¿œä¸ä¼šå®ç°çš„ã€‚ è¿™äº›æ˜¯å¸¸å¸¸ä½¿æˆ‘ä»¬çš„é’å¹´ä¸èƒ½åšæŒè‡ªå·±çš„ç†æƒ³ã€ä¸ºè‡ªå·±çš„ç†æƒ³å¥‹æ–—åˆ°åº•çš„åŸå› ã€‚è¿™äº›å¼±ç‚¹çš„å…‹æœï¼Œæ˜¯æ¯ä¸€ä¸ªä¸­å›½é’å¹´çš„ä¸¥é‡ä»»åŠ¡ã€‚è¿™å½“ç„¶ä¸æ˜¯ä¸€ä»¶å®¹æ˜“çš„äº‹ï¼Œç„¶è€Œè¿™ä»¶äº‹æ˜¯å¿…é¡»åšä¸å¯èƒ½åšåˆ°çš„ã€‚ å½“ç„¶ï¼Œä»Šå¤©æˆ‘ä»¬ç¦»å¼€æˆ‘ä»¬çš„ç†æƒ³è¿˜å¾ˆè¿œï¼Œç„¶è€Œæˆ‘ä»¬æ€»æ˜¯åœ¨ä¸€å¤©ä¸€å¤©æ¥è¿‘ç€è‡ªå·±çš„ç†æƒ³ã€‚ç¤¾ä¼šä¸»ä¹‰çš„ç†æƒ³ï¼Œè¿‡å»è¿˜åªæ˜¯åœ¨ä¹¦æœ¬ä¸Šï¼Œè€Œç°åœ¨å·²ç»åœ¨å å…¨ä¸–ç•Œå…­åˆ†ä¹‹ä¸€çš„åœŸåœ°çš„è‹è”ï¼Œå˜æˆäº†å®Œå…¨çš„ç°å®ã€‚æ‰€ä»¥åªè¦æˆ‘ä»¬èƒ½å¤ŸåšæŒè‡ªå·±çš„ç†æƒ³ï¼Œä¸ºè‡ªå·±çš„ç†æƒ³å¥‹æ–—åˆ°åº•ï¼Œæˆ‘ä»¬çš„ç†æƒ³çš„å®ç°æ˜¯å¯èƒ½è€Œä¸”æ˜¯å¿…ç„¶çš„ã€‚ ä¸‰ã€è¦å­¦ä¹ å®ç°ç†æƒ³çš„åŠæ³• æœ‰äº†ç†æƒ³ï¼Œæœ‰äº†å®ç°ç†æƒ³çš„å†³å¿ƒï¼Œæ˜¯ä¸æ˜¯å°±å·²ç»å¤Ÿäº†å‘¢?è¿˜æ˜¯ä¸å¤Ÿçš„ã€‚æˆ‘ä»¬é’å¹´è¿˜è¦æœ‰å®ç°ç†æƒ³çš„åŠæ³•ã€‚ é’å¹´æœ‰ä¸€ç§å¾ˆå¤§çš„é•¿å¤„ï¼Œå°±æ˜¯æœ‰çƒ­çƒˆçš„é©å‘½æƒ…ç»ªï¼Œçº¯æ´å¦ç™½çš„èƒ¸æ€€ã€‚æ­£æ˜¯å› ä¸ºä»–ä»¬æœ‰çƒ­çƒˆçš„é©å‘½æƒ…ç»ªï¼Œæ‰€ä»¥ä»–ä»¬èƒ½å¤Ÿå‹‡å¾€ç›´å‰ï¼Œä¸é¡¾ä¸€åˆ‡å›°éš¾ä¸ä¸ªäººåˆ©ç›Šï¼Œå‘ç€è‡ªå·±çš„ç†æƒ³å‰è¿›ã€‚æ­£æ˜¯å› ä¸ºä»–ä»¬æœ‰çº¯æ´å¦ç™½çš„èƒ¸æ€€ï¼Œå¾ˆå°‘å—åˆ°æ—§ç¤¾ä¼šçš„å„ç§é™ˆè…çš„æ€æƒ³ã€ä¹ æƒ¯ä¸ä¼ ç»Ÿçš„å½±å“ï¼Œæ‰€ä»¥ä»–ä»¬æ¯”è¾ƒå®¹æ˜“æ¥å—é©å‘½çš„çœŸç†ã€‚é’å¹´åŒé‚£äº›éº»æœ¨ä¸ä»çš„äººæ˜¯ä¸ç›¸åŒçš„ï¼ŒåŒé‚£é¡½å›ºå®ˆæ—§çš„æ­»ç¡¬æ´¾ä¹Ÿæ˜¯ä¸ç›¸åŒçš„ã€‚é’å¹´æ˜¯æœ‰ç”Ÿæ°”çš„ï¼Œæ´»è·ƒçš„ï¼Œå……æ»¡ç€æ„‰å¿«ä¸å…‰æ˜çš„ä¸€ä»£ã€‚ä»–ä»¬æ˜¯æ—§ç¤¾ä¼šä¸­ç”Ÿé•¿èµ·æ¥çš„ç¾ä¸½çš„èŠ±ï¼Œä»–ä»¬ä¹Ÿæ˜¯ç¾ä¸½çš„æ–°ç¤¾ä¼šçš„åˆ›é€ è€…ã€‚ åœ¨ä¸­å›½é©å‘½å²ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ä¸¾å‡ºæ— æ•°ä¾‹å­ï¼Œæ¥è¯æ˜ä¸­å›½é’å¹´å¦‚ä½•å¸¸å¸¸ç«™åœ¨æ°‘æ—è§£æ”¾çš„å‰å«åœ°ä½ï¼Œä»¥ä»–ä»¬çš„å¤´é¢…ä¸çƒ­è¡€åˆ›é€ äº†æ— æ•°å¯æ­Œå¯æ³£çš„è‹±å‹‡çš„å…‰è£çš„å²è¯—ã€‚åœ¨ä»Šå¤©ä¼Ÿå¤§çš„æ°‘æ—æŠ—æˆ˜ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åˆ°å¤„çœ‹åˆ°é’å¹´æ€æ ·ä¸ºæ°‘æ—æŠ—æˆ˜çš„æœ€åèƒœåˆ©è€Œè¿›è¡Œç€å‹‡æ•¢æ— æ¯”çš„æ–—äº‰ã€‚å¦‚æœä»–ä»¬æ²¡æœ‰çƒ­çƒˆçš„é©å‘½æƒ…ç»ªä¸çº¯æ´å¦ç™½çš„èƒ¸æ€€ï¼Œåˆ™ä¸€åˆ‡è¿™äº›äº‹ä¸šçš„åˆ›é€ æ˜¯ä¸å¯èƒ½çš„ã€‚æˆ‘ä»¬å…±äº§å…šäººå¯¹äºé’å¹´çš„è¿™ä¸€ä¼˜è‰¯çš„ç‰¹è´¨ï¼Œå°¤å…¶æœ‰æ·±åˆ‡çš„æ„Ÿè§‰ã€‚å½“æˆ‘ä»¬åœ¨æœ€é»‘æš—æœ€å›°éš¾çš„æ—¶å€™ï¼Œå½“åœ¨æˆ‘ä»¬çš„å‘¨å›´åˆ°å¤„æ˜¯ææ€–ä¸é€ è°£æ±¡è”‘çš„æ—¶å€™ï¼Œæˆ‘ä»¬æ€»æ˜¯ä»è®¸å¤šé’å¹´æœ‹å‹é‚£é‡Œå¾—åˆ°ä»–ä»¬çš„åŒæƒ…ä¸æ‹¥æŠ¤ã€‚åœ¨ä»Šå¤©ï¼Œä»–ä»¬å¯¹äºæˆ‘ä»¬æ‰€è¡¨ç¤ºçš„çˆ±æˆ´ä¸ä¿¡ä»»ï¼Œä¹Ÿæ˜¯æˆ‘ä»¬ä¸èƒ½ä»¥è¨€è¯­æ¥è¡¨ç¤ºæ„Ÿæ¿€çš„ã€‚è°éƒ½å¯ä»¥çœ‹åˆ°ï¼Œåœ¨æˆ‘ä»¬å»¶å®‰ï¼Œæ²¡æœ‰å®˜å¯åšï¼Œæ²¡æœ‰è–ªæ°´å¯æ‹¿ï¼Œæ²¡æœ‰å¾ˆå¥½çš„ç”Ÿæ´»å¯è¿‡ï¼Œè¿˜æœ‰ä¸å°‘äººåœ¨æˆ‘ä»¬çš„å‘¨å›´é€ æˆ‘ä»¬çš„è°£è¨€ï¼Œç ´åæˆ‘ä»¬ï¼Œç„¶è€Œä½ ä»¬ä»ç„¶ä¸è¿œåƒé‡Œè€Œæ¥ï¼Œå…¶åŸå› ä½•åœ¨å‘¢?é™¤äº†ä½ ä»¬çš„é‚£ç§çƒ­çƒˆçš„é©å‘½æƒ…ç»ªä¸çº¯æ´å¦ç™½çš„èƒ¸æ€€ï¼Œè¿˜èƒ½æœ‰å…¶ä»–çš„è¯´æ˜å—? é’å¹´çš„è¿™ç§ä¼˜è‰¯çš„å“è´¨ï¼Œæ˜¯æˆ‘ä»¬æ‰€åº”æåŠ›çˆ±æŠ¤ä¸å‘æ‰¬çš„ã€‚ ä½†æ˜¯å…‰æ˜¯çƒ­çƒˆçš„é©å‘½æƒ…ç»ªï¼Œçº¯æ´å¦ç™½çš„èƒ¸æ€€ï¼Œè¿˜æ˜¯ä¸èƒ½å®ç°è‡ªå·±çš„ç†æƒ³ï¼Œå®Œæˆä¼Ÿå¤§çš„é©å‘½äº‹ä¸šçš„ã€‚æœ‰äº›é’å¹´çš„å¼±ç‚¹ï¼Œå¸¸å¸¸è¡¨ç°åœ¨ä¸ä¼šä½¿é©å‘½çš„çƒ­æƒ…å»æœä»äºé©å‘½çš„ç†æ™ºï¼Œä¸ä¼šæŠŠçº¯æ´å¦ç™½å˜ä¸ºå¯¹äºçœŸç†çš„æ·±åˆ»çš„è¿½æ±‚ã€‚å“äº®çš„é©å‘½å£å·ï¼Œè€€çœ¼çš„é©å‘½è¯å¥ï¼Œå¯ä»¥è¿·æƒ‘æˆ‘ä»¬çš„é’å¹´ï¼Œä½¿ä»–ä»¬å‘ç‹‚ï¼Œä½¿ä»–ä»¬ä»¥æ­¤ä¸ºæ»¡è¶³ã€‚ä»–ä»¬å¾€å¾€æŠ“ä½é—®é¢˜çš„ä¸€æ–¹é¢ï¼ŒæŠŠå®ƒå‘æŒ¥ï¼ŒæŠŠå®ƒå¤¸å¤§ï¼Œè®¤ä¸ºè¿™æ˜¯å”¯ä¸€çš„â€œçœŸç†â€ï¼Œæ’é™¤ä¸€åˆ‡å…¶ä»–çš„æ–¹é¢ï¼Œå¦è®¤ä¸€åˆ‡å…¶ä»–çš„æ„è§ã€‚ä»–ä»¬çš„é©å‘½çƒ­æƒ…å®¹æ˜“å˜ä¸ºç›²ç›®çš„å†²åŠ¨ï¼Œä»–ä»¬çš„çº¯æ´å¦ç™½å®¹æ˜“èµ°å‘ç‰‡é¢æ€§ã€ç‹­éš˜æ€§ä¸å¹¼ç¨šç—…ã€‚ä»–ä»¬å¾€å¾€ä¸èƒ½æ›´å†·é™åœ°å»è€ƒè™‘é—®é¢˜ï¼Œæƒ³å‡ºå…·ä½“çš„åŠæ³•æ¥å®ç°è‡ªå·±å½“å‰çš„ä»»åŠ¡ï¼Œæ¥å®ç°è‡ªå·±çš„ç†æƒ³ã€‚è¿™ç§å¼±ç‚¹ï¼Œå½“ç„¶æ˜¯æˆ‘ä»¬çš„é’å¹´æ‰€åº”è¯¥è®¾æ³•å…‹æœçš„ã€‚ æˆ‘ä»¬åº”è¯¥ä½¿æˆ‘ä»¬çš„é’å¹´æ¸…æ¥šåœ°äº†è§£åˆ°ï¼šåœ¨ç†æƒ³ç¡®å®šä¹‹åï¼Œæœ‰äº†ä¸ºç†æƒ³è€Œå¥‹æ–—åˆ°åº•çš„å†³å¿ƒä¹‹åï¼Œå­¦ä¹ å®ç°ç†æƒ³çš„å…·ä½“åŠæ³•å°±æœ‰ç€å†³å®šçš„æ„ä¹‰ã€‚åœ¨è¿™ä¸€æ–¹é¢ï¼Œæˆ‘æƒ³å‘åŒå¿—ä»¬è´¡çŒ®å‡ ç‚¹æ„è§ã€‚ ç¬¬ä¸€ï¼Œå°±æ˜¯è¦äº†è§£å…·ä½“æƒ…å†µã€‚ æˆ‘ä»¬æ— è®ºåšä»€ä¹ˆäº‹ï¼Œé¦–å…ˆçš„é—®é¢˜å°±æ˜¯äº†è§£æƒ…å†µã€‚æ­£åƒä¸€ä¸ªåœ¨å‰çº¿ä¸ŠæŒ‡æŒ¥å†›é˜Ÿçš„å°†å†›ï¼Œä»–ä¸ºäº†è¦å®ç°ä»–æ‰“èƒœä»—çš„ç†æƒ³ï¼Œå°±å¿…é¡»è¦è®²æ±‚ä½œæˆ˜çš„æ–¹æ³•ã€‚è¿™é‡Œï¼Œé¦–å…ˆå°±æ˜¯è¦å¼„æ¸…æ•Œæƒ…ï¼Œç„¶åæ¥å†³å®šä½œæˆ˜çš„è®¡åˆ’ã€‚æˆ‘ä»¬çš„å·¥ä½œæ–¹æ³•ä¹Ÿæ˜¯å¦‚æ­¤ã€‚æ¯”å¦‚ï¼Œä½ ä»¬å°†æ¥ä»å­¦æ ¡æ¯•ä¸šä¹‹åï¼Œä½ ä»¬åˆ°ä¸€ä¸ªåœ°æ–¹å»å·¥ä½œï¼Œä½ ä»¬çš„è´£ä»»å†³ä¸æ˜¯åˆ°é‚£é‡Œå»ç…§ä½ ä»¬è‡ªå·±çš„å¤´è„‘ä¸­æ‰€æƒ³çš„æ¥ä¹±å¹²ä¸€é¡¿ã€‚è€Œæ˜¯è¦é¦–å…ˆäº†è§£å½“æ—¶å½“åœ°çš„å…·ä½“æƒ…å†µï¼Œæ¯”å¦‚é‚£é‡Œçš„æŠ—æˆ˜å½¢åŠ¿ï¼Œé‚£é‡Œçš„æ”¿æ²»ä¸ç»æµï¼Œå„é˜¶çº§ã€å„é˜¶å±‚ã€å„å…šæ´¾ã€å„æ°‘ä¼—å›¢ä½“ä»¥åŠå…šã€æ”¿ã€å†›ã€æ°‘é—´çš„ç›¸äº’å…³ç³»ç­‰ã€‚æ²¡æœ‰è¿™ç§äº†è§£ï¼Œæˆ‘ä»¬å°±æ— æ³•å†³å®šæ­£ç¡®çš„å·¥ä½œæ–¹é’ˆä¸å·¥ä½œè®¡åˆ’æ¥å®ç°è‡ªå·±çš„ç†æƒ³ã€‚ å½“ç„¶äº†è§£å…·ä½“æƒ…å†µä¸æ˜¯ä¸€ä»¶å®¹æ˜“çš„äº‹ã€‚ä½†æ˜¯ï¼Œä¸€åˆ‡å…·ä½“æƒ…å†µéƒ½æ˜¯åœ¨çŸ›ç›¾ä¸­å‘å±•ç€çš„ï¼Œéƒ½æ˜¯ä¾ç…§æ™®éçš„è¾©è¯æ³•çš„è§„å¾‹å˜åŠ¨ç€çš„ï¼Œæ‰€ä»¥åªè¦æˆ‘ä»¬èƒ½å¤ŸæŠŠæ¡ä½è¿™äº›æ–¹æ³•ï¼Œé‚£æ¯”è¾ƒæ­£ç¡®åœ°å»äº†è§£å…·ä½“æƒ…å†µä¹Ÿä¸æ˜¯ä¸å¯èƒ½çš„ã€‚é—®é¢˜åªæ˜¯è¦æˆ‘ä»¬çš„é’å¹´åœ¨æ¥è§¦å…·ä½“æƒ…å†µçš„æ—¶å€™ï¼Œèƒ½å¤Ÿæ›´å¤šåœ°â€œæƒ³ä¸€æƒ³â€ï¼Œæ›´å¤šåœ°ç ”ç©¶ä¸€ä¸‹ï¼Œè€ƒå¯Ÿä¸€ä¸‹ï¼Œå†³ä¸è¦ä»¥è‡ªå·±çš„ä¸€äº›ç‰‡é¢çš„ä¸»è§‚çš„äº†è§£ä¸ºæ»¡è¶³ã€‚ä¸–ç•Œä¸Šçš„ä¸€åˆ‡éƒ½æ˜¯éå¸¸å¤æ‚çš„ï¼Œä¸æ˜¯é©¬é©¬è™è™ã€å†’å†’å¤±å¤±å°±èƒ½å¤Ÿäº†è§£çš„ã€‚å¦‚æœæˆ‘ä»¬æ²¡æœ‰è¿™ç§äº†è§£å…·ä½“æƒ…å†µçš„è¦æ±‚ä¸å¿è€å¿ƒï¼Œé‚£æˆ‘å¯ä»¥å‘Šè¯‰å¤§å®¶ï¼Œä½ ä»¬æ˜¯ä»€ä¹ˆäº‹ä¹Ÿåšä¸å¥½çš„ã€‚ å½“ç„¶ï¼Œè¿™å¹¶ä¸æ˜¯è¯´æˆ‘ä»¬ä¸€å®šè¦å½»åº•äº†è§£å…·ä½“æƒ…å†µä¹‹åæ‰èƒ½å¼€å§‹å·¥ä½œã€‚è¿™ç§å½»åº•äº†è§£ï¼Œåœ¨ä¸€ä¸ªçŸ­çš„æ—¶æœŸå†…æ˜¯ä¸å¯èƒ½çš„ã€‚ä½†æˆ‘ä»¬è¦æ±‚åœ¨å¼€å§‹å·¥ä½œä¹‹å‰ï¼Œæœ‰ä¸€ç§åˆæ­¥çš„ä¸èµ·ç çš„äº†è§£ï¼Œä¸ç„¶ï¼Œåˆ°ä¸€ä¸ªåœ°æ–¹ä¸ç®¡ä¸€åˆ‡ä¹±å¹²ä¸€æ°”ï¼Œé‚£æ˜¯å¼‚å¸¸å±é™©çš„ã€‚ ç¬¬äºŒï¼Œåœ¨æˆ‘ä»¬å¯¹äºå…·ä½“æƒ…å†µæœ‰äº†åˆæ­¥çš„ä¸èµ·ç çš„äº†è§£ä¹‹åï¼Œæˆ‘ä»¬å°±è¦æ ¹æ®å¯¹å…·ä½“æƒ…å†µçš„äº†è§£æ¥å†³å®šæˆ‘ä»¬çš„æ–¹é’ˆï¼Œæˆ‘ä»¬çš„ä»»åŠ¡ï¼Œæ–—äº‰çš„å½¢å¼ï¼Œå·¥ä½œçš„æ–¹æ³•æ–¹å¼ç­‰ã€‚ æ¯”å¦‚ä½ ä»¬ç°åœ¨åˆ°ä¸Šæµ·å·¥ä½œï¼Œä½ ä»¬åœ¨è§£åˆ°äº†ä¸Šæµ·çš„å…·ä½“æƒ…å†µä¹‹åï¼Œä½ ä»¬å°±å¿…é¡»è§„å®šä½ ä»¬ä»Šå¤©åœ¨ä¸Šæµ·éœ€è¦åšä»€ä¹ˆï¼Œèƒ½å¤Ÿåšä»€ä¹ˆï¼Œè€Œä¸”å¦‚ä½•åšæ³•ã€‚æ˜¾ç„¶åœ°ï¼Œåœ¨ä¸Šæµ·æ—¥å¯‡å†›é˜Ÿå é¢†çš„åœ°åŒºï¼Œæˆ‘ä»¬ä»Šå¤©çš„å…·ä½“ä»»åŠ¡ã€æ–—äº‰å½¢å¼ã€å·¥ä½œæ–¹æ³•æ–¹å¼ç­‰ï¼Œå†³ä¸èƒ½åŒå…¶ä»–åŒºåŸŸç›¸åŒã€‚ä½ ä»¬è¦è€è™‘ï¼Œç©¶ç«Ÿä»Šå¤©åœ¨ä¸Šæµ·æ˜¯åŒåœ¨å…¶ä»–æŸäº›æˆ˜åŒºä¸€æ ·åœ°å»å‘å±•æ¸¸å‡»æˆ˜äº‰ï¼Œè¿›è¡Œå…¬å¼€çš„åæ—¥çš„æ´»åŠ¨ï¼Œæˆ–è€…æ˜¯è¿™é‡Œéœ€è¦æ‰§è¡Œå¦ä¸€ç§ä»»åŠ¡ï¼Œå³ç§¯èšè‡ªå·±åŠ›é‡å‡†å¤‡å¾…æ—¶è€ŒåŠ¨çš„ä»»åŠ¡ï¼Œé‡‡å–å¦ä¸€ç§æ–—äº‰å½¢å¼ï¼Œå³ç§˜å¯†çš„åæ—¥æ–—äº‰çš„æ´»åŠ¨å‘¢?æ˜¯ç»„ç»‡å…¬å¼€çš„æŠ—æ•Œåæ´ä¼šï¼Œè¿˜æ˜¯ä¸€æ–¹é¢ç»„ç»‡ç§˜å¯†çš„æŠ—æ—¥å›¢ä½“è€ŒåŒæ—¶å»åˆ©ç”¨å…¬å¼€çš„åˆæ³•çš„ç»„ç»‡å½¢å¼å‘¢?åªæœ‰æ­£ç¡®åœ°è§£å†³è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬æ‰èƒ½ä½¿æˆ‘ä»¬çš„åŠ›é‡å·©å›ºä¸å‘å±•ï¼Œè¾¾åˆ°æœ€åé…åˆå…¨å›½åŠ›é‡æˆ˜èƒœæ—¥å¯‡çš„ç†æƒ³ã€‚å¦‚æœæˆ‘ä»¬çš„ä»»åŠ¡è§„å®šå¾—ä¸æ­£ç¡®ï¼Œå·¥ä½œæ–¹æ³•æ–¹å¼ç­‰éƒ½è§„å®šå¾—ä¸å¯¹ï¼Œé‚£æˆ‘ä»¬å¿…ç„¶ä¼šé­å—ä¸¥é‡çš„å¤±è´¥ï¼Œè€Œè¾¾ä¸åˆ°æˆ‘ä»¬çš„ç›®çš„åœ°ã€‚ åœ¨ç›®å‰å…¨ä¸­å›½äººæ°‘çš„å‰é¢çš„æœ€ä¸­å¿ƒçš„ä»»åŠ¡æ˜¯åšæŒæŠ—æˆ˜ï¼Œæœ€åæˆ˜èƒœæ—¥å¯‡ã€‚ä½†æ˜¯å®ç°è¿™ä¸ªä¸­å¿ƒä»»åŠ¡çš„æ–¹æ³•æ˜¯åœ¨å„ä¸ªå…·ä½“çš„åœ°æ–¹éƒ½ä¸èƒ½å®Œå…¨ç›¸åŒçš„ã€‚æˆ‘ä»¬é’å¹´è¦å–„äºæ ¹æ®ä¸åŒåœ°åŒºçš„å…·ä½“æƒ…å†µï¼Œæ¥å†³å®šå®ç°è¿™ä¸ªä¸­å¿ƒä»»åŠ¡çš„å…·ä½“åŠæ³•ã€‚ç”±äºä¸­å›½æ”¿æ²»ç»æµå‘å±•çš„ä¸å¹³è¡¡ï¼Œç”±äºä¸­å›½çš„åœ°å¤§ç‰©åšï¼Œæ‰€ä»¥å®ç°ç›®å‰ä¸­å¿ƒä»»åŠ¡çš„æ–¹æ³•ï¼Œéƒ½ä¸èƒ½æœ‰åƒç¯‡ä¸€å¾‹çš„å…¬å¼ã€‚å…¬å¼ä¸»ä¹‰å¸¸å¸¸æ˜¯æˆ‘ä»¬å®ç°æ€»ä»»åŠ¡ä¸­çš„æœ€å¤§çš„éšœç¢ç‰©ã€‚ å°±æ˜¯å„åœ°æ–¹çš„å…·ä½“æƒ…å†µï¼Œä¹Ÿä¸æ˜¯å›ºå®šä¸å˜çš„ã€‚å®ƒåŒæ ·åœ°å˜åŠ¨ç€ã€‚æ‰€ä»¥ä½ ä»¬å°±åœ¨ä¸€ä¸ªåœ°æ–¹çš„å·¥ä½œä¸­ä»ç„¶è¦æ—¶æ—¶åˆ»åˆ»æ³¨æ„æ–°çš„æƒ…å†µçš„å˜åŒ–ï¼Œè€ŒåŠæ—¶åœ°æ”¹å˜è‡ªå·±çš„ä»»åŠ¡åŠå·¥ä½œæ–¹æ³•æ–¹å¼ç­‰ã€‚è‡³æ­»ä¸å˜çš„ä¸œè¥¿æ˜¯æ²¡æœ‰çš„ã€‚è¿™é‡Œï¼Œè¦æ±‚æˆ‘ä»¬ä»¥æå¤§çš„çµæ´»æ€§ã€æœºåŠ¨æ€§ä¸åˆ›é€ æ€§ï¼Œæ¥å®ç°è‡ªå·±çš„ç†æƒ³ã€‚å›ºæ‰§è‡ªå·±çš„æ­»å…¬å¼æˆ–è€åŠæ³•ï¼Œç»“æœå¿…ç„¶ä¼šé­å—ä¸¥é‡çš„å¤±è´¥ï¼Œè€Œè¾¾ä¸åˆ°ç›®çš„åœ°ã€‚ ç¬¬ä¸‰ï¼Œåœ¨ä»»åŠ¡ç­‰è§„å®šä¹‹åï¼Œå°±åº”è¯¥ç«‹åˆ»å¼€å§‹è‡ªå·±çš„å®é™…å·¥ä½œã€‚ æˆ‘ä»¬æ˜¯é©å‘½å®¶ï¼Œè¡ŒåŠ¨å®¶ï¼Œè€Œä¸æ˜¯ç©ºè°ˆå®¶ã€‚â€œè®®è€Œä¸å†³ã€å†³è€Œä¸è¡Œâ€çš„æ¶ä¹ æƒ¯ï¼Œæˆ‘ä»¬é’å¹´æ˜¯å†³ä¸åº”è¯¥å­¦ä¹ çš„ã€‚æˆ‘ä»¬å¿…é¡»æŠŠæˆ‘ä»¬è‡ªå·±æ‰€å†³å®šçš„æ–¹é’ˆä¸è®¡åˆ’æ¥è§è¯¸å®è¡Œã€‚åªæœ‰é©å‘½çš„è¡ŒåŠ¨æ‰èƒ½æ”¹é€ ä¸–ç•Œã€‚é©å‘½çš„ä¼Ÿäººé©¬å…‹æ€æ›¾ç»è¯´è¿‡ï¼Œæˆ‘ä»¬çš„ä»»åŠ¡ä¸ä½†åœ¨è®¤è¯†ä¸–ç•Œï¼Œè€Œä¸»è¦çš„åœ¨æ”¹é€ ä¸–ç•Œã€‚è¦æ”¹é€ ä¸–ç•Œå°±è¦æœ‰é©å‘½çš„å®é™…å·¥ä½œï¼Œè€Œä¸”ä¹Ÿåªæœ‰åœ¨å®é™…å·¥ä½œä¸­ï¼Œæˆ‘ä»¬æ‰æ›´èƒ½è¿›ä¸€æ­¥åœ°è®¤è¯†ä¸–ç•Œï¼Œæ›´æ­£ç¡®åœ°æ¥å†³å®šè‡ªå·±çš„ä»»åŠ¡ä¸å·¥ä½œæ–¹æ³•æ–¹å¼ç­‰ã€‚ä¹Ÿåªæœ‰å®é™…å·¥ä½œï¼Œèƒ½å¤Ÿè€ƒéªŒæˆ‘ä»¬è¿‡å»çš„å†³å®šæ˜¯å¦æ­£ç¡®ï¼Œå……å®ä¸å‘å±•æˆ‘ä»¬çš„å†³å®šï¼Œæ”¹æ­£é”™è¯¯ç­‰ã€‚ æ‰€ä»¥æˆ‘ä»¬é’å¹´åœ¨å®é™…å·¥ä½œä¸­ä¹Ÿä»ç„¶ä¸æ˜¯ç›²ç›®åœ°ä¹±å¹²ä¸€é¡¿ï¼Œè€Œè¦æ—¶æ—¶åˆ»åˆ»æ³¨æ„è‡ªå·±åœ¨å®é™…å·¥ä½œä¸­æ‰€ç¢°åˆ°çš„ä¸€åˆ‡é—®é¢˜ï¼Œæ€»ç»“è‡ªå·±åœ¨å®é™…å·¥ä½œä¸­çš„ç»éªŒã€‚å¦‚æœåœ¨å®é™…å·¥ä½œä¸­è¯æ˜è¿‡å»è‡ªå·±çš„å†³å®šæ˜¯ä¸æ­£ç¡®çš„ï¼Œæ˜¯åšä¸é€šçš„ï¼Œé‚£è‡ªå·±åº”è¯¥æ¯«æ— æ€œæƒœåœ°æŠ›å¼ƒè¿‡å»è‡ªå·±çš„å†³å®šï¼Œè€Œæ ¹æ®è‡ªå·±å¯¹äºå…·ä½“æƒ…å†µçš„æ–°çš„äº†è§£æ¥é‡æ–°å†³å®šè‡ªå·±çš„ä»»åŠ¡ã€‚å¦‚æœæœ‰éƒ¨åˆ†çš„é”™è¯¯ï¼Œå³åº”æ”¹æ­£éƒ¨åˆ†çš„é”™è¯¯ã€‚å¦‚æœæœ‰ä¸å¤Ÿçš„åœ°æ–¹ï¼Œå³åº”ä»¥æ–°çš„ç»éªŒä½¿ä¹‹å……å®ï¼Œä½¿ä¹‹å‘å±•ã€‚è¿™é‡Œæ‰€éœ€è¦çš„æ˜¯è™šå¿ƒçš„æœä»çœŸç†çš„æ€åº¦ï¼Œè€Œä¸æ˜¯â€œè‡ªä½œèªæ˜â€å»è›®å¹²ã€‚ä¸é¡¾äº‹å®çš„è›®å¹²ï¼Œæ˜¯ä¼šç¢°åˆ°é’‰å­ä»¥è‡³æ¯ç­è‡ªå·±çš„ã€‚ æ‰€ä»¥æˆ‘ä»¬çš„é’å¹´ï¼Œåº”è¯¥æ—¶æ—¶åˆ»åˆ»åœ¨å®é™…å·¥ä½œä¸­å®è¡Œå·¥ä½œçš„æ£€æŸ¥ï¼Œå‘å±•è‡ªæˆ‘æ‰¹è¯„ï¼Œæ€»ç»“å·¥ä½œä¸­çš„ç»éªŒä¸æ•™è®­ï¼Œä½¿æˆ‘ä»¬çš„å·¥ä½œèƒ½å¤Ÿæ›´å¥½åœ°å¾—åˆ°è¿›æ­¥ä¸æˆç»©ã€‚ä¸€åˆ‡å…ˆè¿›çš„é©å‘½çš„ç†è®ºï¼Œæˆ‘ä»¬ä¹Ÿåªèƒ½å½“ä½œè¡ŒåŠ¨çš„æŒ‡å—è€Œä¸èƒ½å½“ä½œæ•™æ¡ã€‚ä¸€åˆ‡å…ˆè¿›çš„é©å‘½ç†è®ºï¼Œä¹Ÿè¦åœ¨å®è·µä¸­å……å®è‡ªå·±ä¸å‘å±•è‡ªå·±çš„ã€‚ æˆ‘æƒ³ï¼Œè¿™ä¸‰ç‚¹æ˜¯æˆ‘ä»¬é’å¹´äººåœ¨å·¥ä½œä¸­æ‰€åº”è¯¥æ³¨æ„çš„ã€‚è¿™ä¸‰ç‚¹çš„ä¸­å¿ƒæ‰€åœ¨ï¼Œå³æ˜¯è¦ä½¿æˆ‘ä»¬çš„é’å¹´ä¸ä½†è¦æœ‰ç†æƒ³ï¼Œæœ‰å®ç°ç†æƒ³çš„å†³å¿ƒï¼Œè€Œä¸”è¦å­¦ä¹ å®ç°ç†æƒ³çš„å…·ä½“åŠæ³•ã€‚ å½“ç„¶ï¼Œé’å¹´äººç»ˆç©¶æ˜¯é’å¹´äººï¼Œä»–ä»¬ä¸€èˆ¬æ˜¯å¯Œäºé©å‘½çƒ­æƒ…è€Œç¼ºä¹å®é™…ç»éªŒï¼Œå› æ­¤ä»–ä»¬æœ‰æ—¶è¦â€œæ„Ÿæƒ…ç”¨äº‹â€ï¼Œæœ‰ç‚¹â€œå†²åŠ¨â€ï¼Œæœ‰ç‚¹â€œå¹¼ç¨šç—…â€ã€‚æˆ‘ä»¬æŒ‡å‡ºé’å¹´çš„è¿™äº›å¼±ç‚¹ï¼Œå¹¶ä¸æƒ³ä»¥æ­¤æ¥è´£å¤‡é’å¹´ï¼Œè€Œåªæ˜¯è¦æ±‚é’å¹´ä»¬åœ¨è‡ªå·±çš„å·¥ä½œä¸­æ³¨æ„åˆ°è‡ªå·±çš„è¿™äº›å¼±ç‚¹ï¼Œå…‹æœè¿™äº›å¼±ç‚¹ï¼Œä½¿è‡ªå·±é€æ¸åœ°åœ¨å®é™…å·¥ä½œä¸­æˆä¸ºä¸€ä¸ªæ¯”è¾ƒâ€œèƒ½å¹²çš„â€ä¸â€œè€ç»ƒçš„â€é©å‘½é’å¹´ã€‚ å››ã€è¦åŒç¾¤ä¼—åœ¨ä¸€èµ·å»å®ç°è‡ªå·±çš„ç†æƒ³ æˆ‘ä»¬åœ¨å‰é¢å·²ç»è®²è¿‡ï¼Œè¦å®ç°é©å‘½çš„ç†æƒ³ï¼Œä¸€å®šè¦ä¾é äºä¸€å®šçš„ç¤¾ä¼šçš„åŠ›é‡ï¼Œè¿™ç¤¾ä¼šçš„åŠ›é‡å°±æ˜¯åƒåƒä¸‡ä¸‡çš„ç¾¤ä¼—ã€‚å†å²ä¸Šçš„ä¼Ÿäººï¼Œå›ºç„¶åœ¨åˆ›é€ äººç±»å†å²ä¸­èµ·äº†å¾ˆå¤§çš„ä½œç”¨ï¼Œç„¶è€Œå¦‚æœæ²¡æœ‰ç¾¤ä¼—çš„æ‹¥æŠ¤ä¸ç¾¤ä¼—çš„è¡ŒåŠ¨ï¼Œä»»ä½•æ¨åŠ¨å†å²å‰è¿›çš„ç†æƒ³éƒ½æ˜¯ä¸å¯èƒ½å®ç°çš„ã€‚æ‰€ä»¥æˆ‘ä»¬é’å¹´è¦å®ç°è‡ªå·±çš„ç†æƒ³ï¼Œå°±å¿…é¡»è¦èƒ½å¤Ÿç‡é¢†ç¾¤ä¼—å»ä¸ºè‡ªå·±çš„ç†æƒ³å¥‹æ–—ã€‚ é’å¹´åœ¨é©å‘½è¡ŒåŠ¨ä¸­è‚¯è´Ÿè´£ï¼Œè‚¯å‡ºå¤´ï¼Œè‚¯æ‰“å…ˆé”‹ï¼Œè¿™æ˜¯å¾ˆå¯å®è´µçš„å“è´¨ã€‚åœ¨ä¸­å›½æ°‘æ—è§£æ”¾çš„å†å²ä¸­ï¼Œé’å¹´å¸¸å¸¸èµ·ç€å…ˆé”‹çš„ä½œç”¨ï¼Œå°±æ˜¯ç”±äºé’å¹´è¿™ç§ä¼˜è‰¯å“è´¨çš„ç»“æœã€‚ä½†æ˜¯å°±åœ¨è¿™ä¸ªæ–¹é¢ï¼Œéƒ¨åˆ†é’å¹´ä»ç„¶è¡¨ç°å‡ºä»–ä»¬çš„å¼±ç‚¹ã€‚ä»–ä»¬è‚¯è´Ÿè´£ï¼Œè‚¯å‡ºå¤´ï¼Œè‚¯æ‰“å…ˆé”‹çš„å“è´¨ï¼Œå¾€å¾€å‘å±•åˆ°å¥½å‡ºé£å¤´ï¼Œç›®ç©ºä¸€åˆ‡ï¼Œè‡ªé«˜è‡ªå¤§ï¼ŒåŒ…åŠï¼Œä¸è€çƒ¦ï¼Œè„±ç¦»ç¾¤ä¼—çš„åå‘ã€‚è¿™ç§ä¾‹å­ï¼Œæˆ‘æ˜¯è§å¾—å¾ˆå¤šçš„ï¼Œä¸çŸ¥é“ä½ ä»¬è§è¿‡æ²¡æœ‰?æˆ‘æƒ³ä¸€å®šæ˜¯è§è¿‡çš„ã€‚ åœ¨é™•åŒ—å…¬å­¦å­¦ä¹ çš„é’å¹´ï¼Œä¸€èˆ¬åœ°æ˜¯è§‰æ‚Ÿç¨‹åº¦è¾ƒé«˜çš„ä¸€éƒ¨åˆ†ä¸­å›½äººï¼Œä»–ä»¬çš„ç¡®æœ‰è´£ä»»å»é¢†å¯¼å¦ä¸€éƒ¨åˆ†æ¯”è¾ƒè½åè€Œåˆå æœ€å¤§å¤šæ•°çš„ä¸­å›½äººï¼Œå‘åŠ¨ä»–ä»¬ï¼Œæ•™è‚²ä»–ä»¬ï¼Œè®­ç»ƒä»–ä»¬ï¼Œä»¥æé«˜ä»–ä»¬çš„æ”¿æ²»æ°´å¹³ä¸ç»„ç»‡åŠ›é‡ã€‚æ²¡æœ‰å…ˆé”‹çš„é¢†å¯¼ï¼Œå¹¿å¤§çš„æ¯”è¾ƒè½åçš„ç¾¤ä¼—ï¼Œæ˜¯ä¸ä¼šè‡ªå·±èµ°åˆ°å…ˆé”‹çš„åœ°ä½çš„ï¼Œè¿™æ˜¯æ— å¯å¦è®¤çš„çœŸç†ã€‚ ç„¶è€Œæ€æ ·å¯ä»¥ä½¿æˆ‘ä»¬é™•å…¬çš„é’å¹´èƒ½å¤Ÿè´Ÿæ‹…èµ·è¿™ä¸ªå…ˆé”‹çš„é¢†å¯¼çš„è´£ä»»å‘¢?æ˜¯ä¸æ˜¯æˆ‘ä»¬é’å¹´è£…å‡ºä¸€ä¸ªé¢†å¯¼è€…çš„æ¶å­ï¼Œè‡ªå‘½ä¸å‡¡ï¼Œç›®ç©ºä¸€åˆ‡ï¼Œå°±èƒ½å¤Ÿå®ç°è¿™ä¸ªé¢†å¯¼ä½œç”¨å‘¢?æ˜¯ä¸æ˜¯åªè¦æˆ‘ä»¬çš„é’å¹´æŠŠæˆ‘ä»¬çš„ç†æƒ³åœ¨ç¾¤ä¼—å‰é¢ä¸€è§£é‡Šä¸€å®£å¸ƒï¼Œç¾¤ä¼—å°±ä¼šè·Ÿäº†æˆ‘ä»¬èµ°ï¼Œå°±å®ç°äº†æˆ‘ä»¬çš„é¢†å¯¼ä½œç”¨å‘¢?è¿™äº›éƒ½æ˜¯ä¸èƒ½æˆåŠŸçš„ã€‚ä»»ä½•é¢†å¯¼è€…ï¼Œå¦‚æœè‡ªå‘½ä¸å‡¡ï¼Œç›®ç©ºä¸€åˆ‡ï¼Œè£…å‡ºé¢†å¯¼è€…çš„æ¶å­ï¼Œé‚£ç»“æœä»–ä¸ä½†ä¸èƒ½é¢†å¯¼ç¾¤ä¼—ï¼Œè€Œä¸”ä¼šè„±ç¦»ç¾¤ä¼—ã€‚è‡³äºæŠŠå¾ˆç¾ä¸½çš„ç†æƒ³è®²ç»™ç¾¤ä¼—å¬;ç¾¤ä¼—è‡ªç„¶å¯èƒ½æ¥å¬ä¸€ä¸‹ï¼Œç„¶è€Œè¦ä»–ä»¬ä¸ºäº†è¿™ä¸ªç†æƒ³æ¥ç‰ºç‰²å¥‹æ–—ï¼Œé‚£å•é è¿™ç§å®£ä¼ å·¥ä½œæ˜¯ä¸èƒ½è¾¾è‡³åˆ°ç›®çš„çš„ã€‚ é¢†å¯¼ç¾¤ä¼—ï¼Œæ˜¯ä¸€ä»¶éå¸¸ä¸å®¹æ˜“çš„äº‹ã€‚é’å¹´äººå†³ä¸è¦æŠŠè¿™ä¸ªé—®é¢˜çœ‹å¾—å¤ªç®€å•äº†ã€‚è¿™é‡Œï¼Œç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯è¦æ±‚æˆ‘ä»¬çš„é’å¹´åˆ°ç¾¤ä¼—ä¸­å»ã€‚æˆ‘ä»¬çš„é’å¹´å¯¹äºâ€œç¾¤ä¼—â€ä¸¤ä¸ªå­—çš„è§‚å¿µå¸¸å¸¸æ˜¯æ¯”è¾ƒæŠ½è±¡çš„ï¼Œæœ‰æ—¶æŠŠâ€œç¾¤ä¼—â€ç†æƒ³åŒ–ï¼Œæœ‰æ—¶çœ‹ä¸èµ·â€œç¾¤ä¼—â€ï¼Œè€Œä¸èƒ½æ´»ç”Ÿç”Ÿåœ°å»äº†è§£â€œç¾¤ä¼—â€ã€‚æ‰€ä»¥ä¸‹å†³å¿ƒåˆ°ç¾¤ä¼—ä¸­å»ï¼Œå®æ˜¯å¼€å§‹é¢†å¯¼ç¾¤ä¼—æ—¶çš„å¿…è¦çš„ä¸€æ­¥ã€‚ æˆ‘ä»¬é’å¹´åˆ°äº†ç¾¤ä¼—ä¸­ä¹‹åï¼Œå°±è¦å­¦ä¹ å¦‚ä½•å»æ¥è¿‘ç¾¤ä¼—ï¼Œå»åŒä»–ä»¬ç”Ÿæ´»åœ¨ä¸€èµ·ï¼Œå»äº†è§£ä»–ä»¬ï¼Œä»¥è‡³å–å¾—ä»–ä»¬çš„ä¿¡ä»»ã€‚è¿™é‡Œï¼Œé¦–å…ˆå°±æ˜¯è¦æ—¶æ—¶åˆ»åˆ»å»ä¸ºç¾¤ä¼—æœåŠ¡ï¼Œå¤„å¤„èƒ½å¤Ÿä¸ºä»–ä»¬è°‹åˆ©ç›Šï¼Œä¸ºä»–ä»¬çš„åˆ©ç›Šç‰ºç‰²è‡ªå·±çš„ä¸€åˆ‡ã€‚å…¶æ¬¡ï¼Œè¦æˆ‘ä»¬å¤„å¤„è°¦é€Šå’Œæ°”ï¼Œåˆ»è‹¦è€åŠ³ï¼Œå®½å®å¤§é‡ï¼Œæ€¥å…¬å¥½ä¹‰ï¼Œè¯²äººä¸å€¦ï¼Œåšäººå®¶çš„æ¨¡èŒƒä¸æ•™å¸ˆã€‚ç¬¬ä¸‰ï¼Œè¦èƒ½å¤Ÿå›¢ç»“ä¸åŸ¹å…»ç¾¤ä¼—ä¸­çš„ç§¯æåˆ†å­ï¼Œå‘æŒ¥ç§¯æåˆ†å­çš„ä½œç”¨ã€‚ä¾é ç§¯æåˆ†å­æ¨åŠ¨å…¨ä½“ã€‚ç¬¬å››ï¼Œè¦ä»¥æ°‘ä¸»çš„ç²¾ç¥ä¸æ°‘ä¸»çš„å·¥ä½œæ–¹æ³•æ¥å¸æ”¶ä¸æ•™è‚²ç¾¤ä¼—ç§¯æå‚åŠ å·¥ä½œï¼Œä¸è¦ä¸ªäººåŒ…åŠä¸€åˆ‡ã€‚ç¬¬äº”ï¼Œè¦å–„äºå­¤ç«‹æœ€é¡½å›ºçš„å°‘æ•°åäººï¼Œä¾é ç¾¤ä¼—çš„å…¬æ„¤å»æ‰“å‡»ä»–ä»¬ä¸é©±é€ä»–ä»¬ã€‚åªè¦è¿™æ ·ã€‚ç¾¤ä¼—å°±ä¼šæŠŠæˆ‘ä»¬å½“ä½œä»–ä»¬â€œè‡ªå·±çš„äººâ€ï¼Œå°±ä¼šä¿¡ä»»æˆ‘ä»¬ï¼Œæ¥å—æˆ‘ä»¬çš„é¢†å¯¼ã€‚ æ— ç–‘çš„ï¼Œå½“æˆ‘ä»¬çœŸæ­£æ·±å…¥åˆ°ç¾¤ä¼—ä¸­å»æ—¶ï¼Œæˆ‘ä»¬å¿…ç„¶ä¼šçœ‹åˆ°ç¾¤ä¼—ä¸­æœ‰è®¸å¤šè½åæ„è¯†ï¼Œè½åçš„æ€æƒ³ä¸ä¹ æƒ¯ï¼Œä»–ä»¬çš„ç‹­éš˜çš„å®—æ³•çš„ä¸è¡Œä¼šçš„è§‚ç‚¹ã€‚è¿™ä¸€åˆ‡æˆ‘ä»¬éƒ½ä¼šç¢°åˆ°çš„ã€‚ç„¶è€Œæˆ‘ä»¬æ˜¯ä¸æ˜¯å› æ­¤å°±å¤±æœ›è€Œè„±ç¦»ä»–ä»¬å‘¢?å†³ä¸æ˜¯çš„ã€‚æˆ‘ä»¬çš„è´£ä»»ï¼Œæ­£æ˜¯è¦æé«˜ä»–ä»¬çš„æ”¿æ²»æ°´å¹³ï¼Œå…‹æœä»–ä»¬çš„è½åæ€§ã€‚ä½†æ˜¯å½“æˆ‘ä»¬è®¤çœŸåœ¨ç¾¤ä¼—ä¸­å·¥ä½œæ—¶ï¼Œæˆ‘ä»¬æ›´ä¼šç¢°åˆ°ç¾¤ä¼—ä¸­çš„å…‰æ˜çš„ä¸€é¢ï¼Œä»–ä»¬çš„ä¸°å¯Œçš„é©å‘½æ€§ä¸ä»–ä»¬çš„ä¼Ÿå¤§çš„é©å‘½åŠ›é‡ã€‚æˆ‘ä»¬åœ¨ä»–ä»¬çš„æ·±å¤„ï¼Œå¯ä»¥çœ‹åˆ°åœ¨æ—§ç¤¾ä¼šçš„ä¸Šå±‚æ‰€æ²¡æœ‰çš„é‚£ç§å¾·æ€§ã€‚ä»–ä»¬çš„åŠ›é‡ï¼Œä»–ä»¬çš„å¾·æ€§ï¼Œå¯ä»¥ç»™æˆ‘ä»¬ä»¥æœ€å¤§çš„ä¿¡å¿ƒï¼Œä½¿æˆ‘ä»¬ç›¸ä¿¡ä»–ä»¬æ˜¯æˆ‘ä»¬çš„æœ€ä¼Ÿå¤§ç†æƒ³çš„è´Ÿæ‹…è€…ï¼Œè€Œä¸”ä»–ä»¬æœ€åä¸€å®šèƒ½èƒœåˆ©ã€‚è¿™å°±ä½¿æˆ‘ä»¬åœ¨ä»–ä»¬ä¸­é—´æ„Ÿè§‰åˆ°ä¸€ç§å´‡é«˜çš„å®‰æ…°ä¸å–œæ‚¦ï¼Œè¿™å°±ä½¿æˆ‘ä»¬åœ¨ä»»ä½•å›°éš¾çš„æƒ…å½¢ä¹‹ä¸‹ï¼Œæ€»æ˜¯ä¸ä¼šè„±ç¦»ä»–ä»¬ï¼Œè€Œä¸”æ€»æ˜¯è¦ä¾é ä»–ä»¬çš„åŠ›é‡æ¥å…‹æœä¸€åˆ‡å›°éš¾ã€‚äº‹å®å·²ç»è¯æ˜ï¼Œæ­£åœ¨è¯æ˜ï¼Œå°†è¦è¯æ˜ï¼Œä¸€åˆ‡æˆ‘ä»¬å½“å‰çš„å›°éš¾ï¼Œåªè¦æˆ‘ä»¬çœŸèƒ½å‘åŠ¨åƒç™¾ä¸‡ç¾¤ä¼—èµ·æ¥ï¼Œå¹¶ä¸”ä¾é ä»–ä»¬çš„åŠ›é‡ï¼Œå°±æ˜¯ä¸€å®šèƒ½å¤Ÿå…‹æœçš„ã€‚ä¸€åˆ‡å‰è¿›çš„é©å‘½è€…ï¼Œæ˜¯å†³ä¸åº”è¯¥æƒ§æ€•ç¾¤ä¼—çš„ï¼Œç›¸åçš„ï¼Œä»–ä»¬å¿…é¡»ä¾é ç¾¤ä¼—ã€‚ é¢†å¯¼ç¾¤ä¼—çš„ç¬¬äºŒä¸ªé—®é¢˜ï¼Œå°±æ˜¯è¦å–„äºä½¿ç¾¤ä¼—æ ¹æ®è‡ªèº«çš„ç»éªŒæ¥äº†è§£æˆ‘ä»¬çš„é¢†å¯¼çš„æ­£ç¡®ã€‚æ¯”å¦‚æŠ—æ—¥æ°‘æ—ç»Ÿä¸€æˆ˜çº¿çš„æ–¹é’ˆï¼Œå¼€å§‹æ—¶ä¸æ˜¯å¤§å¤šæ•°ä¸­å›½äººéƒ½èƒ½äº†è§£ä¸æ‹¥æŠ¤çš„ã€‚å½“æ—¶æˆ‘ä»¬ç”¨ä»€ä¹ˆå£å·ä½¿ç¾¤ä¼—æ ¹æ®è‡ªèº«çš„ç»éªŒæ¥äº†è§£æˆ‘ä»¬çš„æ–¹é’ˆçš„æ­£ç¡®å‘¢?è¿™å°±æ˜¯â€œåœæ­¢å†…æˆ˜ï¼Œä¸€è‡´æŠ—æ—¥â€çš„å£å·ã€‚æ¯ä¸€ä¸ªæœ‰è‰¯å¿ƒçš„ä¸­å›½äººï¼Œå¯¹äºä¸­å›½å†…æˆ˜çš„ç—›è‹¦éƒ½æ˜¯åˆ‡èº«æ„Ÿå—åˆ°çš„ï¼Œä»–ä»¬éƒ½èƒ½å¤Ÿæ‡‚å¾—æ—¥å¯‡çš„æ— é™åˆ¶çš„ä¾µæ åŒå†…æˆ˜æ˜¯ä¸èƒ½åˆ†ç¦»çš„ã€‚å› æ­¤ä»–ä»¬ä¹Ÿè®¸è¿˜ä¸äº†è§£æŠ—æ—¥æ°‘æ—ç»Ÿä¸€æˆ˜çº¿çš„æ–¹é’ˆï¼Œç„¶è€Œå¯¹äºâ€œåœæ­¢å†…æˆ˜ï¼Œä¸€è‡´æŠ—æ—¥â€çš„å£å·æ˜¯çƒ­çƒˆæ‹¥æŠ¤çš„ã€‚ç»“æœï¼Œå†…æˆ˜åœæ­¢äº†ï¼Œä¸­å›½å¼€å§‹ç»Ÿä¸€äº†ï¼ŒæŠ—æ—¥æ°‘æ—ç»Ÿä¸€æˆ˜çº¿å¾—åˆ°äº†åˆæ­¥çš„æˆåŠŸã€‚ä¸ä¹…å¢æ²Ÿæ¡¥äº‹å˜å‘ç”Ÿäº†ã€‚å½“æ—¶æˆ‘ä»¬ç”¨ä»€ä¹ˆå£å·ä½¿ç¾¤ä¼—æ ¹æ®è‡ªèº«çš„ç»éªŒæ¥äº†è§£æˆ‘ä»¬çš„æ–¹é’ˆçš„æ­£ç¡®å‘¢?è¿™å°±æ˜¯â€œä¸ºä¿å«å¹³æ´¥ã€ä¿å«ååŒ—ã€ä¿å«å…¨ä¸­å›½è€Œæˆ˜â€ã€‚æ¯ä¸€ä¸ªæœ‰è‰¯å¿ƒçš„ä¸­å›½äººï¼Œå¯¹äºæ—¥å¯‡çš„è¿™ç§æ— é™åˆ¶çš„ä¾µæ å·²ç»åˆ°äº†ä¸èƒ½å†è¡Œå¿è€çš„åœ°æ­¥ï¼Œä»–ä»¬éƒ½è¦æ±‚æŠµæŠ—ã€‚å…¨å›½æŠ—æˆ˜å¼€å§‹äº†ï¼Œäºæ˜¯æŠ—æ—¥æ°‘æ—ç»Ÿä¸€æˆ˜çº¿æœ‰äº†è¿›ä¸€æ­¥çš„æˆåŠŸã€‚åœ¨æŠ—æˆ˜å‘åŠ¨ä¹‹åï¼Œæˆ‘ä»¬ç”¨ä»€ä¹ˆå£å·ä½¿ç¾¤ä¼—æ ¹æ®åˆ‡èº«çš„ç»éªŒæ¥äº†è§£æˆ‘ä»¬çš„æ–¹é’ˆçš„æ­£ç¡®å‘¢?è¿™å°±æ˜¯â€œåšæŒæŠ—æˆ˜ã€äº‰å–æŠ—æˆ˜æœ€åèƒœåˆ©â€çš„å£å·ã€‚æ¯ä¸€ä¸ªæœ‰è‰¯å¿ƒçš„ä¸­å›½äººï¼Œå¯¹äºè¿™ä¸ªå£å·æ˜¯èƒ½å¤Ÿæ‡‚å¾—çš„ï¼Œå› ä¸ºè°éƒ½å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœä¸­å›½ä»Šå¤©åŠé€”æŠ•é™å¦¥åï¼Œé‚£ä¸­å›½å°±ä¼šäº¡å›½ï¼Œä¸­å›½äººå°±ä¼šå˜ä¸ºäº¡å›½å¥´ï¼Œè€Œäº¡å›½å¥´æ˜¯ä¸å¥½å½“çš„ã€‚äºæ˜¯æŠ—æ—¥æ°‘æ—ç»Ÿä¸€æˆ˜çº¿æœ‰äº†æ›´è¿›ä¸€æ­¥çš„æˆåŠŸã€‚ è¿™ä¸è¿‡æ˜¯ä¸¾ä¸€ä¸ªä¾‹å­ç½¢äº†ã€‚ä¸ä½†åœ¨æå‡ºå£å·ä¸Šæ˜¯å¦‚æ­¤ï¼Œå³åœ¨æ–—äº‰å½¢å¼çš„é‡‡ç”¨ä¸Šä¹Ÿæ˜¯å¦‚æ­¤ã€‚æˆ‘ä»¬è¦ä½¿è‡ªå·±ä¸è„±ç¦»ç¾¤ä¼—ï¼Œå¿…é¡»é‡‡å–é‚£ç§èƒ½å¤Ÿå¸å¼•ç¾¤ä¼—å‚åŠ çš„æ–—äº‰å½¢å¼ï¼Œä»–ä»¬è®¤ä¸ºä»Šå¤©å¯ä»¥è€Œä¸”éœ€è¦çš„æ–—äº‰å½¢å¼ï¼Œä»¥é”»ç‚¼ä»–ä»¬ï¼Œæé«˜ä»–ä»¬çš„è§‰æ‚Ÿç¨‹åº¦ä¸ç»„ç»‡åŠ›é‡ã€‚åœ¨æ–—äº‰å½¢å¼ä¸Šæ˜¯å¦‚æ­¤ï¼Œåœ¨å…¶ä»–é—®é¢˜ä¸Šä¹Ÿè«ä¸å¦‚æ­¤ã€‚ ä¸ä¼°è®¡ç¾¤ä¼—ä»Šå¤©è§‰æ‚Ÿçš„ç¨‹åº¦ï¼Œè€Œæå‡ºå¾ˆé«˜å¾ˆâ€œå·¦â€çš„å£å·ï¼Œæ˜¯å†³ç„¶ä¸èƒ½åŠ¨å‘˜ç¾¤ä¼—å‚åŠ è¿åŠ¨çš„ã€‚è¿™é‡Œéœ€è¦é‡‡å–å„ç§è¿‡æ¸¡çš„åŠæ³•æ¥åŠ¨å‘˜ä»–ä»¬ï¼Œå†åœ¨è¿åŠ¨ä¸­æé«˜ä»–ä»¬èµ°å‘æˆ‘ä»¬çš„ç†æƒ³ã€‚è¿™é‡Œï¼Œä¸€åˆ‡æ€¥æ€§ç—…æ˜¯æœ‰å®³çš„;è¿™é‡Œï¼Œé¢†å¯¼è€…çš„åŠªåŠ›å·¥ä½œçš„ç²¾ç¥ï¼Œè¦åŒæå¤§çš„å¿è€å¿ƒé…åˆèµ·æ¥ã€‚ç¾¤ä¼—çš„è§‰æ‚Ÿçš„é€Ÿåº¦ï¼Œä¸ä½†ä¾é äºæˆ‘ä»¬çš„å·¥ä½œï¼Œè€Œä¸”ä¾é äºæ— æ•°å®¢è§‚çš„æ”¿æ²»ç»æµçš„è¦ç´ ã€‚é©å‘½æ˜¯å†³ä¸èƒ½å‡­ä¸»è§‚çš„æ„¿æœ›æ¥åˆ¶é€ çš„ã€‚åœ¨æ²¡æœ‰é©å‘½å½¢åŠ¿çš„æ—¶å€™ï¼Œç‰¹åˆ«åœ¨ååŠ¨çš„é»‘æš—çš„æ—¶æœŸï¼Œç¾¤ä¼—è§‰æ‚Ÿçš„é€Ÿåº¦éå¸¸ç¼“æ…¢ã€‚é‚£æ—¶æˆ‘ä»¬å¦‚æœæ²¡æœ‰ç­‰å¾…æ—¶æœºçš„å¿è€å¿ƒï¼Œè€Œæƒ³ç”¨å¼ºè¿½å‘½ä»¤çš„æ–¹æ³•å»å¯¹å¾…ç¾¤ä¼—ï¼Œé‚£ç»“æœæ˜¯å¿…ç„¶ä¼šå¤±è´¥çš„ã€‚æ‰€è°“ç­‰å¾…æ—¶æœºï¼Œå½“ç„¶ä¸æ˜¯ä¸è¦åŠªåŠ›å·¥ä½œï¼Œè€Œæ˜¯æŠŠæˆ‘ä»¬çš„å·¥ä½œæ”¾åœ¨å‡†å¤‡å¿…è¦çš„åŠ›é‡ä¸Šï¼Œä»¥ä¾¿å°†æ¥é©å‘½å½¢åŠ¿åˆ°æ¥æ—¶ï¼Œç¾¤ä¼—æˆåƒæˆä¸‡å·å…¥é©å‘½æµªæ½®ä¸­æ—¶ï¼Œæˆ‘ä»¬èƒ½å¤Ÿç«™åœ¨æµªæ½®çš„å‰é¢è´Ÿæ‹…èµ·é¢†å¯¼è€…çš„è´£ä»»ã€‚ åœ¨ç¾¤ä¼—å·¥ä½œçš„å‘½ä»¤ä¸»ä¹‰ï¼Œç»“æœæ²¡æœ‰ä¸é­å—å¤±è´¥çš„ã€‚ç¾¤ä¼—åœ¨æŸç§å‹åŠ›ä¹‹ä¸‹ï¼Œå¯èƒ½å‹‰å¼ºåœ°æœä»ï¼Œç„¶è€Œä¸€åˆ‡ä¸æ ¹æ®ç¾¤ä¼—è‡ªè§‰çš„æœä»ï¼Œè¿åäºä»–ä»¬æ„å¿—çš„æœä»ï¼Œæœ€åå¿…ç„¶ä¼šå¼•èµ·ä»–ä»¬åæŠ—å¹¶æ¨ç¿»é‚£äº›å‹è¿«è€…æˆ–å‘½ä»¤ä¸»ä¹‰è€…ã€‚åªæœ‰ç¾¤ä¼—è‡ªè§‰çš„è‡ªæ„¿çš„æœä»ï¼Œæ‰èƒ½å‘æŒ¥ç¾¤ä¼—çš„ç§¯ææ€§ä¸åˆ›é€ åŠ›é‡åˆ°æœ€é«˜é™åº¦ï¼Œæ¥å®ç°æˆ‘ä»¬è¿œå¤§çš„ç†æƒ³ã€‚æ‰€ä»¥æˆ‘ä»¬é¢†å¯¼ç¾¤ä¼—çš„ä¸­å¿ƒé—®é¢˜ï¼Œä¹Ÿå°±æ˜¯å¦‚ä½•ä½¿ç¾¤ä¼—å¿ƒæ‚¦è¯šæœåœ°æ¥æ¥å—æˆ‘ä»¬çš„é¢†å¯¼ï¼Œå¹¶ä¸”ä¸ºäº†æˆ‘ä»¬çš„ç†æƒ³çš„å®ç°ç‰ºç‰²ä¸€åˆ‡ã€‚è¿™å°±è¦æ±‚æˆ‘ä»¬åœ¨é¢†å¯¼å·¥ä½œä¸­å–„äºä½¿ç¾¤ä¼—èƒ½å¤Ÿæ ¹æ®è‡ªèº«çš„ç»éªŒæ¥äº†è§£æˆ‘ä»¬é¢†å¯¼çš„æ­£ç¡®ã€‚è¿™é‡Œï¼Œåº”è¯¥åå¯¹é‚£äº›å…‰ä¼šå–Šå–Šé©å‘½å£å·ã€å”±å”±é«˜è°ƒçš„ç©ºè°ˆä¸»ä¹‰è€…ï¼Œä¸ä¼å›¾ä»¥å¼ºè¿«å‘½ä»¤çš„æ–¹æ³•æ¥â€œé©±ä½¿ç¾¤ä¼—ä¸ºå·±ç”¨â€çš„è€çˆ·ä»¬! ä½†æ˜¯ï¼Œå½“é©å‘½å½¢åŠ¿è¿…é€Ÿå‘å±•ã€ç¾¤ä¼—è§‰é†’çš„é€Ÿåº¦ä¸€æ—¥åƒé‡Œçš„æ—¶å€™ï¼Œæˆ‘ä»¬è¦è°¨é˜²è‡ªå·±è½åäºç¾¤ä¼—ï¼Œå˜ä¸ºç¾¤ä¼—çš„å°¾å·´ã€‚åœ¨è¿™ç§æƒ…å†µä¹‹ä¸‹ï¼Œæˆ‘ä»¬ä»ç„¶åº”è¯¥ç«™åœ¨ç¾¤ä¼—çš„å‰é¢ï¼Œç»„ç»‡ç¾¤ä¼—çš„ç§¯ææ€§å‘ç€ä¸€å®šçš„ç›®æ ‡å‰è¿›ã€‚æˆ‘ä»¬è¦å–„äºè¿…é€Ÿåœ°æ”¹å˜è¿‡æ—¶çš„å£å·ï¼Œæå‡ºæ–°çš„æ›´é«˜çš„åŠ¨å‘˜å£å·ï¼Œé‡‡å–å¤§åˆ€é˜”æ–§çš„åŠæ³•æ¥åŠ¨å‘˜ã€ç»„ç»‡ä¸æ­¦è£…ç¾¤ä¼—ï¼Œæ¨åŠ¨ç¾¤ä¼—æ–—äº‰èµ°å‘æœ€é«˜çš„å½¢å¼ã€‚æ¯”å¦‚åœ¨ç›®å‰è¢«æ•Œäººå é¢†åŒºåŸŸçš„å¹¿å¤§ä¹¡æ‘ä¸æˆ˜åŒºçš„æƒ…å†µï¼Œå°±æ˜¯å¦‚æ­¤ã€‚ç¾¤ä¼—æŠ—æ—¥çš„æ–—äº‰å¾€å¾€ä¸€å¼€å§‹å°±é‡‡å–æ­¦è£…æ–—äº‰çš„å½¢å¼ã€‚åœ¨è¿™é‡Œï¼Œå‡ å¤©å†…ç¾¤ä¼—æ‰€è¾¾åˆ°çš„è§‰é†’ç¨‹åº¦ï¼Œå¯ä»¥æ¯”ä¸Šè¿‡å»çš„å‡ åå¹´ã€‚æ—§çš„å£å·ã€æ—§çš„æ–—äº‰æ–¹å¼ä¸å·¥ä½œæ–¹æ³•ç­‰ï¼Œå†³ä¸èƒ½æ»¡è¶³ç¾¤ä¼—ä»Šå¤©çš„è¦æ±‚ã€‚ç¾¤ä¼—çš„æ°‘æ—é©å‘½çš„é«˜æ½®ï¼Œä¼šå†²å¼€ä¸€åˆ‡è¿™äº›é™ˆè…çš„ä¸œè¥¿ï¼Œæ‰¾åˆ°ä»–ä»¬çš„æ–°çš„é¢†å¯¼è€…ï¼Œèµ°å‘ä»–ä»¬çš„ç›®çš„åœ°ã€‚ é¢†å¯¼ç¾¤ä¼—çš„ç¬¬ä¸‰ä¸ªé—®é¢˜ï¼Œå°±æ˜¯è¦å‘ç¾¤ä¼—å­¦ä¹ ã€‚ä¸€åˆ‡é©å‘½çš„ç»éªŒï¼Œéƒ½æ˜¯ä»ç¾¤ä¼—çš„å®é™…æ–—äº‰ä¸­åˆ›é€ å‡ºæ¥çš„ã€‚ç¦»å¼€ç¾¤ä¼—çš„é©å‘½å®è·µï¼Œæˆ‘ä»¬å°±ä¸èƒ½æœ‰é©å‘½çš„ç†è®ºã€‚è€Œç¾¤ä¼—çš„é©å‘½å®è·µæ˜¯é•¿ç”Ÿçš„ï¼Œæ˜¯æ— ç©·çš„ï¼Œæ˜¯æ°¸è¿œç»§ç»­å‰è¿›ç€çš„ã€‚å®ƒå‘å±•ä¸å……å®æˆ‘ä»¬çš„ç†è®ºï¼Œå®ƒæ”¹æ­£æˆ‘ä»¬çš„é”™è¯¯ï¼Œå®ƒä½¿æˆ‘ä»¬ä¸€å¤©ä¸€å¤©æ¥è¿‘ç€ç»å¯¹çš„çœŸç†ã€‚æ‰€ä»¥æˆ‘ä»¬å¿…é¡»åœ¨ç¾¤ä¼—æ–—äº‰ä¸­å»å­¦ä¹ ï¼Œåœ¨è¿™ä¸ªäººç”Ÿçš„å¤§æµ·ä¸­å»å­¦ä¹ ã€‚æˆ‘ä»¬çš„å­¦ä¹ æ˜¯æ²¡æœ‰æ­¢å¢ƒçš„ã€‚ç¾¤ä¼—çš„é©å‘½å®è·µä¸æ–­åˆ›é€ å‡ºæå¯å®è´µçš„æ–—äº‰å½¢å¼ã€ç»„ç»‡å½¢å¼ã€å·¥ä½œæ–¹æ³•ä¸æ–¹å¼ä»¥åŠå„ç§æå¯å®è´µçš„ç»éªŒã€‚è¿™äº›ç¾¤ä¼—åˆ›é€ å‡ºæ¥çš„ä¸œè¥¿ï¼Œå¸¸å¸¸æ˜¯ä¸€ä¸ªé¢†å¯¼è€…ï¼Œå³ä½¿æ˜¯å¤©æ‰çš„é¢†å¯¼è€…ï¼Œä¹Ÿä¸èƒ½é¢„æ–™åˆ°çš„ã€‚æœ‰æ—¶ä¸€ä¸ªé¢†å¯¼è€…å¸¸å¸¸è‹¦äºæ‰¾ä¸åˆ°ä¸€ä¸ªé€‚å½“çš„æ–—äº‰å½¢å¼æˆ–ç»„ç»‡å½¢å¼ä»¥è¿›ä¸€æ­¥å¼€å±•ç¾¤ä¼—è¿åŠ¨ã€‚ä½†æ˜¯ç¾¤ä¼—çš„é©å‘½å®è·µå¸¸å¸¸åˆ›é€ äº†è¿™ç§é€‚åˆçš„å½¢å¼ã€‚ç¾¤ä¼—å¯¹äºä¸€ä¸ªé—®é¢˜æ‰€å‘è¡¨çš„æ„è§ï¼Œä»–ä»¬å¯¹äºä¸€ä¸ªé—®é¢˜çš„çœ‹æ³•ä¸æ„Ÿè§‰ï¼Œå¸¸å¸¸æ˜¯ä¸€ä¸ªé¢†å¯¼è€…ï¼Œå³ä½¿æ˜¯å¤©æ‰çš„é¢†å¯¼è€…ï¼Œä¹Ÿæƒ³ä¸åˆ°çš„ä¸æ„Ÿè§‰ä¸åˆ°çš„ã€‚è€Œæ­£æ˜¯ä»–ä»¬çš„æ„è§ï¼Œä»–ä»¬çš„çœ‹æ³•ä¸æ„Ÿè§‰ï¼Œå¯ä»¥è¡¥è¶³ä¸€ä¸ªé¢†å¯¼è€…å¯¹äºæŸä¸ªé—®é¢˜çš„ç†è§£ä¹‹ä¸è¶³ä¸ç¼ºé™·ï¼Œä½¿æŸä¸ªé—®é¢˜å¾—åˆ°åœ†æ»¡çš„æ­£ç¡®çš„è§£å†³ã€‚ æ‰€ä»¥ï¼Œç¾¤ä¼—ä¸ä½†éœ€è¦æˆ‘ä»¬å»æ•™è‚²ï¼Œè€Œä¸”ä»–ä»¬ä¹Ÿæ•™è‚²æˆ‘ä»¬ã€‚æˆ‘ä»¬çš„é’å¹´åˆ‡ä¸è¦åœ¨ç¾¤ä¼—å‰é¢æ‘†èµ„æ ¼ï¼Œè‡ªé«˜è‡ªå¤§ï¼Œç§ä¸èµ·ç¾¤ä¼—ï¼Œè€Œåº”è¯¥å¾ˆè™šå¿ƒåœ°å»è·Ÿä»–ä»¬å­¦ä¹ ï¼Œå¾ˆç»†å¿ƒåœ°å»å€¾å¬ä»–ä»¬çš„æ„è§ï¼Œä¸ä»–ä»¬çš„è„‰æä¸€èµ·è·³åŠ¨ã€‚ æ€»ä¹‹ï¼Œæˆ‘ä»¬åœ¨é¢†å¯¼ç¾¤ä¼—ä¸­çš„åŸºæœ¬åŸåˆ™ï¼Œæ˜¯æ— è®ºå¦‚ä½•è¦é¢†å¯¼ç¾¤ä¼—å‰è¿›ï¼Œè€ŒåŒæ—¶æ— è®ºå¦‚ä½•ä¸è¦è„±ç¦»ç¾¤ä¼—ã€‚è„±ç¦»ç¾¤ä¼—çš„å…ˆé”‹ä¸»ä¹‰ä¸è½åäºç¾¤ä¼—çš„å°¾å·´ä¸»ä¹‰ï¼Œéƒ½æ˜¯æˆ‘ä»¬æ‰€ä¸åº”è¯¥èµæˆçš„ã€‚ åŒå¿—ä»¬ï¼Œè¦æŠŠè¿™æ ·å¹¿å¤§çš„ã€åƒåƒä¸‡ä¸‡çš„ã€è§‰æ‚Ÿç¨‹åº¦ä¸åŒçš„ç¾¤ä¼—åŠ¨å‘˜åˆ°ä¸ºæˆ‘ä»¬çš„ç†æƒ³è€Œç‰ºç‰²å¥‹æ–—çš„ä¸€æ¡æˆ˜çº¿ä¸Šï¼ŒçœŸä¸æ˜¯ç®€å•çš„äº‹ã€‚è¦è¾¾åˆ°è¿™ä¸ªç›®çš„ï¼Œä½ ä»¬æ— è®ºå¦‚ä½•ä¸è¦è„±ç¦»ç¾¤ä¼—ï¼Œè€Œè¦æˆä¸ºä»–ä»¬çš„é¢†è¢–ã€‚ åŒå¿—ä»¬ï¼è¿™å°±æ˜¯æˆ‘ä»Šå¤©æƒ³åŒåŒå¿—ä»¬è®¨è®ºçš„å…³äºé’å¹´çš„ä¿®å…»çš„å››ä¸ªé—®é¢˜ã€‚ åŒå¿—ä»¬ï¼æˆ‘å‰é¢å·²ç»è¯´è¿‡ï¼Œé©å‘½æ˜¯ä¸€ä»¶æœ€ä¼Ÿäººçš„äº‹ä¸šï¼Œä¹Ÿæ˜¯æœ€å›°éš¾çš„äº‹ä¸šã€‚æˆ‘ä»¬åœ¨é©å‘½ä¸­çŠ¯äº›é”™è¯¯ï¼Œç”šè‡³æ˜¯éå¸¸ä¸¥é‡çš„é”™è¯¯ï¼Œæ˜¯å…ä¸äº†çš„ã€‚è‡³äºé’å¹´æœ‹å‹ä»¬ï¼Œç”±äºç”Ÿæ´»ç»éªŒä¸æ–—äº‰ç»éªŒçš„ç¼ºä¹ï¼ŒçŠ¯äº›é”™è¯¯æ›´ä¸æ˜¯ä»€ä¹ˆä¸å¾—äº†çš„é—®é¢˜ã€‚æˆ‘ä»¬å†³ä¸èƒ½å› ä¸ºæ€•çŠ¯é”™è¯¯ï¼Œå°±ä¸å¹²é©å‘½ã€‚ç›¸åçš„ï¼Œæˆ‘ä»¬å°±è¦åœ¨é”™è¯¯ä¸­å­¦ä¹ ã€‚ æˆ‘ä»¬é’å¹´äººåˆ‡ä¸è¦ä»¥è‡ªå·±å·²ç»æœ‰çš„ä¸€ç‚¹çŸ¥è¯†ä¸ä¸€ç‚¹ç»éªŒï¼Œç”šè‡³ä¸€äº›ç”Ÿåæ´»å‰¥çš„é©å‘½çš„å…¬å¼ä¸å£å·ä¸ºæ»¡è¶³ã€‚è¿™å¯¹äºé’å¹´ä»¬æ˜¯æœ€å¤§çš„å±é™©ï¼Œå› ä¸ºè¿™ç§æ»¡è¶³å°±é˜»ç¢äº†ä½ ä»¬çš„è¿›æ­¥ï¼Œç»“æœå¿…ç„¶ä¼šä½¿ä½ ä»¬æˆä¸ºæ— ç”¨çš„â€œç©ºå¤´é©å‘½å®¶â€ã€‚é’å¹´ä»¬å¿…é¡»ä»¥åˆ—å®çš„â€œå­¦ä¹ å­¦ä¹ å†å­¦ä¹ â€çš„å£å·ï¼Œå½“ä½œè‡ªå·±çš„åº§å³é“­ã€‚ä½ ä»¬ä»Šå¤©åœ¨é™•åŒ—å…¬å­¦å­¦ä¹ ï¼Œæ˜å¤©å°±è¦åˆ°æŠ—æˆ˜çš„å‰çº¿ä¸åæ–¹çš„å®é™…å·¥ä½œä¸­å»å­¦ä¹ ã€‚é’å¹´åº”è¯¥æœ‰æœ€çƒ­çƒˆçš„å­¦ä¹ æ„¿æœ›ï¼Œå¾ˆé«˜çš„å­¦ä¹ ç²¾ç¥ä¸è°¦é€Šçš„å­¦ä¹ æ€åº¦ã€‚åªæœ‰è¿™ç§ä¸æ–­åœ°å­¦ä¹ ï¼Œæ‰èƒ½ä¸°å¯Œä½ ä»¬çš„çŸ¥è¯†ä¸ç»éªŒï¼Œæ‰èƒ½ä½¿ä½ ä»¬æˆä¸ºä¸€ä¸ªèƒ½å¹²çš„é©å‘½è€…ï¼Œæ‰èƒ½ä½¿ä½ ä»¬æ›´èƒ½è´Ÿæ‹…èµ·åœ¨è‡ªå·±è‚©è†€ä¸Šæ‰€è´Ÿæ‹…çš„è´£ä»»ã€‚ æˆ‘é‡å¤åœ°è¯´ï¼Œå·¥ä½œä¸­çš„é”™è¯¯æ˜¯è°ä¹Ÿå…ä¸äº†çš„ã€‚æˆ‘ä»¬å°±è¦åœ¨é”™è¯¯ä¸­å­¦ä¹ ã€‚ä»»ä½•é”™è¯¯ï¼Œä¸è®ºä¸ºå®ƒæ›¾ç»ä»˜äº†å¦‚ä½•é«˜æ˜‚çš„ä»£ä»·ï¼Œåªè¦æˆ‘ä»¬ä»é”™è¯¯ä¸­å¾—äº†å®è´µçš„ç»éªŒï¼Œé‚£è¿™ç§ä»£ä»·ä¹Ÿæ˜¯ä¸ç®—å¯æƒœçš„ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬ç”¨ä¸ç€æ€•çŠ¯é”™è¯¯ã€‚ä½†çŠ¯äº†é”™è¯¯ï¼Œæˆ‘ä»¬åº”è¯¥çŸ¥é“å¾ˆå¿«åœ°å»æ”¹æ­£é”™è¯¯ï¼Œåˆ‡ä¸è¦åšæŒé”™è¯¯ã€‚ä»»ä½•é”™è¯¯ï¼Œå¦‚æœåšæŒä¸‹å»ï¼Œé‚£æ˜¯éå¸¸å±é™©çš„ã€‚é’å¹´äººåº”è¯¥æ‰“ç ´â€œçˆ±å¥½é¢å­â€ã€ä¸è‚¯æˆ–è€…å®³æ€•æ‰¿è®¤é”™è¯¯çš„æ¶åŠ£å€¾å‘ã€‚é’å¹´äººåº”è¯¥â€œçˆ±å¥½çœŸç†â€ã€‚ä¸€åˆ‡é”™è¯¯çš„éçœŸç†çš„ä¸œè¥¿ï¼Œéƒ½åº”è¯¥å†³ç„¶æŠ›å¼ƒï¼Œä¸æ¯«ä¹Ÿä¸åº”è¯¥ç•™æ‹ã€‚åªæœ‰è¿™æ ·ï¼Œæ‰èƒ½ä½¿ä½ ä»¬ä¸æ–­åœ°è¿›æ­¥ã€‚ æ‰€ä»¥ï¼ŒåŒå¿—ä»¬ï¼Œä½ ä»¬æ›´åŠªåŠ›åœ°å»å­¦ä¹ é©å‘½ç†è®ºå§ï¼Œæ›´å¤§èƒ†åœ°å»å·¥ä½œå¥‹æ–—å§ï¼Œåœ¨å­¦ä¹ çš„è¿‡ç¨‹ä¸­ï¼Œåœ¨å·¥ä½œå¥‹æ–—çš„è¿‡ç¨‹ä¸­ï¼Œå»é”»ç‚¼ä½ ä»¬è‡ªå·±æˆä¸ºé’¢é“ä¸€æ ·çš„æˆ˜å£«å§ï¼è¦ä¸æ€•å›°éš¾ï¼Œä¸æ€•æŒ«æŠ˜ä¸å¤±è´¥ï¼Œè¦ä¸æ€•å¤©ä¸æ€•åœ°ï¼Œè¦å†æ¥å†å‰åœ°ä¸å±ˆä¸æŒ åœ°å‘ç€ä½ ä»¬å…‰æ˜çš„ä¼Ÿå¤§çš„ç†æƒ³å‰è¿›! "},"ReadingNotes/è¯­å½•-æ¯›æ³½ä¸œ.html":{"url":"ReadingNotes/è¯­å½•-æ¯›æ³½ä¸œ.html","title":"è¯­å½•-æ¯›æ³½ä¸œ","keywords":"","body":"ä¸¢æ‰å¹»æƒ³ï¼Œå‡†å¤‡æ–—äº‰ â€œè¯´æ¥ä¹Ÿæ˜¯ç¬‘è¯ï¼Œæˆ‘è¯»è¿‡å°å­¦ã€ä¸­å­¦ï¼Œä¹Ÿå½“è¿‡å…µï¼Œå´ä¸æ›¾çœ‹è§è¿‡ä¸–ç•Œåœ°å›¾ï¼Œå› æ­¤å°±ä¸çŸ¥é“ä¸–ç•Œæœ‰å¤šå¤§ã€‚æ¹–å—çœå›¾ä¹¦é¦†çš„å¢™å£ä¸Šï¼ŒæŒ‚æœ‰ä¸€å¼ ä¸–ç•Œå¤§åœ°å›¾ï¼Œæˆ‘æ¯å¤©ç»è¿‡é‚£é‡Œï¼Œæ€»æ˜¯ç«™ç€çœ‹ä¸€çœ‹ã€‚ è¿‡å»æˆ‘è®¤ä¸ºæ¹˜æ½­å¿å¤§ï¼Œæ¹–å—çœæ›´å¤§ï¼Œä¸­å›½è‡ªå¤å°±ç§°ä¸ºå¤©ä¸‹ï¼Œå½“ç„¶å¤§å¾—äº†ä¸å¾—ã€‚ä½†ä»è¿™ä¸ªåœ°å›¾ä¸Šçœ‹æ¥ï¼Œä¸­å›½åªå ä¸–ç•Œçš„ä¸€å°éƒ¨åˆ†ï¼Œæ¹–å—çœæ›´å°ï¼Œæ¹˜æ½­å¿åœ¨åœ°å›¾ä¸Šæ²¡æœ‰çœ‹è§ï¼ŒéŸ¶å±±å½“ç„¶æ›´æ²¡æœ‰å½±å­äº†ã€‚ä¸–ç•ŒåŸæ¥æœ‰è¿™ä¹ˆå¤§ï¼ ä¸–ç•Œæ—¢å¤§ï¼Œäººå°±ä¸€å®šç‰¹åˆ«å¤šã€‚è¿™æ ·å¤šçš„äººæ€æ ·è¿‡ç”Ÿæ´»ï¼Œéš¾é“ä¸å€¼å¾—æˆ‘ä»¬æ³¨æ„å—ï¼Ÿä»éŸ¶å±±å†²çš„æƒ…å½¢æ¥çœ‹ï¼Œé‚£é‡Œçš„äººå¤§éƒ½è¿‡ç€ç—›è‹¦çš„ç”Ÿæ´»ï¼Œä¸æ˜¯æŒ¨é¥¿ï¼Œå°±æ˜¯æŒ¨å†»ã€‚æœ‰æ— é’±æ²»ç—…çœ‹ç€ç—…æ­»çš„ï¼›è¿˜æœ‰å®¶åº­é‡Œã€ä¹¡é‚»é—´ï¼Œä¸ºç€å¤§å¤§å°å°çš„çº çº·ï¼Œåµå˜´ã€æ‰“æ¶ï¼Œé—¹å¾—é¸¡çŠ¬ä¸å®ï¼Œç”šè‡³å¼„å¾—æŠ•å¡˜ã€åŠé¢ˆçš„ï¼›è‡³äºæ²¡æœ‰ä¹¦è¯»ï¼Œåšä¸€ä¸–ççœ¼çå­çš„å°±æ›´å¤šäº†ã€‚åœ¨éŸ¶å±±å†²é‡Œï¼Œæˆ‘å°±æ²¡æœ‰çœ‹è§å‡ ä¸ªç”Ÿæ´»è¿‡å¾—å¿«æ´»çš„äººã€‚éŸ¶å±±å†²çš„æƒ…å½¢æ˜¯è¿™æ ·ï¼Œå…¨æ¹˜æ½­å¿ã€å…¨æ¹–å—çœã€å…¨ä¸­å›½ã€å…¨ä¸–ç•Œçš„æƒ…å½¢ï¼Œææ€•ä¹Ÿå·®ä¸å¤šï¼ æˆ‘çœŸæ€€ç–‘ï¼Œäººç”Ÿåœ¨ä¸–é—´ï¼Œéš¾é“éƒ½æ³¨å®šè¦è¿‡ç—›è‹¦çš„ç”Ÿæ´»å—ï¼Ÿå†³ä¸ï¼ä¸ºä»€ä¹ˆä¼šæœ‰è¿™ç§ç°è±¡å‘¢ï¼Ÿ è¿™æ˜¯åˆ¶åº¦ä¸å¥½ï¼Œæ”¿æ²»ä¸å¥½ï¼Œæ˜¯å› ä¸ºä¸–ç•Œä¸Šå­˜åœ¨äººå‰¥å‰Šäººã€äººå‹è¿«äººçš„åˆ¶åº¦ï¼Œæ‰€ä»¥ä½¿ä¸–ç•Œå¤§å¤šæ•°çš„äººéƒ½é™·å…¥ç—›è‹¦çš„æ·±æ½­ã€‚è¿™ç§ä¸åˆç†çš„ç°è±¡ï¼Œæ˜¯ä¸åº”è¯¥æ°¸è¿œå­˜åœ¨çš„ï¼Œæ˜¯åº”è¯¥å½»åº•æ¨ç¿»ã€å½»åº•æ”¹é€ çš„ï¼æ€»æœ‰ä¸€å¤©ï¼Œä¸–ç•Œä¼šèµ·å˜åŒ–ï¼Œä¸€åˆ‡ç—›è‹¦çš„äººï¼Œéƒ½ä¼šå˜æˆå¿«æ´»çš„äººï¼å¹¸ç¦çš„äººï¼ ä¸–ç•Œçš„å˜åŒ–ï¼Œä¸ä¼šè‡ªå·±å‘ç”Ÿï¼Œå¿…é¡»é€šè¿‡é©å‘½ï¼Œé€šè¿‡äººçš„åŠªåŠ›ã€‚æˆ‘å› æ­¤æƒ³åˆ°ï¼Œæˆ‘ä»¬é’å¹´çš„è´£ä»»çœŸæ˜¯é‡å¤§ï¼Œæˆ‘ä»¬åº”è¯¥åšçš„äº‹æƒ…çœŸå¤šï¼Œè¦èµ°çš„é“è·¯çœŸé•¿ã€‚ ä»è¿™æ—¶å€™èµ·ï¼Œæˆ‘å°±å†³å¿ƒè¦ä¸ºå…¨ä¸­å›½ç—›è‹¦çš„äººã€å…¨ä¸–ç•Œç—›è‹¦çš„äººè´¡çŒ®è‡ªå·±å…¨éƒ¨çš„åŠ›é‡ã€‚â€ æˆ‘æ˜¯ä¸ªå­¦ç”Ÿå‡ºèº«çš„äººï¼Œé‚£æ—¶ï¼Œæˆ‘è§‰å¾—ä¸–ç•Œä¸Šå¹²å‡€çš„äººåªæœ‰çŸ¥è¯†åˆ†å­ï¼Œå·¥äººå†œæ°‘æ€»æ˜¯æ¯”è¾ƒè„çš„ã€‚çŸ¥è¯†åˆ†å­çš„è¡£æœï¼Œåˆ«äººçš„æˆ‘å¯ä»¥ç©¿ï¼Œä»¥ä¸ºæ˜¯å¹²å‡€çš„ï¼›å·¥äººå†œæ°‘çš„è¡£æœï¼Œæˆ‘å°±ä¸æ„¿æ„ç©¿ï¼Œä»¥ä¸ºæ˜¯è„çš„ã€‚é©å‘½äº†ï¼ŒåŒå·¥äººå†œæ°‘å’Œé©å‘½å†›çš„æˆ˜å£«åœ¨ä¸€èµ·äº†ï¼Œæˆ‘é€æ¸ç†Ÿæ‚‰ä»–ä»¬ï¼Œä»–ä»¬ä¹Ÿé€æ¸ç†Ÿæ‚‰äº†æˆ‘ã€‚è¿™æ—¶ï¼Œåªæ˜¯åœ¨è¿™æ—¶ï¼Œæˆ‘æ‰æ ¹æœ¬åœ°æ”¹å˜äº†èµ„äº§é˜¶çº§å­¦æ ¡æ‰€æ•™ç»™æˆ‘çš„é‚£ç§èµ„äº§é˜¶çº§çš„å’Œå°èµ„äº§é˜¶çº§çš„æ„Ÿæƒ…ã€‚è¿™æ—¶ï¼Œæ‹¿æœªæ›¾æ”¹é€ çš„çŸ¥è¯†åˆ†å­å’Œå·¥äººå†œæ°‘æ¯”è¾ƒï¼Œå°±è§‰å¾—çŸ¥è¯†åˆ†å­ä¸å¹²å‡€äº†ï¼Œæœ€å¹²å‡€çš„è¿˜æ˜¯å·¥äººå†œæ°‘ï¼Œå°½ç®¡ä»–ä»¬æ‰‹æ˜¯é»‘çš„ï¼Œè„šä¸Šæœ‰ç‰›å±ï¼Œè¿˜æ˜¯æ¯”èµ„äº§é˜¶çº§å’Œå°èµ„äº§é˜¶çº§çŸ¥è¯†åˆ†å­éƒ½å¹²å‡€ã€‚ â€œä¸€ä¸ªäººï¼›å¦‚è‹¥ä¸è¢«æ•Œäººåå¯¹ï¼Œé‚£å°±ä¸å¥½äº†ï¼Œé‚£ä¸€å®šæ˜¯åŒæ•ŒäººåŒæµåˆæ±¡äº†ã€‚å¦‚è‹¥è¢«æ•Œäººåå¯¹ï¼Œé‚£å°±å¥½äº†ï¼Œé‚£å°±è¯æ˜æˆ‘ä»¬åŒæ•Œäººåˆ’æ¸…ç•Œé™äº†ã€‚å¦‚è‹¥æ•Œäººèµ·åŠ²åœ°åå¯¹æˆ‘ä»¬ï¼ŒæŠŠæˆ‘ä»¬è¯´å¾—ä¸€å¡Œç³Šæ¶‚ï¼Œä¸€æ— æ˜¯å¤„ï¼Œé‚£å°±æ›´å¥½äº†ï¼Œé‚£å°±è¯æ˜æˆ‘ä»¬ä¸ä½†åŒæ•Œäººåˆ’æ¸…äº†ç•Œé™ï¼Œè€Œä¸”è¯æ˜æˆ‘ä»¬çš„å·¥ä½œæ˜¯å“æœ‰æˆæ•ˆçš„äº†ã€‚â€ ä¸å¤©å¥‹æ–—ï¼Œå…¶ä¹æ— ç©·ï¼› ä¸åœ°å¥‹æ–—ï¼Œå…¶ä¹æ— ç©·ï¼› ä¸äººå¥‹æ–—ï¼Œå…¶ä¹æ— ç©·ã€‚ â€œè®©å†…å¤–ååŠ¨æ´¾åœ¨æˆ‘ä»¬çš„é¢å‰å‘æŠ–å§ï¼è®©ä»–ä»¬å»è¯´æˆ‘ä»¬è¿™ä¹Ÿä¸è¡Œé‚£ä¹Ÿä¸è¡Œå§ï¼ä¸­å›½äººæ°‘ä¸å±ˆä¸æŒ çš„åŠªåŠ›ï¼Œå¿…å°†ç¨³æ­¥åœ°è¾¾åˆ°è‡ªå·±çš„ç›®çš„ï¼â€ â€œä»—æˆ‘ä»¬æ˜¯ä¸æ€•æ‰“çš„ï¼Œå¸å›½ä¸»ä¹‰è¦æƒ³â€˜å’Œå¹³æ¼”å˜â€™æˆ‘ä»¬è¿™ä¸€ä»£äººä¹Ÿéš¾ï¼›å¯ä¸‹ä¸€ä»£ã€å†ä¸‹ä¸€ä»£å°±ä¸å¥½è®²äº†ã€‚ä¸­å›½äººè®²â€˜å›å­ä¹‹æ³½ï¼Œäº”ä¸–è€Œæ–©â€™ï¼Œè‹±å›½äººè¯´â€˜çˆµä½ä¸ä¼ ä¸‰ä»£â€™ï¼›åˆ°æˆ‘ä»¬çš„ç¬¬ä¸‰ä»£ã€ç¬¬å››ä»£äººèº«ä¸Šï¼Œæƒ…å½¢åˆä¼šæ˜¯ä¸ªä»€ä¹ˆæ ·å­å•Šï¼Ÿæˆ‘ä¸æƒ³å“ªä¸€å¤©ï¼Œåœ¨ä¸­å›½çš„å¤§åœ°ä¸Šå†å‡ºç°äººå‰¥å‰Šäººçš„ç°è±¡ï¼Œå†å‡ºç°èµ„æœ¬å®¶ã€ä¼ä¸šä¸»ã€é›‡å·¥ã€å¦“å¥³å’Œå¸é£Ÿé¸¦ç‰‡çƒŸï¼›å¦‚æœé‚£æ ·ï¼Œè®¸å¤šçƒˆå£«çš„è¡€å°±ç™½æµäº†â€¦â€¦â€ åˆ›é€ å¼ºå¤§çš„äººæ°‘ç©ºå†›ï¼Œæ­¼ç­æ®‹æ•Œï¼Œå·©å›ºå›½é˜²ã€‚ æŒ‡ç‚¹æ±Ÿå±±ï¼Œæ¿€æ‰¬æ–‡å­—ï¼Œç²ªåœŸå½“å¹´ä¸‡æˆ·ä¾¯ã€‚ è¦ä¼¼æ˜†ä»‘å´©ç»å£ï¼Œåˆæ°åƒå°é£æ‰«å¯°å®‡ã€‚é‡æ¯”ç¿¼ï¼Œå’Œäº‘ç¿¥ã€‚ å†›å«å·¥å†œé©å‘½ï¼Œæ——å·é•°åˆ€æ–§å¤´ã€‚åŒ¡åºä¸€å¸¦ä¸åœç•™ï¼Œè¦å‘æ½‡æ¹˜ç›´è¿›ã€‚ é›„å…³æ¼«é“çœŸå¦‚é“ï¼Œè€Œä»Šè¿ˆæ­¥ä»å¤´è¶Š çº¢å†›ä¸æ€•è¿œå¾éš¾ï¼Œä¸‡æ°´åƒå±±åªç­‰é—² å®‰å¾—å€šå¤©æŠ½å®å‰‘ï¼ŒæŠŠæ±è£ä¸ºä¸‰æˆªï¼Ÿä¸€æˆªé—æ¬§ï¼Œä¸€æˆªèµ ç¾ï¼Œä¸€æˆªè¿˜ä¸œå›½ã€‚å¤ªå¹³ä¸–ç•Œï¼Œç¯çƒåŒæ­¤å‡‰çƒ­ã€‚ æµ´è¡€ä¸œç“œå®ˆï¼Œé©±å€­æ£ å‰å½’ã€‚æ²™åœºç«Ÿæ®’å‘½ï¼Œå£®å¿—ä¹Ÿæ— è¿ã€‚ éåœ°å“€é¸¿éåœ°è¡€ï¼Œæ— éä¸€å¿µæ•‘è‹ç”Ÿã€‚ å®œå°†å‰©å‹‡è¿½ç©·å¯‡ï¼Œä¸å¯æ²½åå­¦éœ¸ç‹ã€‚ è¯—è¯ æµªæ·˜æ²™ åŒ—æˆ´æ²³ï¼ˆ1954å¹´å¤ï¼‰ å¤§é›¨è½å¹½ç‡•ï¼Œ ç™½æµªæ»”å¤©ï¼Œ ç§¦çš‡å²›å¤–æ‰“é±¼èˆ¹ã€‚ ä¸€ç‰‡æ±ªæ´‹éƒ½ä¸è§ï¼Œ çŸ¥å‘è°è¾¹ï¼Ÿ å¾€äº‹è¶Šåƒå¹´ï¼Œ é­æ­¦æŒ¥é­ï¼Œ ä¸œä¸´ç¢£çŸ³æœ‰é—ç¯‡ã€‚ è§ç‘Ÿç§‹é£ä»Šåˆæ˜¯ï¼Œ æ¢äº†äººé—´ã€‚ "},"ReadingNotes/é’å¹´åœ¨é€‰æ‹©èŒä¸šæ—¶çš„è€ƒè™‘-é©¬å…‹æ€-1835.html":{"url":"ReadingNotes/é’å¹´åœ¨é€‰æ‹©èŒä¸šæ—¶çš„è€ƒè™‘-é©¬å…‹æ€-1835.html","title":"é’å¹´åœ¨é€‰æ‹©èŒä¸šæ—¶çš„è€ƒè™‘-é©¬å…‹æ€-1835","keywords":"","body":"é’å¹´åœ¨é€‰æ‹©èŒä¸šæ—¶çš„è€ƒè™‘ å¡Â·é©¬å…‹æ€çš„ä¸­å­¦è€ƒè¯•å¾·è¯­ä½œæ–‡ è‡ªç„¶æœ¬èº«ç»™åŠ¨ç‰©è§„å®šäº†å®ƒåº”è¯¥éµå®ˆçš„æ´»åŠ¨èŒƒå›´ï¼ŒåŠ¨ç‰©ä¹Ÿå°±å®‰åˆ†åœ°åœ¨è¿™ä¸ªèŒƒå›´å†…æ´»åŠ¨ï¼Œè€Œä¸è¯•å›¾è¶Šå‡ºè¿™ä¸ªèŒƒå›´ï¼Œç”šè‡³ä¸è€ƒè™‘æœ‰å…¶å®ƒèŒƒå›´å­˜åœ¨ã€‚ç¥ä¹Ÿç»™äººæŒ‡å®šäº†å…±åŒçš„ç›®æ ‡â”€â”€ä½¿äººç±»å’Œä»–è‡ªå·±è¶‹äºé«˜å°šï¼Œä½†æ˜¯ï¼Œç¥è¦äººè‡ªå·±å»å¯»æ‰¾å¯ä»¥è¾¾åˆ°è¿™ä¸ªç›®æ ‡çš„æ‰‹æ®µï¼›ç¥è®©äººåœ¨ç¤¾ä¼šä¸Šé€‰æ‹©ä¸€ä¸ªæœ€é€‚åˆäºä»–ã€æœ€èƒ½ä½¿ä»–å’Œç¤¾ä¼šå˜å¾—é«˜å°šçš„åœ°ä½ã€‚ è¿™ç§é€‰æ‹©æ˜¯äººæ¯”å…¶å®ƒåˆ›é€ ç‰©è¿œä¸ºä¼˜è¶Šçš„åœ°æ–¹ï¼Œä½†åŒæ—¶ä¹Ÿæ˜¯å¯èƒ½æ¯ç­äººçš„ä¸€ç”Ÿã€ç ´åä»–çš„ä¸€åˆ‡è®¡åˆ’å¹¶ä½¿ä»–é™·äºä¸å¹¸çš„è¡Œä¸ºã€‚å› æ­¤ï¼Œè®¤çœŸåœ°æƒè¡¡è¿™ç§é€‰æ‹©ï¼Œæ— ç–‘æ˜¯å¼€å§‹èµ°ä¸Šç”Ÿæ´»é“è·¯è€Œåˆä¸æ„¿åœ¨æœ€é‡è¦çš„äº‹æƒ…ä¸Šå¬å¤©ç”±å‘½çš„é’å¹´çš„é¦–è¦è´£ä»»ã€‚ æ¯ä¸ªäººçœ¼å‰éƒ½æœ‰ä¸€ä¸ªç›®æ ‡ï¼Œè¿™ä¸ªç›®æ ‡è‡³å°‘åœ¨ä»–æœ¬äººçœ‹æ¥æ˜¯ä¼Ÿå¤§çš„ï¼Œè€Œä¸”å¦‚æœæœ€æ·±åˆ»çš„ä¿¡å¿µï¼Œå³å†…å¿ƒæ·±å¤„çš„å£°éŸ³ï¼Œè®¤ä¸ºè¿™ä¸ªç›®æ ‡æ˜¯ä¼Ÿå¤§çš„ï¼Œé‚£å®ƒå®é™…ä¸Šä¹Ÿæ˜¯ä¼Ÿå¤§çš„ï¼Œå› ä¸ºç¥å†³ä¸ä¼šä½¿ä¸–äººå®Œå…¨æ²¡æœ‰å¼•å¯¼è€…ï¼›ç¥è½»å£°åœ°ä½†åšå®šåœ°ä½œå¯ç¤ºã€‚ ä½†æ˜¯ï¼Œè¿™å£°éŸ³å¾ˆå®¹æ˜“è¢«æ·¹æ²¡ï¼›æˆ‘ä»¬è®¤ä¸ºæ˜¯çƒ­æƒ…çš„ä¸œè¥¿å¯èƒ½å€å¿½è€Œç”Ÿï¼ŒåŒæ ·å¯èƒ½å€å¿½è€Œé€ã€‚ä¹Ÿè®¸ï¼Œæˆ‘ä»¬çš„å¹»æƒ³è“¦ç„¶è¿¸å‘ï¼Œæˆ‘ä»¬çš„æ„Ÿæƒ…æ¿€åŠ¨èµ·æ¥ï¼Œæˆ‘ä»¬çš„çœ¼å‰æµ®æƒ³è”ç¿©ï¼Œæˆ‘ä»¬ç‹‚çƒ­åœ°è¿½æ±‚æˆ‘ä»¬ä»¥ä¸ºæ˜¯ç¥æœ¬èº«ç»™æˆ‘ä»¬æŒ‡å‡ºçš„ç›®æ ‡ï¼›ä½†æ˜¯ï¼Œæˆ‘ä»¬æ¢¦å¯ä»¥æ±‚çš„ä¸œè¥¿å¾ˆå¿«å°±ä½¿æˆ‘ä»¬åŒæ¶ï¼Œäºæ˜¯ï¼Œæˆ‘ä»¬ä¾¿æ„Ÿåˆ°è‡ªå·±çš„æ•´ä¸ªå­˜åœ¨é­åˆ°äº†æ¯ç­ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬åº”å½“è®¤çœŸè€ƒè™‘ï¼šæˆ‘ä»¬å¯¹æ‰€é€‰æ‹©çš„èŒä¸šæ˜¯ä¸æ˜¯çœŸçš„æ€€æœ‰çƒ­æƒ…ï¼Ÿå‘è‡ªæˆ‘ä»¬å†…å¿ƒçš„å£°éŸ³æ˜¯ä¸æ˜¯åŒæ„é€‰æ‹©è¿™ç§èŒä¸šï¼Ÿæˆ‘ä»¬çš„çƒ­æƒ…æ˜¯ä¸æ˜¯ä¸€ç§è¿·è¯¯ï¼Ÿæˆ‘ä»¬è®¤ä¸ºæ˜¯ç¥çš„å¬å”¤çš„ä¸œè¥¿æ˜¯ä¸æ˜¯ä¸€ç§è‡ªæˆ‘æ¬ºéª—ï¼Ÿä¸è¿‡ï¼Œå¦‚æœä¸å¯¹çƒ­æƒ…çš„æ¥æºæœ¬èº«åŠ ä»¥æ¢ç©¶ï¼Œæˆ‘ä»¬åˆæ€ä¹ˆèƒ½è®¤æ¸…è¿™ä¸€åˆ‡å‘¢ï¼Ÿ ä¼Ÿå¤§çš„ä¸œè¥¿æ˜¯é—ªå…‰çš„ï¼Œé—ªå…‰ä¼šæ¿€å‘è™šè£å¿ƒï¼Œè™šè£å¿ƒå®¹æ˜“ä½¿äººäº§ç”Ÿçƒ­æƒ…æˆ–è€…ä¸€ç§æˆ‘ä»¬è§‰å¾—æ˜¯çƒ­æƒ…çš„ä¸œè¥¿ï¼›ä½†æ˜¯ï¼Œè¢«ååˆ©è¿·ä½äº†å¿ƒçªçš„äººï¼Œç†æ€§æ˜¯æ— æ³•åŠ ä»¥çº¦æŸçš„ï¼Œäºæ˜¯ä»–ä¸€å¤´æ ½è¿›é‚£ä¸å¯æŠ—æ‹’çš„æ¬²å¿µå¬å”¤ä»–å»çš„åœ°æ–¹ï¼›ä»–çš„èŒä¸šå·²ç»ä¸å†æ˜¯ç”±ä»–è‡ªå·±é€‰æ‹©ï¼Œè€Œæ˜¯ç”±å¶ç„¶æœºä¼šå’Œå‡è±¡å»å†³å®šäº†ã€‚ æˆ‘ä»¬çš„ä½¿å‘½å†³ä¸æ˜¯æ±‚å¾—ä¸€ä¸ªæœ€è¶³ä»¥ç‚«è€€çš„èŒä¸šï¼Œå› ä¸ºå®ƒä¸æ˜¯é‚£ç§å¯èƒ½ç”±æˆ‘ä»¬é•¿æœŸä»äº‹ï¼Œä½†å§‹ç»ˆä¸ä¼šä½¿æˆ‘ä»¬æ„Ÿåˆ°åŒå€¦ã€å§‹ç»ˆä¸ä¼šä½¿æˆ‘ä»¬åŠ²å¤´ä½è½ã€å§‹ç»ˆä¸ä¼šä½¿æˆ‘ä»¬çš„çƒ­æƒ…å†·å´çš„èŒä¸šï¼Œç›¸åï¼Œæˆ‘ä»¬å¾ˆå¿«å°±ä¼šè§‰å¾—ï¼Œæˆ‘ä»¬çš„æ„¿æœ›æ²¡æœ‰å¾—åˆ°æ»¡è¶³ï¼Œæˆ‘ä»¬çš„ç†æƒ³æ²¡æœ‰å®ç°ï¼Œæˆ‘ä»¬å°±å°†æ€¨å¤©å°¤äººã€‚ ä½†æ˜¯ï¼Œä¸ä»…è™šè£å¿ƒèƒ½å¤Ÿå¼•èµ·å¯¹æŸç§èŒä¸šçš„çªç„¶çš„çƒ­æƒ…ï¼Œè€Œä¸”æˆ‘ä»¬ä¹Ÿè®¸ä¼šç”¨è‡ªå·±çš„å¹»æƒ³æŠŠè¿™ç§èŒä¸šç¾åŒ–ï¼ŒæŠŠå®ƒç¾åŒ–æˆç”Ÿæ´»æ‰€èƒ½æä¾›çš„è‡³é«˜æ— ä¸Šçš„ä¸œè¥¿ã€‚æˆ‘ä»¬æ²¡æœ‰ä»”ç»†åˆ†æå®ƒï¼Œæ²¡æœ‰è¡¡é‡å®ƒçš„å…¨éƒ¨åˆ†é‡ï¼Œå³å®ƒåŠ åœ¨æˆ‘ä»¬è‚©ä¸Šçš„é‡å¤§è´£ä»»ï¼›æˆ‘ä»¬åªæ˜¯ä»è¿œå¤„è§‚å¯Ÿå®ƒï¼Œè€Œä»è¿œå¤„è§‚å¯Ÿæ˜¯é ä¸ä½çš„ã€‚ åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬è‡ªå·±çš„ç†æ€§ä¸èƒ½ç»™æˆ‘ä»¬å……å½“é¡¾é—®ï¼Œå› ä¸ºå½“å®ƒè¢«æ„Ÿæƒ…æ¬ºéª—ï¼Œå—å¹»æƒ³è’™è”½æ—¶ï¼Œå®ƒæ—¢ä¸ä¾é ç»éªŒï¼Œä¹Ÿä¸ä¾é æ›´æ·±å…¥çš„è§‚å¯Ÿã€‚ç„¶è€Œï¼Œæˆ‘ä»¬çš„ç›®å…‰åº”è¯¥æŠ•å‘è°å‘¢ï¼Ÿå½“æˆ‘ä»¬ä¸§å¤±ç†æ€§çš„æ—¶å€™ï¼Œè°æ¥æ”¯æŒæˆ‘ä»¬å‘¢ï¼Ÿ æ˜¯æˆ‘ä»¬çš„çˆ¶æ¯ï¼Œä»–ä»¬èµ°è¿‡äº†æ¼«é•¿çš„ç”Ÿæ´»é“è·¯ï¼Œé¥±å°äº†äººä¸–è¾›é…¸ã€‚â”€â”€æˆ‘ä»¬çš„å¿ƒè¿™æ ·æé†’æˆ‘ä»¬ã€‚ å¦‚æœæˆ‘ä»¬ç»è¿‡å†·é™çš„è€ƒå¯Ÿï¼Œè®¤æ¸…äº†æ‰€é€‰æ‹©çš„èŒä¸šçš„å…¨éƒ¨åˆ†é‡ï¼Œäº†è§£å®ƒçš„å›°éš¾ä»¥åï¼Œä»ç„¶å¯¹å®ƒå……æ»¡çƒ­æƒ…ï¼Œä»ç„¶çˆ±å®ƒï¼Œè§‰å¾—è‡ªå·±é€‚åˆäºå®ƒï¼Œé‚£æ—¶æˆ‘ä»¬å°±å¯ä»¥é€‰æ‹©å®ƒï¼Œé‚£æ—¶æˆ‘ä»¬æ—¢ä¸ä¼šå—çƒ­æƒ…çš„æ¬ºéª—ï¼Œä¹Ÿä¸ä¼šä»“ä¿ƒä»äº‹ã€‚ ä½†æ˜¯ï¼Œæˆ‘ä»¬å¹¶ä¸æ€»æ˜¯èƒ½å¤Ÿé€‰æ‹©æˆ‘ä»¬è‡ªè®¤ä¸ºé€‚åˆçš„èŒä¸šï¼›æˆ‘ä»¬åœ¨ç¤¾ä¼šä¸Šçš„å…³ç³»ï¼Œè¿˜åœ¨æˆ‘ä»¬æœ‰èƒ½åŠ›å†³å®šå®ƒä»¬ä»¥å‰å°±å·²ç»åœ¨æŸç§ç¨‹åº¦ä¸Šå¼€å§‹ç¡®ç«‹äº†ã€‚ æˆ‘ä»¬çš„ä½“è´¨å¸¸å¸¸å¨èƒæˆ‘ä»¬ï¼Œå¯æ˜¯ä»»ä½•äººä¹Ÿä¸æ•¢è—è§†å®ƒçš„æƒåˆ©ã€‚ è¯šç„¶ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè¶…è¶Šä½“è´¨çš„é™åˆ¶ï¼Œä½†è¿™ä¹ˆä¸€æ¥ï¼Œæˆ‘ä»¬ä¹Ÿå°±å®å¾—æ›´å¿«ï¼›åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°±æ˜¯å†’é™©æŠŠå¤§å¦å»ºç­‘åœ¨æ®‹ç ´çš„åºŸå¢Ÿä¸Šï¼Œæˆ‘ä»¬çš„ä¸€ç”Ÿä¹Ÿå°±å˜æˆä¸€åœºç²¾ç¥åŸåˆ™å’Œè‚‰ä½“åŸåˆ™ä¹‹é—´çš„ä¸å¹¸çš„æ–—äº‰ã€‚ä½†æ˜¯ï¼Œä¸€ä¸ªä¸èƒ½å…‹æœè‡ªèº«ç›¸äº’æ–—äº‰çš„å› ç´ çš„äººï¼Œåˆæ€èƒ½æŠ—å¾¡ç”Ÿæ´»çš„çŒ›çƒˆå†²å‡»ï¼Œæ€èƒ½å®‰é™åœ°ä»äº‹æ´»åŠ¨å‘¢ï¼Ÿç„¶è€Œåªæœ‰ä»å®‰é™ä¸­æ‰èƒ½äº§ç”Ÿå‡ºä¼Ÿå¤§å£®ä¸½çš„äº‹ä¸šï¼Œå®‰é™æ˜¯å”¯ä¸€èƒ½ç”Ÿé•¿å‡ºæˆç†Ÿæœå®çš„åœŸå£¤ã€‚ å°½ç®¡æˆ‘ä»¬ç”±äºä½“è´¨ä¸é€‚åˆæˆ‘ä»¬çš„èŒä¸šï¼Œä¸èƒ½æŒä¹…åœ°å·¥ä½œï¼Œè€Œä¸”å¾ˆå°‘èƒ½å¤Ÿæ„‰å¿«åœ°å·¥ä½œï¼Œä½†æ˜¯ï¼Œä¸ºäº†å…‹å°½èŒå®ˆè€Œç‰ºç‰²è‡ªå·±å¹¸ç¦çš„æ€æƒ³æ¿€åŠ±ç€æˆ‘ä»¬ä¸é¡¾ä½“å¼±å»åŠªåŠ›å·¥ä½œã€‚å¦‚æœæˆ‘ä»¬é€‰æ‹©äº†åŠ›ä¸èƒœä»»çš„èŒä¸šï¼Œé‚£ä¹ˆæˆ‘ä»¬å†³ä¸èƒ½æŠŠå®ƒåšå¥½ï¼Œæˆ‘ä»¬å¾ˆå¿«å°±ä¼šè‡ªæ„§æ— èƒ½ï¼Œå°±ä¼šæ„Ÿåˆ°è‡ªå·±æ˜¯æ— ç”¨çš„äººï¼Œæ˜¯ä¸èƒ½å®Œæˆè‡ªå·±ä½¿å‘½çš„ç¤¾ä¼šæˆå‘˜ã€‚ç”±æ­¤äº§ç”Ÿçš„æœ€è‡ªç„¶çš„ç»“æœå°±æ˜¯è‡ªå‘ã€‚è¿˜æœ‰æ¯”è¿™æ›´ç—›è‹¦çš„æ„Ÿæƒ…å—ï¼Ÿè¿˜æœ‰æ¯”è¿™æ›´éš¾äºé å¤–ç•Œçš„å„ç§èµäºˆæ¥è¡¥å¿çš„æ„Ÿæƒ…å—ï¼Ÿè‡ªå‘æ˜¯ä¸€æ¡æ¯’è›‡ï¼Œå®ƒæ— å°½æ— ä¼‘åœ°æ…æ‰°ã€å•ƒå•®æˆ‘ä»¬çš„èƒ¸è†›ï¼Œå®å¸æˆ‘ä»¬å¿ƒä¸­æ»‹æ¶¦ç”Ÿå‘½çš„è¡€æ¶²ï¼Œæ³¨å…¥åŒä¸–å’Œç»æœ›çš„æ¯’æ¶²ã€‚ å¦‚æœæˆ‘ä»¬é”™è¯¯åœ°ä¼°è®¡äº†è‡ªå·±çš„èƒ½åŠ›ï¼Œä»¥ä¸ºèƒ½å¤Ÿèƒœä»»ç»è¿‡è¾ƒä¸ºä»”ç»†çš„è€ƒè™‘è€Œé€‰å®šçš„èŒä¸šï¼Œé‚£ä¹ˆè¿™ç§é”™è¯¯å°†ä½¿æˆ‘ä»¬å—åˆ°æƒ©ç½šã€‚å³ä½¿ä¸å—åˆ°å¤–ç•Œçš„æŒ‡è´£ï¼Œæˆ‘ä»¬ä¹Ÿä¼šæ„Ÿåˆ°æ¯”å¤–ç•ŒæŒ‡è´£æ›´ä¸ºå¯æ€•çš„ç—›è‹¦ã€‚ å¦‚æœæˆ‘ä»¬æŠŠè¿™ä¸€åˆ‡éƒ½è€ƒè™‘è¿‡äº†ï¼Œå¦‚æœæˆ‘ä»¬çš„ç”Ÿæ´»æ¡ä»¶å®¹è®¸æˆ‘ä»¬é€‰æ‹©ä»»ä½•ä¸€ç§èŒä¸šï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥é€‰æ‹©ä¸€ç§ä½¿æˆ‘ä»¬è·å¾—æœ€é«˜å°Šä¸¥çš„èŒä¸šï¼Œä¸€ç§å»ºç«‹åœ¨æˆ‘ä»¬æ·±ä¿¡å…¶æ­£ç¡®çš„æ€æƒ³ä¸Šçš„èŒä¸šï¼Œä¸€ç§èƒ½ç»™æˆ‘ä»¬æä¾›æœ€å¹¿é˜”çš„åœºæ‰€æ¥ä¸ºäººç±»å·¥ä½œï¼Œå¹¶ä½¿æˆ‘ä»¬è‡ªå·±ä¸æ–­æ¥è¿‘å…±åŒç›®æ ‡å³è‡»äºå®Œç¾å¢ƒç•Œçš„èŒä¸šï¼Œè€Œå¯¹äºè¿™ä¸ªå…±åŒç›®æ ‡æ¥è¯´ï¼Œä»»ä½•èŒä¸šéƒ½åªä¸è¿‡æ˜¯ä¸€ç§æ‰‹æ®µã€‚ å°Šä¸¥æ˜¯æœ€èƒ½ä½¿äººé«˜å°šã€ä½¿ä»–çš„æ´»åŠ¨å’Œä»–çš„ä¸€åˆ‡åŠªåŠ›å…·æœ‰æ›´åŠ å´‡é«˜å“è´¨çš„ä¸œè¥¿ï¼Œæ˜¯ä½¿ä»–æ— å¯éè®®ã€å—åˆ°ä¼—äººé’¦ä½©å¹¶é«˜å‡ºäºä¼—äººä¹‹ä¸Šçš„ä¸œè¥¿ã€‚ ä½†æ˜¯ï¼Œèƒ½ç»™äººä»¥å°Šä¸¥çš„åªæœ‰è¿™æ ·çš„èŒä¸šï¼Œåœ¨ä»äº‹è¿™ç§èŒä¸šæ—¶æˆ‘ä»¬ä¸æ˜¯ä½œä¸ºå¥´éš¶èˆ¬çš„å·¥å…·ï¼Œè€Œæ˜¯åœ¨è‡ªå·±çš„é¢†åŸŸå†…ç‹¬ç«‹åœ°è¿›è¡Œåˆ›é€ ï¼›è¿™ç§èŒä¸šä¸éœ€è¦æœ‰ä¸ä½“é¢çš„è¡ŒåŠ¨ï¼ˆå“ªæ€•åªæ˜¯è¡¨é¢ä¸Šä¸ä½“é¢çš„è¡ŒåŠ¨ï¼‰ï¼Œç”šè‡³æœ€ä¼˜ç§€çš„äººç‰©ä¹Ÿä¼šæ€€ç€å´‡é«˜çš„è‡ªè±ªæ„Ÿå»ä»äº‹å®ƒã€‚æœ€åˆä¹è¿™äº›è¦æ±‚çš„èŒä¸šï¼Œå¹¶ä¸æ€»æ˜¯æœ€é«˜çš„èŒä¸šï¼Œä½†å¾€å¾€æ˜¯æœ€å¯å–çš„èŒä¸šã€‚ ä½†æ˜¯ï¼Œæ­£å¦‚æœ‰å¤±å°Šä¸¥çš„èŒä¸šä¼šè´¬ä½æˆ‘ä»¬ä¸€æ ·ï¼Œé‚£ç§å»ºç«‹åœ¨æˆ‘ä»¬åæ¥è®¤ä¸ºæ˜¯é”™è¯¯çš„æ€æƒ³ä¸Šçš„èŒä¸šä¹Ÿä¸€å®šä¼šæˆä¸ºæˆ‘ä»¬çš„æ²‰é‡è´Ÿæ‹…ã€‚ è¿™é‡Œï¼Œæˆ‘ä»¬é™¤äº†è‡ªæˆ‘æ¬ºéª—ï¼Œåˆ«æ— è§£æ•‘åŠæ³•ï¼Œè€Œè®©äººè‡ªæˆ‘æ¬ºéª—çš„è§£æ•‘åŠæ³•æ˜¯å¤šä¹ˆä»¤äººå¤±æœ›å•Šï¼ é‚£äº›ä¸»è¦ä¸æ˜¯å¹²é¢„ç”Ÿæ´»æœ¬èº«ï¼Œè€Œæ˜¯ä»äº‹æŠ½è±¡çœŸç†çš„ç ”ç©¶çš„èŒä¸šï¼Œå¯¹äºè¿˜æ²¡æœ‰ç¡®ç«‹åšå®šçš„åŸåˆ™å’Œç‰¢å›ºçš„ã€ä¸å¯åŠ¨æ‘‡çš„ä¿¡å¿µçš„é’å¹´æ˜¯æœ€å±é™©çš„ï¼Œå½“ç„¶ï¼Œå¦‚æœè¿™äº›èŒä¸šåœ¨æˆ‘ä»¬å¿ƒé‡Œæ·±æ·±åœ°æ‰ä¸‹äº†æ ¹ï¼Œå¦‚æœæˆ‘ä»¬èƒ½å¤Ÿä¸ºå®ƒä»¬çš„ä¸»å¯¼æ€æƒ³è€Œç‰ºç‰²ç”Ÿå‘½ã€ç«­å°½å…¨åŠ›ï¼Œè¿™äº›èŒä¸šçœ‹æ¥è¿˜æ˜¯æœ€é«˜å°šçš„ã€‚ è¿™äº›èŒä¸šèƒ½å¤Ÿä½¿å…·æœ‰åˆé€‚æ‰å¹²çš„äººå¹¸ç¦ï¼Œä½†æ˜¯ä¹Ÿä¼šä½¿é‚£äº›ä¸ç»è€ƒè™‘ã€å‡­ä¸€æ—¶å†²åŠ¨è€Œè´¸ç„¶ä»äº‹çš„äººæ¯ç­ã€‚ ç›¸åï¼Œé‡è§†ä½œä¸ºæˆ‘ä»¬èŒä¸šçš„åŸºç¡€çš„æ€æƒ³ï¼Œä¼šä½¿æˆ‘ä»¬åœ¨ç¤¾ä¼šä¸Šå æœ‰è¾ƒé«˜çš„åœ°ä½ï¼Œæé«˜æˆ‘ä»¬è‡ªå·±çš„å°Šä¸¥ï¼Œä½¿æˆ‘ä»¬çš„è¡Œä¸ºä¸å¯åŠ¨æ‘‡ã€‚ ä¸€ä¸ªé€‰æ‹©äº†è‡ªå·±æ‰€çè§†çš„èŒä¸šçš„äººï¼Œä¸€æƒ³åˆ°ä»–å¯èƒ½ä¸ç§°èŒæ—¶å°±ä¼šæˆ˜æˆ˜å…¢å…¢â”€â”€è¿™ç§äººå•æ˜¯å› ä¸ºä»–åœ¨ç¤¾ä¼šä¸Šæ‰€å¤„çš„åœ°ä½æ˜¯é«˜å°šçš„ï¼Œä»–ä¹Ÿå°±ä¼šä½¿è‡ªå·±çš„è¡Œä¸ºä¿æŒé«˜å°šã€‚ åœ¨é€‰æ‹©èŒä¸šæ—¶ï¼Œæˆ‘ä»¬åº”è¯¥éµå®ˆçš„ä¸»è¦æŒ‡é’ˆæ˜¯äººç±»çš„å¹¸ç¦å’Œæˆ‘ä»¬è‡ªèº«çš„å®Œç¾ã€‚ä¸åº”è®¤ä¸ºï¼Œè¿™ä¸¤ç§åˆ©ç›Šä¼šå½¼æ­¤æ•Œå¯¹ã€äº’ç›¸å†²çªï¼Œä¸€ç§åˆ©ç›Šå¿…å®šæ¶ˆç­å¦ä¸€ç§åˆ©ç›Šï¼›ç›¸åï¼Œäººçš„æœ¬æ€§æ˜¯è¿™æ ·çš„ï¼šäººåªæœ‰ä¸ºåŒæ—¶ä»£äººçš„å®Œç¾ã€ä¸ºä»–ä»¬çš„å¹¸ç¦è€Œå·¥ä½œï¼Œè‡ªå·±æ‰èƒ½è¾¾åˆ°å®Œç¾ã€‚ å¦‚æœä¸€ä¸ªäººåªä¸ºè‡ªå·±åŠ³åŠ¨ï¼Œä»–ä¹Ÿè®¸èƒ½å¤Ÿæˆä¸ºè‘—åçš„å­¦è€…ã€ä¼Ÿå¤§çš„å“²äººã€å“è¶Šçš„è¯—äººï¼Œç„¶è€Œä»–æ°¸è¿œä¸èƒ½æˆä¸ºå®Œç¾çš„ã€çœŸæ­£ä¼Ÿå¤§çš„äººç‰©ã€‚ å†å²æŠŠé‚£äº›ä¸ºå…±åŒç›®æ ‡å·¥ä½œå› è€Œè‡ªå·±å˜å¾—é«˜å°šçš„äººç§°ä¸ºæœ€ä¼Ÿå¤§çš„äººç‰©ï¼›ç»éªŒèµç¾é‚£äº›ä¸ºå¤§å¤šæ•°äººå¸¦æ¥å¹¸ç¦çš„äººæ˜¯æœ€å¹¸ç¦çš„äººï¼›å®—æ•™æœ¬èº«ä¹Ÿæ•™è¯²æˆ‘ä»¬ï¼Œäººäººæ•¬ä»°çš„å…¸èŒƒï¼Œå°±æ›¾ä¸ºäººç±»è€Œç‰ºç‰²è‡ªå·±â”€â”€æœ‰è°æ•¢å¦å®šè¿™ç±»æ•™è¯²å‘¢ï¼Ÿ å¦‚æœæˆ‘ä»¬é€‰æ‹©äº†æœ€èƒ½ä¸ºäººç±»è€Œå·¥ä½œçš„èŒä¸šï¼Œé‚£ä¹ˆï¼Œé‡æ‹…å°±ä¸èƒ½æŠŠæˆ‘ä»¬å‹å€’ï¼Œå› ä¸ºè¿™æ˜¯ä¸ºå¤§å®¶ä½œå‡ºçš„ç‰ºç‰²ï¼›é‚£æ—¶æˆ‘ä»¬æ‰€äº«å—çš„å°±ä¸æ˜¯å¯æ€œçš„ã€æœ‰é™çš„ã€è‡ªç§çš„ä¹è¶£ï¼Œæˆ‘ä»¬çš„å¹¸ç¦å°†å±äºåƒç™¾ä¸‡äººï¼Œæˆ‘ä»¬çš„äº‹ä¸šå°†æ‚„ç„¶æ— å£°åœ°å­˜åœ¨ä¸‹å»ï¼Œä½†æ˜¯å®ƒä¼šæ°¸è¿œå‘æŒ¥ä½œç”¨ï¼Œè€Œé¢å¯¹æˆ‘ä»¬çš„éª¨ç°ï¼Œé«˜å°šçš„äººä»¬å°†æ´’ä¸‹çƒ­æ³ªã€‚ å¡Â·é©¬å…‹æ€å†™äº1835å¹´8æœˆ "}}